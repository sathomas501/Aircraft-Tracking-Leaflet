"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_pages-dir-browser_components_tracking_map_AircraftTrackingMap_tsx",{

/***/ "(pages-dir-browser)/./components/tracking/hooks/useFilterLogic.ts":
/*!*****************************************************!*\
  !*** ./components/tracking/hooks/useFilterLogic.ts ***!
  \*****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useFilterLogic: () => (/* binding */ useFilterLogic)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _types_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/types/base */ \"(pages-dir-browser)/./types/base.ts\");\n/* harmony import */ var _context_EnhancedMapContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../context/EnhancedMapContext */ \"(pages-dir-browser)/./components/tracking/context/EnhancedMapContext.tsx\");\n/* harmony import */ var _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/services/openSkyTrackingService */ \"(pages-dir-browser)/./lib/services/openSkyTrackingService.ts\");\n/* harmony import */ var _lib_services_MapboxService__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../lib/services/MapboxService */ \"(pages-dir-browser)/./lib/services/MapboxService.ts\");\n/* harmony import */ var _lib_utils_geofenceAdapter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/lib/utils/geofenceAdapter */ \"(pages-dir-browser)/./lib/utils/geofenceAdapter.ts\");\n/* harmony import */ var _lib_utils_geofenceEnricher__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/lib/utils/geofenceEnricher */ \"(pages-dir-browser)/./lib/utils/geofenceEnricher.ts\");\n/* harmony import */ var _hooks_useGeolocationServices__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../hooks/useGeolocationServices */ \"(pages-dir-browser)/./components/tracking/hooks/useGeolocationServices.ts\");\n/* harmony import */ var _lib_services_geofencing__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../lib/services/geofencing */ \"(pages-dir-browser)/./lib/services/geofencing.ts\");\n/* harmony import */ var _hooks_useGeolocation__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../hooks/useGeolocation */ \"(pages-dir-browser)/./components/tracking/hooks/useGeolocation.ts\");\n/* harmony import */ var _config_map__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../config/map */ \"(pages-dir-browser)/./config/map.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\nfunction useFilterLogic() {\n    // Get context state and functions\n    const { selectedManufacturer, selectedModel, totalActive, selectManufacturer, selectModel, reset, fullRefresh, refreshPositions, mapInstance, updateAircraftData, clearGeofenceData, updateGeofenceAircraft, blockManufacturerApiCalls, setBlockManufacturerApiCalls, isManufacturerApiBlocked, setIsManufacturerApiBlocked, geofenceCenter, setGeofenceCenter, toggleGeofence, clearGeofence, displayedAircraft } = (0,_context_EnhancedMapContext__WEBPACK_IMPORTED_MODULE_2__.useEnhancedMapContext)();\n    // Use our combined geolocation services hook\n    const geolocationServices = (0,_hooks_useGeolocationServices__WEBPACK_IMPORTED_MODULE_7__.useGeolocationServices)();\n    // Local state\n    const [localLoading, setLocalLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [filterMode, setFilterMode] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [activeDropdown, setActiveDropdown] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [manufacturerSearchTerm, setManufacturerSearchTerm] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)('');\n    const [isRefreshing, setIsRefreshing] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [isRateLimited, setIsRateLimited] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [rateLimitTimer, setRateLimitTimer] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    // Geofence state\n    const [isGettingLocation, setIsGettingLocation] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [geofenceLocation, setGeofenceLocation] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)('');\n    const [geofenceRadius, setGeofenceRadius] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(25);\n    const [geofenceCoordinates, setGeofenceCoordinates] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [geofenceAircraft, setGeofenceAircraft] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [geofenceEnabled, setGeofenceEnabled] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [isGeofenceActive, setIsGeofenceActive] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [isSearchReady, setIsSearchReady] = react__WEBPACK_IMPORTED_MODULE_0___default().useState(false);\n    // Region state\n    const [activeRegion, setActiveRegion] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [regionOutline, setRegionOutline] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [selectedRegion, setSelectedRegion] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(_types_base__WEBPACK_IMPORTED_MODULE_1__.RegionCode.GLOBAL);\n    // Combined mode state\n    const [combinedModeReady, setCombinedModeReady] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    // Owner filter state\n    const allOwnerTypes = [\n        'individual',\n        'partnership',\n        'corp-owner',\n        'co-owned',\n        'llc',\n        'non-citizen-corp',\n        'airline',\n        'freight',\n        'medical',\n        'media',\n        'historical',\n        'flying-club',\n        'emergency',\n        'local-govt',\n        'education',\n        'federal-govt',\n        'flight-school',\n        'leasing-corp',\n        'military',\n        'unknown'\n    ];\n    const [ownerFilters, setOwnerFilters] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([\n        ...allOwnerTypes\n    ]);\n    // Refs for dropdown handling\n    const dropdownRefs = {\n        filter: (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),\n        manufacturer: (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),\n        model: (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),\n        location: (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),\n        region: (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),\n        owner: (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),\n        actions: (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null)\n    };\n    // Get geolocation hook - use the entire hook instance\n    const geolocation = (0,_hooks_useGeolocation__WEBPACK_IMPORTED_MODULE_9__.useGeolocation)(null);\n    // Geofence methods\n    // Fixed getUserLocation function\n    const getUserLocation = async ()=>{\n        if (isRateLimited) {\n            alert(\"Rate limited. Please wait \".concat(rateLimitTimer || 30, \" seconds before trying to get location.\"));\n            return;\n        }\n        const getUserLocation = async ()=>{\n            if (isRateLimited) {\n                alert(\"Rate limited. Please wait \".concat(rateLimitTimer || 30, \" seconds before trying to get location.\"));\n                return;\n            }\n            setIsGettingLocation(true);\n            try {\n                // Use the getCurrentPosition from our combined hook\n                const position = await geolocationServices.getCurrentPosition();\n                if (position) {\n                    const { latitude, longitude } = position.coords;\n                    // Update state with coordinates\n                    setGeofenceCoordinates({\n                        lat: latitude,\n                        lng: longitude\n                    });\n                    setGeofenceCenter({\n                        lat: latitude,\n                        lng: longitude\n                    });\n                    // Update the location display with coordinates\n                    setGeofenceLocation(\"\".concat(latitude.toFixed(6), \", \").concat(longitude.toFixed(6)));\n                    // Automatically trigger the geofence search\n                    try {\n                        const fetchedAircraft = await (0,_lib_services_geofencing__WEBPACK_IMPORTED_MODULE_8__.getAircraftNearLocation)(latitude, longitude, geofenceRadius);\n                        if (fetchedAircraft.length === 0) {\n                            alert(\"No aircraft found near your current location. Try increasing the radius.\");\n                            setIsGettingLocation(false);\n                            return;\n                        }\n                        // Process the aircraft data\n                        const adaptedAircraft = (0,_lib_utils_geofenceAdapter__WEBPACK_IMPORTED_MODULE_5__.adaptGeofenceAircraft)(fetchedAircraft);\n                        const enrichedAircraft = await (0,_lib_utils_geofenceEnricher__WEBPACK_IMPORTED_MODULE_6__.enrichGeofenceAircraft)(adaptedAircraft);\n                        // Save to local state\n                        setGeofenceAircraft(enrichedAircraft);\n                        // Clear existing aircraft data\n                        if (clearGeofenceData) {\n                            clearGeofenceData();\n                        }\n                        // Update the map with new aircraft\n                        updateGeofenceAircraft(enrichedAircraft);\n                        setIsGeofenceActive(true);\n                        // Center the map on user's location - SIMPLIFIED ZOOM LOGIC\n                        if (mapInstance) {\n                            // Don't modify zoom if it's already at an appropriate level\n                            const currentZoom = mapInstance.getZoom();\n                            const targetZoom = currentZoom <= 7 ? 9 : currentZoom;\n                            // Set the view directly to the user's location\n                            mapInstance.setView([\n                                latitude,\n                                longitude\n                            ], targetZoom);\n                            // Make sure the map reflects changes\n                            mapInstance.invalidateSize();\n                        }\n                        // If in geofence mode, ensure the filter mode is set correctly\n                        if (filterMode !== 'geofence' && filterMode !== 'both') {\n                            setFilterMode('geofence');\n                        }\n                    } catch (error) {\n                        var _error_message;\n                        if (((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes('rate limit')) || error.status === 429) {\n                            handleRateLimit(30);\n                            // Still update the location even if we couldn't get aircraft\n                            if (mapInstance) {\n                                mapInstance.setView([\n                                    latitude,\n                                    longitude\n                                ], 9);\n                                mapInstance.invalidateSize();\n                            }\n                        } else {\n                            throw error;\n                        }\n                    }\n                    // Close the dropdown after selection\n                    setActiveDropdown(null);\n                }\n            } catch (error) {\n                console.error('Error getting user location:', error);\n                alert('Unable to access your location. Please make sure location services are enabled in your browser.');\n            } finally{\n                setIsGettingLocation(false);\n            }\n        };\n        // Effects\n        react__WEBPACK_IMPORTED_MODULE_0___default().useEffect({\n            \"useFilterLogic.getUserLocation.useEffect\": ()=>{\n                if (geofenceCoordinates) {\n                    setIsSearchReady(true);\n                }\n            }\n        }[\"useFilterLogic.getUserLocation.useEffect\"], [\n            geofenceCoordinates\n        ]);\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n            \"useFilterLogic.getUserLocation.useEffect\": ()=>{\n                if (isRateLimited && rateLimitTimer) {\n                    const timer = setTimeout({\n                        \"useFilterLogic.getUserLocation.useEffect.timer\": ()=>{\n                            setIsRateLimited(false);\n                            setRateLimitTimer(null);\n                            console.log('Rate limit timer expired, resuming API calls');\n                        }\n                    }[\"useFilterLogic.getUserLocation.useEffect.timer\"], rateLimitTimer * 1000);\n                    return ({\n                        \"useFilterLogic.getUserLocation.useEffect\": ()=>clearTimeout(timer)\n                    })[\"useFilterLogic.getUserLocation.useEffect\"];\n                }\n            }\n        }[\"useFilterLogic.getUserLocation.useEffect\"], [\n            isRateLimited,\n            rateLimitTimer\n        ]);\n        // Effect to sync geofence state\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n            \"useFilterLogic.getUserLocation.useEffect\": ()=>{\n                // Update internal state when geofence is toggled externally\n                if (isGeofenceActive !== geofenceEnabled) {\n                    setGeofenceEnabled(isGeofenceActive);\n                }\n            }\n        }[\"useFilterLogic.getUserLocation.useEffect\"], [\n            isGeofenceActive\n        ]);\n        // Close dropdown when clicking outside\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n            \"useFilterLogic.getUserLocation.useEffect\": ()=>{\n                const handleClickOutside = {\n                    \"useFilterLogic.getUserLocation.useEffect.handleClickOutside\": (event)=>{\n                        // Check if click is outside of all dropdowns\n                        const isOutsideAll = Object.values(dropdownRefs).every({\n                            \"useFilterLogic.getUserLocation.useEffect.handleClickOutside.isOutsideAll\": (ref)=>!ref.current || !ref.current.contains(event.target)\n                        }[\"useFilterLogic.getUserLocation.useEffect.handleClickOutside.isOutsideAll\"]);\n                        if (isOutsideAll) {\n                            setActiveDropdown(null);\n                        }\n                    }\n                }[\"useFilterLogic.getUserLocation.useEffect.handleClickOutside\"];\n                document.addEventListener('mousedown', handleClickOutside);\n                return ({\n                    \"useFilterLogic.getUserLocation.useEffect\": ()=>{\n                        document.removeEventListener('mousedown', handleClickOutside);\n                    }\n                })[\"useFilterLogic.getUserLocation.useEffect\"];\n            }\n        }[\"useFilterLogic.getUserLocation.useEffect\"], []);\n        // Clean up region outline when component unmounts\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n            \"useFilterLogic.getUserLocation.useEffect\": ()=>{\n                return ({\n                    \"useFilterLogic.getUserLocation.useEffect\": ()=>{\n                        if (regionOutline) {\n                            regionOutline.remove();\n                        }\n                    }\n                })[\"useFilterLogic.getUserLocation.useEffect\"];\n            }\n        }[\"useFilterLogic.getUserLocation.useEffect\"], [\n            regionOutline\n        ]);\n        // Effect to handle map click for geofence\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n            \"useFilterLogic.getUserLocation.useEffect\": ()=>{\n                const handleMapGeofenceClick = {\n                    \"useFilterLogic.getUserLocation.useEffect.handleMapGeofenceClick\": async (event)=>{\n                        try {\n                            // Cast the event to the proper type\n                            const customEvent = event;\n                            const { lat, lng } = customEvent.detail;\n                            // First update coordinates immediately\n                            setGeofenceCoordinates({\n                                lat,\n                                lng\n                            });\n                            // Then start an async operation to get the location name\n                            console.log(\"Getting location name for: \".concat(lat, \", \").concat(lng));\n                            // Temporarily show coordinates while fetching the name\n                            setGeofenceLocation(\"\".concat(lat.toFixed(6), \", \").concat(lng.toFixed(6)));\n                            // Get the friendly name asynchronously\n                            const locationName = await _lib_services_MapboxService__WEBPACK_IMPORTED_MODULE_4__.MapboxService.getLocationNameFromCoordinates(lat, lng);\n                            console.log(\"Got location name: \".concat(locationName));\n                            // Update with the friendly name once we have it\n                            if (locationName !== null) {\n                                setGeofenceLocation(locationName);\n                            }\n                            // Open the location dropdown if needed\n                            if (activeDropdown !== 'location') {\n                                setActiveDropdown('location');\n                            }\n                        } catch (error) {\n                            console.error('Error handling map click:', error);\n                        // Keep the coordinates display if there was an error\n                        }\n                    }\n                }[\"useFilterLogic.getUserLocation.useEffect.handleMapGeofenceClick\"];\n                // Add the event listener - use the standard event listener pattern\n                document.addEventListener('map-geofence-click', handleMapGeofenceClick);\n                // Clean up\n                return ({\n                    \"useFilterLogic.getUserLocation.useEffect\": ()=>{\n                        document.removeEventListener('map-geofence-click', handleMapGeofenceClick);\n                    }\n                })[\"useFilterLogic.getUserLocation.useEffect\"];\n            }\n        }[\"useFilterLogic.getUserLocation.useEffect\"], [\n            setGeofenceLocation,\n            setGeofenceCoordinates,\n            setActiveDropdown,\n            activeDropdown\n        ]);\n        // Main methods\n        const toggleDropdown = (dropdown, event)=>{\n            if (activeDropdown === dropdown) {\n                setActiveDropdown(null);\n            } else {\n                setActiveDropdown(dropdown);\n            }\n            // Prevent events from bubbling up\n            event.stopPropagation();\n        };\n        const handleRateLimit = function() {\n            let retryAfter = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 30;\n            setIsRateLimited(true);\n            setRateLimitTimer(retryAfter);\n            console.log(\"Rate limited by API. Retry after \".concat(retryAfter, \"s\"));\n            // Block all API calls\n            _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].setBlockAllApiCalls(true);\n            setBlockManufacturerApiCalls(true);\n            // Show notification to user\n            if (retryAfter > 0) {\n                alert(\"Aircraft data refresh rate limited. Please wait \".concat(retryAfter, \" seconds before trying again.\"));\n            }\n        };\n        /**\r\n     * Toggle filter mode\r\n     */ const toggleFilterMode = (mode)=>{\n            setFilterMode(mode);\n            setActiveDropdown(null);\n            // Apply appropriate filters based on new mode\n            if (mode === 'region') {\n                // Block API calls in region mode\n                _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].setBlockAllApiCalls(true);\n                // Apply region filtering if we already have data\n                if (displayedAircraft && displayedAircraft.length > 0) {\n                    filterAircraftByRegion(selectedRegion.toString());\n                }\n                // Clear manufacturer selection from the UI\n                selectManufacturer(null);\n                selectModel(null);\n                // If geofence is active, restore the full geofence data\n                if (geofenceCoordinates && geofenceAircraft.length > 0) {\n                    updateGeofenceAircraft(geofenceAircraft);\n                }\n            } else if (mode === 'owner') {\n                // Filter displayed aircraft by owner type\n                if (displayedAircraft && displayedAircraft.length > 0) {\n                    // First filter for valid coordinates\n                    const aircraftWithValidCoords = displayedAircraft.filter((plane)=>typeof plane.latitude === 'number' && typeof plane.longitude === 'number' && !isNaN(plane.latitude) && !isNaN(plane.longitude));\n                    // Apply owner type filter\n                    let filteredByOwner = ownerFilters.length === 0 ? aircraftWithValidCoords : aircraftWithValidCoords.filter((aircraft)=>ownerFilters.includes(getAircraftOwnerType(aircraft)));\n                    // Update display with filtered aircraft\n                    if (clearGeofenceData) {\n                        clearGeofenceData();\n                    }\n                    updateGeofenceAircraft(filteredByOwner);\n                }\n            } else if (mode === 'both') {\n                // Both mode - BLOCK API CALLS\n                _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].setBlockAllApiCalls(true);\n                if (selectedManufacturer && isGeofenceActive && geofenceAircraft.length > 0) {\n                    applyCombinedFilters();\n                } else {\n                    // If one is missing, prompt the user\n                    if (!selectedManufacturer && isGeofenceActive) {\n                        alert('Please select a manufacturer to use combined filter mode');\n                    } else if (selectedManufacturer && !isGeofenceActive) {\n                        alert('Please set a location to use combined filter mode');\n                    } else {\n                        alert('Please select both a manufacturer and location to use combined filter mode');\n                    }\n                }\n            }\n        };\n        // Owner filter methods\n        const getAircraftOwnerType = (aircraft)=>{\n            const ownerType = aircraft.TYPE_REGISTRANT || 0;\n            return ownerTypeToString(ownerType);\n        };\n        const ownerTypeToString = (type)=>{\n            const typeNum = typeof type === 'string' ? parseInt(type, 10) : type;\n            const ownerTypeMap = {\n                1: 'individual',\n                2: 'partnership',\n                3: 'corp-owner',\n                4: 'co-owned',\n                7: 'llc',\n                8: 'non-citizen-corp',\n                9: 'airline',\n                10: 'freight',\n                11: 'medical',\n                12: 'media',\n                13: 'historical',\n                14: 'flying-club',\n                15: 'emergency',\n                16: 'local-govt',\n                17: 'education',\n                18: 'federal-govt',\n                19: 'flight-school',\n                20: 'leasing-corp',\n                21: 'military'\n            };\n            return ownerTypeMap[typeNum] || 'unknown';\n        };\n        const applyOwnerTypeFilter = (filters)=>{\n            // Skip filtering if all types are selected or none are selected\n            if (filters.length === 0 || filters.length === allOwnerTypes.length) {\n                return;\n            }\n            // Filter the aircraft based on selected owner types\n            if (displayedAircraft && displayedAircraft.length > 0) {\n                const filteredAircraft = displayedAircraft.filter((aircraft)=>{\n                    const ownerType = getAircraftOwnerType(aircraft);\n                    return filters.includes(ownerType);\n                });\n                // Update the displayed aircraft\n                if (clearGeofenceData) {\n                    clearGeofenceData();\n                }\n                updateGeofenceAircraft(filteredAircraft);\n            }\n        };\n        const handleOwnerFilterChange = (updatedFilters)=>{\n            setOwnerFilters(updatedFilters);\n            // Apply the filter to your aircraft data\n            applyOwnerTypeFilter(updatedFilters);\n        };\n        const resetOwnerFilters = ()=>{\n            setOwnerFilters([\n                ...allOwnerTypes\n            ]);\n        };\n        // Region filter methods\n        const filterAircraftByRegion = (region)=>{\n            if (!displayedAircraft || displayedAircraft.length === 0) return;\n            setLocalLoading(true);\n            try {\n                // Get the bounds for the selected region\n                const boundsExpression = (0,_config_map__WEBPACK_IMPORTED_MODULE_10__.getBoundsByRegion)(region);\n                // Ensure bounds is in the correct format\n                if (!Array.isArray(boundsExpression) || boundsExpression.length !== 2) {\n                    console.error(\"Invalid bounds format for region: \".concat(region), boundsExpression);\n                    setLocalLoading(false);\n                    return;\n                }\n                // Extract coordinates - Leaflet uses [lat, lng] format\n                const [[minLat, minLng], [maxLat, maxLng]] = boundsExpression;\n                console.log(\"Filtering by region: \".concat(region, \" with bounds:\"), {\n                    minLat,\n                    minLng,\n                    maxLat,\n                    maxLng\n                });\n                // Filter aircraft based on coordinates within the bounds\n                const filteredAircraft = displayedAircraft.filter((aircraft)=>{\n                    // Check if aircraft has valid coordinates\n                    if (typeof aircraft.latitude !== 'number' || typeof aircraft.longitude !== 'number' || isNaN(aircraft.latitude) || isNaN(aircraft.longitude)) {\n                        return false;\n                    }\n                    // Check if coordinates are within the bounds\n                    return aircraft.latitude >= minLat && aircraft.latitude <= maxLat && aircraft.longitude >= minLng && aircraft.longitude <= maxLng;\n                });\n                // Update the display with filtered aircraft\n                if (clearGeofenceData) {\n                    clearGeofenceData();\n                }\n                updateGeofenceAircraft(filteredAircraft);\n                console.log(\"Filtered to \".concat(filteredAircraft.length, \" aircraft in \").concat(region, \" region (out of \").concat(displayedAircraft.length, \" total)\"));\n            } catch (error) {\n                console.error('Error filtering aircraft by region:', error);\n            } finally{\n                setLocalLoading(false);\n            }\n        };\n        const handleRegionSelect = async (region)=>{\n            setActiveRegion(region);\n            setSelectedRegion(region);\n            setLocalLoading(true);\n            try {\n                // Set map bounds based on region\n                if (mapInstance) {\n                    const bounds = (0,_config_map__WEBPACK_IMPORTED_MODULE_10__.getBoundsByRegion)(region);\n                    // Get the appropriate zoom level for this region from your config\n                    const zoomLevel = (0,_config_map__WEBPACK_IMPORTED_MODULE_10__.getZoomLevelForRegion)(region);\n                    // First, set the appropriate zoom level\n                    mapInstance.setZoom(zoomLevel);\n                    // Then fit bounds with padding\n                    const options = {\n                        padding: _config_map__WEBPACK_IMPORTED_MODULE_10__.MAP_CONFIG.PADDING.DEFAULT\n                    };\n                    mapInstance.fitBounds(bounds, options);\n                    mapInstance.invalidateSize();\n                    drawRegionOutline(region);\n                }\n                // Instead of immediately fetching aircraft data,\n                // just store the region selection for later use\n                console.log(\"Region selected. Waiting for manufacturer selection...\");\n                // Optionally, you could fetch just the count of aircraft in this region\n                // to give the user an idea of the data volume\n                const countResponse = await fetch(\"/api/tracking/region-count?region=\".concat(region));\n                if (countResponse.ok) {\n                    const countData = await countResponse.json();\n                    console.log(\"\".concat(countData.count, \" aircraft available in this region\"));\n                }\n                // Clear any previous aircraft data\n                if (clearGeofenceData) {\n                    clearGeofenceData();\n                }\n            } catch (error) {\n                console.error('Error in region selection:', error);\n            } finally{\n                setLocalLoading(false);\n                setActiveDropdown(null);\n            }\n        };\n        const drawRegionOutline = (region)=>{\n            if (!mapInstance) return;\n            // Clear any existing outline\n            if (regionOutline) {\n                regionOutline.remove();\n            }\n            // Get the bounds for the selected region\n            const bounds = (0,_config_map__WEBPACK_IMPORTED_MODULE_10__.getBoundsByRegion)(region);\n            // Create a polygon from the bounds\n            const L = __webpack_require__(/*! leaflet */ \"(pages-dir-browser)/./node_modules/leaflet/dist/leaflet-src.js\");\n            const rectangle = L.rectangle(bounds, {\n                color: '#4f46e5',\n                weight: 3,\n                opacity: 0.7,\n                fill: true,\n                fillColor: '#4f46e5',\n                fillOpacity: 0.1,\n                dashArray: '5, 10',\n                interactive: false\n            });\n            // Add to map\n            rectangle.addTo(mapInstance);\n            // Update the state to include both the rectangle and the label\n            setRegionOutline({\n                remove: ()=>{\n                    rectangle.remove();\n                }\n            });\n        };\n        const processGeofenceSearch = async ()=>{\n            if (!geofenceLocation) return;\n            // Check if rate limited\n            if (isRateLimited) {\n                alert(\"Rate limited. Please wait \".concat(rateLimitTimer || 30, \" seconds before searching again.\"));\n                return;\n            }\n            // Block API calls while doing geofence search in combined mode\n            if (filterMode === 'both') {\n                _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].setBlockAllApiCalls(true);\n                setBlockManufacturerApiCalls(true);\n            }\n            // Set loading state\n            setLocalLoading(true);\n            try {\n                console.log('Searching for aircraft near location: \"'.concat(geofenceLocation, '\"'));\n                // This will handle Postal codes, place names, addresses, POIs, etc.\n                let fetchedAircraft;\n                try {\n                    fetchedAircraft = await (0,_lib_services_geofencing__WEBPACK_IMPORTED_MODULE_8__.getAircraftNearSearchedLocation)(geofenceLocation, geofenceRadius);\n                } catch (error) {\n                    var _error_message;\n                    if (((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes('rate limit')) || error.status === 429) {\n                        const retryAfter = 30; // Default to 30 seconds if not specified\n                        handleRateLimit(retryAfter);\n                        setLocalLoading(false);\n                        return;\n                    }\n                    throw error;\n                }\n                // Get coordinates for the map\n                let locations;\n                try {\n                    locations = await _lib_services_MapboxService__WEBPACK_IMPORTED_MODULE_4__.MapboxService.searchLocationWithMapbox(geofenceLocation, 1);\n                } catch (error) {\n                    console.error('Error searching location with Mapbox:', error);\n                    // Continue with aircraft data if available\n                    locations = [];\n                }\n                let coordinates = null;\n                if (locations.length > 0) {\n                    coordinates = {\n                        lat: locations[0].lat,\n                        lng: locations[0].lng\n                    };\n                    // Save the formatted location name\n                    setGeofenceLocation(locations[0].name);\n                } else if (fetchedAircraft.length > 0 && fetchedAircraft[0].latitude && fetchedAircraft[0].longitude) {\n                    // Fallback to first aircraft position\n                    coordinates = {\n                        lat: fetchedAircraft[0].latitude,\n                        lng: fetchedAircraft[0].longitude\n                    };\n                }\n                if (fetchedAircraft.length === 0) {\n                    alert(\"No aircraft found near \".concat(geofenceLocation, \". Try increasing the radius or searching in a different area.\"));\n                    setLocalLoading(false);\n                    return;\n                }\n                // Update state with the coordinates\n                if (coordinates) {\n                    setGeofenceCoordinates(coordinates);\n                    setGeofenceCenter(coordinates);\n                    setGeofenceRadius(geofenceRadius);\n                }\n                if (!isGeofenceActive) {\n                    toggleGeofence();\n                } else if (!coordinates) {\n                    throw new Error('Could not determine coordinates for the location');\n                }\n                console.log(\"Found \".concat(fetchedAircraft.length, \" aircraft in the area, preparing for display...\"));\n                // Ensure the data is in the right format\n                const adaptedAircraft = fetchedAircraft[0].MANUFACTURER !== undefined ? fetchedAircraft // Already in the right format\n                 : (0,_lib_utils_geofenceAdapter__WEBPACK_IMPORTED_MODULE_5__.adaptGeofenceAircraft)(fetchedAircraft); // Needs adaptation\n                // Enrich with static data\n                console.log('Enriching geofence aircraft with static data...');\n                const enrichedAircraft = await (0,_lib_utils_geofenceEnricher__WEBPACK_IMPORTED_MODULE_6__.enrichGeofenceAircraft)(adaptedAircraft);\n                // Save the FULL set to local state\n                setGeofenceAircraft(enrichedAircraft);\n                setIsGeofenceActive(true);\n                // Clear existing aircraft data\n                if (clearGeofenceData) {\n                    clearGeofenceData();\n                }\n                // If we're in combined mode and have a manufacturer, apply the combined filter\n                if (filterMode === 'both' && selectedManufacturer) {\n                    // Make sure API calls remain blocked\n                    _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].setBlockAllApiCalls(true);\n                    setBlockManufacturerApiCalls(true);\n                    setTimeout(()=>{\n                        applyCombinedFilters();\n                    }, 100);\n                } else {\n                    // Just show all aircraft in the geofence\n                    updateGeofenceAircraft(enrichedAircraft);\n                    // Center the map - SIMPLIFIED ZOOM LOGIC\n                    if (mapInstance && coordinates) {\n                        // Get current zoom level\n                        const currentZoom = mapInstance.getZoom();\n                        // Use appropriate zoom level based on current view\n                        const targetZoom = currentZoom <= 7 ? 9 : currentZoom;\n                        // Set view to the coordinates\n                        mapInstance.setView([\n                            coordinates.lat,\n                            coordinates.lng\n                        ], targetZoom);\n                        // Ensure map is updated\n                        mapInstance.invalidateSize();\n                    }\n                }\n                // Close dropdown after search\n                setActiveDropdown(null);\n            } catch (error) {\n                var _error_message1;\n                console.error('Error in geofence search:', error);\n                if (((_error_message1 = error.message) === null || _error_message1 === void 0 ? void 0 : _error_message1.includes('rate limit')) || error.status === 429) {\n                    handleRateLimit(30);\n                } else {\n                    alert(\"Error: \".concat(error instanceof Error ? error.message : 'Unknown error occurred'));\n                }\n            } finally{\n                setLocalLoading(false);\n            }\n        };\n        /**\r\n     * STEP 3: Fix toggleGeofenceState to better handle manually clicking the button\r\n     */ const toggleGeofenceState = (enabled)=>{\n            console.log('toggleGeofenceState called with:', enabled);\n            console.log('Current geofenceCoordinates:', geofenceCoordinates);\n            if (enabled) {\n                // Check if we have valid coordinates\n                if (geofenceCoordinates && typeof geofenceCoordinates.lat === 'number' && typeof geofenceCoordinates.lng === 'number' && !isNaN(geofenceCoordinates.lat) && !isNaN(geofenceCoordinates.lng)) {\n                    console.log('Valid coordinates found, enabling geofence');\n                    // Set flags first\n                    setGeofenceEnabled(true);\n                    setIsGeofenceActive(true);\n                    // Call context toggle function if available\n                    if (typeof toggleGeofence === 'function') {\n                        toggleGeofence();\n                    }\n                    // Display aircraft if we have them\n                    if (geofenceAircraft && geofenceAircraft.length > 0) {\n                        console.log(\"Showing \".concat(geofenceAircraft.length, \" aircraft in geofence\"));\n                        updateGeofenceAircraft(geofenceAircraft);\n                    } else {\n                        // No aircraft data yet, trigger a search\n                        console.log('No aircraft data yet, triggering search');\n                        setTimeout(()=>{\n                            processGeofenceSearch();\n                        }, 100);\n                    }\n                } else {\n                    // No valid coordinates\n                    console.warn('No valid coordinates, showing alert');\n                    alert('Please set a location before enabling geofence.\\n\\nClick anywhere on the map to set a location.');\n                    setGeofenceEnabled(false);\n                    setIsGeofenceActive(false);\n                }\n            } else {\n                // Disabling geofence\n                console.log('Disabling geofence');\n                setGeofenceEnabled(false);\n                setIsGeofenceActive(false);\n                // Clear geofence data if function available\n                if (typeof clearGeofenceData === 'function') {\n                    clearGeofenceData();\n                }\n            }\n        };\n        // Manufacturer filter methods\n        const selectManufacturerAndClose = (value)=>{\n            // Close dropdown\n            setActiveDropdown(null);\n            setManufacturerSearchTerm('');\n            // If clearing the selection\n            if (value === '') {\n                selectManufacturer(null);\n                return;\n            }\n            // Set the manufacturer selection\n            selectManufacturer(value);\n            // If region is already selected, fetch filtered data\n            if (activeRegion !== null) {\n                fetchAircraftByRegionAndManufacturer(activeRegion, value);\n            } else {\n                // Otherwise, just proceed with manufacturer-only filtering as before\n                fetchManufacturerData(value);\n            }\n        };\n        const fetchManufacturerData = (manufacturer)=>{\n            if (isRateLimited) {\n                console.log(\"Skipping data fetch - rate limited for \".concat(rateLimitTimer, \"s\"));\n                return;\n            }\n            console.log(\"Fetching data for manufacturer: \".concat(manufacturer));\n            try {\n                // If you have a context function for this, call it after a slight delay\n                if (typeof refreshPositions === 'function') {\n                    // Apply a small delay to prevent overwhelming the API\n                    setTimeout(()=>{\n                        refreshPositions().catch((error)=>{\n                            var _error_message;\n                            if (((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes('rate limit')) || error.status === 429) {\n                                handleRateLimit(30);\n                            } else {\n                                console.error('Error fetching manufacturer data:', error);\n                            }\n                        });\n                    }, 200);\n                }\n            } catch (error) {\n                var _error_message;\n                if (((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes('rate limit')) || error.status === 429) {\n                    handleRateLimit(30);\n                } else {\n                    console.error('Error scheduling manufacturer data fetch:', error);\n                }\n            }\n        };\n        const fetchAircraftByRegionAndManufacturer = async function(region, manufacturer) {\n            let page = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, limit = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 500;\n            if (!region || !manufacturer) {\n                console.log('Both region and manufacturer must be selected');\n                return;\n            }\n            setLocalLoading(true);\n            try {\n                const response = await fetch(\"/api/tracking/filtered-aircraft?region=\".concat(region, \"&manufacturer=\").concat(encodeURIComponent(manufacturer), \"&page=\").concat(page, \"&limit=\").concat(limit));\n                const data = await response.json();\n                const aircraftData = data.aircraft || [];\n                if (!response.ok) {\n                    throw new Error(\"API error: \".concat(response.statusText));\n                }\n                // Process the filtered aircraft data\n                if (aircraftData.length > 0) {\n                    const extendedAircraft = aircraftData.map((aircraft)=>{\n                        var _aircraft_OPERATOR;\n                        var _aircraft_OPERATOR_toLowerCase_includes;\n                        return {\n                            ...aircraft,\n                            type: aircraft.TYPE_AIRCRAFT || 'Unknown',\n                            isGovernment: (_aircraft_OPERATOR_toLowerCase_includes = (_aircraft_OPERATOR = aircraft.OPERATOR) === null || _aircraft_OPERATOR === void 0 ? void 0 : _aircraft_OPERATOR.toLowerCase().includes('government')) !== null && _aircraft_OPERATOR_toLowerCase_includes !== void 0 ? _aircraft_OPERATOR_toLowerCase_includes : false,\n                            REGION: aircraft.REGION,\n                            zoomLevel: undefined\n                        };\n                    });\n                    // Update the map\n                    updateGeofenceAircraft(extendedAircraft);\n                } else {\n                    console.log(\"No aircraft found for manufacturer \".concat(manufacturer, \" in region \").concat(region));\n                }\n            } catch (error) {\n                console.error('Error fetching filtered aircraft:', error);\n            } finally{\n                setLocalLoading(false);\n            }\n        };\n        // Model selection methods\n        const handleModelSelect = (value)=>{\n            selectModel(value === '' ? null : value);\n            setActiveDropdown(null);\n            // If in combined mode, reapply the filter\n            if (filterMode === 'both' && isGeofenceActive && selectedManufacturer) {\n                setTimeout(()=>{\n                    applyCombinedFilters();\n                }, 100);\n            }\n        };\n        // Combined filter methods\n        const applyCombinedFilters = ()=>{\n            if (!selectedManufacturer || !isGeofenceActive || geofenceAircraft.length === 0) {\n                return;\n            }\n            setLocalLoading(true);\n            try {\n                console.log(\"Filtering \".concat(geofenceAircraft.length, \" aircraft by \").concat(selectedManufacturer));\n                // Filter the aircraft by manufacturer\n                let filteredAircraft = geofenceAircraft.filter((aircraft)=>{\n                    var _aircraft_MANUFACTURER;\n                    return ((_aircraft_MANUFACTURER = aircraft.MANUFACTURER) === null || _aircraft_MANUFACTURER === void 0 ? void 0 : _aircraft_MANUFACTURER.toLowerCase()) === selectedManufacturer.toLowerCase();\n                });\n                // Further filter by model if selected\n                if (selectedModel) {\n                    filteredAircraft = filteredAircraft.filter((aircraft)=>{\n                        var _aircraft_MODEL;\n                        return ((_aircraft_MODEL = aircraft.MODEL) === null || _aircraft_MODEL === void 0 ? void 0 : _aircraft_MODEL.toLowerCase()) === selectedModel.toLowerCase();\n                    });\n                }\n                console.log(\"Found \".concat(filteredAircraft.length, \" matching aircraft\"));\n                if (filteredAircraft.length === 0) {\n                    alert(\"No \".concat(selectedManufacturer, \" aircraft found in this area.\"));\n                    return;\n                }\n                // Clear display data\n                if (clearGeofenceData) {\n                    clearGeofenceData();\n                }\n                // Update the display\n                updateGeofenceAircraft(filteredAircraft);\n            } catch (error) {\n                console.error('Error filtering aircraft:', error);\n            } finally{\n                setLocalLoading(false);\n            }\n        };\n        // Reset all filters\n        const clearAllFilters = ()=>{\n            console.log('Clearing all filters...');\n            // 1. Reset filter mode\n            setFilterMode('manufacturer');\n            // 2. Unblock API calls that might have been blocked\n            _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].setBlockAllApiCalls(false);\n            setBlockManufacturerApiCalls(false);\n            setIsManufacturerApiBlocked(false);\n            // 3. Clear manufacturer selection\n            selectManufacturer(null);\n            selectModel(null);\n            // 4. Clear geofence\n            setGeofenceLocation('');\n            setGeofenceCoordinates(null);\n            setGeofenceAircraft([]);\n            setGeofenceEnabled(false);\n            setIsGeofenceActive(false);\n            if (typeof clearGeofence === 'function') {\n                clearGeofence();\n            }\n            if (typeof clearGeofenceData === 'function') {\n                clearGeofenceData();\n            }\n            // 5. Reset owner filters to select all\n            setOwnerFilters([\n                ...allOwnerTypes\n            ]);\n            // 6. Clear region filter properly\n            setActiveRegion(null);\n            setSelectedRegion(_types_base__WEBPACK_IMPORTED_MODULE_1__.RegionCode.GLOBAL);\n            // Clear region outline from map\n            if (regionOutline) {\n                try {\n                    // Handle different possible object structures\n                    if (typeof regionOutline.remove === 'function') {\n                        regionOutline.remove();\n                    } else if (regionOutline.rectangle && typeof regionOutline.rectangle.remove === 'function') {\n                        regionOutline.rectangle.remove();\n                    }\n                    // Clear any labels associated with the region\n                    if (regionOutline.label && typeof regionOutline.label.remove === 'function') {\n                        regionOutline.label.remove();\n                    }\n                } catch (error) {\n                    console.error('Error removing region outline:', error);\n                }\n                // Always reset the region outline state\n                setRegionOutline(null);\n            }\n            // 7. Reset map view to global\n            if (mapInstance) {\n                // Use the predefined center and zoom level from your map config\n                mapInstance.setView(_config_map__WEBPACK_IMPORTED_MODULE_10__.MAP_CONFIG.CENTER, _config_map__WEBPACK_IMPORTED_MODULE_10__.MAP_CONFIG.DEFAULT_ZOOM);\n                mapInstance.invalidateSize();\n            }\n            // 8. Reset to initial aircraft data\n            if (typeof reset === 'function') {\n                reset();\n            } else if (typeof fullRefresh === 'function') {\n                fullRefresh();\n            }\n            // 9. Close any open dropdown\n            setActiveDropdown(null);\n            // 10. Reset rate limiting states\n            setIsRateLimited(false);\n            setRateLimitTimer(null);\n            // 11. Clear combined mode state\n            setCombinedModeReady(false);\n            // 12. Reset search terms\n            setManufacturerSearchTerm('');\n            // 13. Dispatch a custom event that other components can listen for\n            const clearEvent = new CustomEvent('ribbon-filters-cleared');\n            document.dispatchEvent(clearEvent);\n            console.log('All filters cleared successfully');\n        };\n        // Calculate combined loading state\n        const combinedLoading = localLoading;\n        return {\n            // State\n            filterMode,\n            activeDropdown,\n            selectedManufacturer,\n            selectedModel,\n            geofenceLocation,\n            geofenceRadius,\n            isGeofenceActive,\n            geofenceCoordinates,\n            getUserLocation,\n            activeRegion,\n            ownerFilters,\n            allOwnerTypes,\n            manufacturerSearchTerm,\n            combinedLoading,\n            isGettingLocation,\n            dropdownRefs,\n            localLoading,\n            isRateLimited,\n            selectedRegion,\n            isRefreshing,\n            isGeofencePlacementMode: false,\n            // Methods\n            toggleDropdown,\n            toggleFilterMode,\n            selectManufacturerAndClose,\n            handleModelSelect,\n            processGeofenceSearch,\n            handleOwnerFilterChange,\n            handleRegionSelect,\n            setManufacturerSearchTerm,\n            setGeofenceLocation,\n            setGeofenceRadius,\n            toggleGeofenceState,\n            clearAllFilters,\n            applyCombinedFilters,\n            getAircraftOwnerType,\n            setGeofenceCoordinates,\n            setGeofenceCenter,\n            updateGeofenceAircraft,\n            refreshWithFilters: ()=>{\n                // Implement refresh logic here\n                if (typeof refreshPositions === 'function') {\n                    refreshPositions().catch((error)=>{\n                        console.error('Error refreshing positions:', error);\n                    });\n                }\n            },\n            setActiveDropdown\n        };\n    };\n}\nfunction applyCombinedFilters() {\n    throw new Error('Function not implemented.');\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvdHJhY2tpbmcvaG9va3MvdXNlRmlsdGVyTG9naWMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFvRDtBQUMxQjtBQUNnQjtBQUU0QjtBQUNLO0FBQ1A7QUFDQTtBQUNFO0FBQ0c7QUFJL0I7QUFDZTtBQU01QjtBQTJCdEIsU0FBU2lCO0lBQ2Qsa0NBQWtDO0lBQ2xDLE1BQU0sRUFDSkMsb0JBQW9CLEVBQ3BCQyxhQUFhLEVBQ2JDLFdBQVcsRUFDWEMsa0JBQWtCLEVBQ2xCQyxXQUFXLEVBQ1hDLEtBQUssRUFDTEMsV0FBVyxFQUNYQyxnQkFBZ0IsRUFDaEJDLFdBQVcsRUFDWEMsa0JBQWtCLEVBQ2xCQyxpQkFBaUIsRUFDakJDLHNCQUFzQixFQUN0QkMseUJBQXlCLEVBQ3pCQyw0QkFBNEIsRUFDNUJDLHdCQUF3QixFQUN4QkMsMkJBQTJCLEVBQzNCQyxjQUFjLEVBQ2RDLGlCQUFpQixFQUNqQkMsY0FBYyxFQUNkQyxhQUFhLEVBQ2JDLGlCQUFpQixFQUNsQixHQUFHakMsa0ZBQXFCQTtJQUV6Qiw2Q0FBNkM7SUFDN0MsTUFBTWtDLHNCQUFzQjdCLHFGQUFzQkE7SUFFbEQsY0FBYztJQUNkLE1BQU0sQ0FBQzhCLGNBQWNDLGdCQUFnQixHQUFHekMsK0NBQVFBLENBQUM7SUFDakQsTUFBTSxDQUFDMEMsWUFBWUMsY0FBYyxHQUFHM0MsK0NBQVFBLENBQW9CO0lBQ2hFLE1BQU0sQ0FBQzRDLGdCQUFnQkMsa0JBQWtCLEdBQUc3QywrQ0FBUUEsQ0FBZ0I7SUFDcEUsTUFBTSxDQUFDOEMsd0JBQXdCQywwQkFBMEIsR0FBRy9DLCtDQUFRQSxDQUFDO0lBQ3JFLE1BQU0sQ0FBQ2dELGNBQWNDLGdCQUFnQixHQUFHakQsK0NBQVFBLENBQUM7SUFDakQsTUFBTSxDQUFDa0QsZUFBZUMsaUJBQWlCLEdBQUduRCwrQ0FBUUEsQ0FBQztJQUNuRCxNQUFNLENBQUNvRCxnQkFBZ0JDLGtCQUFrQixHQUFHckQsK0NBQVFBLENBQWdCO0lBRXBFLGlCQUFpQjtJQUNqQixNQUFNLENBQUNzRCxtQkFBbUJDLHFCQUFxQixHQUFHdkQsK0NBQVFBLENBQUM7SUFDM0QsTUFBTSxDQUFDd0Qsa0JBQWtCQyxvQkFBb0IsR0FBR3pELCtDQUFRQSxDQUFTO0lBQ2pFLE1BQU0sQ0FBQzBELGdCQUFnQkMsa0JBQWtCLEdBQUczRCwrQ0FBUUEsQ0FBUztJQUM3RCxNQUFNLENBQUM0RCxxQkFBcUJDLHVCQUF1QixHQUFHN0QsK0NBQVFBLENBR3BEO0lBQ1YsTUFBTSxDQUFDOEQsa0JBQWtCQyxvQkFBb0IsR0FBRy9ELCtDQUFRQSxDQUN0RCxFQUFFO0lBRUosTUFBTSxDQUFDZ0UsaUJBQWlCQyxtQkFBbUIsR0FBR2pFLCtDQUFRQSxDQUFDO0lBQ3ZELE1BQU0sQ0FBQ2tFLGtCQUFrQkMsb0JBQW9CLEdBQUduRSwrQ0FBUUEsQ0FBQztJQUN6RCxNQUFNLENBQUNvRSxlQUFlQyxpQkFBaUIsR0FBR2xFLHFEQUFjLENBQUM7SUFFekQsZUFBZTtJQUNmLE1BQU0sQ0FBQ21FLGNBQWNDLGdCQUFnQixHQUFHdkUsK0NBQVFBLENBQzlDO0lBRUYsTUFBTSxDQUFDd0UsZUFBZUMsaUJBQWlCLEdBQUd6RSwrQ0FBUUEsQ0FBTTtJQUN4RCxNQUFNLENBQUMwRSxnQkFBZ0JDLGtCQUFrQixHQUFHM0UsK0NBQVFBLENBQ2xESSxtREFBVUEsQ0FBQ3dFLE1BQU07SUFHbkIsc0JBQXNCO0lBQ3RCLE1BQU0sQ0FBQ0MsbUJBQW1CQyxxQkFBcUIsR0FBRzlFLCtDQUFRQSxDQUFVO0lBRXBFLHFCQUFxQjtJQUNyQixNQUFNK0UsZ0JBQWdCO1FBQ3BCO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7S0FDRDtJQUVELE1BQU0sQ0FBQ0MsY0FBY0MsZ0JBQWdCLEdBQUdqRiwrQ0FBUUEsQ0FBVztXQUN0RCtFO0tBQ0o7SUFFRCw2QkFBNkI7SUFDN0IsTUFBTUcsZUFBZTtRQUNuQkMsUUFBUWxGLDZDQUFNQSxDQUFpQjtRQUMvQm1GLGNBQWNuRiw2Q0FBTUEsQ0FBaUI7UUFDckNvRixPQUFPcEYsNkNBQU1BLENBQWlCO1FBQzlCcUYsVUFBVXJGLDZDQUFNQSxDQUFpQjtRQUNqQ3NGLFFBQVF0Riw2Q0FBTUEsQ0FBaUI7UUFDL0J1RixPQUFPdkYsNkNBQU1BLENBQWlCO1FBQzlCd0YsU0FBU3hGLDZDQUFNQSxDQUFpQjtJQUNsQztJQUVBLHNEQUFzRDtJQUN0RCxNQUFNeUYsY0FBYzdFLHFFQUFjQSxDQUFDO0lBRW5DLG1CQUFtQjtJQUNuQixpQ0FBaUM7SUFDakMsTUFBTThFLGtCQUFrQjtRQUN0QixJQUFJekMsZUFBZTtZQUNqQjBDLE1BQ0UsNkJBQWtELE9BQXJCeEMsa0JBQWtCLElBQUc7WUFFcEQ7UUFDRjtRQUVBLE1BQU11QyxrQkFBa0I7WUFDdEIsSUFBSXpDLGVBQWU7Z0JBQ2pCMEMsTUFDRSw2QkFBa0QsT0FBckJ4QyxrQkFBa0IsSUFBRztnQkFFcEQ7WUFDRjtZQUVBRyxxQkFBcUI7WUFDckIsSUFBSTtnQkFDRixvREFBb0Q7Z0JBQ3BELE1BQU1zQyxXQUFXLE1BQU10RCxvQkFBb0J1RCxrQkFBa0I7Z0JBRTdELElBQUlELFVBQVU7b0JBQ1osTUFBTSxFQUFFRSxRQUFRLEVBQUVDLFNBQVMsRUFBRSxHQUFHSCxTQUFTSSxNQUFNO29CQUUvQyxnQ0FBZ0M7b0JBQ2hDcEMsdUJBQXVCO3dCQUFFcUMsS0FBS0g7d0JBQVVJLEtBQUtIO29CQUFVO29CQUN2RDdELGtCQUFrQjt3QkFBRStELEtBQUtIO3dCQUFVSSxLQUFLSDtvQkFBVTtvQkFFbEQsK0NBQStDO29CQUMvQ3ZDLG9CQUNFLEdBQTJCdUMsT0FBeEJELFNBQVNLLE9BQU8sQ0FBQyxJQUFHLE1BQXlCLE9BQXJCSixVQUFVSSxPQUFPLENBQUM7b0JBRy9DLDRDQUE0QztvQkFDNUMsSUFBSTt3QkFDRixNQUFNQyxrQkFBa0IsTUFBTTFGLGlGQUF1QkEsQ0FDbkRvRixVQUNBQyxXQUNBdEM7d0JBR0YsSUFBSTJDLGdCQUFnQkMsTUFBTSxLQUFLLEdBQUc7NEJBQ2hDVixNQUNHOzRCQUVIckMscUJBQXFCOzRCQUNyQjt3QkFDRjt3QkFFQSw0QkFBNEI7d0JBQzVCLE1BQU1nRCxrQkFBa0IvRixpRkFBcUJBLENBQUM2Rjt3QkFDOUMsTUFBTUcsbUJBQ0osTUFBTS9GLG1GQUFzQkEsQ0FBQzhGO3dCQUUvQixzQkFBc0I7d0JBQ3RCeEMsb0JBQW9CeUM7d0JBRXBCLCtCQUErQjt3QkFDL0IsSUFBSTVFLG1CQUFtQjs0QkFDckJBO3dCQUNGO3dCQUVBLG1DQUFtQzt3QkFDbkNDLHVCQUF1QjJFO3dCQUN2QnJDLG9CQUFvQjt3QkFFcEIsNERBQTREO3dCQUM1RCxJQUFJekMsYUFBYTs0QkFDZiw0REFBNEQ7NEJBQzVELE1BQU0rRSxjQUFjL0UsWUFBWWdGLE9BQU87NEJBQ3ZDLE1BQU1DLGFBQWFGLGVBQWUsSUFBSSxJQUFJQTs0QkFFMUMsK0NBQStDOzRCQUMvQy9FLFlBQVlrRixPQUFPLENBQUM7Z0NBQUNiO2dDQUFVQzs2QkFBVSxFQUFFVzs0QkFFM0MscUNBQXFDOzRCQUNyQ2pGLFlBQVltRixjQUFjO3dCQUM1Qjt3QkFFQSwrREFBK0Q7d0JBQy9ELElBQUluRSxlQUFlLGNBQWNBLGVBQWUsUUFBUTs0QkFDdERDLGNBQWM7d0JBQ2hCO29CQUNGLEVBQUUsT0FBT21FLE9BQVk7NEJBQ2ZBO3dCQUFKLElBQUlBLEVBQUFBLGlCQUFBQSxNQUFNQyxPQUFPLGNBQWJELHFDQUFBQSxlQUFlRSxRQUFRLENBQUMsa0JBQWlCRixNQUFNRyxNQUFNLEtBQUssS0FBSzs0QkFDakVDLGdCQUFnQjs0QkFDaEIsNkRBQTZEOzRCQUM3RCxJQUFJeEYsYUFBYTtnQ0FDZkEsWUFBWWtGLE9BQU8sQ0FBQztvQ0FBQ2I7b0NBQVVDO2lDQUFVLEVBQUU7Z0NBQzNDdEUsWUFBWW1GLGNBQWM7NEJBQzVCO3dCQUNGLE9BQU87NEJBQ0wsTUFBTUM7d0JBQ1I7b0JBQ0Y7b0JBRUEscUNBQXFDO29CQUNyQ2pFLGtCQUFrQjtnQkFDcEI7WUFDRixFQUFFLE9BQU9pRSxPQUFPO2dCQUNkSyxRQUFRTCxLQUFLLENBQUMsZ0NBQWdDQTtnQkFDOUNsQixNQUNFO1lBRUosU0FBVTtnQkFDUnJDLHFCQUFxQjtZQUN2QjtRQUNGO1FBRUEsVUFBVTtRQUVWcEQsc0RBQWU7d0RBQUM7Z0JBQ2QsSUFBSXlELHFCQUFxQjtvQkFDdkJTLGlCQUFpQjtnQkFDbkI7WUFDRjt1REFBRztZQUFDVDtTQUFvQjtRQUV4QjFELGdEQUFTQTt3REFBQztnQkFDUixJQUFJZ0QsaUJBQWlCRSxnQkFBZ0I7b0JBQ25DLE1BQU1nRSxRQUFRQzswRUFBVzs0QkFDdkJsRSxpQkFBaUI7NEJBQ2pCRSxrQkFBa0I7NEJBQ2xCOEQsUUFBUUcsR0FBRyxDQUFDO3dCQUNkO3lFQUFHbEUsaUJBQWlCO29CQUVwQjtvRUFBTyxJQUFNbUUsYUFBYUg7O2dCQUM1QjtZQUNGO3VEQUFHO1lBQUNsRTtZQUFlRTtTQUFlO1FBRWxDLGdDQUFnQztRQUNoQ2xELGdEQUFTQTt3REFBQztnQkFDUiw0REFBNEQ7Z0JBQzVELElBQUlnRSxxQkFBcUJGLGlCQUFpQjtvQkFDeENDLG1CQUFtQkM7Z0JBQ3JCO1lBQ0Y7dURBQUc7WUFBQ0E7U0FBaUI7UUFFckIsdUNBQXVDO1FBQ3ZDaEUsZ0RBQVNBO3dEQUFDO2dCQUNSLE1BQU1zSDttRkFBcUIsQ0FBQ0M7d0JBQzFCLDZDQUE2Qzt3QkFDN0MsTUFBTUMsZUFBZUMsT0FBT0MsTUFBTSxDQUFDMUMsY0FBYzJDLEtBQUs7d0dBQ3BELENBQUNDLE1BQVEsQ0FBQ0EsSUFBSUMsT0FBTyxJQUFJLENBQUNELElBQUlDLE9BQU8sQ0FBQ0MsUUFBUSxDQUFDUCxNQUFNUSxNQUFNOzt3QkFHN0QsSUFBSVAsY0FBYzs0QkFDaEI3RSxrQkFBa0I7d0JBQ3BCO29CQUNGOztnQkFFQXFGLFNBQVNDLGdCQUFnQixDQUFDLGFBQWFYO2dCQUN2QztnRUFBTzt3QkFDTFUsU0FBU0UsbUJBQW1CLENBQUMsYUFBYVo7b0JBQzVDOztZQUNGO3VEQUFHLEVBQUU7UUFFTCxrREFBa0Q7UUFDbER0SCxnREFBU0E7d0RBQUM7Z0JBQ1I7Z0VBQU87d0JBQ0wsSUFBSXNFLGVBQWU7NEJBQ2pCQSxjQUFjNkQsTUFBTTt3QkFDdEI7b0JBQ0Y7O1lBQ0Y7dURBQUc7WUFBQzdEO1NBQWM7UUFFbEIsMENBQTBDO1FBQzFDdEUsZ0RBQVNBO3dEQUFDO2dCQUNSLE1BQU1vSTt1RkFBeUIsT0FBT2I7d0JBQ3BDLElBQUk7NEJBQ0Ysb0NBQW9DOzRCQUNwQyxNQUFNYyxjQUFjZDs0QkFJcEIsTUFBTSxFQUFFdkIsR0FBRyxFQUFFQyxHQUFHLEVBQUUsR0FBR29DLFlBQVlDLE1BQU07NEJBRXZDLHVDQUF1Qzs0QkFDdkMzRSx1QkFBdUI7Z0NBQUVxQztnQ0FBS0M7NEJBQUk7NEJBRWxDLHlEQUF5RDs0QkFDekRnQixRQUFRRyxHQUFHLENBQUMsOEJBQXNDbkIsT0FBUkQsS0FBSSxNQUFRLE9BQUpDOzRCQUVsRCx1REFBdUQ7NEJBQ3ZEMUMsb0JBQW9CLEdBQXNCMEMsT0FBbkJELElBQUlFLE9BQU8sQ0FBQyxJQUFHLE1BQW1CLE9BQWZELElBQUlDLE9BQU8sQ0FBQzs0QkFFdEQsdUNBQXVDOzRCQUN2QyxNQUFNcUMsZUFDSixNQUFNbEksc0VBQWFBLENBQUNtSSw4QkFBOEIsQ0FBQ3hDLEtBQUtDOzRCQUMxRGdCLFFBQVFHLEdBQUcsQ0FBQyxzQkFBbUMsT0FBYm1COzRCQUVsQyxnREFBZ0Q7NEJBQ2hELElBQUlBLGlCQUFpQixNQUFNO2dDQUN6QmhGLG9CQUFvQmdGOzRCQUN0Qjs0QkFFQSx1Q0FBdUM7NEJBQ3ZDLElBQUk3RixtQkFBbUIsWUFBWTtnQ0FDakNDLGtCQUFrQjs0QkFDcEI7d0JBQ0YsRUFBRSxPQUFPaUUsT0FBTzs0QkFDZEssUUFBUUwsS0FBSyxDQUFDLDZCQUE2QkE7d0JBQzNDLHFEQUFxRDt3QkFDdkQ7b0JBQ0Y7O2dCQUVBLG1FQUFtRTtnQkFDbkVvQixTQUFTQyxnQkFBZ0IsQ0FDdkIsc0JBQ0FHO2dCQUdGLFdBQVc7Z0JBQ1g7Z0VBQU87d0JBQ0xKLFNBQVNFLG1CQUFtQixDQUMxQixzQkFDQUU7b0JBRUo7O1lBQ0Y7dURBQUc7WUFDRDdFO1lBQ0FJO1lBQ0FoQjtZQUNBRDtTQUNEO1FBRUQsZUFBZTtRQUNmLE1BQU0rRixpQkFBaUIsQ0FBQ0MsVUFBa0JuQjtZQUN4QyxJQUFJN0UsbUJBQW1CZ0csVUFBVTtnQkFDL0IvRixrQkFBa0I7WUFDcEIsT0FBTztnQkFDTEEsa0JBQWtCK0Y7WUFDcEI7WUFDQSxrQ0FBa0M7WUFDbENuQixNQUFNb0IsZUFBZTtRQUN2QjtRQUVBLE1BQU0zQixrQkFBa0I7Z0JBQUM0Qiw4RUFBcUI7WUFDNUMzRixpQkFBaUI7WUFDakJFLGtCQUFrQnlGO1lBQ2xCM0IsUUFBUUcsR0FBRyxDQUFDLG9DQUErQyxPQUFYd0IsWUFBVztZQUUzRCxzQkFBc0I7WUFDdEJ4SSxnR0FBMEMsQ0FBQztZQUMzQ3lCLDZCQUE2QjtZQUU3Qiw0QkFBNEI7WUFDNUIsSUFBSStHLGFBQWEsR0FBRztnQkFDbEJsRCxNQUNFLG1EQUE4RCxPQUFYa0QsWUFBVztZQUVsRTtRQUNGO1FBRUE7O0tBRUMsR0FDRCxNQUFNRSxtQkFBbUIsQ0FBQ0M7WUFDeEJ0RyxjQUFjc0c7WUFDZHBHLGtCQUFrQjtZQUVsQiw4Q0FBOEM7WUFDOUMsSUFBSW9HLFNBQVMsVUFBVTtnQkFDckIsaUNBQWlDO2dCQUNqQzNJLGdHQUEwQyxDQUFDO2dCQUUzQyxpREFBaUQ7Z0JBQ2pELElBQUlnQyxxQkFBcUJBLGtCQUFrQmdFLE1BQU0sR0FBRyxHQUFHO29CQUNyRDRDLHVCQUF1QnhFLGVBQWV5RSxRQUFRO2dCQUNoRDtnQkFFQSwyQ0FBMkM7Z0JBQzNDOUgsbUJBQW1CO2dCQUNuQkMsWUFBWTtnQkFFWix3REFBd0Q7Z0JBQ3hELElBQUlzQyx1QkFBdUJFLGlCQUFpQndDLE1BQU0sR0FBRyxHQUFHO29CQUN0RHpFLHVCQUF1QmlDO2dCQUN6QjtZQUNGLE9BQU8sSUFBSW1GLFNBQVMsU0FBUztnQkFDM0IsMENBQTBDO2dCQUMxQyxJQUFJM0cscUJBQXFCQSxrQkFBa0JnRSxNQUFNLEdBQUcsR0FBRztvQkFDckQscUNBQXFDO29CQUNyQyxNQUFNOEMsMEJBQTBCOUcsa0JBQWtCNkMsTUFBTSxDQUN0RCxDQUFDa0UsUUFDQyxPQUFPQSxNQUFNdEQsUUFBUSxLQUFLLFlBQzFCLE9BQU9zRCxNQUFNckQsU0FBUyxLQUFLLFlBQzNCLENBQUNzRCxNQUFNRCxNQUFNdEQsUUFBUSxLQUNyQixDQUFDdUQsTUFBTUQsTUFBTXJELFNBQVM7b0JBRzFCLDBCQUEwQjtvQkFDMUIsSUFBSXVELGtCQUNGdkUsYUFBYXNCLE1BQU0sS0FBSyxJQUNwQjhDLDBCQUNBQSx3QkFBd0JqRSxNQUFNLENBQUMsQ0FBQ3FFLFdBQzlCeEUsYUFBYWdDLFFBQVEsQ0FBQ3lDLHFCQUFxQkQ7b0JBR25ELHdDQUF3QztvQkFDeEMsSUFBSTVILG1CQUFtQjt3QkFDckJBO29CQUNGO29CQUNBQyx1QkFBdUIwSDtnQkFDekI7WUFDRixPQUFPLElBQUlOLFNBQVMsUUFBUTtnQkFDMUIsOEJBQThCO2dCQUM5QjNJLGdHQUEwQyxDQUFDO2dCQUUzQyxJQUNFWSx3QkFDQWdELG9CQUNBSixpQkFBaUJ3QyxNQUFNLEdBQUcsR0FDMUI7b0JBQ0FvRDtnQkFDRixPQUFPO29CQUNMLHFDQUFxQztvQkFDckMsSUFBSSxDQUFDeEksd0JBQXdCZ0Qsa0JBQWtCO3dCQUM3QzBCLE1BQU07b0JBQ1IsT0FBTyxJQUFJMUUsd0JBQXdCLENBQUNnRCxrQkFBa0I7d0JBQ3BEMEIsTUFBTTtvQkFDUixPQUFPO3dCQUNMQSxNQUNFO29CQUVKO2dCQUNGO1lBQ0Y7UUFDRjtRQUVBLHVCQUF1QjtRQUN2QixNQUFNNkQsdUJBQXVCLENBQUNEO1lBQzVCLE1BQU1HLFlBQVlILFNBQVNJLGVBQWUsSUFBSTtZQUM5QyxPQUFPQyxrQkFBa0JGO1FBQzNCO1FBRUEsTUFBTUUsb0JBQW9CLENBQUNDO1lBQ3pCLE1BQU1DLFVBQVUsT0FBT0QsU0FBUyxXQUFXRSxTQUFTRixNQUFNLE1BQU1BO1lBRWhFLE1BQU1HLGVBQXVDO2dCQUMzQyxHQUFHO2dCQUNILEdBQUc7Z0JBQ0gsR0FBRztnQkFDSCxHQUFHO2dCQUNILEdBQUc7Z0JBQ0gsR0FBRztnQkFDSCxHQUFHO2dCQUNILElBQUk7Z0JBQ0osSUFBSTtnQkFDSixJQUFJO2dCQUNKLElBQUk7Z0JBQ0osSUFBSTtnQkFDSixJQUFJO2dCQUNKLElBQUk7Z0JBQ0osSUFBSTtnQkFDSixJQUFJO2dCQUNKLElBQUk7Z0JBQ0osSUFBSTtnQkFDSixJQUFJO1lBQ047WUFFQSxPQUFPQSxZQUFZLENBQUNGLFFBQVEsSUFBSTtRQUNsQztRQUVBLE1BQU1HLHVCQUF1QixDQUFDQztZQUM1QixnRUFBZ0U7WUFDaEUsSUFBSUEsUUFBUTdELE1BQU0sS0FBSyxLQUFLNkQsUUFBUTdELE1BQU0sS0FBS3ZCLGNBQWN1QixNQUFNLEVBQUU7Z0JBQ25FO1lBQ0Y7WUFFQSxvREFBb0Q7WUFDcEQsSUFBSWhFLHFCQUFxQkEsa0JBQWtCZ0UsTUFBTSxHQUFHLEdBQUc7Z0JBQ3JELE1BQU04RCxtQkFBbUI5SCxrQkFBa0I2QyxNQUFNLENBQUMsQ0FBQ3FFO29CQUNqRCxNQUFNRyxZQUFZRixxQkFBcUJEO29CQUN2QyxPQUFPVyxRQUFRbkQsUUFBUSxDQUFDMkM7Z0JBQzFCO2dCQUVBLGdDQUFnQztnQkFDaEMsSUFBSS9ILG1CQUFtQjtvQkFDckJBO2dCQUNGO2dCQUNBQyx1QkFBdUJ1STtZQUN6QjtRQUNGO1FBRUEsTUFBTUMsMEJBQTBCLENBQUNDO1lBQy9CckYsZ0JBQWdCcUY7WUFDaEIseUNBQXlDO1lBQ3pDSixxQkFBcUJJO1FBQ3ZCO1FBRUEsTUFBTUMsb0JBQW9CO1lBQ3hCdEYsZ0JBQWdCO21CQUFJRjthQUFjO1FBQ3BDO1FBRUEsd0JBQXdCO1FBQ3hCLE1BQU1tRSx5QkFBeUIsQ0FBQzNEO1lBQzlCLElBQUksQ0FBQ2pELHFCQUFxQkEsa0JBQWtCZ0UsTUFBTSxLQUFLLEdBQUc7WUFDMUQ3RCxnQkFBZ0I7WUFFaEIsSUFBSTtnQkFDRix5Q0FBeUM7Z0JBQ3pDLE1BQU0rSCxtQkFBbUJ6SiwrREFBaUJBLENBQUN3RTtnQkFFM0MseUNBQXlDO2dCQUN6QyxJQUFJLENBQUNrRixNQUFNQyxPQUFPLENBQUNGLHFCQUFxQkEsaUJBQWlCbEUsTUFBTSxLQUFLLEdBQUc7b0JBQ3JFYSxRQUFRTCxLQUFLLENBQ1gscUNBQTRDLE9BQVB2QixTQUNyQ2lGO29CQUVGL0gsZ0JBQWdCO29CQUNoQjtnQkFDRjtnQkFFQSx1REFBdUQ7Z0JBQ3ZELE1BQU0sQ0FBQyxDQUFDa0ksUUFBUUMsT0FBTyxFQUFFLENBQUNDLFFBQVFDLE9BQU8sQ0FBQyxHQUFHTjtnQkFFN0NyRCxRQUFRRyxHQUFHLENBQUMsd0JBQStCLE9BQVAvQixRQUFPLGtCQUFnQjtvQkFDekRvRjtvQkFDQUM7b0JBQ0FDO29CQUNBQztnQkFDRjtnQkFFQSx5REFBeUQ7Z0JBQ3pELE1BQU1WLG1CQUFtQjlILGtCQUFrQjZDLE1BQU0sQ0FBQyxDQUFDcUU7b0JBQ2pELDBDQUEwQztvQkFDMUMsSUFDRSxPQUFPQSxTQUFTekQsUUFBUSxLQUFLLFlBQzdCLE9BQU95RCxTQUFTeEQsU0FBUyxLQUFLLFlBQzlCc0QsTUFBTUUsU0FBU3pELFFBQVEsS0FDdkJ1RCxNQUFNRSxTQUFTeEQsU0FBUyxHQUN4Qjt3QkFDQSxPQUFPO29CQUNUO29CQUVBLDZDQUE2QztvQkFDN0MsT0FDRXdELFNBQVN6RCxRQUFRLElBQUk0RSxVQUNyQm5CLFNBQVN6RCxRQUFRLElBQUk4RSxVQUNyQnJCLFNBQVN4RCxTQUFTLElBQUk0RSxVQUN0QnBCLFNBQVN4RCxTQUFTLElBQUk4RTtnQkFFMUI7Z0JBRUEsNENBQTRDO2dCQUM1QyxJQUFJbEosbUJBQW1CO29CQUNyQkE7Z0JBQ0Y7Z0JBQ0FDLHVCQUF1QnVJO2dCQUN2QmpELFFBQVFHLEdBQUcsQ0FDVCxlQUFzRC9CLE9BQXZDNkUsaUJBQWlCOUQsTUFBTSxFQUFDLGlCQUF3Q2hFLE9BQXpCaUQsUUFBTyxvQkFBMkMsT0FBekJqRCxrQkFBa0JnRSxNQUFNLEVBQUM7WUFFNUcsRUFBRSxPQUFPUSxPQUFPO2dCQUNkSyxRQUFRTCxLQUFLLENBQUMsdUNBQXVDQTtZQUN2RCxTQUFVO2dCQUNSckUsZ0JBQWdCO1lBQ2xCO1FBQ0Y7UUFFQSxNQUFNc0kscUJBQXFCLE9BQU94RjtZQUNoQ2hCLGdCQUFnQmdCO1lBQ2hCWixrQkFBa0JZO1lBQ2xCOUMsZ0JBQWdCO1lBRWhCLElBQUk7Z0JBQ0YsaUNBQWlDO2dCQUNqQyxJQUFJZixhQUFhO29CQUNmLE1BQU1zSixTQUFTakssK0RBQWlCQSxDQUFDd0U7b0JBRWpDLGtFQUFrRTtvQkFDbEUsTUFBTTBGLFlBQVlqSyxtRUFBcUJBLENBQUN1RTtvQkFFeEMsd0NBQXdDO29CQUN4QzdELFlBQVl3SixPQUFPLENBQUNEO29CQUVwQiwrQkFBK0I7b0JBQy9CLE1BQU1FLFVBQVU7d0JBQ2RDLFNBQVN0SyxvREFBVUEsQ0FBQ3VLLE9BQU8sQ0FBQ0MsT0FBTztvQkFFckM7b0JBRUE1SixZQUFZNkosU0FBUyxDQUFDUCxRQUFlRztvQkFDckN6SixZQUFZbUYsY0FBYztvQkFDMUIyRSxrQkFBa0JqRztnQkFDcEI7Z0JBRUEsaURBQWlEO2dCQUNqRCxnREFBZ0Q7Z0JBQ2hENEIsUUFBUUcsR0FBRyxDQUFFO2dCQUViLHdFQUF3RTtnQkFDeEUsOENBQThDO2dCQUM5QyxNQUFNbUUsZ0JBQWdCLE1BQU1DLE1BQzFCLHFDQUE0QyxPQUFQbkc7Z0JBRXZDLElBQUlrRyxjQUFjRSxFQUFFLEVBQUU7b0JBQ3BCLE1BQU1DLFlBQVksTUFBTUgsY0FBY0ksSUFBSTtvQkFDMUMxRSxRQUFRRyxHQUFHLENBQUMsR0FBbUIsT0FBaEJzRSxVQUFVRSxLQUFLLEVBQUM7Z0JBQ2pDO2dCQUVBLG1DQUFtQztnQkFDbkMsSUFBSWxLLG1CQUFtQjtvQkFDckJBO2dCQUNGO1lBQ0YsRUFBRSxPQUFPa0YsT0FBTztnQkFDZEssUUFBUUwsS0FBSyxDQUFDLDhCQUE4QkE7WUFDOUMsU0FBVTtnQkFDUnJFLGdCQUFnQjtnQkFDaEJJLGtCQUFrQjtZQUNwQjtRQUNGO1FBRUEsTUFBTTJJLG9CQUFvQixDQUFDakc7WUFDekIsSUFBSSxDQUFDN0QsYUFBYTtZQUVsQiw2QkFBNkI7WUFDN0IsSUFBSThDLGVBQWU7Z0JBQ2pCQSxjQUFjNkQsTUFBTTtZQUN0QjtZQUVBLHlDQUF5QztZQUN6QyxNQUFNMkMsU0FBU2pLLCtEQUFpQkEsQ0FBQ3dFO1lBS2pDLG1DQUFtQztZQUNuQyxNQUFNd0csSUFBSUMsbUJBQU9BLENBQUMsK0VBQVM7WUFDM0IsTUFBTUMsWUFBWUYsRUFBRUUsU0FBUyxDQUFDakIsUUFBUTtnQkFDcENrQixPQUFPO2dCQUNQQyxRQUFRO2dCQUNSQyxTQUFTO2dCQUNUQyxNQUFNO2dCQUNOQyxXQUFXO2dCQUNYQyxhQUFhO2dCQUNiQyxXQUFXO2dCQUNYQyxhQUFhO1lBQ2Y7WUFFQSxhQUFhO1lBQ2JSLFVBQVVTLEtBQUssQ0FBQ2hMO1lBRWhCLCtEQUErRDtZQUMvRCtDLGlCQUFpQjtnQkFDZjRELFFBQVE7b0JBQ040RCxVQUFVNUQsTUFBTTtnQkFDbEI7WUFDRjtRQUNGO1FBRUEsTUFBTXNFLHdCQUF3QjtZQUM1QixJQUFJLENBQUNuSixrQkFBa0I7WUFFdkIsd0JBQXdCO1lBQ3hCLElBQUlOLGVBQWU7Z0JBQ2pCMEMsTUFDRSw2QkFBa0QsT0FBckJ4QyxrQkFBa0IsSUFBRztnQkFFcEQ7WUFDRjtZQUVBLCtEQUErRDtZQUMvRCxJQUFJVixlQUFlLFFBQVE7Z0JBQ3pCcEMsZ0dBQTBDLENBQUM7Z0JBQzNDeUIsNkJBQTZCO1lBQy9CO1lBRUEsb0JBQW9CO1lBQ3BCVSxnQkFBZ0I7WUFFaEIsSUFBSTtnQkFDRjBFLFFBQVFHLEdBQUcsQ0FDVCwwQ0FBMkQsT0FBakI5RCxrQkFBaUI7Z0JBRzdELG9FQUFvRTtnQkFDcEUsSUFBSTZDO2dCQUNKLElBQUk7b0JBQ0ZBLGtCQUFrQixNQUFNekYseUZBQStCQSxDQUNyRDRDLGtCQUNBRTtnQkFFSixFQUFFLE9BQU9vRCxPQUFZO3dCQUNmQTtvQkFBSixJQUFJQSxFQUFBQSxpQkFBQUEsTUFBTUMsT0FBTyxjQUFiRCxxQ0FBQUEsZUFBZUUsUUFBUSxDQUFDLGtCQUFpQkYsTUFBTUcsTUFBTSxLQUFLLEtBQUs7d0JBQ2pFLE1BQU02QixhQUFhLElBQUkseUNBQXlDO3dCQUNoRTVCLGdCQUFnQjRCO3dCQUNoQnJHLGdCQUFnQjt3QkFDaEI7b0JBQ0Y7b0JBQ0EsTUFBTXFFO2dCQUNSO2dCQUVBLDhCQUE4QjtnQkFDOUIsSUFBSThGO2dCQUNKLElBQUk7b0JBQ0ZBLFlBQVksTUFBTXJNLHNFQUFhQSxDQUFDc00sd0JBQXdCLENBQ3REckosa0JBQ0E7Z0JBRUosRUFBRSxPQUFPc0QsT0FBTztvQkFDZEssUUFBUUwsS0FBSyxDQUFDLHlDQUF5Q0E7b0JBQ3ZELDJDQUEyQztvQkFDM0M4RixZQUFZLEVBQUU7Z0JBQ2hCO2dCQUVBLElBQUlFLGNBQW1EO2dCQUV2RCxJQUFJRixVQUFVdEcsTUFBTSxHQUFHLEdBQUc7b0JBQ3hCd0csY0FBYzt3QkFDWjVHLEtBQUswRyxTQUFTLENBQUMsRUFBRSxDQUFDMUcsR0FBRzt3QkFDckJDLEtBQUt5RyxTQUFTLENBQUMsRUFBRSxDQUFDekcsR0FBRztvQkFDdkI7b0JBQ0EsbUNBQW1DO29CQUNuQzFDLG9CQUFvQm1KLFNBQVMsQ0FBQyxFQUFFLENBQUNHLElBQUk7Z0JBQ3ZDLE9BQU8sSUFDTDFHLGdCQUFnQkMsTUFBTSxHQUFHLEtBQ3pCRCxlQUFlLENBQUMsRUFBRSxDQUFDTixRQUFRLElBQzNCTSxlQUFlLENBQUMsRUFBRSxDQUFDTCxTQUFTLEVBQzVCO29CQUNBLHNDQUFzQztvQkFDdEM4RyxjQUFjO3dCQUNaNUcsS0FBS0csZUFBZSxDQUFDLEVBQUUsQ0FBQ04sUUFBUTt3QkFDaENJLEtBQUtFLGVBQWUsQ0FBQyxFQUFFLENBQUNMLFNBQVM7b0JBQ25DO2dCQUNGO2dCQUVBLElBQUlLLGdCQUFnQkMsTUFBTSxLQUFLLEdBQUc7b0JBQ2hDVixNQUNFLDBCQUEyQyxPQUFqQnBDLGtCQUFpQjtvQkFFN0NmLGdCQUFnQjtvQkFDaEI7Z0JBQ0Y7Z0JBRUEsb0NBQW9DO2dCQUNwQyxJQUFJcUssYUFBYTtvQkFDZmpKLHVCQUF1QmlKO29CQUN2QjNLLGtCQUFrQjJLO29CQUNsQm5KLGtCQUFrQkQ7Z0JBQ3BCO2dCQUNBLElBQUksQ0FBQ1Esa0JBQWtCO29CQUNyQjlCO2dCQUNGLE9BQU8sSUFBSSxDQUFDMEssYUFBYTtvQkFDdkIsTUFBTSxJQUFJRSxNQUFNO2dCQUNsQjtnQkFFQTdGLFFBQVFHLEdBQUcsQ0FDVCxTQUFnQyxPQUF2QmpCLGdCQUFnQkMsTUFBTSxFQUFDO2dCQUdsQyx5Q0FBeUM7Z0JBQ3pDLE1BQU1DLGtCQUNKRixlQUFlLENBQUMsRUFBRSxDQUFDNEcsWUFBWSxLQUFLQyxZQUNoQzdHLGdCQUFnQiw4QkFBOEI7bUJBQzlDN0YsaUZBQXFCQSxDQUFDNkYsa0JBQWtCLG1CQUFtQjtnQkFFakUsMEJBQTBCO2dCQUMxQmMsUUFBUUcsR0FBRyxDQUFDO2dCQUNaLE1BQU1kLG1CQUFtQixNQUFNL0YsbUZBQXNCQSxDQUFDOEY7Z0JBRXRELG1DQUFtQztnQkFDbkN4QyxvQkFBb0J5QztnQkFDcEJyQyxvQkFBb0I7Z0JBRXBCLCtCQUErQjtnQkFDL0IsSUFBSXZDLG1CQUFtQjtvQkFDckJBO2dCQUNGO2dCQUVBLCtFQUErRTtnQkFDL0UsSUFBSWMsZUFBZSxVQUFVeEIsc0JBQXNCO29CQUNqRCxxQ0FBcUM7b0JBQ3JDWixnR0FBMEMsQ0FBQztvQkFDM0N5Qiw2QkFBNkI7b0JBQzdCc0YsV0FBVzt3QkFDVHFDO29CQUNGLEdBQUc7Z0JBQ0wsT0FBTztvQkFDTCx5Q0FBeUM7b0JBQ3pDN0gsdUJBQXVCMkU7b0JBRXZCLHlDQUF5QztvQkFDekMsSUFBSTlFLGVBQWVvTCxhQUFhO3dCQUM5Qix5QkFBeUI7d0JBQ3pCLE1BQU1yRyxjQUFjL0UsWUFBWWdGLE9BQU87d0JBQ3ZDLG1EQUFtRDt3QkFDbkQsTUFBTUMsYUFBYUYsZUFBZSxJQUFJLElBQUlBO3dCQUUxQyw4QkFBOEI7d0JBQzlCL0UsWUFBWWtGLE9BQU8sQ0FBQzs0QkFBQ2tHLFlBQVk1RyxHQUFHOzRCQUFFNEcsWUFBWTNHLEdBQUc7eUJBQUMsRUFBRVE7d0JBRXhELHdCQUF3Qjt3QkFDeEJqRixZQUFZbUYsY0FBYztvQkFDNUI7Z0JBQ0Y7Z0JBRUEsOEJBQThCO2dCQUM5QmhFLGtCQUFrQjtZQUNwQixFQUFFLE9BQU9pRSxPQUFZO29CQUVmQTtnQkFESkssUUFBUUwsS0FBSyxDQUFDLDZCQUE2QkE7Z0JBQzNDLElBQUlBLEVBQUFBLGtCQUFBQSxNQUFNQyxPQUFPLGNBQWJELHNDQUFBQSxnQkFBZUUsUUFBUSxDQUFDLGtCQUFpQkYsTUFBTUcsTUFBTSxLQUFLLEtBQUs7b0JBQ2pFQyxnQkFBZ0I7Z0JBQ2xCLE9BQU87b0JBQ0x0QixNQUNFLFVBQTRFLE9BQWxFa0IsaUJBQWlCa0csUUFBUWxHLE1BQU1DLE9BQU8sR0FBRztnQkFFdkQ7WUFDRixTQUFVO2dCQUNSdEUsZ0JBQWdCO1lBQ2xCO1FBQ0Y7UUFFQTs7S0FFQyxHQUNELE1BQU0wSyxzQkFBc0IsQ0FBQ0M7WUFDM0JqRyxRQUFRRyxHQUFHLENBQUMsb0NBQW9DOEY7WUFDaERqRyxRQUFRRyxHQUFHLENBQUMsZ0NBQWdDMUQ7WUFFNUMsSUFBSXdKLFNBQVM7Z0JBQ1gscUNBQXFDO2dCQUNyQyxJQUNFeEosdUJBQ0EsT0FBT0Esb0JBQW9Cc0MsR0FBRyxLQUFLLFlBQ25DLE9BQU90QyxvQkFBb0J1QyxHQUFHLEtBQUssWUFDbkMsQ0FBQ21ELE1BQU0xRixvQkFBb0JzQyxHQUFHLEtBQzlCLENBQUNvRCxNQUFNMUYsb0JBQW9CdUMsR0FBRyxHQUM5QjtvQkFDQWdCLFFBQVFHLEdBQUcsQ0FBQztvQkFFWixrQkFBa0I7b0JBQ2xCckQsbUJBQW1CO29CQUNuQkUsb0JBQW9CO29CQUVwQiw0Q0FBNEM7b0JBQzVDLElBQUksT0FBTy9CLG1CQUFtQixZQUFZO3dCQUN4Q0E7b0JBQ0Y7b0JBRUEsbUNBQW1DO29CQUNuQyxJQUFJMEIsb0JBQW9CQSxpQkFBaUJ3QyxNQUFNLEdBQUcsR0FBRzt3QkFDbkRhLFFBQVFHLEdBQUcsQ0FDVCxXQUFtQyxPQUF4QnhELGlCQUFpQndDLE1BQU0sRUFBQzt3QkFFckN6RSx1QkFBdUJpQztvQkFDekIsT0FBTzt3QkFDTCx5Q0FBeUM7d0JBQ3pDcUQsUUFBUUcsR0FBRyxDQUFDO3dCQUNaRCxXQUFXOzRCQUNUc0Y7d0JBQ0YsR0FBRztvQkFDTDtnQkFDRixPQUFPO29CQUNMLHVCQUF1QjtvQkFDdkJ4RixRQUFRa0csSUFBSSxDQUFDO29CQUNiekgsTUFDRTtvQkFFRjNCLG1CQUFtQjtvQkFDbkJFLG9CQUFvQjtnQkFDdEI7WUFDRixPQUFPO2dCQUNMLHFCQUFxQjtnQkFDckJnRCxRQUFRRyxHQUFHLENBQUM7Z0JBQ1pyRCxtQkFBbUI7Z0JBQ25CRSxvQkFBb0I7Z0JBRXBCLDRDQUE0QztnQkFDNUMsSUFBSSxPQUFPdkMsc0JBQXNCLFlBQVk7b0JBQzNDQTtnQkFDRjtZQUNGO1FBQ0Y7UUFFQSw4QkFBOEI7UUFDOUIsTUFBTTBMLDZCQUE2QixDQUFDQztZQUNsQyxpQkFBaUI7WUFDakIxSyxrQkFBa0I7WUFDbEJFLDBCQUEwQjtZQUUxQiw0QkFBNEI7WUFDNUIsSUFBSXdLLFVBQVUsSUFBSTtnQkFDaEJsTSxtQkFBbUI7Z0JBQ25CO1lBQ0Y7WUFFQSxpQ0FBaUM7WUFDakNBLG1CQUFtQmtNO1lBRW5CLHFEQUFxRDtZQUNyRCxJQUFJakosaUJBQWlCLE1BQU07Z0JBQ3pCa0oscUNBQXFDbEosY0FBNEJpSjtZQUNuRSxPQUFPO2dCQUNMLHFFQUFxRTtnQkFDckVFLHNCQUFzQkY7WUFDeEI7UUFDRjtRQUVBLE1BQU1FLHdCQUF3QixDQUFDckk7WUFDN0IsSUFBSWxDLGVBQWU7Z0JBQ2pCaUUsUUFBUUcsR0FBRyxDQUNULDBDQUF5RCxPQUFmbEUsZ0JBQWU7Z0JBRTNEO1lBQ0Y7WUFFQStELFFBQVFHLEdBQUcsQ0FBQyxtQ0FBZ0QsT0FBYmxDO1lBRS9DLElBQUk7Z0JBQ0Ysd0VBQXdFO2dCQUN4RSxJQUFJLE9BQU8zRCxxQkFBcUIsWUFBWTtvQkFDMUMsc0RBQXNEO29CQUN0RDRGLFdBQVc7d0JBQ1Q1RixtQkFBbUJpTSxLQUFLLENBQUMsQ0FBQzVHO2dDQUV0QkE7NEJBREYsSUFDRUEsRUFBQUEsaUJBQUFBLE1BQU1DLE9BQU8sY0FBYkQscUNBQUFBLGVBQWVFLFFBQVEsQ0FBQyxrQkFDeEJGLE1BQU1HLE1BQU0sS0FBSyxLQUNqQjtnQ0FDQUMsZ0JBQWdCOzRCQUNsQixPQUFPO2dDQUNMQyxRQUFRTCxLQUFLLENBQUMscUNBQXFDQTs0QkFDckQ7d0JBQ0Y7b0JBQ0YsR0FBRztnQkFDTDtZQUNGLEVBQUUsT0FBT0EsT0FBWTtvQkFDZkE7Z0JBQUosSUFBSUEsRUFBQUEsaUJBQUFBLE1BQU1DLE9BQU8sY0FBYkQscUNBQUFBLGVBQWVFLFFBQVEsQ0FBQyxrQkFBaUJGLE1BQU1HLE1BQU0sS0FBSyxLQUFLO29CQUNqRUMsZ0JBQWdCO2dCQUNsQixPQUFPO29CQUNMQyxRQUFRTCxLQUFLLENBQUMsNkNBQTZDQTtnQkFDN0Q7WUFDRjtRQUNGO1FBRUEsTUFBTTBHLHVDQUF1QyxlQUMzQ2pJLFFBQ0FIO2dCQUNBdUksd0VBQWUsR0FDZkMseUVBQWdCO1lBRWhCLElBQUksQ0FBQ3JJLFVBQVUsQ0FBQ0gsY0FBYztnQkFDNUIrQixRQUFRRyxHQUFHLENBQUM7Z0JBQ1o7WUFDRjtZQUVBN0UsZ0JBQWdCO1lBRWhCLElBQUk7Z0JBQ0YsTUFBTW9MLFdBQVcsTUFBTW5DLE1BQ3JCLDBDQUFpRW9DLE9BQXZCdkksUUFBTyxrQkFBeURvSSxPQUF6Q0csbUJBQW1CMUksZUFBYyxVQUFzQndJLE9BQWRELE1BQUssV0FBZSxPQUFOQztnQkFHMUgsTUFBTUcsT0FBTyxNQUFNRixTQUFTaEMsSUFBSTtnQkFDaEMsTUFBTW1DLGVBQWVELEtBQUt2RSxRQUFRLElBQUksRUFBRTtnQkFFeEMsSUFBSSxDQUFDcUUsU0FBU2xDLEVBQUUsRUFBRTtvQkFDaEIsTUFBTSxJQUFJcUIsTUFBTSxjQUFrQyxPQUFwQmEsU0FBU0ksVUFBVTtnQkFDbkQ7Z0JBRUEscUNBQXFDO2dCQUNyQyxJQUFJRCxhQUFhMUgsTUFBTSxHQUFHLEdBQUc7b0JBUTNCLE1BQU00SCxtQkFBdUNGLGFBQWFHLEdBQUcsQ0FDM0QsQ0FBQzNFOzRCQUlHQTs0QkFBQUE7K0JBSnlCOzRCQUMzQixHQUFHQSxRQUFROzRCQUNYTSxNQUFNTixTQUFTNEUsYUFBYSxJQUFJOzRCQUNoQ0MsY0FDRTdFLENBQUFBLDJDQUFBQSxxQkFBQUEsU0FBUzhFLFFBQVEsY0FBakI5RSx5Q0FBQUEsbUJBQW1CK0UsV0FBVyxHQUFHdkgsUUFBUSxDQUFDLDJCQUExQ3dDLHFEQUFBQSwwQ0FDQTs0QkFDRmdGLFFBQVFoRixTQUFTZ0YsTUFBTTs0QkFDdkJ2RCxXQUFXaUM7d0JBQ2I7O29CQUdGLGlCQUFpQjtvQkFDakJyTCx1QkFBdUJxTTtnQkFDekIsT0FBTztvQkFDTC9HLFFBQVFHLEdBQUcsQ0FDVCxzQ0FBZ0UvQixPQUExQkgsY0FBYSxlQUFvQixPQUFQRztnQkFFcEU7WUFDRixFQUFFLE9BQU91QixPQUFPO2dCQUNkSyxRQUFRTCxLQUFLLENBQUMscUNBQXFDQTtZQUNyRCxTQUFVO2dCQUNSckUsZ0JBQWdCO1lBQ2xCO1FBQ0Y7UUFFQSwwQkFBMEI7UUFDMUIsTUFBTWdNLG9CQUFvQixDQUFDbEI7WUFDekJqTSxZQUFZaU0sVUFBVSxLQUFLLE9BQU9BO1lBQ2xDMUssa0JBQWtCO1lBRWxCLDBDQUEwQztZQUMxQyxJQUFJSCxlQUFlLFVBQVV3QixvQkFBb0JoRCxzQkFBc0I7Z0JBQ3JFbUcsV0FBVztvQkFDVHFDO2dCQUNGLEdBQUc7WUFDTDtRQUNGO1FBRUEsMEJBQTBCO1FBQzFCLE1BQU1BLHVCQUF1QjtZQUMzQixJQUNFLENBQUN4SSx3QkFDRCxDQUFDZ0Qsb0JBQ0RKLGlCQUFpQndDLE1BQU0sS0FBSyxHQUM1QjtnQkFDQTtZQUNGO1lBRUE3RCxnQkFBZ0I7WUFFaEIsSUFBSTtnQkFDRjBFLFFBQVFHLEdBQUcsQ0FDVCxhQUFvRHBHLE9BQXZDNEMsaUJBQWlCd0MsTUFBTSxFQUFDLGlCQUFvQyxPQUFyQnBGO2dCQUd0RCxzQ0FBc0M7Z0JBQ3RDLElBQUlrSixtQkFBbUJ0RyxpQkFBaUJxQixNQUFNLENBQzVDLENBQUNxRTt3QkFDQ0E7MkJBQUFBLEVBQUFBLHlCQUFBQSxTQUFTeUQsWUFBWSxjQUFyQnpELDZDQUFBQSx1QkFBdUIrRSxXQUFXLFFBQ2xDck4scUJBQXFCcU4sV0FBVzs7Z0JBR3BDLHNDQUFzQztnQkFDdEMsSUFBSXBOLGVBQWU7b0JBQ2pCaUosbUJBQW1CQSxpQkFBaUJqRixNQUFNLENBQ3hDLENBQUNxRTs0QkFDQ0E7K0JBQUFBLEVBQUFBLGtCQUFBQSxTQUFTa0YsS0FBSyxjQUFkbEYsc0NBQUFBLGdCQUFnQitFLFdBQVcsUUFBT3BOLGNBQWNvTixXQUFXOztnQkFFakU7Z0JBRUFwSCxRQUFRRyxHQUFHLENBQUMsU0FBaUMsT0FBeEI4QyxpQkFBaUI5RCxNQUFNLEVBQUM7Z0JBRTdDLElBQUk4RCxpQkFBaUI5RCxNQUFNLEtBQUssR0FBRztvQkFDakNWLE1BQU0sTUFBMkIsT0FBckIxRSxzQkFBcUI7b0JBQ2pDO2dCQUNGO2dCQUVBLHFCQUFxQjtnQkFDckIsSUFBSVUsbUJBQW1CO29CQUNyQkE7Z0JBQ0Y7Z0JBRUEscUJBQXFCO2dCQUNyQkMsdUJBQXVCdUk7WUFDekIsRUFBRSxPQUFPdEQsT0FBTztnQkFDZEssUUFBUUwsS0FBSyxDQUFDLDZCQUE2QkE7WUFDN0MsU0FBVTtnQkFDUnJFLGdCQUFnQjtZQUNsQjtRQUNGO1FBRUEsb0JBQW9CO1FBQ3BCLE1BQU1rTSxrQkFBa0I7WUFDdEJ4SCxRQUFRRyxHQUFHLENBQUM7WUFFWix1QkFBdUI7WUFDdkIzRSxjQUFjO1lBRWQsb0RBQW9EO1lBQ3BEckMsZ0dBQTBDLENBQUM7WUFDM0N5Qiw2QkFBNkI7WUFDN0JFLDRCQUE0QjtZQUU1QixrQ0FBa0M7WUFDbENaLG1CQUFtQjtZQUNuQkMsWUFBWTtZQUVaLG9CQUFvQjtZQUNwQm1DLG9CQUFvQjtZQUNwQkksdUJBQXVCO1lBQ3ZCRSxvQkFBb0IsRUFBRTtZQUN0QkUsbUJBQW1CO1lBQ25CRSxvQkFBb0I7WUFDcEIsSUFBSSxPQUFPOUIsa0JBQWtCLFlBQVk7Z0JBQ3ZDQTtZQUNGO1lBQ0EsSUFBSSxPQUFPVCxzQkFBc0IsWUFBWTtnQkFDM0NBO1lBQ0Y7WUFFQSx1Q0FBdUM7WUFDdkNxRCxnQkFBZ0I7bUJBQUlGO2FBQWM7WUFFbEMsa0NBQWtDO1lBQ2xDUixnQkFBZ0I7WUFDaEJJLGtCQUFrQnZFLG1EQUFVQSxDQUFDd0UsTUFBTTtZQUVuQyxnQ0FBZ0M7WUFDaEMsSUFBSUosZUFBZTtnQkFDakIsSUFBSTtvQkFDRiw4Q0FBOEM7b0JBQzlDLElBQUksT0FBT0EsY0FBYzZELE1BQU0sS0FBSyxZQUFZO3dCQUM5QzdELGNBQWM2RCxNQUFNO29CQUN0QixPQUFPLElBQ0w3RCxjQUFjeUgsU0FBUyxJQUN2QixPQUFPekgsY0FBY3lILFNBQVMsQ0FBQzVELE1BQU0sS0FBSyxZQUMxQzt3QkFDQTdELGNBQWN5SCxTQUFTLENBQUM1RCxNQUFNO29CQUNoQztvQkFFQSw4Q0FBOEM7b0JBQzlDLElBQ0U3RCxjQUFjb0ssS0FBSyxJQUNuQixPQUFPcEssY0FBY29LLEtBQUssQ0FBQ3ZHLE1BQU0sS0FBSyxZQUN0Qzt3QkFDQTdELGNBQWNvSyxLQUFLLENBQUN2RyxNQUFNO29CQUM1QjtnQkFDRixFQUFFLE9BQU92QixPQUFPO29CQUNkSyxRQUFRTCxLQUFLLENBQUMsa0NBQWtDQTtnQkFDbEQ7Z0JBRUEsd0NBQXdDO2dCQUN4Q3JDLGlCQUFpQjtZQUNuQjtZQUVBLDhCQUE4QjtZQUM5QixJQUFJL0MsYUFBYTtnQkFDZixnRUFBZ0U7Z0JBQ2hFQSxZQUFZa0YsT0FBTyxDQUFDOUYsb0RBQVVBLENBQUMrTixNQUFNLEVBQUUvTixvREFBVUEsQ0FBQ2dPLFlBQVk7Z0JBQzlEcE4sWUFBWW1GLGNBQWM7WUFDNUI7WUFFQSxvQ0FBb0M7WUFDcEMsSUFBSSxPQUFPdEYsVUFBVSxZQUFZO2dCQUMvQkE7WUFDRixPQUFPLElBQUksT0FBT0MsZ0JBQWdCLFlBQVk7Z0JBQzVDQTtZQUNGO1lBRUEsNkJBQTZCO1lBQzdCcUIsa0JBQWtCO1lBRWxCLGlDQUFpQztZQUNqQ00saUJBQWlCO1lBQ2pCRSxrQkFBa0I7WUFFbEIsZ0NBQWdDO1lBQ2hDeUIscUJBQXFCO1lBRXJCLHlCQUF5QjtZQUN6Qi9CLDBCQUEwQjtZQUUxQixtRUFBbUU7WUFDbkUsTUFBTWdNLGFBQWEsSUFBSUMsWUFBWTtZQUNuQzlHLFNBQVMrRyxhQUFhLENBQUNGO1lBRXZCNUgsUUFBUUcsR0FBRyxDQUFDO1FBQ2Q7UUFFQSxtQ0FBbUM7UUFDbkMsTUFBTTRILGtCQUFrQjFNO1FBRXhCLE9BQU87WUFDTCxRQUFRO1lBQ1JFO1lBQ0FFO1lBQ0ExQjtZQUNBQztZQUNBcUM7WUFDQUU7WUFDQVE7WUFDQU47WUFDQStCO1lBQ0FyQjtZQUNBVTtZQUNBRDtZQUNBakM7WUFDQW9NO1lBQ0E1TDtZQUNBNEI7WUFDQTFDO1lBQ0FVO1lBQ0F3QjtZQUNBMUI7WUFDQW1NLHlCQUF5QjtZQUV6QixVQUFVO1lBQ1Z4RztZQUNBSztZQUNBc0U7WUFDQW1CO1lBQ0E5QjtZQUNBdEM7WUFDQVU7WUFDQWhJO1lBQ0FVO1lBQ0FFO1lBQ0F3SjtZQUNBd0I7WUFDQWpGO1lBQ0FEO1lBQ0E1RjtZQUNBMUI7WUFDQU47WUFFQXVOLG9CQUFvQjtnQkFDbEIsK0JBQStCO2dCQUMvQixJQUFJLE9BQU8zTixxQkFBcUIsWUFBWTtvQkFDMUNBLG1CQUFtQmlNLEtBQUssQ0FBQyxDQUFDNUc7d0JBQ3hCSyxRQUFRTCxLQUFLLENBQUMsK0JBQStCQTtvQkFDL0M7Z0JBQ0Y7WUFDRjtZQUNBakU7UUFDRjtJQUNGO0FBQ0Y7QUFDQSxTQUFTNkc7SUFDUCxNQUFNLElBQUlzRCxNQUFNO0FBQ2xCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXHNhdGhvXFxEb2N1bWVudHNcXFByb2plY3RzXFxhaXJjcmFmdC10cmFja2luZ1xcY29tcG9uZW50c1xcdHJhY2tpbmdcXGhvb2tzXFx1c2VGaWx0ZXJMb2dpYy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlUmVmLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7IFJlZ2lvbkNvZGUgfSBmcm9tICdAL3R5cGVzL2Jhc2UnO1xyXG5pbXBvcnQgdHlwZSB7IEV4dGVuZGVkQWlyY3JhZnQgfSBmcm9tICdAL3R5cGVzL2Jhc2UnO1xyXG5pbXBvcnQgeyB1c2VFbmhhbmNlZE1hcENvbnRleHQgfSBmcm9tICcuLi9jb250ZXh0L0VuaGFuY2VkTWFwQ29udGV4dCc7XHJcbmltcG9ydCBvcGVuU2t5VHJhY2tpbmdTZXJ2aWNlIGZyb20gJ0AvbGliL3NlcnZpY2VzL29wZW5Ta3lUcmFja2luZ1NlcnZpY2UnO1xyXG5pbXBvcnQgeyBNYXBib3hTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vLi4vbGliL3NlcnZpY2VzL01hcGJveFNlcnZpY2UnO1xyXG5pbXBvcnQgeyBhZGFwdEdlb2ZlbmNlQWlyY3JhZnQgfSBmcm9tICdAL2xpYi91dGlscy9nZW9mZW5jZUFkYXB0ZXInO1xyXG5pbXBvcnQgeyBlbnJpY2hHZW9mZW5jZUFpcmNyYWZ0IH0gZnJvbSAnQC9saWIvdXRpbHMvZ2VvZmVuY2VFbnJpY2hlcic7XHJcbmltcG9ydCB7IHVzZUdlb2xvY2F0aW9uU2VydmljZXMgfSBmcm9tICcuLi9ob29rcy91c2VHZW9sb2NhdGlvblNlcnZpY2VzJztcclxuaW1wb3J0IHtcclxuICBnZXRBaXJjcmFmdE5lYXJMb2NhdGlvbixcclxuICBnZXRBaXJjcmFmdE5lYXJTZWFyY2hlZExvY2F0aW9uLFxyXG59IGZyb20gJy4uLy4uLy4uL2xpYi9zZXJ2aWNlcy9nZW9mZW5jaW5nJztcclxuaW1wb3J0IHsgdXNlR2VvbG9jYXRpb24gfSBmcm9tICcuLi9ob29rcy91c2VHZW9sb2NhdGlvbic7XHJcblxyXG5pbXBvcnQge1xyXG4gIE1BUF9DT05GSUcsXHJcbiAgZ2V0Qm91bmRzQnlSZWdpb24sXHJcbiAgZ2V0Wm9vbUxldmVsRm9yUmVnaW9uLFxyXG59IGZyb20gJy4uLy4uLy4uL2NvbmZpZy9tYXAnO1xyXG5cclxuaW50ZXJmYWNlIEZpbHRlckxvZ2ljUmVzdWx0IHtcclxuICBnZW9mZW5jZUxvY2F0aW9uOiBzdHJpbmc7XHJcbiAgZ2VvZmVuY2VSYWRpdXM6IG51bWJlcjtcclxuICBpc0dldHRpbmdMb2NhdGlvbjogYm9vbGVhbjtcclxuICBpc0dlb2ZlbmNlQWN0aXZlOiBib29sZWFuO1xyXG4gIGdlb2ZlbmNlQ29vcmRpbmF0ZXM6IHsgbGF0OiBudW1iZXI7IGxuZzogbnVtYmVyIH0gfCBudWxsO1xyXG4gIGNvbWJpbmVkTG9hZGluZzogYm9vbGVhbjtcclxuICBwcm9jZXNzR2VvZmVuY2VTZWFyY2g6ICgpID0+IHZvaWQ7XHJcbiAgdG9nZ2xlR2VvZmVuY2VTdGF0ZTogKGFjdGl2ZTogYm9vbGVhbikgPT4gdm9pZDtcclxuICBzZXRHZW9mZW5jZUxvY2F0aW9uOiAobG9jYXRpb246IHN0cmluZykgPT4gdm9pZDtcclxuICBzZXRHZW9mZW5jZVJhZGl1czogKHJhZGl1czogbnVtYmVyKSA9PiB2b2lkO1xyXG4gIHNldEdlb2ZlbmNlQ29vcmRpbmF0ZXM6IChjb29yZHM6IHsgbGF0OiBudW1iZXI7IGxuZzogbnVtYmVyIH0gfCBudWxsKSA9PiB2b2lkO1xyXG4gIHNldEdlb2ZlbmNlQ2VudGVyOiAoY29vcmRzOiB7IGxhdDogbnVtYmVyOyBsbmc6IG51bWJlciB9KSA9PiB2b2lkO1xyXG4gIHVwZGF0ZUdlb2ZlbmNlQWlyY3JhZnQ6IChhaXJjcmFmdDogYW55W10pID0+IHZvaWQ7XHJcbn1cclxuXHJcbnR5cGUgTWFwR2VvZmVuY2VDbGlja0V2ZW50ID0gQ3VzdG9tRXZlbnQ8eyBsYXQ6IG51bWJlcjsgbG5nOiBudW1iZXIgfT47XHJcblxyXG5leHBvcnQgdHlwZSBGaWx0ZXJNb2RlID1cclxuICB8ICdtYW51ZmFjdHVyZXInXHJcbiAgfCAnZ2VvZmVuY2UnXHJcbiAgfCAnYm90aCdcclxuICB8ICdvd25lcidcclxuICB8ICdyZWdpb24nO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUZpbHRlckxvZ2ljKCkge1xyXG4gIC8vIEdldCBjb250ZXh0IHN0YXRlIGFuZCBmdW5jdGlvbnNcclxuICBjb25zdCB7XHJcbiAgICBzZWxlY3RlZE1hbnVmYWN0dXJlcixcclxuICAgIHNlbGVjdGVkTW9kZWwsXHJcbiAgICB0b3RhbEFjdGl2ZSxcclxuICAgIHNlbGVjdE1hbnVmYWN0dXJlcixcclxuICAgIHNlbGVjdE1vZGVsLFxyXG4gICAgcmVzZXQsXHJcbiAgICBmdWxsUmVmcmVzaCxcclxuICAgIHJlZnJlc2hQb3NpdGlvbnMsXHJcbiAgICBtYXBJbnN0YW5jZSxcclxuICAgIHVwZGF0ZUFpcmNyYWZ0RGF0YSxcclxuICAgIGNsZWFyR2VvZmVuY2VEYXRhLFxyXG4gICAgdXBkYXRlR2VvZmVuY2VBaXJjcmFmdCxcclxuICAgIGJsb2NrTWFudWZhY3R1cmVyQXBpQ2FsbHMsXHJcbiAgICBzZXRCbG9ja01hbnVmYWN0dXJlckFwaUNhbGxzLFxyXG4gICAgaXNNYW51ZmFjdHVyZXJBcGlCbG9ja2VkLFxyXG4gICAgc2V0SXNNYW51ZmFjdHVyZXJBcGlCbG9ja2VkLFxyXG4gICAgZ2VvZmVuY2VDZW50ZXIsXHJcbiAgICBzZXRHZW9mZW5jZUNlbnRlcixcclxuICAgIHRvZ2dsZUdlb2ZlbmNlLFxyXG4gICAgY2xlYXJHZW9mZW5jZSxcclxuICAgIGRpc3BsYXllZEFpcmNyYWZ0LFxyXG4gIH0gPSB1c2VFbmhhbmNlZE1hcENvbnRleHQoKTtcclxuXHJcbiAgLy8gVXNlIG91ciBjb21iaW5lZCBnZW9sb2NhdGlvbiBzZXJ2aWNlcyBob29rXHJcbiAgY29uc3QgZ2VvbG9jYXRpb25TZXJ2aWNlcyA9IHVzZUdlb2xvY2F0aW9uU2VydmljZXMoKTtcclxuXHJcbiAgLy8gTG9jYWwgc3RhdGVcclxuICBjb25zdCBbbG9jYWxMb2FkaW5nLCBzZXRMb2NhbExvYWRpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gIGNvbnN0IFtmaWx0ZXJNb2RlLCBzZXRGaWx0ZXJNb2RlXSA9IHVzZVN0YXRlPEZpbHRlck1vZGUgfCBudWxsPihudWxsKTtcclxuICBjb25zdCBbYWN0aXZlRHJvcGRvd24sIHNldEFjdGl2ZURyb3Bkb3duXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xyXG4gIGNvbnN0IFttYW51ZmFjdHVyZXJTZWFyY2hUZXJtLCBzZXRNYW51ZmFjdHVyZXJTZWFyY2hUZXJtXSA9IHVzZVN0YXRlKCcnKTtcclxuICBjb25zdCBbaXNSZWZyZXNoaW5nLCBzZXRJc1JlZnJlc2hpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gIGNvbnN0IFtpc1JhdGVMaW1pdGVkLCBzZXRJc1JhdGVMaW1pdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICBjb25zdCBbcmF0ZUxpbWl0VGltZXIsIHNldFJhdGVMaW1pdFRpbWVyXSA9IHVzZVN0YXRlPG51bWJlciB8IG51bGw+KG51bGwpO1xyXG5cclxuICAvLyBHZW9mZW5jZSBzdGF0ZVxyXG4gIGNvbnN0IFtpc0dldHRpbmdMb2NhdGlvbiwgc2V0SXNHZXR0aW5nTG9jYXRpb25dID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gIGNvbnN0IFtnZW9mZW5jZUxvY2F0aW9uLCBzZXRHZW9mZW5jZUxvY2F0aW9uXSA9IHVzZVN0YXRlPHN0cmluZz4oJycpO1xyXG4gIGNvbnN0IFtnZW9mZW5jZVJhZGl1cywgc2V0R2VvZmVuY2VSYWRpdXNdID0gdXNlU3RhdGU8bnVtYmVyPigyNSk7XHJcbiAgY29uc3QgW2dlb2ZlbmNlQ29vcmRpbmF0ZXMsIHNldEdlb2ZlbmNlQ29vcmRpbmF0ZXNdID0gdXNlU3RhdGU8e1xyXG4gICAgbGF0OiBudW1iZXI7XHJcbiAgICBsbmc6IG51bWJlcjtcclxuICB9IHwgbnVsbD4obnVsbCk7XHJcbiAgY29uc3QgW2dlb2ZlbmNlQWlyY3JhZnQsIHNldEdlb2ZlbmNlQWlyY3JhZnRdID0gdXNlU3RhdGU8RXh0ZW5kZWRBaXJjcmFmdFtdPihcclxuICAgIFtdXHJcbiAgKTtcclxuICBjb25zdCBbZ2VvZmVuY2VFbmFibGVkLCBzZXRHZW9mZW5jZUVuYWJsZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gIGNvbnN0IFtpc0dlb2ZlbmNlQWN0aXZlLCBzZXRJc0dlb2ZlbmNlQWN0aXZlXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICBjb25zdCBbaXNTZWFyY2hSZWFkeSwgc2V0SXNTZWFyY2hSZWFkeV0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XHJcblxyXG4gIC8vIFJlZ2lvbiBzdGF0ZVxyXG4gIGNvbnN0IFthY3RpdmVSZWdpb24sIHNldEFjdGl2ZVJlZ2lvbl0gPSB1c2VTdGF0ZTxSZWdpb25Db2RlIHwgc3RyaW5nIHwgbnVsbD4oXHJcbiAgICBudWxsXHJcbiAgKTtcclxuICBjb25zdCBbcmVnaW9uT3V0bGluZSwgc2V0UmVnaW9uT3V0bGluZV0gPSB1c2VTdGF0ZTxhbnk+KG51bGwpO1xyXG4gIGNvbnN0IFtzZWxlY3RlZFJlZ2lvbiwgc2V0U2VsZWN0ZWRSZWdpb25dID0gdXNlU3RhdGU8bnVtYmVyPihcclxuICAgIFJlZ2lvbkNvZGUuR0xPQkFMXHJcbiAgKTtcclxuXHJcbiAgLy8gQ29tYmluZWQgbW9kZSBzdGF0ZVxyXG4gIGNvbnN0IFtjb21iaW5lZE1vZGVSZWFkeSwgc2V0Q29tYmluZWRNb2RlUmVhZHldID0gdXNlU3RhdGU8Ym9vbGVhbj4oZmFsc2UpO1xyXG5cclxuICAvLyBPd25lciBmaWx0ZXIgc3RhdGVcclxuICBjb25zdCBhbGxPd25lclR5cGVzID0gW1xyXG4gICAgJ2luZGl2aWR1YWwnLFxyXG4gICAgJ3BhcnRuZXJzaGlwJyxcclxuICAgICdjb3JwLW93bmVyJyxcclxuICAgICdjby1vd25lZCcsXHJcbiAgICAnbGxjJyxcclxuICAgICdub24tY2l0aXplbi1jb3JwJyxcclxuICAgICdhaXJsaW5lJyxcclxuICAgICdmcmVpZ2h0JyxcclxuICAgICdtZWRpY2FsJyxcclxuICAgICdtZWRpYScsXHJcbiAgICAnaGlzdG9yaWNhbCcsXHJcbiAgICAnZmx5aW5nLWNsdWInLFxyXG4gICAgJ2VtZXJnZW5jeScsXHJcbiAgICAnbG9jYWwtZ292dCcsXHJcbiAgICAnZWR1Y2F0aW9uJyxcclxuICAgICdmZWRlcmFsLWdvdnQnLFxyXG4gICAgJ2ZsaWdodC1zY2hvb2wnLFxyXG4gICAgJ2xlYXNpbmctY29ycCcsXHJcbiAgICAnbWlsaXRhcnknLFxyXG4gICAgJ3Vua25vd24nLFxyXG4gIF07XHJcblxyXG4gIGNvbnN0IFtvd25lckZpbHRlcnMsIHNldE93bmVyRmlsdGVyc10gPSB1c2VTdGF0ZTxzdHJpbmdbXT4oW1xyXG4gICAgLi4uYWxsT3duZXJUeXBlcyxcclxuICBdKTtcclxuXHJcbiAgLy8gUmVmcyBmb3IgZHJvcGRvd24gaGFuZGxpbmdcclxuICBjb25zdCBkcm9wZG93blJlZnMgPSB7XHJcbiAgICBmaWx0ZXI6IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCksXHJcbiAgICBtYW51ZmFjdHVyZXI6IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCksXHJcbiAgICBtb2RlbDogdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKSxcclxuICAgIGxvY2F0aW9uOiB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpLFxyXG4gICAgcmVnaW9uOiB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpLFxyXG4gICAgb3duZXI6IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCksXHJcbiAgICBhY3Rpb25zOiB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpLFxyXG4gIH07XHJcblxyXG4gIC8vIEdldCBnZW9sb2NhdGlvbiBob29rIC0gdXNlIHRoZSBlbnRpcmUgaG9vayBpbnN0YW5jZVxyXG4gIGNvbnN0IGdlb2xvY2F0aW9uID0gdXNlR2VvbG9jYXRpb24obnVsbCk7XHJcblxyXG4gIC8vIEdlb2ZlbmNlIG1ldGhvZHNcclxuICAvLyBGaXhlZCBnZXRVc2VyTG9jYXRpb24gZnVuY3Rpb25cclxuICBjb25zdCBnZXRVc2VyTG9jYXRpb24gPSBhc3luYyAoKSA9PiB7XHJcbiAgICBpZiAoaXNSYXRlTGltaXRlZCkge1xyXG4gICAgICBhbGVydChcclxuICAgICAgICBgUmF0ZSBsaW1pdGVkLiBQbGVhc2Ugd2FpdCAke3JhdGVMaW1pdFRpbWVyIHx8IDMwfSBzZWNvbmRzIGJlZm9yZSB0cnlpbmcgdG8gZ2V0IGxvY2F0aW9uLmBcclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGdldFVzZXJMb2NhdGlvbiA9IGFzeW5jICgpID0+IHtcclxuICAgICAgaWYgKGlzUmF0ZUxpbWl0ZWQpIHtcclxuICAgICAgICBhbGVydChcclxuICAgICAgICAgIGBSYXRlIGxpbWl0ZWQuIFBsZWFzZSB3YWl0ICR7cmF0ZUxpbWl0VGltZXIgfHwgMzB9IHNlY29uZHMgYmVmb3JlIHRyeWluZyB0byBnZXQgbG9jYXRpb24uYFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzZXRJc0dldHRpbmdMb2NhdGlvbih0cnVlKTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICAvLyBVc2UgdGhlIGdldEN1cnJlbnRQb3NpdGlvbiBmcm9tIG91ciBjb21iaW5lZCBob29rXHJcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBhd2FpdCBnZW9sb2NhdGlvblNlcnZpY2VzLmdldEN1cnJlbnRQb3NpdGlvbigpO1xyXG5cclxuICAgICAgICBpZiAocG9zaXRpb24pIHtcclxuICAgICAgICAgIGNvbnN0IHsgbGF0aXR1ZGUsIGxvbmdpdHVkZSB9ID0gcG9zaXRpb24uY29vcmRzO1xyXG5cclxuICAgICAgICAgIC8vIFVwZGF0ZSBzdGF0ZSB3aXRoIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICBzZXRHZW9mZW5jZUNvb3JkaW5hdGVzKHsgbGF0OiBsYXRpdHVkZSwgbG5nOiBsb25naXR1ZGUgfSk7XHJcbiAgICAgICAgICBzZXRHZW9mZW5jZUNlbnRlcih7IGxhdDogbGF0aXR1ZGUsIGxuZzogbG9uZ2l0dWRlIH0pO1xyXG5cclxuICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgbG9jYXRpb24gZGlzcGxheSB3aXRoIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICBzZXRHZW9mZW5jZUxvY2F0aW9uKFxyXG4gICAgICAgICAgICBgJHtsYXRpdHVkZS50b0ZpeGVkKDYpfSwgJHtsb25naXR1ZGUudG9GaXhlZCg2KX1gXHJcbiAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgIC8vIEF1dG9tYXRpY2FsbHkgdHJpZ2dlciB0aGUgZ2VvZmVuY2Ugc2VhcmNoXHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBmZXRjaGVkQWlyY3JhZnQgPSBhd2FpdCBnZXRBaXJjcmFmdE5lYXJMb2NhdGlvbihcclxuICAgICAgICAgICAgICBsYXRpdHVkZSxcclxuICAgICAgICAgICAgICBsb25naXR1ZGUsXHJcbiAgICAgICAgICAgICAgZ2VvZmVuY2VSYWRpdXNcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChmZXRjaGVkQWlyY3JhZnQubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgYWxlcnQoXHJcbiAgICAgICAgICAgICAgICBgTm8gYWlyY3JhZnQgZm91bmQgbmVhciB5b3VyIGN1cnJlbnQgbG9jYXRpb24uIFRyeSBpbmNyZWFzaW5nIHRoZSByYWRpdXMuYFxyXG4gICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgc2V0SXNHZXR0aW5nTG9jYXRpb24oZmFsc2UpO1xyXG4gICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUHJvY2VzcyB0aGUgYWlyY3JhZnQgZGF0YVxyXG4gICAgICAgICAgICBjb25zdCBhZGFwdGVkQWlyY3JhZnQgPSBhZGFwdEdlb2ZlbmNlQWlyY3JhZnQoZmV0Y2hlZEFpcmNyYWZ0KTtcclxuICAgICAgICAgICAgY29uc3QgZW5yaWNoZWRBaXJjcmFmdCA9XHJcbiAgICAgICAgICAgICAgYXdhaXQgZW5yaWNoR2VvZmVuY2VBaXJjcmFmdChhZGFwdGVkQWlyY3JhZnQpO1xyXG5cclxuICAgICAgICAgICAgLy8gU2F2ZSB0byBsb2NhbCBzdGF0ZVxyXG4gICAgICAgICAgICBzZXRHZW9mZW5jZUFpcmNyYWZ0KGVucmljaGVkQWlyY3JhZnQpO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2xlYXIgZXhpc3RpbmcgYWlyY3JhZnQgZGF0YVxyXG4gICAgICAgICAgICBpZiAoY2xlYXJHZW9mZW5jZURhdGEpIHtcclxuICAgICAgICAgICAgICBjbGVhckdlb2ZlbmNlRGF0YSgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIG1hcCB3aXRoIG5ldyBhaXJjcmFmdFxyXG4gICAgICAgICAgICB1cGRhdGVHZW9mZW5jZUFpcmNyYWZ0KGVucmljaGVkQWlyY3JhZnQpO1xyXG4gICAgICAgICAgICBzZXRJc0dlb2ZlbmNlQWN0aXZlKHRydWUpO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2VudGVyIHRoZSBtYXAgb24gdXNlcidzIGxvY2F0aW9uIC0gU0lNUExJRklFRCBaT09NIExPR0lDXHJcbiAgICAgICAgICAgIGlmIChtYXBJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgIC8vIERvbid0IG1vZGlmeSB6b29tIGlmIGl0J3MgYWxyZWFkeSBhdCBhbiBhcHByb3ByaWF0ZSBsZXZlbFxyXG4gICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRab29tID0gbWFwSW5zdGFuY2UuZ2V0Wm9vbSgpO1xyXG4gICAgICAgICAgICAgIGNvbnN0IHRhcmdldFpvb20gPSBjdXJyZW50Wm9vbSA8PSA3ID8gOSA6IGN1cnJlbnRab29tO1xyXG5cclxuICAgICAgICAgICAgICAvLyBTZXQgdGhlIHZpZXcgZGlyZWN0bHkgdG8gdGhlIHVzZXIncyBsb2NhdGlvblxyXG4gICAgICAgICAgICAgIG1hcEluc3RhbmNlLnNldFZpZXcoW2xhdGl0dWRlLCBsb25naXR1ZGVdLCB0YXJnZXRab29tKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBtYXAgcmVmbGVjdHMgY2hhbmdlc1xyXG4gICAgICAgICAgICAgIG1hcEluc3RhbmNlLmludmFsaWRhdGVTaXplKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIElmIGluIGdlb2ZlbmNlIG1vZGUsIGVuc3VyZSB0aGUgZmlsdGVyIG1vZGUgaXMgc2V0IGNvcnJlY3RseVxyXG4gICAgICAgICAgICBpZiAoZmlsdGVyTW9kZSAhPT0gJ2dlb2ZlbmNlJyAmJiBmaWx0ZXJNb2RlICE9PSAnYm90aCcpIHtcclxuICAgICAgICAgICAgICBzZXRGaWx0ZXJNb2RlKCdnZW9mZW5jZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygncmF0ZSBsaW1pdCcpIHx8IGVycm9yLnN0YXR1cyA9PT0gNDI5KSB7XHJcbiAgICAgICAgICAgICAgaGFuZGxlUmF0ZUxpbWl0KDMwKTtcclxuICAgICAgICAgICAgICAvLyBTdGlsbCB1cGRhdGUgdGhlIGxvY2F0aW9uIGV2ZW4gaWYgd2UgY291bGRuJ3QgZ2V0IGFpcmNyYWZ0XHJcbiAgICAgICAgICAgICAgaWYgKG1hcEluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICBtYXBJbnN0YW5jZS5zZXRWaWV3KFtsYXRpdHVkZSwgbG9uZ2l0dWRlXSwgOSk7XHJcbiAgICAgICAgICAgICAgICBtYXBJbnN0YW5jZS5pbnZhbGlkYXRlU2l6ZSgpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIENsb3NlIHRoZSBkcm9wZG93biBhZnRlciBzZWxlY3Rpb25cclxuICAgICAgICAgIHNldEFjdGl2ZURyb3Bkb3duKG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHVzZXIgbG9jYXRpb246JywgZXJyb3IpO1xyXG4gICAgICAgIGFsZXJ0KFxyXG4gICAgICAgICAgJ1VuYWJsZSB0byBhY2Nlc3MgeW91ciBsb2NhdGlvbi4gUGxlYXNlIG1ha2Ugc3VyZSBsb2NhdGlvbiBzZXJ2aWNlcyBhcmUgZW5hYmxlZCBpbiB5b3VyIGJyb3dzZXIuJ1xyXG4gICAgICAgICk7XHJcbiAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgc2V0SXNHZXR0aW5nTG9jYXRpb24oZmFsc2UpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEVmZmVjdHNcclxuXHJcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICBpZiAoZ2VvZmVuY2VDb29yZGluYXRlcykge1xyXG4gICAgICAgIHNldElzU2VhcmNoUmVhZHkodHJ1ZSk7XHJcbiAgICAgIH1cclxuICAgIH0sIFtnZW9mZW5jZUNvb3JkaW5hdGVzXSk7XHJcblxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgaWYgKGlzUmF0ZUxpbWl0ZWQgJiYgcmF0ZUxpbWl0VGltZXIpIHtcclxuICAgICAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgc2V0SXNSYXRlTGltaXRlZChmYWxzZSk7XHJcbiAgICAgICAgICBzZXRSYXRlTGltaXRUaW1lcihudWxsKTtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKCdSYXRlIGxpbWl0IHRpbWVyIGV4cGlyZWQsIHJlc3VtaW5nIEFQSSBjYWxscycpO1xyXG4gICAgICAgIH0sIHJhdGVMaW1pdFRpbWVyICogMTAwMCk7XHJcblxyXG4gICAgICAgIHJldHVybiAoKSA9PiBjbGVhclRpbWVvdXQodGltZXIpO1xyXG4gICAgICB9XHJcbiAgICB9LCBbaXNSYXRlTGltaXRlZCwgcmF0ZUxpbWl0VGltZXJdKTtcclxuXHJcbiAgICAvLyBFZmZlY3QgdG8gc3luYyBnZW9mZW5jZSBzdGF0ZVxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgLy8gVXBkYXRlIGludGVybmFsIHN0YXRlIHdoZW4gZ2VvZmVuY2UgaXMgdG9nZ2xlZCBleHRlcm5hbGx5XHJcbiAgICAgIGlmIChpc0dlb2ZlbmNlQWN0aXZlICE9PSBnZW9mZW5jZUVuYWJsZWQpIHtcclxuICAgICAgICBzZXRHZW9mZW5jZUVuYWJsZWQoaXNHZW9mZW5jZUFjdGl2ZSk7XHJcbiAgICAgIH1cclxuICAgIH0sIFtpc0dlb2ZlbmNlQWN0aXZlXSk7XHJcblxyXG4gICAgLy8gQ2xvc2UgZHJvcGRvd24gd2hlbiBjbGlja2luZyBvdXRzaWRlXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICBjb25zdCBoYW5kbGVDbGlja091dHNpZGUgPSAoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICAvLyBDaGVjayBpZiBjbGljayBpcyBvdXRzaWRlIG9mIGFsbCBkcm9wZG93bnNcclxuICAgICAgICBjb25zdCBpc091dHNpZGVBbGwgPSBPYmplY3QudmFsdWVzKGRyb3Bkb3duUmVmcykuZXZlcnkoXHJcbiAgICAgICAgICAocmVmKSA9PiAhcmVmLmN1cnJlbnQgfHwgIXJlZi5jdXJyZW50LmNvbnRhaW5zKGV2ZW50LnRhcmdldCBhcyBOb2RlKVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGlmIChpc091dHNpZGVBbGwpIHtcclxuICAgICAgICAgIHNldEFjdGl2ZURyb3Bkb3duKG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGhhbmRsZUNsaWNrT3V0c2lkZSk7XHJcbiAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgaGFuZGxlQ2xpY2tPdXRzaWRlKTtcclxuICAgICAgfTtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICAvLyBDbGVhbiB1cCByZWdpb24gb3V0bGluZSB3aGVuIGNvbXBvbmVudCB1bm1vdW50c1xyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICBpZiAocmVnaW9uT3V0bGluZSkge1xyXG4gICAgICAgICAgcmVnaW9uT3V0bGluZS5yZW1vdmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICB9LCBbcmVnaW9uT3V0bGluZV0pO1xyXG5cclxuICAgIC8vIEVmZmVjdCB0byBoYW5kbGUgbWFwIGNsaWNrIGZvciBnZW9mZW5jZVxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgY29uc3QgaGFuZGxlTWFwR2VvZmVuY2VDbGljayA9IGFzeW5jIChldmVudDogRXZlbnQpID0+IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgLy8gQ2FzdCB0aGUgZXZlbnQgdG8gdGhlIHByb3BlciB0eXBlXHJcbiAgICAgICAgICBjb25zdCBjdXN0b21FdmVudCA9IGV2ZW50IGFzIEN1c3RvbUV2ZW50PHtcclxuICAgICAgICAgICAgbGF0OiBudW1iZXI7XHJcbiAgICAgICAgICAgIGxuZzogbnVtYmVyO1xyXG4gICAgICAgICAgfT47XHJcbiAgICAgICAgICBjb25zdCB7IGxhdCwgbG5nIH0gPSBjdXN0b21FdmVudC5kZXRhaWw7XHJcblxyXG4gICAgICAgICAgLy8gRmlyc3QgdXBkYXRlIGNvb3JkaW5hdGVzIGltbWVkaWF0ZWx5XHJcbiAgICAgICAgICBzZXRHZW9mZW5jZUNvb3JkaW5hdGVzKHsgbGF0LCBsbmcgfSk7XHJcblxyXG4gICAgICAgICAgLy8gVGhlbiBzdGFydCBhbiBhc3luYyBvcGVyYXRpb24gdG8gZ2V0IHRoZSBsb2NhdGlvbiBuYW1lXHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhgR2V0dGluZyBsb2NhdGlvbiBuYW1lIGZvcjogJHtsYXR9LCAke2xuZ31gKTtcclxuXHJcbiAgICAgICAgICAvLyBUZW1wb3JhcmlseSBzaG93IGNvb3JkaW5hdGVzIHdoaWxlIGZldGNoaW5nIHRoZSBuYW1lXHJcbiAgICAgICAgICBzZXRHZW9mZW5jZUxvY2F0aW9uKGAke2xhdC50b0ZpeGVkKDYpfSwgJHtsbmcudG9GaXhlZCg2KX1gKTtcclxuXHJcbiAgICAgICAgICAvLyBHZXQgdGhlIGZyaWVuZGx5IG5hbWUgYXN5bmNocm9ub3VzbHlcclxuICAgICAgICAgIGNvbnN0IGxvY2F0aW9uTmFtZSA9XHJcbiAgICAgICAgICAgIGF3YWl0IE1hcGJveFNlcnZpY2UuZ2V0TG9jYXRpb25OYW1lRnJvbUNvb3JkaW5hdGVzKGxhdCwgbG5nKTtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGBHb3QgbG9jYXRpb24gbmFtZTogJHtsb2NhdGlvbk5hbWV9YCk7XHJcblxyXG4gICAgICAgICAgLy8gVXBkYXRlIHdpdGggdGhlIGZyaWVuZGx5IG5hbWUgb25jZSB3ZSBoYXZlIGl0XHJcbiAgICAgICAgICBpZiAobG9jYXRpb25OYW1lICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHNldEdlb2ZlbmNlTG9jYXRpb24obG9jYXRpb25OYW1lKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBPcGVuIHRoZSBsb2NhdGlvbiBkcm9wZG93biBpZiBuZWVkZWRcclxuICAgICAgICAgIGlmIChhY3RpdmVEcm9wZG93biAhPT0gJ2xvY2F0aW9uJykge1xyXG4gICAgICAgICAgICBzZXRBY3RpdmVEcm9wZG93bignbG9jYXRpb24nKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaGFuZGxpbmcgbWFwIGNsaWNrOicsIGVycm9yKTtcclxuICAgICAgICAgIC8vIEtlZXAgdGhlIGNvb3JkaW5hdGVzIGRpc3BsYXkgaWYgdGhlcmUgd2FzIGFuIGVycm9yXHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gQWRkIHRoZSBldmVudCBsaXN0ZW5lciAtIHVzZSB0aGUgc3RhbmRhcmQgZXZlbnQgbGlzdGVuZXIgcGF0dGVyblxyXG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFxyXG4gICAgICAgICdtYXAtZ2VvZmVuY2UtY2xpY2snLFxyXG4gICAgICAgIGhhbmRsZU1hcEdlb2ZlbmNlQ2xpY2sgYXMgRXZlbnRMaXN0ZW5lclxyXG4gICAgICApO1xyXG5cclxuICAgICAgLy8gQ2xlYW4gdXBcclxuICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFxyXG4gICAgICAgICAgJ21hcC1nZW9mZW5jZS1jbGljaycsXHJcbiAgICAgICAgICBoYW5kbGVNYXBHZW9mZW5jZUNsaWNrIGFzIEV2ZW50TGlzdGVuZXJcclxuICAgICAgICApO1xyXG4gICAgICB9O1xyXG4gICAgfSwgW1xyXG4gICAgICBzZXRHZW9mZW5jZUxvY2F0aW9uLFxyXG4gICAgICBzZXRHZW9mZW5jZUNvb3JkaW5hdGVzLFxyXG4gICAgICBzZXRBY3RpdmVEcm9wZG93bixcclxuICAgICAgYWN0aXZlRHJvcGRvd24sXHJcbiAgICBdKTtcclxuXHJcbiAgICAvLyBNYWluIG1ldGhvZHNcclxuICAgIGNvbnN0IHRvZ2dsZURyb3Bkb3duID0gKGRyb3Bkb3duOiBzdHJpbmcsIGV2ZW50OiBSZWFjdC5Nb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgIGlmIChhY3RpdmVEcm9wZG93biA9PT0gZHJvcGRvd24pIHtcclxuICAgICAgICBzZXRBY3RpdmVEcm9wZG93bihudWxsKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzZXRBY3RpdmVEcm9wZG93bihkcm9wZG93bik7XHJcbiAgICAgIH1cclxuICAgICAgLy8gUHJldmVudCBldmVudHMgZnJvbSBidWJibGluZyB1cFxyXG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgaGFuZGxlUmF0ZUxpbWl0ID0gKHJldHJ5QWZ0ZXI6IG51bWJlciA9IDMwKSA9PiB7XHJcbiAgICAgIHNldElzUmF0ZUxpbWl0ZWQodHJ1ZSk7XHJcbiAgICAgIHNldFJhdGVMaW1pdFRpbWVyKHJldHJ5QWZ0ZXIpO1xyXG4gICAgICBjb25zb2xlLmxvZyhgUmF0ZSBsaW1pdGVkIGJ5IEFQSS4gUmV0cnkgYWZ0ZXIgJHtyZXRyeUFmdGVyfXNgKTtcclxuXHJcbiAgICAgIC8vIEJsb2NrIGFsbCBBUEkgY2FsbHNcclxuICAgICAgb3BlblNreVRyYWNraW5nU2VydmljZS5zZXRCbG9ja0FsbEFwaUNhbGxzKHRydWUpO1xyXG4gICAgICBzZXRCbG9ja01hbnVmYWN0dXJlckFwaUNhbGxzKHRydWUpO1xyXG5cclxuICAgICAgLy8gU2hvdyBub3RpZmljYXRpb24gdG8gdXNlclxyXG4gICAgICBpZiAocmV0cnlBZnRlciA+IDApIHtcclxuICAgICAgICBhbGVydChcclxuICAgICAgICAgIGBBaXJjcmFmdCBkYXRhIHJlZnJlc2ggcmF0ZSBsaW1pdGVkLiBQbGVhc2Ugd2FpdCAke3JldHJ5QWZ0ZXJ9IHNlY29uZHMgYmVmb3JlIHRyeWluZyBhZ2Fpbi5gXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRvZ2dsZSBmaWx0ZXIgbW9kZVxyXG4gICAgICovXHJcbiAgICBjb25zdCB0b2dnbGVGaWx0ZXJNb2RlID0gKG1vZGU6IEZpbHRlck1vZGUpID0+IHtcclxuICAgICAgc2V0RmlsdGVyTW9kZShtb2RlKTtcclxuICAgICAgc2V0QWN0aXZlRHJvcGRvd24obnVsbCk7XHJcblxyXG4gICAgICAvLyBBcHBseSBhcHByb3ByaWF0ZSBmaWx0ZXJzIGJhc2VkIG9uIG5ldyBtb2RlXHJcbiAgICAgIGlmIChtb2RlID09PSAncmVnaW9uJykge1xyXG4gICAgICAgIC8vIEJsb2NrIEFQSSBjYWxscyBpbiByZWdpb24gbW9kZVxyXG4gICAgICAgIG9wZW5Ta3lUcmFja2luZ1NlcnZpY2Uuc2V0QmxvY2tBbGxBcGlDYWxscyh0cnVlKTtcclxuXHJcbiAgICAgICAgLy8gQXBwbHkgcmVnaW9uIGZpbHRlcmluZyBpZiB3ZSBhbHJlYWR5IGhhdmUgZGF0YVxyXG4gICAgICAgIGlmIChkaXNwbGF5ZWRBaXJjcmFmdCAmJiBkaXNwbGF5ZWRBaXJjcmFmdC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICBmaWx0ZXJBaXJjcmFmdEJ5UmVnaW9uKHNlbGVjdGVkUmVnaW9uLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2xlYXIgbWFudWZhY3R1cmVyIHNlbGVjdGlvbiBmcm9tIHRoZSBVSVxyXG4gICAgICAgIHNlbGVjdE1hbnVmYWN0dXJlcihudWxsKTtcclxuICAgICAgICBzZWxlY3RNb2RlbChudWxsKTtcclxuXHJcbiAgICAgICAgLy8gSWYgZ2VvZmVuY2UgaXMgYWN0aXZlLCByZXN0b3JlIHRoZSBmdWxsIGdlb2ZlbmNlIGRhdGFcclxuICAgICAgICBpZiAoZ2VvZmVuY2VDb29yZGluYXRlcyAmJiBnZW9mZW5jZUFpcmNyYWZ0Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIHVwZGF0ZUdlb2ZlbmNlQWlyY3JhZnQoZ2VvZmVuY2VBaXJjcmFmdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdvd25lcicpIHtcclxuICAgICAgICAvLyBGaWx0ZXIgZGlzcGxheWVkIGFpcmNyYWZ0IGJ5IG93bmVyIHR5cGVcclxuICAgICAgICBpZiAoZGlzcGxheWVkQWlyY3JhZnQgJiYgZGlzcGxheWVkQWlyY3JhZnQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgLy8gRmlyc3QgZmlsdGVyIGZvciB2YWxpZCBjb29yZGluYXRlc1xyXG4gICAgICAgICAgY29uc3QgYWlyY3JhZnRXaXRoVmFsaWRDb29yZHMgPSBkaXNwbGF5ZWRBaXJjcmFmdC5maWx0ZXIoXHJcbiAgICAgICAgICAgIChwbGFuZSkgPT5cclxuICAgICAgICAgICAgICB0eXBlb2YgcGxhbmUubGF0aXR1ZGUgPT09ICdudW1iZXInICYmXHJcbiAgICAgICAgICAgICAgdHlwZW9mIHBsYW5lLmxvbmdpdHVkZSA9PT0gJ251bWJlcicgJiZcclxuICAgICAgICAgICAgICAhaXNOYU4ocGxhbmUubGF0aXR1ZGUpICYmXHJcbiAgICAgICAgICAgICAgIWlzTmFOKHBsYW5lLmxvbmdpdHVkZSlcclxuICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgLy8gQXBwbHkgb3duZXIgdHlwZSBmaWx0ZXJcclxuICAgICAgICAgIGxldCBmaWx0ZXJlZEJ5T3duZXIgPVxyXG4gICAgICAgICAgICBvd25lckZpbHRlcnMubGVuZ3RoID09PSAwXHJcbiAgICAgICAgICAgICAgPyBhaXJjcmFmdFdpdGhWYWxpZENvb3Jkc1xyXG4gICAgICAgICAgICAgIDogYWlyY3JhZnRXaXRoVmFsaWRDb29yZHMuZmlsdGVyKChhaXJjcmFmdCkgPT5cclxuICAgICAgICAgICAgICAgICAgb3duZXJGaWx0ZXJzLmluY2x1ZGVzKGdldEFpcmNyYWZ0T3duZXJUeXBlKGFpcmNyYWZ0KSlcclxuICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgLy8gVXBkYXRlIGRpc3BsYXkgd2l0aCBmaWx0ZXJlZCBhaXJjcmFmdFxyXG4gICAgICAgICAgaWYgKGNsZWFyR2VvZmVuY2VEYXRhKSB7XHJcbiAgICAgICAgICAgIGNsZWFyR2VvZmVuY2VEYXRhKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB1cGRhdGVHZW9mZW5jZUFpcmNyYWZ0KGZpbHRlcmVkQnlPd25lcik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdib3RoJykge1xyXG4gICAgICAgIC8vIEJvdGggbW9kZSAtIEJMT0NLIEFQSSBDQUxMU1xyXG4gICAgICAgIG9wZW5Ta3lUcmFja2luZ1NlcnZpY2Uuc2V0QmxvY2tBbGxBcGlDYWxscyh0cnVlKTtcclxuXHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgc2VsZWN0ZWRNYW51ZmFjdHVyZXIgJiZcclxuICAgICAgICAgIGlzR2VvZmVuY2VBY3RpdmUgJiZcclxuICAgICAgICAgIGdlb2ZlbmNlQWlyY3JhZnQubGVuZ3RoID4gMFxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgYXBwbHlDb21iaW5lZEZpbHRlcnMoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gSWYgb25lIGlzIG1pc3NpbmcsIHByb21wdCB0aGUgdXNlclxyXG4gICAgICAgICAgaWYgKCFzZWxlY3RlZE1hbnVmYWN0dXJlciAmJiBpc0dlb2ZlbmNlQWN0aXZlKSB7XHJcbiAgICAgICAgICAgIGFsZXJ0KCdQbGVhc2Ugc2VsZWN0IGEgbWFudWZhY3R1cmVyIHRvIHVzZSBjb21iaW5lZCBmaWx0ZXIgbW9kZScpO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChzZWxlY3RlZE1hbnVmYWN0dXJlciAmJiAhaXNHZW9mZW5jZUFjdGl2ZSkge1xyXG4gICAgICAgICAgICBhbGVydCgnUGxlYXNlIHNldCBhIGxvY2F0aW9uIHRvIHVzZSBjb21iaW5lZCBmaWx0ZXIgbW9kZScpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYWxlcnQoXHJcbiAgICAgICAgICAgICAgJ1BsZWFzZSBzZWxlY3QgYm90aCBhIG1hbnVmYWN0dXJlciBhbmQgbG9jYXRpb24gdG8gdXNlIGNvbWJpbmVkIGZpbHRlciBtb2RlJ1xyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBPd25lciBmaWx0ZXIgbWV0aG9kc1xyXG4gICAgY29uc3QgZ2V0QWlyY3JhZnRPd25lclR5cGUgPSAoYWlyY3JhZnQ6IEV4dGVuZGVkQWlyY3JhZnQpOiBzdHJpbmcgPT4ge1xyXG4gICAgICBjb25zdCBvd25lclR5cGUgPSBhaXJjcmFmdC5UWVBFX1JFR0lTVFJBTlQgfHwgMDtcclxuICAgICAgcmV0dXJuIG93bmVyVHlwZVRvU3RyaW5nKG93bmVyVHlwZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IG93bmVyVHlwZVRvU3RyaW5nID0gKHR5cGU6IG51bWJlciB8IHN0cmluZyk6IHN0cmluZyA9PiB7XHJcbiAgICAgIGNvbnN0IHR5cGVOdW0gPSB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgPyBwYXJzZUludCh0eXBlLCAxMCkgOiB0eXBlO1xyXG5cclxuICAgICAgY29uc3Qgb3duZXJUeXBlTWFwOiBSZWNvcmQ8bnVtYmVyLCBzdHJpbmc+ID0ge1xyXG4gICAgICAgIDE6ICdpbmRpdmlkdWFsJyxcclxuICAgICAgICAyOiAncGFydG5lcnNoaXAnLFxyXG4gICAgICAgIDM6ICdjb3JwLW93bmVyJyxcclxuICAgICAgICA0OiAnY28tb3duZWQnLFxyXG4gICAgICAgIDc6ICdsbGMnLFxyXG4gICAgICAgIDg6ICdub24tY2l0aXplbi1jb3JwJyxcclxuICAgICAgICA5OiAnYWlybGluZScsXHJcbiAgICAgICAgMTA6ICdmcmVpZ2h0JyxcclxuICAgICAgICAxMTogJ21lZGljYWwnLFxyXG4gICAgICAgIDEyOiAnbWVkaWEnLFxyXG4gICAgICAgIDEzOiAnaGlzdG9yaWNhbCcsXHJcbiAgICAgICAgMTQ6ICdmbHlpbmctY2x1YicsXHJcbiAgICAgICAgMTU6ICdlbWVyZ2VuY3knLFxyXG4gICAgICAgIDE2OiAnbG9jYWwtZ292dCcsXHJcbiAgICAgICAgMTc6ICdlZHVjYXRpb24nLFxyXG4gICAgICAgIDE4OiAnZmVkZXJhbC1nb3Z0JyxcclxuICAgICAgICAxOTogJ2ZsaWdodC1zY2hvb2wnLFxyXG4gICAgICAgIDIwOiAnbGVhc2luZy1jb3JwJyxcclxuICAgICAgICAyMTogJ21pbGl0YXJ5JyxcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHJldHVybiBvd25lclR5cGVNYXBbdHlwZU51bV0gfHwgJ3Vua25vd24nO1xyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBhcHBseU93bmVyVHlwZUZpbHRlciA9IChmaWx0ZXJzOiBzdHJpbmdbXSkgPT4ge1xyXG4gICAgICAvLyBTa2lwIGZpbHRlcmluZyBpZiBhbGwgdHlwZXMgYXJlIHNlbGVjdGVkIG9yIG5vbmUgYXJlIHNlbGVjdGVkXHJcbiAgICAgIGlmIChmaWx0ZXJzLmxlbmd0aCA9PT0gMCB8fCBmaWx0ZXJzLmxlbmd0aCA9PT0gYWxsT3duZXJUeXBlcy5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEZpbHRlciB0aGUgYWlyY3JhZnQgYmFzZWQgb24gc2VsZWN0ZWQgb3duZXIgdHlwZXNcclxuICAgICAgaWYgKGRpc3BsYXllZEFpcmNyYWZ0ICYmIGRpc3BsYXllZEFpcmNyYWZ0Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICBjb25zdCBmaWx0ZXJlZEFpcmNyYWZ0ID0gZGlzcGxheWVkQWlyY3JhZnQuZmlsdGVyKChhaXJjcmFmdCkgPT4ge1xyXG4gICAgICAgICAgY29uc3Qgb3duZXJUeXBlID0gZ2V0QWlyY3JhZnRPd25lclR5cGUoYWlyY3JhZnQpO1xyXG4gICAgICAgICAgcmV0dXJuIGZpbHRlcnMuaW5jbHVkZXMob3duZXJUeXBlKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBkaXNwbGF5ZWQgYWlyY3JhZnRcclxuICAgICAgICBpZiAoY2xlYXJHZW9mZW5jZURhdGEpIHtcclxuICAgICAgICAgIGNsZWFyR2VvZmVuY2VEYXRhKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHVwZGF0ZUdlb2ZlbmNlQWlyY3JhZnQoZmlsdGVyZWRBaXJjcmFmdCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgaGFuZGxlT3duZXJGaWx0ZXJDaGFuZ2UgPSAodXBkYXRlZEZpbHRlcnM6IHN0cmluZ1tdKSA9PiB7XHJcbiAgICAgIHNldE93bmVyRmlsdGVycyh1cGRhdGVkRmlsdGVycyk7XHJcbiAgICAgIC8vIEFwcGx5IHRoZSBmaWx0ZXIgdG8geW91ciBhaXJjcmFmdCBkYXRhXHJcbiAgICAgIGFwcGx5T3duZXJUeXBlRmlsdGVyKHVwZGF0ZWRGaWx0ZXJzKTtcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgcmVzZXRPd25lckZpbHRlcnMgPSAoKSA9PiB7XHJcbiAgICAgIHNldE93bmVyRmlsdGVycyhbLi4uYWxsT3duZXJUeXBlc10pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBSZWdpb24gZmlsdGVyIG1ldGhvZHNcclxuICAgIGNvbnN0IGZpbHRlckFpcmNyYWZ0QnlSZWdpb24gPSAocmVnaW9uOiBzdHJpbmcpID0+IHtcclxuICAgICAgaWYgKCFkaXNwbGF5ZWRBaXJjcmFmdCB8fCBkaXNwbGF5ZWRBaXJjcmFmdC5sZW5ndGggPT09IDApIHJldHVybjtcclxuICAgICAgc2V0TG9jYWxMb2FkaW5nKHRydWUpO1xyXG5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICAvLyBHZXQgdGhlIGJvdW5kcyBmb3IgdGhlIHNlbGVjdGVkIHJlZ2lvblxyXG4gICAgICAgIGNvbnN0IGJvdW5kc0V4cHJlc3Npb24gPSBnZXRCb3VuZHNCeVJlZ2lvbihyZWdpb24pO1xyXG5cclxuICAgICAgICAvLyBFbnN1cmUgYm91bmRzIGlzIGluIHRoZSBjb3JyZWN0IGZvcm1hdFxyXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShib3VuZHNFeHByZXNzaW9uKSB8fCBib3VuZHNFeHByZXNzaW9uLmxlbmd0aCAhPT0gMikge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcclxuICAgICAgICAgICAgYEludmFsaWQgYm91bmRzIGZvcm1hdCBmb3IgcmVnaW9uOiAke3JlZ2lvbn1gLFxyXG4gICAgICAgICAgICBib3VuZHNFeHByZXNzaW9uXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgc2V0TG9jYWxMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEV4dHJhY3QgY29vcmRpbmF0ZXMgLSBMZWFmbGV0IHVzZXMgW2xhdCwgbG5nXSBmb3JtYXRcclxuICAgICAgICBjb25zdCBbW21pbkxhdCwgbWluTG5nXSwgW21heExhdCwgbWF4TG5nXV0gPSBib3VuZHNFeHByZXNzaW9uO1xyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhgRmlsdGVyaW5nIGJ5IHJlZ2lvbjogJHtyZWdpb259IHdpdGggYm91bmRzOmAsIHtcclxuICAgICAgICAgIG1pbkxhdCxcclxuICAgICAgICAgIG1pbkxuZyxcclxuICAgICAgICAgIG1heExhdCxcclxuICAgICAgICAgIG1heExuZyxcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gRmlsdGVyIGFpcmNyYWZ0IGJhc2VkIG9uIGNvb3JkaW5hdGVzIHdpdGhpbiB0aGUgYm91bmRzXHJcbiAgICAgICAgY29uc3QgZmlsdGVyZWRBaXJjcmFmdCA9IGRpc3BsYXllZEFpcmNyYWZ0LmZpbHRlcigoYWlyY3JhZnQpID0+IHtcclxuICAgICAgICAgIC8vIENoZWNrIGlmIGFpcmNyYWZ0IGhhcyB2YWxpZCBjb29yZGluYXRlc1xyXG4gICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICB0eXBlb2YgYWlyY3JhZnQubGF0aXR1ZGUgIT09ICdudW1iZXInIHx8XHJcbiAgICAgICAgICAgIHR5cGVvZiBhaXJjcmFmdC5sb25naXR1ZGUgIT09ICdudW1iZXInIHx8XHJcbiAgICAgICAgICAgIGlzTmFOKGFpcmNyYWZ0LmxhdGl0dWRlKSB8fFxyXG4gICAgICAgICAgICBpc05hTihhaXJjcmFmdC5sb25naXR1ZGUpXHJcbiAgICAgICAgICApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIENoZWNrIGlmIGNvb3JkaW5hdGVzIGFyZSB3aXRoaW4gdGhlIGJvdW5kc1xyXG4gICAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgYWlyY3JhZnQubGF0aXR1ZGUgPj0gbWluTGF0ICYmXHJcbiAgICAgICAgICAgIGFpcmNyYWZ0LmxhdGl0dWRlIDw9IG1heExhdCAmJlxyXG4gICAgICAgICAgICBhaXJjcmFmdC5sb25naXR1ZGUgPj0gbWluTG5nICYmXHJcbiAgICAgICAgICAgIGFpcmNyYWZ0LmxvbmdpdHVkZSA8PSBtYXhMbmdcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgZGlzcGxheSB3aXRoIGZpbHRlcmVkIGFpcmNyYWZ0XHJcbiAgICAgICAgaWYgKGNsZWFyR2VvZmVuY2VEYXRhKSB7XHJcbiAgICAgICAgICBjbGVhckdlb2ZlbmNlRGF0YSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB1cGRhdGVHZW9mZW5jZUFpcmNyYWZ0KGZpbHRlcmVkQWlyY3JhZnQpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgYEZpbHRlcmVkIHRvICR7ZmlsdGVyZWRBaXJjcmFmdC5sZW5ndGh9IGFpcmNyYWZ0IGluICR7cmVnaW9ufSByZWdpb24gKG91dCBvZiAke2Rpc3BsYXllZEFpcmNyYWZ0Lmxlbmd0aH0gdG90YWwpYFxyXG4gICAgICAgICk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmlsdGVyaW5nIGFpcmNyYWZ0IGJ5IHJlZ2lvbjonLCBlcnJvcik7XHJcbiAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgc2V0TG9jYWxMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVSZWdpb25TZWxlY3QgPSBhc3luYyAocmVnaW9uOiBSZWdpb25Db2RlKSA9PiB7XHJcbiAgICAgIHNldEFjdGl2ZVJlZ2lvbihyZWdpb24pO1xyXG4gICAgICBzZXRTZWxlY3RlZFJlZ2lvbihyZWdpb24pO1xyXG4gICAgICBzZXRMb2NhbExvYWRpbmcodHJ1ZSk7XHJcblxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIC8vIFNldCBtYXAgYm91bmRzIGJhc2VkIG9uIHJlZ2lvblxyXG4gICAgICAgIGlmIChtYXBJbnN0YW5jZSkge1xyXG4gICAgICAgICAgY29uc3QgYm91bmRzID0gZ2V0Qm91bmRzQnlSZWdpb24ocmVnaW9uKTtcclxuXHJcbiAgICAgICAgICAvLyBHZXQgdGhlIGFwcHJvcHJpYXRlIHpvb20gbGV2ZWwgZm9yIHRoaXMgcmVnaW9uIGZyb20geW91ciBjb25maWdcclxuICAgICAgICAgIGNvbnN0IHpvb21MZXZlbCA9IGdldFpvb21MZXZlbEZvclJlZ2lvbihyZWdpb24pO1xyXG5cclxuICAgICAgICAgIC8vIEZpcnN0LCBzZXQgdGhlIGFwcHJvcHJpYXRlIHpvb20gbGV2ZWxcclxuICAgICAgICAgIG1hcEluc3RhbmNlLnNldFpvb20oem9vbUxldmVsKTtcclxuXHJcbiAgICAgICAgICAvLyBUaGVuIGZpdCBib3VuZHMgd2l0aCBwYWRkaW5nXHJcbiAgICAgICAgICBjb25zdCBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICBwYWRkaW5nOiBNQVBfQ09ORklHLlBBRERJTkcuREVGQVVMVCxcclxuICAgICAgICAgICAgLy8gRG9uJ3Qgc2V0IG1heFpvb20gaGVyZSBhcyB3ZSB3YW50IHRoZSByZWdpb24gdG8gYmUgcHJvcGVybHkgZGlzcGxheWVkXHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgIG1hcEluc3RhbmNlLmZpdEJvdW5kcyhib3VuZHMgYXMgYW55LCBvcHRpb25zKTtcclxuICAgICAgICAgIG1hcEluc3RhbmNlLmludmFsaWRhdGVTaXplKCk7XHJcbiAgICAgICAgICBkcmF3UmVnaW9uT3V0bGluZShyZWdpb24pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSW5zdGVhZCBvZiBpbW1lZGlhdGVseSBmZXRjaGluZyBhaXJjcmFmdCBkYXRhLFxyXG4gICAgICAgIC8vIGp1c3Qgc3RvcmUgdGhlIHJlZ2lvbiBzZWxlY3Rpb24gZm9yIGxhdGVyIHVzZVxyXG4gICAgICAgIGNvbnNvbGUubG9nKGBSZWdpb24gc2VsZWN0ZWQuIFdhaXRpbmcgZm9yIG1hbnVmYWN0dXJlciBzZWxlY3Rpb24uLi5gKTtcclxuXHJcbiAgICAgICAgLy8gT3B0aW9uYWxseSwgeW91IGNvdWxkIGZldGNoIGp1c3QgdGhlIGNvdW50IG9mIGFpcmNyYWZ0IGluIHRoaXMgcmVnaW9uXHJcbiAgICAgICAgLy8gdG8gZ2l2ZSB0aGUgdXNlciBhbiBpZGVhIG9mIHRoZSBkYXRhIHZvbHVtZVxyXG4gICAgICAgIGNvbnN0IGNvdW50UmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcclxuICAgICAgICAgIGAvYXBpL3RyYWNraW5nL3JlZ2lvbi1jb3VudD9yZWdpb249JHtyZWdpb259YFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgaWYgKGNvdW50UmVzcG9uc2Uub2spIHtcclxuICAgICAgICAgIGNvbnN0IGNvdW50RGF0YSA9IGF3YWl0IGNvdW50UmVzcG9uc2UuanNvbigpO1xyXG4gICAgICAgICAgY29uc29sZS5sb2coYCR7Y291bnREYXRhLmNvdW50fSBhaXJjcmFmdCBhdmFpbGFibGUgaW4gdGhpcyByZWdpb25gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENsZWFyIGFueSBwcmV2aW91cyBhaXJjcmFmdCBkYXRhXHJcbiAgICAgICAgaWYgKGNsZWFyR2VvZmVuY2VEYXRhKSB7XHJcbiAgICAgICAgICBjbGVhckdlb2ZlbmNlRGF0YSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiByZWdpb24gc2VsZWN0aW9uOicsIGVycm9yKTtcclxuICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICBzZXRMb2NhbExvYWRpbmcoZmFsc2UpO1xyXG4gICAgICAgIHNldEFjdGl2ZURyb3Bkb3duKG51bGwpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IGRyYXdSZWdpb25PdXRsaW5lID0gKHJlZ2lvbjogUmVnaW9uQ29kZSkgPT4ge1xyXG4gICAgICBpZiAoIW1hcEluc3RhbmNlKSByZXR1cm47XHJcblxyXG4gICAgICAvLyBDbGVhciBhbnkgZXhpc3Rpbmcgb3V0bGluZVxyXG4gICAgICBpZiAocmVnaW9uT3V0bGluZSkge1xyXG4gICAgICAgIHJlZ2lvbk91dGxpbmUucmVtb3ZlKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEdldCB0aGUgYm91bmRzIGZvciB0aGUgc2VsZWN0ZWQgcmVnaW9uXHJcbiAgICAgIGNvbnN0IGJvdW5kcyA9IGdldEJvdW5kc0J5UmVnaW9uKHJlZ2lvbikgYXMgW1xyXG4gICAgICAgIFtudW1iZXIsIG51bWJlcl0sXHJcbiAgICAgICAgW251bWJlciwgbnVtYmVyXSxcclxuICAgICAgXTtcclxuXHJcbiAgICAgIC8vIENyZWF0ZSBhIHBvbHlnb24gZnJvbSB0aGUgYm91bmRzXHJcbiAgICAgIGNvbnN0IEwgPSByZXF1aXJlKCdsZWFmbGV0Jyk7XHJcbiAgICAgIGNvbnN0IHJlY3RhbmdsZSA9IEwucmVjdGFuZ2xlKGJvdW5kcywge1xyXG4gICAgICAgIGNvbG9yOiAnIzRmNDZlNScsIC8vIEluZGlnbyBjb2xvciBtYXRjaGluZyB5b3VyIFVJXHJcbiAgICAgICAgd2VpZ2h0OiAzLFxyXG4gICAgICAgIG9wYWNpdHk6IDAuNyxcclxuICAgICAgICBmaWxsOiB0cnVlLFxyXG4gICAgICAgIGZpbGxDb2xvcjogJyM0ZjQ2ZTUnLFxyXG4gICAgICAgIGZpbGxPcGFjaXR5OiAwLjEsXHJcbiAgICAgICAgZGFzaEFycmF5OiAnNSwgMTAnLCAvLyBPcHRpb25hbDogY3JlYXRlcyBhIGRhc2hlZCBsaW5lXHJcbiAgICAgICAgaW50ZXJhY3RpdmU6IGZhbHNlLCAvLyBQcmV2ZW50cyB0aGUgcmVjdGFuZ2xlIGZyb20gY2FwdHVyaW5nIG1vdXNlIGV2ZW50c1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIEFkZCB0byBtYXBcclxuICAgICAgcmVjdGFuZ2xlLmFkZFRvKG1hcEluc3RhbmNlKTtcclxuXHJcbiAgICAgIC8vIFVwZGF0ZSB0aGUgc3RhdGUgdG8gaW5jbHVkZSBib3RoIHRoZSByZWN0YW5nbGUgYW5kIHRoZSBsYWJlbFxyXG4gICAgICBzZXRSZWdpb25PdXRsaW5lKHtcclxuICAgICAgICByZW1vdmU6ICgpID0+IHtcclxuICAgICAgICAgIHJlY3RhbmdsZS5yZW1vdmUoKTtcclxuICAgICAgICB9LFxyXG4gICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgcHJvY2Vzc0dlb2ZlbmNlU2VhcmNoID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICBpZiAoIWdlb2ZlbmNlTG9jYXRpb24pIHJldHVybjtcclxuXHJcbiAgICAgIC8vIENoZWNrIGlmIHJhdGUgbGltaXRlZFxyXG4gICAgICBpZiAoaXNSYXRlTGltaXRlZCkge1xyXG4gICAgICAgIGFsZXJ0KFxyXG4gICAgICAgICAgYFJhdGUgbGltaXRlZC4gUGxlYXNlIHdhaXQgJHtyYXRlTGltaXRUaW1lciB8fCAzMH0gc2Vjb25kcyBiZWZvcmUgc2VhcmNoaW5nIGFnYWluLmBcclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQmxvY2sgQVBJIGNhbGxzIHdoaWxlIGRvaW5nIGdlb2ZlbmNlIHNlYXJjaCBpbiBjb21iaW5lZCBtb2RlXHJcbiAgICAgIGlmIChmaWx0ZXJNb2RlID09PSAnYm90aCcpIHtcclxuICAgICAgICBvcGVuU2t5VHJhY2tpbmdTZXJ2aWNlLnNldEJsb2NrQWxsQXBpQ2FsbHModHJ1ZSk7XHJcbiAgICAgICAgc2V0QmxvY2tNYW51ZmFjdHVyZXJBcGlDYWxscyh0cnVlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gU2V0IGxvYWRpbmcgc3RhdGVcclxuICAgICAgc2V0TG9jYWxMb2FkaW5nKHRydWUpO1xyXG5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgIGBTZWFyY2hpbmcgZm9yIGFpcmNyYWZ0IG5lYXIgbG9jYXRpb246IFwiJHtnZW9mZW5jZUxvY2F0aW9ufVwiYFxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIC8vIFRoaXMgd2lsbCBoYW5kbGUgUG9zdGFsIGNvZGVzLCBwbGFjZSBuYW1lcywgYWRkcmVzc2VzLCBQT0lzLCBldGMuXHJcbiAgICAgICAgbGV0IGZldGNoZWRBaXJjcmFmdDtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgZmV0Y2hlZEFpcmNyYWZ0ID0gYXdhaXQgZ2V0QWlyY3JhZnROZWFyU2VhcmNoZWRMb2NhdGlvbihcclxuICAgICAgICAgICAgZ2VvZmVuY2VMb2NhdGlvbixcclxuICAgICAgICAgICAgZ2VvZmVuY2VSYWRpdXNcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCdyYXRlIGxpbWl0JykgfHwgZXJyb3Iuc3RhdHVzID09PSA0MjkpIHtcclxuICAgICAgICAgICAgY29uc3QgcmV0cnlBZnRlciA9IDMwOyAvLyBEZWZhdWx0IHRvIDMwIHNlY29uZHMgaWYgbm90IHNwZWNpZmllZFxyXG4gICAgICAgICAgICBoYW5kbGVSYXRlTGltaXQocmV0cnlBZnRlcik7XHJcbiAgICAgICAgICAgIHNldExvY2FsTG9hZGluZyhmYWxzZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gR2V0IGNvb3JkaW5hdGVzIGZvciB0aGUgbWFwXHJcbiAgICAgICAgbGV0IGxvY2F0aW9uczogeyBsYXQ6IG51bWJlcjsgbG5nOiBudW1iZXI7IG5hbWU6IHN0cmluZyB9W107XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGxvY2F0aW9ucyA9IGF3YWl0IE1hcGJveFNlcnZpY2Uuc2VhcmNoTG9jYXRpb25XaXRoTWFwYm94KFxyXG4gICAgICAgICAgICBnZW9mZW5jZUxvY2F0aW9uLFxyXG4gICAgICAgICAgICAxXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzZWFyY2hpbmcgbG9jYXRpb24gd2l0aCBNYXBib3g6JywgZXJyb3IpO1xyXG4gICAgICAgICAgLy8gQ29udGludWUgd2l0aCBhaXJjcmFmdCBkYXRhIGlmIGF2YWlsYWJsZVxyXG4gICAgICAgICAgbG9jYXRpb25zID0gW107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgY29vcmRpbmF0ZXM6IHsgbGF0OiBudW1iZXI7IGxuZzogbnVtYmVyIH0gfCBudWxsID0gbnVsbDtcclxuXHJcbiAgICAgICAgaWYgKGxvY2F0aW9ucy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICBjb29yZGluYXRlcyA9IHtcclxuICAgICAgICAgICAgbGF0OiBsb2NhdGlvbnNbMF0ubGF0LFxyXG4gICAgICAgICAgICBsbmc6IGxvY2F0aW9uc1swXS5sbmcsXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgLy8gU2F2ZSB0aGUgZm9ybWF0dGVkIGxvY2F0aW9uIG5hbWVcclxuICAgICAgICAgIHNldEdlb2ZlbmNlTG9jYXRpb24obG9jYXRpb25zWzBdLm5hbWUpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgICAgICBmZXRjaGVkQWlyY3JhZnQubGVuZ3RoID4gMCAmJlxyXG4gICAgICAgICAgZmV0Y2hlZEFpcmNyYWZ0WzBdLmxhdGl0dWRlICYmXHJcbiAgICAgICAgICBmZXRjaGVkQWlyY3JhZnRbMF0ubG9uZ2l0dWRlXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAvLyBGYWxsYmFjayB0byBmaXJzdCBhaXJjcmFmdCBwb3NpdGlvblxyXG4gICAgICAgICAgY29vcmRpbmF0ZXMgPSB7XHJcbiAgICAgICAgICAgIGxhdDogZmV0Y2hlZEFpcmNyYWZ0WzBdLmxhdGl0dWRlLFxyXG4gICAgICAgICAgICBsbmc6IGZldGNoZWRBaXJjcmFmdFswXS5sb25naXR1ZGUsXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGZldGNoZWRBaXJjcmFmdC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgIGFsZXJ0KFxyXG4gICAgICAgICAgICBgTm8gYWlyY3JhZnQgZm91bmQgbmVhciAke2dlb2ZlbmNlTG9jYXRpb259LiBUcnkgaW5jcmVhc2luZyB0aGUgcmFkaXVzIG9yIHNlYXJjaGluZyBpbiBhIGRpZmZlcmVudCBhcmVhLmBcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICBzZXRMb2NhbExvYWRpbmcoZmFsc2UpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIHN0YXRlIHdpdGggdGhlIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgaWYgKGNvb3JkaW5hdGVzKSB7XHJcbiAgICAgICAgICBzZXRHZW9mZW5jZUNvb3JkaW5hdGVzKGNvb3JkaW5hdGVzKTtcclxuICAgICAgICAgIHNldEdlb2ZlbmNlQ2VudGVyKGNvb3JkaW5hdGVzKTtcclxuICAgICAgICAgIHNldEdlb2ZlbmNlUmFkaXVzKGdlb2ZlbmNlUmFkaXVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpc0dlb2ZlbmNlQWN0aXZlKSB7XHJcbiAgICAgICAgICB0b2dnbGVHZW9mZW5jZSgpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIWNvb3JkaW5hdGVzKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBkZXRlcm1pbmUgY29vcmRpbmF0ZXMgZm9yIHRoZSBsb2NhdGlvbicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICBgRm91bmQgJHtmZXRjaGVkQWlyY3JhZnQubGVuZ3RofSBhaXJjcmFmdCBpbiB0aGUgYXJlYSwgcHJlcGFyaW5nIGZvciBkaXNwbGF5Li4uYFxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIC8vIEVuc3VyZSB0aGUgZGF0YSBpcyBpbiB0aGUgcmlnaHQgZm9ybWF0XHJcbiAgICAgICAgY29uc3QgYWRhcHRlZEFpcmNyYWZ0ID1cclxuICAgICAgICAgIGZldGNoZWRBaXJjcmFmdFswXS5NQU5VRkFDVFVSRVIgIT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICA/IGZldGNoZWRBaXJjcmFmdCAvLyBBbHJlYWR5IGluIHRoZSByaWdodCBmb3JtYXRcclxuICAgICAgICAgICAgOiBhZGFwdEdlb2ZlbmNlQWlyY3JhZnQoZmV0Y2hlZEFpcmNyYWZ0KTsgLy8gTmVlZHMgYWRhcHRhdGlvblxyXG5cclxuICAgICAgICAvLyBFbnJpY2ggd2l0aCBzdGF0aWMgZGF0YVxyXG4gICAgICAgIGNvbnNvbGUubG9nKCdFbnJpY2hpbmcgZ2VvZmVuY2UgYWlyY3JhZnQgd2l0aCBzdGF0aWMgZGF0YS4uLicpO1xyXG4gICAgICAgIGNvbnN0IGVucmljaGVkQWlyY3JhZnQgPSBhd2FpdCBlbnJpY2hHZW9mZW5jZUFpcmNyYWZ0KGFkYXB0ZWRBaXJjcmFmdCk7XHJcblxyXG4gICAgICAgIC8vIFNhdmUgdGhlIEZVTEwgc2V0IHRvIGxvY2FsIHN0YXRlXHJcbiAgICAgICAgc2V0R2VvZmVuY2VBaXJjcmFmdChlbnJpY2hlZEFpcmNyYWZ0KTtcclxuICAgICAgICBzZXRJc0dlb2ZlbmNlQWN0aXZlKHRydWUpO1xyXG5cclxuICAgICAgICAvLyBDbGVhciBleGlzdGluZyBhaXJjcmFmdCBkYXRhXHJcbiAgICAgICAgaWYgKGNsZWFyR2VvZmVuY2VEYXRhKSB7XHJcbiAgICAgICAgICBjbGVhckdlb2ZlbmNlRGF0YSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSWYgd2UncmUgaW4gY29tYmluZWQgbW9kZSBhbmQgaGF2ZSBhIG1hbnVmYWN0dXJlciwgYXBwbHkgdGhlIGNvbWJpbmVkIGZpbHRlclxyXG4gICAgICAgIGlmIChmaWx0ZXJNb2RlID09PSAnYm90aCcgJiYgc2VsZWN0ZWRNYW51ZmFjdHVyZXIpIHtcclxuICAgICAgICAgIC8vIE1ha2Ugc3VyZSBBUEkgY2FsbHMgcmVtYWluIGJsb2NrZWRcclxuICAgICAgICAgIG9wZW5Ta3lUcmFja2luZ1NlcnZpY2Uuc2V0QmxvY2tBbGxBcGlDYWxscyh0cnVlKTtcclxuICAgICAgICAgIHNldEJsb2NrTWFudWZhY3R1cmVyQXBpQ2FsbHModHJ1ZSk7XHJcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgYXBwbHlDb21iaW5lZEZpbHRlcnMoKTtcclxuICAgICAgICAgIH0sIDEwMCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIEp1c3Qgc2hvdyBhbGwgYWlyY3JhZnQgaW4gdGhlIGdlb2ZlbmNlXHJcbiAgICAgICAgICB1cGRhdGVHZW9mZW5jZUFpcmNyYWZ0KGVucmljaGVkQWlyY3JhZnQpO1xyXG5cclxuICAgICAgICAgIC8vIENlbnRlciB0aGUgbWFwIC0gU0lNUExJRklFRCBaT09NIExPR0lDXHJcbiAgICAgICAgICBpZiAobWFwSW5zdGFuY2UgJiYgY29vcmRpbmF0ZXMpIHtcclxuICAgICAgICAgICAgLy8gR2V0IGN1cnJlbnQgem9vbSBsZXZlbFxyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50Wm9vbSA9IG1hcEluc3RhbmNlLmdldFpvb20oKTtcclxuICAgICAgICAgICAgLy8gVXNlIGFwcHJvcHJpYXRlIHpvb20gbGV2ZWwgYmFzZWQgb24gY3VycmVudCB2aWV3XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldFpvb20gPSBjdXJyZW50Wm9vbSA8PSA3ID8gOSA6IGN1cnJlbnRab29tO1xyXG5cclxuICAgICAgICAgICAgLy8gU2V0IHZpZXcgdG8gdGhlIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICAgIG1hcEluc3RhbmNlLnNldFZpZXcoW2Nvb3JkaW5hdGVzLmxhdCwgY29vcmRpbmF0ZXMubG5nXSwgdGFyZ2V0Wm9vbSk7XHJcblxyXG4gICAgICAgICAgICAvLyBFbnN1cmUgbWFwIGlzIHVwZGF0ZWRcclxuICAgICAgICAgICAgbWFwSW5zdGFuY2UuaW52YWxpZGF0ZVNpemUoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENsb3NlIGRyb3Bkb3duIGFmdGVyIHNlYXJjaFxyXG4gICAgICAgIHNldEFjdGl2ZURyb3Bkb3duKG51bGwpO1xyXG4gICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gZ2VvZmVuY2Ugc2VhcmNoOicsIGVycm9yKTtcclxuICAgICAgICBpZiAoZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ3JhdGUgbGltaXQnKSB8fCBlcnJvci5zdGF0dXMgPT09IDQyOSkge1xyXG4gICAgICAgICAgaGFuZGxlUmF0ZUxpbWl0KDMwKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgYWxlcnQoXHJcbiAgICAgICAgICAgIGBFcnJvcjogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yIG9jY3VycmVkJ31gXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICBzZXRMb2NhbExvYWRpbmcoZmFsc2UpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU1RFUCAzOiBGaXggdG9nZ2xlR2VvZmVuY2VTdGF0ZSB0byBiZXR0ZXIgaGFuZGxlIG1hbnVhbGx5IGNsaWNraW5nIHRoZSBidXR0b25cclxuICAgICAqL1xyXG4gICAgY29uc3QgdG9nZ2xlR2VvZmVuY2VTdGF0ZSA9IChlbmFibGVkOiBib29sZWFuKSA9PiB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCd0b2dnbGVHZW9mZW5jZVN0YXRlIGNhbGxlZCB3aXRoOicsIGVuYWJsZWQpO1xyXG4gICAgICBjb25zb2xlLmxvZygnQ3VycmVudCBnZW9mZW5jZUNvb3JkaW5hdGVzOicsIGdlb2ZlbmNlQ29vcmRpbmF0ZXMpO1xyXG5cclxuICAgICAgaWYgKGVuYWJsZWQpIHtcclxuICAgICAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIHZhbGlkIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgZ2VvZmVuY2VDb29yZGluYXRlcyAmJlxyXG4gICAgICAgICAgdHlwZW9mIGdlb2ZlbmNlQ29vcmRpbmF0ZXMubGF0ID09PSAnbnVtYmVyJyAmJlxyXG4gICAgICAgICAgdHlwZW9mIGdlb2ZlbmNlQ29vcmRpbmF0ZXMubG5nID09PSAnbnVtYmVyJyAmJlxyXG4gICAgICAgICAgIWlzTmFOKGdlb2ZlbmNlQ29vcmRpbmF0ZXMubGF0KSAmJlxyXG4gICAgICAgICAgIWlzTmFOKGdlb2ZlbmNlQ29vcmRpbmF0ZXMubG5nKVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coJ1ZhbGlkIGNvb3JkaW5hdGVzIGZvdW5kLCBlbmFibGluZyBnZW9mZW5jZScpO1xyXG5cclxuICAgICAgICAgIC8vIFNldCBmbGFncyBmaXJzdFxyXG4gICAgICAgICAgc2V0R2VvZmVuY2VFbmFibGVkKHRydWUpO1xyXG4gICAgICAgICAgc2V0SXNHZW9mZW5jZUFjdGl2ZSh0cnVlKTtcclxuXHJcbiAgICAgICAgICAvLyBDYWxsIGNvbnRleHQgdG9nZ2xlIGZ1bmN0aW9uIGlmIGF2YWlsYWJsZVxyXG4gICAgICAgICAgaWYgKHR5cGVvZiB0b2dnbGVHZW9mZW5jZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB0b2dnbGVHZW9mZW5jZSgpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIERpc3BsYXkgYWlyY3JhZnQgaWYgd2UgaGF2ZSB0aGVtXHJcbiAgICAgICAgICBpZiAoZ2VvZmVuY2VBaXJjcmFmdCAmJiBnZW9mZW5jZUFpcmNyYWZ0Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICAgICAgYFNob3dpbmcgJHtnZW9mZW5jZUFpcmNyYWZ0Lmxlbmd0aH0gYWlyY3JhZnQgaW4gZ2VvZmVuY2VgXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHVwZGF0ZUdlb2ZlbmNlQWlyY3JhZnQoZ2VvZmVuY2VBaXJjcmFmdCk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBObyBhaXJjcmFmdCBkYXRhIHlldCwgdHJpZ2dlciBhIHNlYXJjaFxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnTm8gYWlyY3JhZnQgZGF0YSB5ZXQsIHRyaWdnZXJpbmcgc2VhcmNoJyk7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgIHByb2Nlc3NHZW9mZW5jZVNlYXJjaCgpO1xyXG4gICAgICAgICAgICB9LCAxMDApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBObyB2YWxpZCBjb29yZGluYXRlc1xyXG4gICAgICAgICAgY29uc29sZS53YXJuKCdObyB2YWxpZCBjb29yZGluYXRlcywgc2hvd2luZyBhbGVydCcpO1xyXG4gICAgICAgICAgYWxlcnQoXHJcbiAgICAgICAgICAgICdQbGVhc2Ugc2V0IGEgbG9jYXRpb24gYmVmb3JlIGVuYWJsaW5nIGdlb2ZlbmNlLlxcblxcbkNsaWNrIGFueXdoZXJlIG9uIHRoZSBtYXAgdG8gc2V0IGEgbG9jYXRpb24uJ1xyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIHNldEdlb2ZlbmNlRW5hYmxlZChmYWxzZSk7XHJcbiAgICAgICAgICBzZXRJc0dlb2ZlbmNlQWN0aXZlKGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gRGlzYWJsaW5nIGdlb2ZlbmNlXHJcbiAgICAgICAgY29uc29sZS5sb2coJ0Rpc2FibGluZyBnZW9mZW5jZScpO1xyXG4gICAgICAgIHNldEdlb2ZlbmNlRW5hYmxlZChmYWxzZSk7XHJcbiAgICAgICAgc2V0SXNHZW9mZW5jZUFjdGl2ZShmYWxzZSk7XHJcblxyXG4gICAgICAgIC8vIENsZWFyIGdlb2ZlbmNlIGRhdGEgaWYgZnVuY3Rpb24gYXZhaWxhYmxlXHJcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhckdlb2ZlbmNlRGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgY2xlYXJHZW9mZW5jZURhdGEoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8gTWFudWZhY3R1cmVyIGZpbHRlciBtZXRob2RzXHJcbiAgICBjb25zdCBzZWxlY3RNYW51ZmFjdHVyZXJBbmRDbG9zZSA9ICh2YWx1ZTogc3RyaW5nKSA9PiB7XHJcbiAgICAgIC8vIENsb3NlIGRyb3Bkb3duXHJcbiAgICAgIHNldEFjdGl2ZURyb3Bkb3duKG51bGwpO1xyXG4gICAgICBzZXRNYW51ZmFjdHVyZXJTZWFyY2hUZXJtKCcnKTtcclxuXHJcbiAgICAgIC8vIElmIGNsZWFyaW5nIHRoZSBzZWxlY3Rpb25cclxuICAgICAgaWYgKHZhbHVlID09PSAnJykge1xyXG4gICAgICAgIHNlbGVjdE1hbnVmYWN0dXJlcihudWxsKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFNldCB0aGUgbWFudWZhY3R1cmVyIHNlbGVjdGlvblxyXG4gICAgICBzZWxlY3RNYW51ZmFjdHVyZXIodmFsdWUpO1xyXG5cclxuICAgICAgLy8gSWYgcmVnaW9uIGlzIGFscmVhZHkgc2VsZWN0ZWQsIGZldGNoIGZpbHRlcmVkIGRhdGFcclxuICAgICAgaWYgKGFjdGl2ZVJlZ2lvbiAhPT0gbnVsbCkge1xyXG4gICAgICAgIGZldGNoQWlyY3JhZnRCeVJlZ2lvbkFuZE1hbnVmYWN0dXJlcihhY3RpdmVSZWdpb24gYXMgUmVnaW9uQ29kZSwgdmFsdWUpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIE90aGVyd2lzZSwganVzdCBwcm9jZWVkIHdpdGggbWFudWZhY3R1cmVyLW9ubHkgZmlsdGVyaW5nIGFzIGJlZm9yZVxyXG4gICAgICAgIGZldGNoTWFudWZhY3R1cmVyRGF0YSh2YWx1ZSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgZmV0Y2hNYW51ZmFjdHVyZXJEYXRhID0gKG1hbnVmYWN0dXJlcjogc3RyaW5nKSA9PiB7XHJcbiAgICAgIGlmIChpc1JhdGVMaW1pdGVkKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICBgU2tpcHBpbmcgZGF0YSBmZXRjaCAtIHJhdGUgbGltaXRlZCBmb3IgJHtyYXRlTGltaXRUaW1lcn1zYFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zb2xlLmxvZyhgRmV0Y2hpbmcgZGF0YSBmb3IgbWFudWZhY3R1cmVyOiAke21hbnVmYWN0dXJlcn1gKTtcclxuXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgLy8gSWYgeW91IGhhdmUgYSBjb250ZXh0IGZ1bmN0aW9uIGZvciB0aGlzLCBjYWxsIGl0IGFmdGVyIGEgc2xpZ2h0IGRlbGF5XHJcbiAgICAgICAgaWYgKHR5cGVvZiByZWZyZXNoUG9zaXRpb25zID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAvLyBBcHBseSBhIHNtYWxsIGRlbGF5IHRvIHByZXZlbnQgb3ZlcndoZWxtaW5nIHRoZSBBUElcclxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICByZWZyZXNoUG9zaXRpb25zKCkuY2F0Y2goKGVycm9yOiBhbnkpID0+IHtcclxuICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygncmF0ZSBsaW1pdCcpIHx8XHJcbiAgICAgICAgICAgICAgICBlcnJvci5zdGF0dXMgPT09IDQyOVxyXG4gICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlUmF0ZUxpbWl0KDMwKTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgbWFudWZhY3R1cmVyIGRhdGE6JywgZXJyb3IpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9LCAyMDApO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgICAgIGlmIChlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygncmF0ZSBsaW1pdCcpIHx8IGVycm9yLnN0YXR1cyA9PT0gNDI5KSB7XHJcbiAgICAgICAgICBoYW5kbGVSYXRlTGltaXQoMzApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzY2hlZHVsaW5nIG1hbnVmYWN0dXJlciBkYXRhIGZldGNoOicsIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgZmV0Y2hBaXJjcmFmdEJ5UmVnaW9uQW5kTWFudWZhY3R1cmVyID0gYXN5bmMgKFxyXG4gICAgICByZWdpb246IFJlZ2lvbkNvZGUsXHJcbiAgICAgIG1hbnVmYWN0dXJlcjogc3RyaW5nLFxyXG4gICAgICBwYWdlOiBudW1iZXIgPSAxLFxyXG4gICAgICBsaW1pdDogbnVtYmVyID0gNTAwXHJcbiAgICApID0+IHtcclxuICAgICAgaWYgKCFyZWdpb24gfHwgIW1hbnVmYWN0dXJlcikge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdCb3RoIHJlZ2lvbiBhbmQgbWFudWZhY3R1cmVyIG11c3QgYmUgc2VsZWN0ZWQnKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHNldExvY2FsTG9hZGluZyh0cnVlKTtcclxuXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcclxuICAgICAgICAgIGAvYXBpL3RyYWNraW5nL2ZpbHRlcmVkLWFpcmNyYWZ0P3JlZ2lvbj0ke3JlZ2lvbn0mbWFudWZhY3R1cmVyPSR7ZW5jb2RlVVJJQ29tcG9uZW50KG1hbnVmYWN0dXJlcil9JnBhZ2U9JHtwYWdlfSZsaW1pdD0ke2xpbWl0fWBcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICAgIGNvbnN0IGFpcmNyYWZ0RGF0YSA9IGRhdGEuYWlyY3JhZnQgfHwgW107XHJcblxyXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQVBJIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBQcm9jZXNzIHRoZSBmaWx0ZXJlZCBhaXJjcmFmdCBkYXRhXHJcbiAgICAgICAgaWYgKGFpcmNyYWZ0RGF0YS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAvLyBUcmFuc2Zvcm0gdG8gRXh0ZW5kZWRBaXJjcmFmdFxyXG4gICAgICAgICAgaW50ZXJmYWNlIEFpcmNyYWZ0RGF0YSB7XHJcbiAgICAgICAgICAgIFRZUEVfQUlSQ1JBRlQ/OiBzdHJpbmc7XHJcbiAgICAgICAgICAgIE9QRVJBVE9SPzogc3RyaW5nO1xyXG4gICAgICAgICAgICBSRUdJT046IG51bWJlcjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBjb25zdCBleHRlbmRlZEFpcmNyYWZ0OiBFeHRlbmRlZEFpcmNyYWZ0W10gPSBhaXJjcmFmdERhdGEubWFwKFxyXG4gICAgICAgICAgICAoYWlyY3JhZnQ6IEFpcmNyYWZ0RGF0YSkgPT4gKHtcclxuICAgICAgICAgICAgICAuLi5haXJjcmFmdCxcclxuICAgICAgICAgICAgICB0eXBlOiBhaXJjcmFmdC5UWVBFX0FJUkNSQUZUIHx8ICdVbmtub3duJyxcclxuICAgICAgICAgICAgICBpc0dvdmVybm1lbnQ6XHJcbiAgICAgICAgICAgICAgICBhaXJjcmFmdC5PUEVSQVRPUj8udG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnZ292ZXJubWVudCcpID8/XHJcbiAgICAgICAgICAgICAgICBmYWxzZSxcclxuICAgICAgICAgICAgICBSRUdJT046IGFpcmNyYWZ0LlJFR0lPTixcclxuICAgICAgICAgICAgICB6b29tTGV2ZWw6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgLy8gVXBkYXRlIHRoZSBtYXBcclxuICAgICAgICAgIHVwZGF0ZUdlb2ZlbmNlQWlyY3JhZnQoZXh0ZW5kZWRBaXJjcmFmdCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgICBgTm8gYWlyY3JhZnQgZm91bmQgZm9yIG1hbnVmYWN0dXJlciAke21hbnVmYWN0dXJlcn0gaW4gcmVnaW9uICR7cmVnaW9ufWBcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGZpbHRlcmVkIGFpcmNyYWZ0OicsIGVycm9yKTtcclxuICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICBzZXRMb2NhbExvYWRpbmcoZmFsc2UpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIE1vZGVsIHNlbGVjdGlvbiBtZXRob2RzXHJcbiAgICBjb25zdCBoYW5kbGVNb2RlbFNlbGVjdCA9ICh2YWx1ZTogc3RyaW5nKSA9PiB7XHJcbiAgICAgIHNlbGVjdE1vZGVsKHZhbHVlID09PSAnJyA/IG51bGwgOiB2YWx1ZSk7XHJcbiAgICAgIHNldEFjdGl2ZURyb3Bkb3duKG51bGwpO1xyXG5cclxuICAgICAgLy8gSWYgaW4gY29tYmluZWQgbW9kZSwgcmVhcHBseSB0aGUgZmlsdGVyXHJcbiAgICAgIGlmIChmaWx0ZXJNb2RlID09PSAnYm90aCcgJiYgaXNHZW9mZW5jZUFjdGl2ZSAmJiBzZWxlY3RlZE1hbnVmYWN0dXJlcikge1xyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgYXBwbHlDb21iaW5lZEZpbHRlcnMoKTtcclxuICAgICAgICB9LCAxMDApO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIENvbWJpbmVkIGZpbHRlciBtZXRob2RzXHJcbiAgICBjb25zdCBhcHBseUNvbWJpbmVkRmlsdGVycyA9ICgpID0+IHtcclxuICAgICAgaWYgKFxyXG4gICAgICAgICFzZWxlY3RlZE1hbnVmYWN0dXJlciB8fFxyXG4gICAgICAgICFpc0dlb2ZlbmNlQWN0aXZlIHx8XHJcbiAgICAgICAgZ2VvZmVuY2VBaXJjcmFmdC5sZW5ndGggPT09IDBcclxuICAgICAgKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzZXRMb2NhbExvYWRpbmcodHJ1ZSk7XHJcblxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgYEZpbHRlcmluZyAke2dlb2ZlbmNlQWlyY3JhZnQubGVuZ3RofSBhaXJjcmFmdCBieSAke3NlbGVjdGVkTWFudWZhY3R1cmVyfWBcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyBGaWx0ZXIgdGhlIGFpcmNyYWZ0IGJ5IG1hbnVmYWN0dXJlclxyXG4gICAgICAgIGxldCBmaWx0ZXJlZEFpcmNyYWZ0ID0gZ2VvZmVuY2VBaXJjcmFmdC5maWx0ZXIoXHJcbiAgICAgICAgICAoYWlyY3JhZnQpID0+XHJcbiAgICAgICAgICAgIGFpcmNyYWZ0Lk1BTlVGQUNUVVJFUj8udG9Mb3dlckNhc2UoKSA9PT1cclxuICAgICAgICAgICAgc2VsZWN0ZWRNYW51ZmFjdHVyZXIudG9Mb3dlckNhc2UoKVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIC8vIEZ1cnRoZXIgZmlsdGVyIGJ5IG1vZGVsIGlmIHNlbGVjdGVkXHJcbiAgICAgICAgaWYgKHNlbGVjdGVkTW9kZWwpIHtcclxuICAgICAgICAgIGZpbHRlcmVkQWlyY3JhZnQgPSBmaWx0ZXJlZEFpcmNyYWZ0LmZpbHRlcihcclxuICAgICAgICAgICAgKGFpcmNyYWZ0KSA9PlxyXG4gICAgICAgICAgICAgIGFpcmNyYWZ0Lk1PREVMPy50b0xvd2VyQ2FzZSgpID09PSBzZWxlY3RlZE1vZGVsLnRvTG93ZXJDYXNlKClcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhgRm91bmQgJHtmaWx0ZXJlZEFpcmNyYWZ0Lmxlbmd0aH0gbWF0Y2hpbmcgYWlyY3JhZnRgKTtcclxuXHJcbiAgICAgICAgaWYgKGZpbHRlcmVkQWlyY3JhZnQubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICBhbGVydChgTm8gJHtzZWxlY3RlZE1hbnVmYWN0dXJlcn0gYWlyY3JhZnQgZm91bmQgaW4gdGhpcyBhcmVhLmApO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2xlYXIgZGlzcGxheSBkYXRhXHJcbiAgICAgICAgaWYgKGNsZWFyR2VvZmVuY2VEYXRhKSB7XHJcbiAgICAgICAgICBjbGVhckdlb2ZlbmNlRGF0YSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBkaXNwbGF5XHJcbiAgICAgICAgdXBkYXRlR2VvZmVuY2VBaXJjcmFmdChmaWx0ZXJlZEFpcmNyYWZ0KTtcclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmaWx0ZXJpbmcgYWlyY3JhZnQ6JywgZXJyb3IpO1xyXG4gICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHNldExvY2FsTG9hZGluZyhmYWxzZSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8gUmVzZXQgYWxsIGZpbHRlcnNcclxuICAgIGNvbnN0IGNsZWFyQWxsRmlsdGVycyA9ICgpID0+IHtcclxuICAgICAgY29uc29sZS5sb2coJ0NsZWFyaW5nIGFsbCBmaWx0ZXJzLi4uJyk7XHJcblxyXG4gICAgICAvLyAxLiBSZXNldCBmaWx0ZXIgbW9kZVxyXG4gICAgICBzZXRGaWx0ZXJNb2RlKCdtYW51ZmFjdHVyZXInKTtcclxuXHJcbiAgICAgIC8vIDIuIFVuYmxvY2sgQVBJIGNhbGxzIHRoYXQgbWlnaHQgaGF2ZSBiZWVuIGJsb2NrZWRcclxuICAgICAgb3BlblNreVRyYWNraW5nU2VydmljZS5zZXRCbG9ja0FsbEFwaUNhbGxzKGZhbHNlKTtcclxuICAgICAgc2V0QmxvY2tNYW51ZmFjdHVyZXJBcGlDYWxscyhmYWxzZSk7XHJcbiAgICAgIHNldElzTWFudWZhY3R1cmVyQXBpQmxvY2tlZChmYWxzZSk7XHJcblxyXG4gICAgICAvLyAzLiBDbGVhciBtYW51ZmFjdHVyZXIgc2VsZWN0aW9uXHJcbiAgICAgIHNlbGVjdE1hbnVmYWN0dXJlcihudWxsKTtcclxuICAgICAgc2VsZWN0TW9kZWwobnVsbCk7XHJcblxyXG4gICAgICAvLyA0LiBDbGVhciBnZW9mZW5jZVxyXG4gICAgICBzZXRHZW9mZW5jZUxvY2F0aW9uKCcnKTtcclxuICAgICAgc2V0R2VvZmVuY2VDb29yZGluYXRlcyhudWxsKTtcclxuICAgICAgc2V0R2VvZmVuY2VBaXJjcmFmdChbXSk7XHJcbiAgICAgIHNldEdlb2ZlbmNlRW5hYmxlZChmYWxzZSk7XHJcbiAgICAgIHNldElzR2VvZmVuY2VBY3RpdmUoZmFsc2UpO1xyXG4gICAgICBpZiAodHlwZW9mIGNsZWFyR2VvZmVuY2UgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICBjbGVhckdlb2ZlbmNlKCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHR5cGVvZiBjbGVhckdlb2ZlbmNlRGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIGNsZWFyR2VvZmVuY2VEYXRhKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIDUuIFJlc2V0IG93bmVyIGZpbHRlcnMgdG8gc2VsZWN0IGFsbFxyXG4gICAgICBzZXRPd25lckZpbHRlcnMoWy4uLmFsbE93bmVyVHlwZXNdKTtcclxuXHJcbiAgICAgIC8vIDYuIENsZWFyIHJlZ2lvbiBmaWx0ZXIgcHJvcGVybHlcclxuICAgICAgc2V0QWN0aXZlUmVnaW9uKG51bGwpO1xyXG4gICAgICBzZXRTZWxlY3RlZFJlZ2lvbihSZWdpb25Db2RlLkdMT0JBTCk7XHJcblxyXG4gICAgICAvLyBDbGVhciByZWdpb24gb3V0bGluZSBmcm9tIG1hcFxyXG4gICAgICBpZiAocmVnaW9uT3V0bGluZSkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAvLyBIYW5kbGUgZGlmZmVyZW50IHBvc3NpYmxlIG9iamVjdCBzdHJ1Y3R1cmVzXHJcbiAgICAgICAgICBpZiAodHlwZW9mIHJlZ2lvbk91dGxpbmUucmVtb3ZlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHJlZ2lvbk91dGxpbmUucmVtb3ZlKCk7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKFxyXG4gICAgICAgICAgICByZWdpb25PdXRsaW5lLnJlY3RhbmdsZSAmJlxyXG4gICAgICAgICAgICB0eXBlb2YgcmVnaW9uT3V0bGluZS5yZWN0YW5nbGUucmVtb3ZlID09PSAnZnVuY3Rpb24nXHJcbiAgICAgICAgICApIHtcclxuICAgICAgICAgICAgcmVnaW9uT3V0bGluZS5yZWN0YW5nbGUucmVtb3ZlKCk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gQ2xlYXIgYW55IGxhYmVscyBhc3NvY2lhdGVkIHdpdGggdGhlIHJlZ2lvblxyXG4gICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICByZWdpb25PdXRsaW5lLmxhYmVsICYmXHJcbiAgICAgICAgICAgIHR5cGVvZiByZWdpb25PdXRsaW5lLmxhYmVsLnJlbW92ZSA9PT0gJ2Z1bmN0aW9uJ1xyXG4gICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIHJlZ2lvbk91dGxpbmUubGFiZWwucmVtb3ZlKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlbW92aW5nIHJlZ2lvbiBvdXRsaW5lOicsIGVycm9yKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEFsd2F5cyByZXNldCB0aGUgcmVnaW9uIG91dGxpbmUgc3RhdGVcclxuICAgICAgICBzZXRSZWdpb25PdXRsaW5lKG51bGwpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyA3LiBSZXNldCBtYXAgdmlldyB0byBnbG9iYWxcclxuICAgICAgaWYgKG1hcEluc3RhbmNlKSB7XHJcbiAgICAgICAgLy8gVXNlIHRoZSBwcmVkZWZpbmVkIGNlbnRlciBhbmQgem9vbSBsZXZlbCBmcm9tIHlvdXIgbWFwIGNvbmZpZ1xyXG4gICAgICAgIG1hcEluc3RhbmNlLnNldFZpZXcoTUFQX0NPTkZJRy5DRU5URVIsIE1BUF9DT05GSUcuREVGQVVMVF9aT09NKTtcclxuICAgICAgICBtYXBJbnN0YW5jZS5pbnZhbGlkYXRlU2l6ZSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyA4LiBSZXNldCB0byBpbml0aWFsIGFpcmNyYWZ0IGRhdGFcclxuICAgICAgaWYgKHR5cGVvZiByZXNldCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHJlc2V0KCk7XHJcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZ1bGxSZWZyZXNoID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgZnVsbFJlZnJlc2goKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gOS4gQ2xvc2UgYW55IG9wZW4gZHJvcGRvd25cclxuICAgICAgc2V0QWN0aXZlRHJvcGRvd24obnVsbCk7XHJcblxyXG4gICAgICAvLyAxMC4gUmVzZXQgcmF0ZSBsaW1pdGluZyBzdGF0ZXNcclxuICAgICAgc2V0SXNSYXRlTGltaXRlZChmYWxzZSk7XHJcbiAgICAgIHNldFJhdGVMaW1pdFRpbWVyKG51bGwpO1xyXG5cclxuICAgICAgLy8gMTEuIENsZWFyIGNvbWJpbmVkIG1vZGUgc3RhdGVcclxuICAgICAgc2V0Q29tYmluZWRNb2RlUmVhZHkoZmFsc2UpO1xyXG5cclxuICAgICAgLy8gMTIuIFJlc2V0IHNlYXJjaCB0ZXJtc1xyXG4gICAgICBzZXRNYW51ZmFjdHVyZXJTZWFyY2hUZXJtKCcnKTtcclxuXHJcbiAgICAgIC8vIDEzLiBEaXNwYXRjaCBhIGN1c3RvbSBldmVudCB0aGF0IG90aGVyIGNvbXBvbmVudHMgY2FuIGxpc3RlbiBmb3JcclxuICAgICAgY29uc3QgY2xlYXJFdmVudCA9IG5ldyBDdXN0b21FdmVudCgncmliYm9uLWZpbHRlcnMtY2xlYXJlZCcpO1xyXG4gICAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KGNsZWFyRXZlbnQpO1xyXG5cclxuICAgICAgY29uc29sZS5sb2coJ0FsbCBmaWx0ZXJzIGNsZWFyZWQgc3VjY2Vzc2Z1bGx5Jyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIENhbGN1bGF0ZSBjb21iaW5lZCBsb2FkaW5nIHN0YXRlXHJcbiAgICBjb25zdCBjb21iaW5lZExvYWRpbmcgPSBsb2NhbExvYWRpbmc7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgLy8gU3RhdGVcclxuICAgICAgZmlsdGVyTW9kZSxcclxuICAgICAgYWN0aXZlRHJvcGRvd24sXHJcbiAgICAgIHNlbGVjdGVkTWFudWZhY3R1cmVyLFxyXG4gICAgICBzZWxlY3RlZE1vZGVsLFxyXG4gICAgICBnZW9mZW5jZUxvY2F0aW9uLFxyXG4gICAgICBnZW9mZW5jZVJhZGl1cyxcclxuICAgICAgaXNHZW9mZW5jZUFjdGl2ZSxcclxuICAgICAgZ2VvZmVuY2VDb29yZGluYXRlcyxcclxuICAgICAgZ2V0VXNlckxvY2F0aW9uLFxyXG4gICAgICBhY3RpdmVSZWdpb24sXHJcbiAgICAgIG93bmVyRmlsdGVycyxcclxuICAgICAgYWxsT3duZXJUeXBlcyxcclxuICAgICAgbWFudWZhY3R1cmVyU2VhcmNoVGVybSxcclxuICAgICAgY29tYmluZWRMb2FkaW5nLFxyXG4gICAgICBpc0dldHRpbmdMb2NhdGlvbixcclxuICAgICAgZHJvcGRvd25SZWZzLFxyXG4gICAgICBsb2NhbExvYWRpbmcsXHJcbiAgICAgIGlzUmF0ZUxpbWl0ZWQsXHJcbiAgICAgIHNlbGVjdGVkUmVnaW9uLFxyXG4gICAgICBpc1JlZnJlc2hpbmcsXHJcbiAgICAgIGlzR2VvZmVuY2VQbGFjZW1lbnRNb2RlOiBmYWxzZSwgLy8gSW5pdGlhbGl6ZSB3aXRoIGEgZGVmYXVsdCB2YWx1ZVxyXG5cclxuICAgICAgLy8gTWV0aG9kc1xyXG4gICAgICB0b2dnbGVEcm9wZG93bixcclxuICAgICAgdG9nZ2xlRmlsdGVyTW9kZSxcclxuICAgICAgc2VsZWN0TWFudWZhY3R1cmVyQW5kQ2xvc2UsXHJcbiAgICAgIGhhbmRsZU1vZGVsU2VsZWN0LFxyXG4gICAgICBwcm9jZXNzR2VvZmVuY2VTZWFyY2gsXHJcbiAgICAgIGhhbmRsZU93bmVyRmlsdGVyQ2hhbmdlLFxyXG4gICAgICBoYW5kbGVSZWdpb25TZWxlY3QsXHJcbiAgICAgIHNldE1hbnVmYWN0dXJlclNlYXJjaFRlcm0sXHJcbiAgICAgIHNldEdlb2ZlbmNlTG9jYXRpb24sXHJcbiAgICAgIHNldEdlb2ZlbmNlUmFkaXVzLFxyXG4gICAgICB0b2dnbGVHZW9mZW5jZVN0YXRlLFxyXG4gICAgICBjbGVhckFsbEZpbHRlcnMsXHJcbiAgICAgIGFwcGx5Q29tYmluZWRGaWx0ZXJzLFxyXG4gICAgICBnZXRBaXJjcmFmdE93bmVyVHlwZSxcclxuICAgICAgc2V0R2VvZmVuY2VDb29yZGluYXRlcyxcclxuICAgICAgc2V0R2VvZmVuY2VDZW50ZXIsXHJcbiAgICAgIHVwZGF0ZUdlb2ZlbmNlQWlyY3JhZnQsXHJcblxyXG4gICAgICByZWZyZXNoV2l0aEZpbHRlcnM6ICgpID0+IHtcclxuICAgICAgICAvLyBJbXBsZW1lbnQgcmVmcmVzaCBsb2dpYyBoZXJlXHJcbiAgICAgICAgaWYgKHR5cGVvZiByZWZyZXNoUG9zaXRpb25zID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICByZWZyZXNoUG9zaXRpb25zKCkuY2F0Y2goKGVycm9yKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlZnJlc2hpbmcgcG9zaXRpb25zOicsIGVycm9yKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgc2V0QWN0aXZlRHJvcGRvd24sIC8vIEFkZCB0aGlzIGxpbmUgaWYgeW91IGhhdmUgdGhpcyBmdW5jdGlvblxyXG4gICAgfTtcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIGFwcGx5Q29tYmluZWRGaWx0ZXJzKCkge1xyXG4gIHRocm93IG5ldyBFcnJvcignRnVuY3Rpb24gbm90IGltcGxlbWVudGVkLicpO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZVJlZiIsInVzZUVmZmVjdCIsIlJlYWN0IiwiUmVnaW9uQ29kZSIsInVzZUVuaGFuY2VkTWFwQ29udGV4dCIsIm9wZW5Ta3lUcmFja2luZ1NlcnZpY2UiLCJNYXBib3hTZXJ2aWNlIiwiYWRhcHRHZW9mZW5jZUFpcmNyYWZ0IiwiZW5yaWNoR2VvZmVuY2VBaXJjcmFmdCIsInVzZUdlb2xvY2F0aW9uU2VydmljZXMiLCJnZXRBaXJjcmFmdE5lYXJMb2NhdGlvbiIsImdldEFpcmNyYWZ0TmVhclNlYXJjaGVkTG9jYXRpb24iLCJ1c2VHZW9sb2NhdGlvbiIsIk1BUF9DT05GSUciLCJnZXRCb3VuZHNCeVJlZ2lvbiIsImdldFpvb21MZXZlbEZvclJlZ2lvbiIsInVzZUZpbHRlckxvZ2ljIiwic2VsZWN0ZWRNYW51ZmFjdHVyZXIiLCJzZWxlY3RlZE1vZGVsIiwidG90YWxBY3RpdmUiLCJzZWxlY3RNYW51ZmFjdHVyZXIiLCJzZWxlY3RNb2RlbCIsInJlc2V0IiwiZnVsbFJlZnJlc2giLCJyZWZyZXNoUG9zaXRpb25zIiwibWFwSW5zdGFuY2UiLCJ1cGRhdGVBaXJjcmFmdERhdGEiLCJjbGVhckdlb2ZlbmNlRGF0YSIsInVwZGF0ZUdlb2ZlbmNlQWlyY3JhZnQiLCJibG9ja01hbnVmYWN0dXJlckFwaUNhbGxzIiwic2V0QmxvY2tNYW51ZmFjdHVyZXJBcGlDYWxscyIsImlzTWFudWZhY3R1cmVyQXBpQmxvY2tlZCIsInNldElzTWFudWZhY3R1cmVyQXBpQmxvY2tlZCIsImdlb2ZlbmNlQ2VudGVyIiwic2V0R2VvZmVuY2VDZW50ZXIiLCJ0b2dnbGVHZW9mZW5jZSIsImNsZWFyR2VvZmVuY2UiLCJkaXNwbGF5ZWRBaXJjcmFmdCIsImdlb2xvY2F0aW9uU2VydmljZXMiLCJsb2NhbExvYWRpbmciLCJzZXRMb2NhbExvYWRpbmciLCJmaWx0ZXJNb2RlIiwic2V0RmlsdGVyTW9kZSIsImFjdGl2ZURyb3Bkb3duIiwic2V0QWN0aXZlRHJvcGRvd24iLCJtYW51ZmFjdHVyZXJTZWFyY2hUZXJtIiwic2V0TWFudWZhY3R1cmVyU2VhcmNoVGVybSIsImlzUmVmcmVzaGluZyIsInNldElzUmVmcmVzaGluZyIsImlzUmF0ZUxpbWl0ZWQiLCJzZXRJc1JhdGVMaW1pdGVkIiwicmF0ZUxpbWl0VGltZXIiLCJzZXRSYXRlTGltaXRUaW1lciIsImlzR2V0dGluZ0xvY2F0aW9uIiwic2V0SXNHZXR0aW5nTG9jYXRpb24iLCJnZW9mZW5jZUxvY2F0aW9uIiwic2V0R2VvZmVuY2VMb2NhdGlvbiIsImdlb2ZlbmNlUmFkaXVzIiwic2V0R2VvZmVuY2VSYWRpdXMiLCJnZW9mZW5jZUNvb3JkaW5hdGVzIiwic2V0R2VvZmVuY2VDb29yZGluYXRlcyIsImdlb2ZlbmNlQWlyY3JhZnQiLCJzZXRHZW9mZW5jZUFpcmNyYWZ0IiwiZ2VvZmVuY2VFbmFibGVkIiwic2V0R2VvZmVuY2VFbmFibGVkIiwiaXNHZW9mZW5jZUFjdGl2ZSIsInNldElzR2VvZmVuY2VBY3RpdmUiLCJpc1NlYXJjaFJlYWR5Iiwic2V0SXNTZWFyY2hSZWFkeSIsImFjdGl2ZVJlZ2lvbiIsInNldEFjdGl2ZVJlZ2lvbiIsInJlZ2lvbk91dGxpbmUiLCJzZXRSZWdpb25PdXRsaW5lIiwic2VsZWN0ZWRSZWdpb24iLCJzZXRTZWxlY3RlZFJlZ2lvbiIsIkdMT0JBTCIsImNvbWJpbmVkTW9kZVJlYWR5Iiwic2V0Q29tYmluZWRNb2RlUmVhZHkiLCJhbGxPd25lclR5cGVzIiwib3duZXJGaWx0ZXJzIiwic2V0T3duZXJGaWx0ZXJzIiwiZHJvcGRvd25SZWZzIiwiZmlsdGVyIiwibWFudWZhY3R1cmVyIiwibW9kZWwiLCJsb2NhdGlvbiIsInJlZ2lvbiIsIm93bmVyIiwiYWN0aW9ucyIsImdlb2xvY2F0aW9uIiwiZ2V0VXNlckxvY2F0aW9uIiwiYWxlcnQiLCJwb3NpdGlvbiIsImdldEN1cnJlbnRQb3NpdGlvbiIsImxhdGl0dWRlIiwibG9uZ2l0dWRlIiwiY29vcmRzIiwibGF0IiwibG5nIiwidG9GaXhlZCIsImZldGNoZWRBaXJjcmFmdCIsImxlbmd0aCIsImFkYXB0ZWRBaXJjcmFmdCIsImVucmljaGVkQWlyY3JhZnQiLCJjdXJyZW50Wm9vbSIsImdldFpvb20iLCJ0YXJnZXRab29tIiwic2V0VmlldyIsImludmFsaWRhdGVTaXplIiwiZXJyb3IiLCJtZXNzYWdlIiwiaW5jbHVkZXMiLCJzdGF0dXMiLCJoYW5kbGVSYXRlTGltaXQiLCJjb25zb2xlIiwidGltZXIiLCJzZXRUaW1lb3V0IiwibG9nIiwiY2xlYXJUaW1lb3V0IiwiaGFuZGxlQ2xpY2tPdXRzaWRlIiwiZXZlbnQiLCJpc091dHNpZGVBbGwiLCJPYmplY3QiLCJ2YWx1ZXMiLCJldmVyeSIsInJlZiIsImN1cnJlbnQiLCJjb250YWlucyIsInRhcmdldCIsImRvY3VtZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJyZW1vdmUiLCJoYW5kbGVNYXBHZW9mZW5jZUNsaWNrIiwiY3VzdG9tRXZlbnQiLCJkZXRhaWwiLCJsb2NhdGlvbk5hbWUiLCJnZXRMb2NhdGlvbk5hbWVGcm9tQ29vcmRpbmF0ZXMiLCJ0b2dnbGVEcm9wZG93biIsImRyb3Bkb3duIiwic3RvcFByb3BhZ2F0aW9uIiwicmV0cnlBZnRlciIsInNldEJsb2NrQWxsQXBpQ2FsbHMiLCJ0b2dnbGVGaWx0ZXJNb2RlIiwibW9kZSIsImZpbHRlckFpcmNyYWZ0QnlSZWdpb24iLCJ0b1N0cmluZyIsImFpcmNyYWZ0V2l0aFZhbGlkQ29vcmRzIiwicGxhbmUiLCJpc05hTiIsImZpbHRlcmVkQnlPd25lciIsImFpcmNyYWZ0IiwiZ2V0QWlyY3JhZnRPd25lclR5cGUiLCJhcHBseUNvbWJpbmVkRmlsdGVycyIsIm93bmVyVHlwZSIsIlRZUEVfUkVHSVNUUkFOVCIsIm93bmVyVHlwZVRvU3RyaW5nIiwidHlwZSIsInR5cGVOdW0iLCJwYXJzZUludCIsIm93bmVyVHlwZU1hcCIsImFwcGx5T3duZXJUeXBlRmlsdGVyIiwiZmlsdGVycyIsImZpbHRlcmVkQWlyY3JhZnQiLCJoYW5kbGVPd25lckZpbHRlckNoYW5nZSIsInVwZGF0ZWRGaWx0ZXJzIiwicmVzZXRPd25lckZpbHRlcnMiLCJib3VuZHNFeHByZXNzaW9uIiwiQXJyYXkiLCJpc0FycmF5IiwibWluTGF0IiwibWluTG5nIiwibWF4TGF0IiwibWF4TG5nIiwiaGFuZGxlUmVnaW9uU2VsZWN0IiwiYm91bmRzIiwiem9vbUxldmVsIiwic2V0Wm9vbSIsIm9wdGlvbnMiLCJwYWRkaW5nIiwiUEFERElORyIsIkRFRkFVTFQiLCJmaXRCb3VuZHMiLCJkcmF3UmVnaW9uT3V0bGluZSIsImNvdW50UmVzcG9uc2UiLCJmZXRjaCIsIm9rIiwiY291bnREYXRhIiwianNvbiIsImNvdW50IiwiTCIsInJlcXVpcmUiLCJyZWN0YW5nbGUiLCJjb2xvciIsIndlaWdodCIsIm9wYWNpdHkiLCJmaWxsIiwiZmlsbENvbG9yIiwiZmlsbE9wYWNpdHkiLCJkYXNoQXJyYXkiLCJpbnRlcmFjdGl2ZSIsImFkZFRvIiwicHJvY2Vzc0dlb2ZlbmNlU2VhcmNoIiwibG9jYXRpb25zIiwic2VhcmNoTG9jYXRpb25XaXRoTWFwYm94IiwiY29vcmRpbmF0ZXMiLCJuYW1lIiwiRXJyb3IiLCJNQU5VRkFDVFVSRVIiLCJ1bmRlZmluZWQiLCJ0b2dnbGVHZW9mZW5jZVN0YXRlIiwiZW5hYmxlZCIsIndhcm4iLCJzZWxlY3RNYW51ZmFjdHVyZXJBbmRDbG9zZSIsInZhbHVlIiwiZmV0Y2hBaXJjcmFmdEJ5UmVnaW9uQW5kTWFudWZhY3R1cmVyIiwiZmV0Y2hNYW51ZmFjdHVyZXJEYXRhIiwiY2F0Y2giLCJwYWdlIiwibGltaXQiLCJyZXNwb25zZSIsImVuY29kZVVSSUNvbXBvbmVudCIsImRhdGEiLCJhaXJjcmFmdERhdGEiLCJzdGF0dXNUZXh0IiwiZXh0ZW5kZWRBaXJjcmFmdCIsIm1hcCIsIlRZUEVfQUlSQ1JBRlQiLCJpc0dvdmVybm1lbnQiLCJPUEVSQVRPUiIsInRvTG93ZXJDYXNlIiwiUkVHSU9OIiwiaGFuZGxlTW9kZWxTZWxlY3QiLCJNT0RFTCIsImNsZWFyQWxsRmlsdGVycyIsImxhYmVsIiwiQ0VOVEVSIiwiREVGQVVMVF9aT09NIiwiY2xlYXJFdmVudCIsIkN1c3RvbUV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsImNvbWJpbmVkTG9hZGluZyIsImlzR2VvZmVuY2VQbGFjZW1lbnRNb2RlIiwicmVmcmVzaFdpdGhGaWx0ZXJzIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/tracking/hooks/useFilterLogic.ts\n"));

/***/ })

});
"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "(pages-dir-browser)/./components/tracking/context/EnhancedMapContext.tsx":
/*!************************************************************!*\
  !*** ./components/tracking/context/EnhancedMapContext.tsx ***!
  \************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EnhancedMapProvider: () => (/* binding */ EnhancedMapProvider),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   useEnhancedMapContext: () => (/* binding */ useEnhancedMapContext)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _types_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/types/base */ \"(pages-dir-browser)/./types/base.ts\");\n/* harmony import */ var _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/services/openSkyTrackingService */ \"(pages-dir-browser)/./lib/services/openSkyTrackingService.ts\");\n/* harmony import */ var _persistence_AircraftDataPersistence__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../persistence/AircraftDataPersistence */ \"(pages-dir-browser)/./components/tracking/persistence/AircraftDataPersistence.ts\");\n/* harmony import */ var _config_map__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../config/map */ \"(pages-dir-browser)/./config/map.ts\");\n// components/tracking/context/EnhancedMapContext.tsx\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n\n\n// Create context with default values\nconst EnhancedMapContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({\n    mapInstance: null,\n    setMapInstance: ()=>{},\n    zoomLevel: 6,\n    setZoomLevel: ()=>{},\n    displayedAircraft: [],\n    selectedAircraft: null,\n    selectAircraft: ()=>{},\n    // Data persistence defaults\n    cachedAircraftData: {},\n    updateAircraftData: ()=>{},\n    lastPersistenceUpdate: null,\n    selectedManufacturer: null,\n    selectedModel: null,\n    activeModels: [],\n    totalActive: 0,\n    isLoading: false,\n    isRefreshing: false,\n    trackingStatus: '',\n    lastRefreshed: null,\n    selectManufacturer: async ()=>{},\n    selectModel: ()=>{},\n    reset: async ()=>{},\n    refreshPositions: async ()=>{},\n    fullRefresh: async ()=>{},\n    clearCache: ()=>{},\n    clearGeofenceData: ()=>{},\n    // Add default for new function\n    updateGeofenceAircraft: ()=>{},\n    filterMode: 'manufacturer',\n    setFilterMode: ()=>{},\n    blockManufacturerApiCalls: false,\n    setBlockManufacturerApiCalls: ()=>{},\n    isManufacturerApiBlocked: false,\n    setIsManufacturerApiBlocked: ()=>{},\n    // Geofencing properties\n    geofenceCenter: null,\n    geofenceRadius: 25,\n    isGeofenceActive: false,\n    setGeofenceCenter: ()=>{},\n    setGeofenceRadius: ()=>{},\n    geofenceCoordinates: null,\n    toggleGeofence: ()=>{},\n    clearGeofence: ()=>({}),\n    filteredAircraft: [],\n    selectedRegion: _types_base__WEBPACK_IMPORTED_MODULE_2__.RegionCode.GLOBAL,\n    setSelectedRegion: (region)=>{},\n    getBoundsByRegion: (region)=>(0,_config_map__WEBPACK_IMPORTED_MODULE_5__.getBoundsByRegion)('GLOBAL'),\n    isGeofencePlacementMode: false,\n    setIsGeofencePlacementMode: ()=>{}\n});\n// Enhanced Map Provider component\nconst EnhancedMapProvider = (param)=>{\n    let { children, manufacturers, onError } = param;\n    _s();\n    // Map state\n    const [mapInstance, setMapInstance] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [zoomLevel, setZoomLevel] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(6);\n    // Aircraft state\n    const [displayedAircraft, setDisplayedAircraft] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [selectedAircraft, setSelectedAircraft] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // Data persistence state\n    const [cachedAircraftData, setCachedAircraftData] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const [lastPersistenceUpdate, setLastPersistenceUpdate] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [geofenceCenter, setGeofenceCenter] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [selectedRegion, setSelectedRegion] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(_types_base__WEBPACK_IMPORTED_MODULE_2__.RegionCode.GLOBAL);\n    // Derived state for geofence coordinates\n    const geofenceCoordinates = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"EnhancedMapProvider.useMemo[geofenceCoordinates]\": ()=>geofenceCenter\n    }[\"EnhancedMapProvider.useMemo[geofenceCoordinates]\"], [\n        geofenceCenter\n    ]);\n    const [geofenceRadius, setGeofenceRadius] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(25); // Default 25km radius\n    const [isGeofenceActive, setIsGeofenceActive] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [isGeofencePlacementMode, setIsGeofencePlacementMode] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Add this to your state declarations\n    const [aircraftPositions, setAircraftPositions] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    // Toggle geofence activation\n    const toggleGeofence = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"EnhancedMapProvider.useCallback[toggleGeofence]\": ()=>{\n            setIsGeofenceActive({\n                \"EnhancedMapProvider.useCallback[toggleGeofence]\": (prev)=>!prev\n            }[\"EnhancedMapProvider.useCallback[toggleGeofence]\"]);\n        }\n    }[\"EnhancedMapProvider.useCallback[toggleGeofence]\"], []);\n    // Clear geofence\n    const clearGeofence = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"EnhancedMapProvider.useCallback[clearGeofence]\": ()=>{\n            setGeofenceCenter(null);\n            setIsGeofenceActive(false);\n            return {}; // Return an empty object to match the expected type\n        }\n    }[\"EnhancedMapProvider.useCallback[clearGeofence]\"], []);\n    // Selection state\n    const [selectedManufacturer, setSelectedManufacturer] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [selectedModel, setSelectedModel] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [activeModels, setActiveModels] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [totalActive, setTotalActive] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    // Loading state\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [isRefreshing, setIsRefreshing] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [trackingStatus, setTrackingStatus] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');\n    const [lastRefreshed, setLastRefreshed] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // Add this with your other state variables\n    const [lastFullRefreshTime, setLastFullRefreshTime] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [isManufacturerApiBlocked, setIsManufacturerApiBlocked] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [filterMode, setFilterMode] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('manufacturer');\n    const [blockManufacturerApiCalls, setBlockManufacturerApiCalls] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Flag to track if we're in geofence mode\n    const [isGeofenceMode, setIsGeofenceMode] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Define the filter function correctly\n    const filterAircraftByGeofence = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"EnhancedMapProvider.useCallback[filterAircraftByGeofence]\": ()=>{\n            if (!geofenceCenter || !isGeofenceActive) {\n                return displayedAircraft;\n            }\n            // Helper function to calculate distance between two points\n            const calculateDistance = {\n                \"EnhancedMapProvider.useCallback[filterAircraftByGeofence].calculateDistance\": (lat1, lon1, lat2, lon2)=>{\n                    const R = 6371; // Radius of the earth in km\n                    const dLat = deg2rad(lat2 - lat1);\n                    const dLon = deg2rad(lon2 - lon1);\n                    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * Math.sin(dLon / 2) * Math.sin(dLon / 2);\n                    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n                    const distance = R * c; // Distance in km\n                    return distance;\n                }\n            }[\"EnhancedMapProvider.useCallback[filterAircraftByGeofence].calculateDistance\"];\n            const deg2rad = {\n                \"EnhancedMapProvider.useCallback[filterAircraftByGeofence].deg2rad\": (deg)=>{\n                    return deg * (Math.PI / 180);\n                }\n            }[\"EnhancedMapProvider.useCallback[filterAircraftByGeofence].deg2rad\"];\n            // Filter aircraft within the radius\n            return displayedAircraft.filter({\n                \"EnhancedMapProvider.useCallback[filterAircraftByGeofence]\": (aircraft)=>{\n                    if (!aircraft.latitude || !aircraft.longitude) return false;\n                    // Calculate distance between aircraft and geofence center\n                    const distance = calculateDistance(geofenceCenter.lat, geofenceCenter.lng, aircraft.latitude, aircraft.longitude);\n                    // Return true if aircraft is within radius\n                    return geofenceRadius !== null && distance <= geofenceRadius;\n                }\n            }[\"EnhancedMapProvider.useCallback[filterAircraftByGeofence]\"]);\n        }\n    }[\"EnhancedMapProvider.useCallback[filterAircraftByGeofence]\"], [\n        displayedAircraft,\n        geofenceCenter,\n        geofenceRadius,\n        isGeofenceActive\n    ]);\n    // Then separately, define filteredAircraft - don't try to do both in the same function\n    const filteredAircraft = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"EnhancedMapProvider.useMemo[filteredAircraft]\": ()=>{\n            return isGeofenceActive && geofenceCenter ? filterAircraftByGeofence() : displayedAircraft;\n        }\n    }[\"EnhancedMapProvider.useMemo[filteredAircraft]\"], [\n        isGeofenceActive,\n        geofenceCenter,\n        filterAircraftByGeofence,\n        displayedAircraft\n    ]);\n    // Refs for tracking subscriptions\n    const unsubscribeAircraftRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const unsubscribeStatusRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Load persisted aircraft data on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"EnhancedMapProvider.useEffect\": ()=>{\n            const savedData = (0,_persistence_AircraftDataPersistence__WEBPACK_IMPORTED_MODULE_4__.loadAircraftData)();\n            if (savedData) {\n                console.log(\"[EnhancedMapContext] Loaded \".concat(Object.keys(savedData).length, \" aircraft from persistence\"));\n                setCachedAircraftData(savedData);\n                setLastPersistenceUpdate(Date.now());\n            }\n        }\n    }[\"EnhancedMapProvider.useEffect\"], []);\n    // Save aircraft data when cachedAircraftData changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"EnhancedMapProvider.useEffect\": ()=>{\n            if (Object.keys(cachedAircraftData).length > 0) {\n                console.log(\"[EnhancedMapContext] Saving \".concat(Object.keys(cachedAircraftData).length, \" aircraft to persistence\"));\n                (0,_persistence_AircraftDataPersistence__WEBPACK_IMPORTED_MODULE_4__.saveAircraftData)(cachedAircraftData);\n            }\n        }\n    }[\"EnhancedMapProvider.useEffect\"], [\n        cachedAircraftData\n    ]);\n    // Initialize tracking service and subscriptions\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"EnhancedMapProvider.useEffect\": ()=>{\n            // Subscribe to tracking updates that include trail data\n            const handleTrackingUpdate = {\n                \"EnhancedMapProvider.useEffect.handleTrackingUpdate\": (data)=>{\n                    // Only update displayed aircraft if we're not in geofence mode\n                    if (!isGeofenceMode) {\n                        updateAircraftDisplay();\n                    }\n                }\n            }[\"EnhancedMapProvider.useEffect.handleTrackingUpdate\"];\n            // Subscribe to aircraft updates\n            unsubscribeAircraftRef.current = _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].subscribe(handleTrackingUpdate);\n            // Subscribe to status updates\n            unsubscribeStatusRef.current = _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].subscribeToStatus({\n                \"EnhancedMapProvider.useEffect\": (status)=>{\n                    setTrackingStatus(status);\n                    setIsLoading(_lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].isLoading());\n                }\n            }[\"EnhancedMapProvider.useEffect\"]);\n            // IMPORTANT: Clear any existing tracking when component mounts\n            _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].stopTracking();\n            // Cleanup on unmount\n            return ({\n                \"EnhancedMapProvider.useEffect\": ()=>{\n                    if (unsubscribeAircraftRef.current) {\n                        unsubscribeAircraftRef.current();\n                    }\n                    if (unsubscribeStatusRef.current) {\n                        unsubscribeStatusRef.current();\n                    }\n                }\n            })[\"EnhancedMapProvider.useEffect\"];\n        }\n    }[\"EnhancedMapProvider.useEffect\"], [\n        isGeofenceMode\n    ]);\n    // Update aircraft data with persistence\n    const updateAircraftData = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"EnhancedMapProvider.useCallback[updateAircraftData]\": (newAircraftArray)=>{\n            // Convert to a map for easier processing\n            const newAircraftMap = {};\n            newAircraftArray.forEach({\n                \"EnhancedMapProvider.useCallback[updateAircraftData]\": (aircraft)=>{\n                    if (aircraft.ICAO24) {\n                        newAircraftMap[aircraft.ICAO24] = {\n                            ...aircraft,\n                            // Ensure required fields for CachedAircraftData are present\n                            ICAO24: aircraft.ICAO24,\n                            latitude: aircraft.latitude || 0,\n                            longitude: aircraft.longitude || 0,\n                            altitude: aircraft.altitude || 0,\n                            velocity: aircraft.velocity || 0,\n                            heading: aircraft.heading || 0,\n                            on_ground: aircraft.on_ground || false,\n                            last_contact: aircraft.last_contact || Date.now(),\n                            lastSeen: Date.now(),\n                            lastUpdated: Date.now()\n                        };\n                    }\n                }\n            }[\"EnhancedMapProvider.useCallback[updateAircraftData]\"]);\n            // Merge with existing cached data to preserve fields\n            setCachedAircraftData({\n                \"EnhancedMapProvider.useCallback[updateAircraftData]\": (currentCache)=>(0,_persistence_AircraftDataPersistence__WEBPACK_IMPORTED_MODULE_4__.mergeAircraftData)(currentCache, newAircraftMap)\n            }[\"EnhancedMapProvider.useCallback[updateAircraftData]\"]);\n            setLastPersistenceUpdate(Date.now());\n            // If the selected aircraft is updated, update the selection\n            if (selectedAircraft && newAircraftMap[selectedAircraft.ICAO24]) {\n                const updatedAircraft = {\n                    ...selectedAircraft,\n                    ...newAircraftMap[selectedAircraft.ICAO24]\n                };\n                setSelectedAircraft(updatedAircraft);\n            }\n        }\n    }[\"EnhancedMapProvider.useCallback[updateAircraftData]\"], [\n        selectedAircraft\n    ]);\n    // Clear persistence cache\n    const clearCache = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"EnhancedMapProvider.useCallback[clearCache]\": ()=>{\n            (0,_persistence_AircraftDataPersistence__WEBPACK_IMPORTED_MODULE_4__.clearAircraftData)();\n            setCachedAircraftData({});\n            setLastPersistenceUpdate(null);\n            setTrackingStatus('Cache cleared');\n        }\n    }[\"EnhancedMapProvider.useCallback[clearCache]\"], []);\n    // Update aircraft display based on selected MODEL\n    const updateAircraftDisplay = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"EnhancedMapProvider.useCallback[updateAircraftDisplay]\": ()=>{\n            // Get extended aircraft based on selected MODEL\n            const extendedAircraft = _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].getExtendedAircraft(selectedModel || undefined);\n            // Get MODEL stats from the service\n            const { models, totalActive: total } = _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].getModelStats();\n            // Enhance aircraft data with persistence\n            updateAircraftData(extendedAircraft);\n            // Only update displayed aircraft if we're not in geofence mode\n            if (!isGeofenceMode) {\n                setDisplayedAircraft(extendedAircraft);\n                setActiveModels(models);\n                setTotalActive(total);\n            }\n            setIsLoading(_lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].isLoading());\n        }\n    }[\"EnhancedMapProvider.useCallback[updateAircraftDisplay]\"], [\n        selectedModel,\n        updateAircraftData,\n        isGeofenceMode\n    ]);\n    // Update display when MODEL selection changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"EnhancedMapProvider.useEffect\": ()=>{\n            updateAircraftDisplay();\n        }\n    }[\"EnhancedMapProvider.useEffect\"], [\n        selectedModel,\n        updateAircraftDisplay\n    ]);\n    // New function to handle geofence aircraft updates\n    const updateGeofenceAircraft = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"EnhancedMapProvider.useCallback[updateGeofenceAircraft]\": (geofenceAircraft)=>{\n            // Mark that we're in geofence mode\n            setIsGeofenceMode(true);\n            console.log(\"[EnhancedMapContext] Updating \".concat(geofenceAircraft.length, \" aircraft from geofence\"));\n            // Update the cached data (same as regular updates)\n            updateAircraftData(geofenceAircraft);\n            // Also directly update the displayed aircraft\n            setDisplayedAircraft(geofenceAircraft);\n            // Update stats\n            setTotalActive(geofenceAircraft.length);\n            // Extract MODEL stats for the sidebar\n            const modelCounts = geofenceAircraft.reduce({\n                \"EnhancedMapProvider.useCallback[updateGeofenceAircraft].modelCounts\": (acc, aircraft)=>{\n                    const MODEL = aircraft.MODEL || aircraft.TYPE_AIRCRAFT || 'Unknown';\n                    if (!acc[MODEL]) {\n                        acc[MODEL] = {\n                            MODEL,\n                            count: 0,\n                            MANUFACTURER: aircraft.MANUFACTURER || 'Unknown',\n                            // Add required properties for AircraftModel\n                            label: MODEL,\n                            activeCount: 0,\n                            totalCount: 0\n                        };\n                    }\n                    acc[MODEL].count++;\n                    acc[MODEL].activeCount++;\n                    acc[MODEL].totalCount++;\n                    return acc;\n                }\n            }[\"EnhancedMapProvider.useCallback[updateGeofenceAircraft].modelCounts\"], {});\n            // Convert to array for the activeModels state\n            const modelArray = Object.values(modelCounts).map({\n                \"EnhancedMapProvider.useCallback[updateGeofenceAircraft].modelArray\": (MODEL)=>({\n                        MODEL: MODEL.MODEL,\n                        count: MODEL.count,\n                        MANUFACTURER: MODEL.MANUFACTURER,\n                        // Add required properties for AircraftModel type\n                        label: MODEL.MODEL,\n                        activeCount: MODEL.count,\n                        totalCount: MODEL.count\n                    })\n            }[\"EnhancedMapProvider.useCallback[updateGeofenceAircraft].modelArray\"]);\n            setActiveModels(modelArray);\n            // Update the last refreshed timestamp\n            setLastRefreshed(new Date().toLocaleTimeString());\n        }\n    }[\"EnhancedMapProvider.useCallback[updateGeofenceAircraft]\"], [\n        updateAircraftData\n    ]);\n    // Handle MANUFACTURER selection\n    // In your EnhancedMapContext.tsx - modify the selectManufacturer function\n    const selectManufacturer = async (MANUFACTURER)=>{\n        // Exit geofence mode when selecting a MANUFACTURER\n        setIsGeofenceMode(false);\n        setSelectedManufacturer(MANUFACTURER);\n        setSelectedModel(null);\n        setIsLoading(true);\n        setLastRefreshed(null);\n        // Clear previous data\n        setDisplayedAircraft([]);\n        setActiveModels([]);\n        setTotalActive(0);\n        // If null, just exit\n        if (MANUFACTURER === null) {\n            setIsLoading(false);\n            return;\n        }\n        // If we're blocking API calls, exit early\n        if (isManufacturerApiBlocked) {\n            console.log(\"[EnhancedMapContext] API calls blocked for manufacturer: \".concat(MANUFACTURER));\n            setIsLoading(false);\n            return;\n        }\n        try {\n            // Start tracking with a progress handler\n            setTrackingStatus(\"Loading aircraft for \".concat(MANUFACTURER, \"...\"));\n            // Use the existing service but with a progress callback\n            // In EnhancedMapContext.tsx, modify your callback to handle both types:\n            await _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].trackManufacturerWithProgress(MANUFACTURER, (progress)=>{\n                // Update the tracking status message\n                if (progress.message) {\n                    setTrackingStatus(progress.message);\n                }\n                // Update displayed aircraft as they're loaded\n                if (progress.aircraft) {\n                    // Cast the aircraft array to ExtendedAircraft[] since our context uses that type\n                    setDisplayedAircraft(progress.aircraft);\n                }\n                // Update model stats\n                if (progress.models) {\n                    setActiveModels(progress.models);\n                }\n                // Update total count\n                if (progress.total !== undefined) {\n                    setTotalActive(progress.total);\n                }\n            });\n            setLastRefreshed(new Date().toLocaleTimeString());\n        } catch (error) {\n            onError(\"Error tracking manufacturer: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n            setTrackingStatus('Error loading aircraft data');\n        } finally{\n            setIsLoading(false);\n        }\n    };\n    // Handle MODEL selection\n    const selectModel = (MODEL)=>{\n        setSelectedModel(MODEL);\n    };\n    // Handle aircraft selection\n    const selectAircraft = (aircraft)=>{\n        setSelectedAircraft(aircraft);\n        // If selecting an aircraft, check if we have cached data to enhance it\n        if (aircraft && aircraft.ICAO24 && cachedAircraftData[aircraft.ICAO24]) {\n            const enhancedAircraft = {\n                ...aircraft,\n                ...cachedAircraftData[aircraft.ICAO24]\n            };\n            setSelectedAircraft(enhancedAircraft);\n        }\n    };\n    // If you don't already have it, add this function to expose the map's getBoundsByRegion function\n    // Create a wrapped function that calls your map config function\n    const handleGetBoundsByRegion = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"EnhancedMapProvider.useCallback[handleGetBoundsByRegion]\": (region)=>{\n            return (0,_config_map__WEBPACK_IMPORTED_MODULE_5__.getBoundsByRegion)(region);\n        }\n    }[\"EnhancedMapProvider.useCallback[handleGetBoundsByRegion]\"], []);\n    // Reset all selections\n    const reset = async ()=>{\n        await selectManufacturer(null);\n    };\n    // Method to refresh only the positions of active aircraft\n    const refreshPositions = async ()=>{\n        if (isRefreshing || !selectedManufacturer && !isGeofenceMode) return;\n        setIsRefreshing(true);\n        setTrackingStatus('Updating aircraft positions...');\n        try {\n            // Call the service\n            await _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].refreshPositionsOnly();\n            setLastRefreshed(new Date().toLocaleTimeString());\n            setTrackingStatus(\"Positions updated for \".concat(displayedAircraft.length, \" aircraft\"));\n        } catch (error) {\n            onError(\"Error refreshing positions: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        } finally{\n            setTimeout(()=>{\n                setIsRefreshing(false);\n            }, 500);\n        }\n    };\n    // Method for full tracking refresh\n    const fullRefresh = async ()=>{\n        if (!selectedManufacturer && !isGeofenceMode || isRefreshing) return;\n        // Set a timeout to force exit from loading state after 10 seconds\n        // This is a safety mechanism\n        const safetyTimeout = setTimeout(()=>{\n            setIsRefreshing(false);\n            setTrackingStatus('Refresh timed out');\n        }, 10000);\n        setIsRefreshing(true);\n        try {\n            // Get currently tracked aircraft\n            const allTrackedAircraft = _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].getTrackedAircraft();\n            // Get active aircraft (those with position data)\n            const activeAircraft = allTrackedAircraft.filter((aircraft)=>aircraft.ICAO24 && aircraft.latitude && aircraft.longitude);\n            const needsFullRefresh = !lastFullRefreshTime || Date.now() - lastFullRefreshTime > 3600000;\n            let success = false;\n            if (activeAircraft.length === 0 || needsFullRefresh) {\n                // Do a full refresh\n                setTrackingStatus('Performing full refresh...');\n                try {\n                    await _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].refreshNow();\n                    setLastFullRefreshTime(Date.now());\n                    success = true;\n                } catch (error) {\n                    // Silently handle this error\n                    console.warn('Full refresh failed');\n                }\n            } else {\n                // Do an optimized refresh\n                const activeIcaos = activeAircraft.map((aircraft)=>aircraft.ICAO24).filter(Boolean);\n                if (activeIcaos.length > 0) {\n                    setTrackingStatus(\"Refreshing \".concat(activeIcaos.length, \" active aircraft...\"));\n                    try {\n                        await _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].refreshSpecificAircraft(activeIcaos);\n                        success = true;\n                    } catch (error) {\n                        // Try falling back to a full refresh\n                        console.warn('Optimized refresh failed, trying full refresh');\n                        try {\n                            await _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].refreshNow();\n                            setLastFullRefreshTime(Date.now());\n                            success = true;\n                        } catch (fallbackError) {\n                            // Silently handle this error\n                            console.warn('Fallback refresh failed');\n                        }\n                    }\n                }\n            }\n            clearTimeout(safetyTimeout);\n            // Only update if the refresh was successful\n            if (success) {\n                const currentCount = _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].getTrackedAircraft().length;\n                setTrackingStatus(\"Refresh completed with \".concat(currentCount, \" aircraft\"));\n                setLastRefreshed(new Date().toLocaleTimeString());\n            } else {\n                setTrackingStatus('Refresh failed');\n            }\n        } catch (error) {\n            clearTimeout(safetyTimeout);\n            // Only show errors to the user if they appear to be significant\n            if (error instanceof Error && error.message !== 'aborted') {\n                onError(\"Error during refresh: \".concat(error.message || 'Unknown error'));\n            }\n            setTrackingStatus('Error during refresh');\n        } finally{\n            clearTimeout(safetyTimeout);\n            setIsRefreshing(false);\n        }\n    };\n    const clearGeofenceData = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"EnhancedMapProvider.useCallback[clearGeofenceData]\": ()=>{\n            // Reset geofence mode flag\n            setIsGeofenceMode(false);\n            // Clear displayed aircraft\n            setDisplayedAircraft([]);\n            setActiveModels([]);\n            setTotalActive(0);\n            // If there was a previously selected MANUFACTURER, we can restore it\n            if (selectedManufacturer) {\n                // Small delay to ensure state updates properly\n                setTimeout({\n                    \"EnhancedMapProvider.useCallback[clearGeofenceData]\": ()=>{\n                        _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].trackManufacturer(selectedManufacturer);\n                    }\n                }[\"EnhancedMapProvider.useCallback[clearGeofenceData]\"], 100);\n            }\n        }\n    }[\"EnhancedMapProvider.useCallback[clearGeofenceData]\"], [\n        selectedManufacturer\n    ]);\n    // Create context value\n    const contextValue = {\n        mapInstance,\n        setMapInstance,\n        zoomLevel,\n        setZoomLevel,\n        displayedAircraft,\n        selectedAircraft,\n        selectAircraft,\n        // Data persistence\n        cachedAircraftData,\n        updateAircraftData,\n        lastPersistenceUpdate,\n        selectedManufacturer,\n        selectedModel,\n        activeModels,\n        totalActive,\n        isLoading,\n        isRefreshing,\n        trackingStatus,\n        lastRefreshed,\n        selectManufacturer,\n        selectModel,\n        reset,\n        refreshPositions,\n        fullRefresh,\n        clearCache,\n        clearGeofenceData,\n        updateGeofenceAircraft,\n        filteredAircraft,\n        filterMode,\n        setFilterMode,\n        blockManufacturerApiCalls,\n        setBlockManufacturerApiCalls,\n        isManufacturerApiBlocked,\n        setIsManufacturerApiBlocked,\n        // Geofencing properties\n        geofenceCenter,\n        geofenceRadius,\n        isGeofenceActive,\n        geofenceCoordinates,\n        setGeofenceCenter,\n        setGeofenceRadius,\n        toggleGeofence,\n        clearGeofence,\n        isGeofencePlacementMode,\n        setIsGeofencePlacementMode,\n        // Region selection\n        selectedRegion,\n        setSelectedRegion,\n        getBoundsByRegion: handleGetBoundsByRegion\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(EnhancedMapContext.Provider, {\n        value: contextValue,\n        children: children\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\satho\\\\Documents\\\\Projects\\\\aircraft-tracking\\\\components\\\\tracking\\\\context\\\\EnhancedMapContext.tsx\",\n        lineNumber: 824,\n        columnNumber: 5\n    }, undefined);\n};\n_s(EnhancedMapProvider, \"ft4R0gMInmgVu/GQ1zBkgSrD/lQ=\");\n_c = EnhancedMapProvider;\n// Custom hook to use the context\nconst useEnhancedMapContext = ()=>{\n    _s1();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(EnhancedMapContext);\n};\n_s1(useEnhancedMapContext, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EnhancedMapContext);\nvar _c;\n$RefreshReg$(_c, \"EnhancedMapProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvdHJhY2tpbmcvY29udGV4dC9FbmhhbmNlZE1hcENvbnRleHQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUEscURBQXFEOzs7QUFTdEM7QUFPTztBQUdxRDtBQU0zQjtBQUtuQjtBQXVFN0IscUNBQXFDO0FBQ3JDLE1BQU1nQixtQ0FBcUJmLG9EQUFhQSxDQUF5QjtJQUMvRGdCLGFBQWE7SUFDYkMsZ0JBQWdCLEtBQU87SUFDdkJDLFdBQVc7SUFDWEMsY0FBYyxLQUFPO0lBQ3JCQyxtQkFBbUIsRUFBRTtJQUNyQkMsa0JBQWtCO0lBQ2xCQyxnQkFBZ0IsS0FBTztJQUV2Qiw0QkFBNEI7SUFDNUJDLG9CQUFvQixDQUFDO0lBQ3JCQyxvQkFBb0IsS0FBTztJQUMzQkMsdUJBQXVCO0lBRXZCQyxzQkFBc0I7SUFDdEJDLGVBQWU7SUFDZkMsY0FBYyxFQUFFO0lBQ2hCQyxhQUFhO0lBRWJDLFdBQVc7SUFDWEMsY0FBYztJQUNkQyxnQkFBZ0I7SUFDaEJDLGVBQWU7SUFFZkMsb0JBQW9CLFdBQWE7SUFDakNDLGFBQWEsS0FBTztJQUNwQkMsT0FBTyxXQUFhO0lBQ3BCQyxrQkFBa0IsV0FBYTtJQUMvQkMsYUFBYSxXQUFhO0lBQzFCQyxZQUFZLEtBQU87SUFDbkJDLG1CQUFtQixLQUFPO0lBQzFCLCtCQUErQjtJQUMvQkMsd0JBQXdCLEtBQU87SUFFL0JDLFlBQVk7SUFDWkMsZUFBZSxLQUFPO0lBQ3RCQywyQkFBMkI7SUFDM0JDLDhCQUE4QixLQUFPO0lBQ3JDQywwQkFBMEI7SUFDMUJDLDZCQUE2QixLQUFPO0lBRXBDLHdCQUF3QjtJQUN4QkMsZ0JBQWdCO0lBQ2hCQyxnQkFBZ0I7SUFDaEJDLGtCQUFrQjtJQUNsQkMsbUJBQW1CLEtBQU87SUFDMUJDLG1CQUFtQixLQUFPO0lBQzFCQyxxQkFBcUI7SUFDckJDLGdCQUFnQixLQUFPO0lBQ3ZCQyxlQUFlLElBQU8sRUFBQztJQUN2QkMsa0JBQWtCLEVBQUU7SUFDcEJDLGdCQUFnQmxELG1EQUFVQSxDQUFDbUQsTUFBTTtJQUNqQ0MsbUJBQW1CLENBQUNDLFVBQWlDO0lBQ3JEL0MsbUJBQW1CLENBQUMrQyxTQUNsQjlDLDhEQUF1QkEsQ0FBQztJQUMxQitDLHlCQUF5QjtJQUN6QkMsNEJBQTRCLEtBQU87QUFDckM7QUFTQSxrQ0FBa0M7QUFDM0IsTUFBTUMsc0JBQTBEO1FBQUMsRUFDdEVDLFFBQVEsRUFDUkMsYUFBYSxFQUNiQyxPQUFPLEVBQ1I7O0lBQ0MsWUFBWTtJQUNaLE1BQU0sQ0FBQ2xELGFBQWFDLGVBQWUsR0FBR2YsK0NBQVFBLENBQWU7SUFDN0QsTUFBTSxDQUFDZ0IsV0FBV0MsYUFBYSxHQUFHakIsK0NBQVFBLENBQVM7SUFFbkQsaUJBQWlCO0lBQ2pCLE1BQU0sQ0FBQ2tCLG1CQUFtQitDLHFCQUFxQixHQUFHakUsK0NBQVFBLENBRXhELEVBQUU7SUFDSixNQUFNLENBQUNtQixrQkFBa0IrQyxvQkFBb0IsR0FDM0NsRSwrQ0FBUUEsQ0FBMEI7SUFFcEMseUJBQXlCO0lBQ3pCLE1BQU0sQ0FBQ3FCLG9CQUFvQjhDLHNCQUFzQixHQUFHbkUsK0NBQVFBLENBRTFELENBQUM7SUFDSCxNQUFNLENBQUN1Qix1QkFBdUI2Qyx5QkFBeUIsR0FBR3BFLCtDQUFRQSxDQUVoRTtJQUVGLE1BQU0sQ0FBQzhDLGdCQUFnQkcsa0JBQWtCLEdBQUdqRCwrQ0FBUUEsQ0FHMUM7SUFFVixNQUFNLENBQUN1RCxnQkFBZ0JFLGtCQUFrQixHQUFHekQsK0NBQVFBLENBQ2xESyxtREFBVUEsQ0FBQ21ELE1BQU07SUFHbkIseUNBQXlDO0lBQ3pDLE1BQU1MLHNCQUFzQi9DLDhDQUFPQTs0REFBQyxJQUFNMEM7MkRBQWdCO1FBQUNBO0tBQWU7SUFDMUUsTUFBTSxDQUFDQyxnQkFBZ0JHLGtCQUFrQixHQUFHbEQsK0NBQVFBLENBQWdCLEtBQUssc0JBQXNCO0lBQy9GLE1BQU0sQ0FBQ2dELGtCQUFrQnFCLG9CQUFvQixHQUFHckUsK0NBQVFBLENBQVU7SUFDbEUsTUFBTSxDQUFDMkQseUJBQXlCQywyQkFBMkIsR0FDekQ1RCwrQ0FBUUEsQ0FBVTtJQUVwQixzQ0FBc0M7SUFDdEMsTUFBTSxDQUFDc0UsbUJBQW1CQyxxQkFBcUIsR0FBR3ZFLCtDQUFRQSxDQUV4RCxFQUFFO0lBQ0osNkJBQTZCO0lBQzdCLE1BQU1vRCxpQkFBaUJsRCxrREFBV0E7MkRBQUM7WUFDakNtRTttRUFBb0IsQ0FBQ0csT0FBUyxDQUFDQTs7UUFDakM7MERBQUcsRUFBRTtJQUVMLGlCQUFpQjtJQUNqQixNQUFNbkIsZ0JBQWdCbkQsa0RBQVdBOzBEQUFDO1lBQ2hDK0Msa0JBQWtCO1lBQ2xCb0Isb0JBQW9CO1lBQ3BCLE9BQU8sQ0FBQyxHQUFHLG9EQUFvRDtRQUNqRTt5REFBRyxFQUFFO0lBRUwsa0JBQWtCO0lBQ2xCLE1BQU0sQ0FBQzdDLHNCQUFzQmlELHdCQUF3QixHQUFHekUsK0NBQVFBLENBRTlEO0lBQ0YsTUFBTSxDQUFDeUIsZUFBZWlELGlCQUFpQixHQUFHMUUsK0NBQVFBLENBQWdCO0lBQ2xFLE1BQU0sQ0FBQzBCLGNBQWNpRCxnQkFBZ0IsR0FBRzNFLCtDQUFRQSxDQUFrQixFQUFFO0lBQ3BFLE1BQU0sQ0FBQzJCLGFBQWFpRCxlQUFlLEdBQUc1RSwrQ0FBUUEsQ0FBUztJQUV2RCxnQkFBZ0I7SUFDaEIsTUFBTSxDQUFDNEIsV0FBV2lELGFBQWEsR0FBRzdFLCtDQUFRQSxDQUFVO0lBQ3BELE1BQU0sQ0FBQzZCLGNBQWNpRCxnQkFBZ0IsR0FBRzlFLCtDQUFRQSxDQUFVO0lBQzFELE1BQU0sQ0FBQzhCLGdCQUFnQmlELGtCQUFrQixHQUFHL0UsK0NBQVFBLENBQVM7SUFDN0QsTUFBTSxDQUFDK0IsZUFBZWlELGlCQUFpQixHQUFHaEYsK0NBQVFBLENBQWdCO0lBQ2xFLDJDQUEyQztJQUMzQyxNQUFNLENBQUNpRixxQkFBcUJDLHVCQUF1QixHQUFHbEYsK0NBQVFBLENBQzVEO0lBRUYsTUFBTSxDQUFDNEMsMEJBQTBCQyw0QkFBNEIsR0FDM0Q3QywrQ0FBUUEsQ0FBVTtJQUVwQixNQUFNLENBQUN3QyxZQUFZQyxjQUFjLEdBQUd6QywrQ0FBUUEsQ0FFMUM7SUFDRixNQUFNLENBQUMwQywyQkFBMkJDLDZCQUE2QixHQUM3RDNDLCtDQUFRQSxDQUFVO0lBRXBCLDBDQUEwQztJQUMxQyxNQUFNLENBQUNtRixnQkFBZ0JDLGtCQUFrQixHQUFHcEYsK0NBQVFBLENBQVU7SUFFOUQsdUNBQXVDO0lBQ3ZDLE1BQU1xRiwyQkFBMkJuRixrREFBV0E7cUVBQUM7WUFDM0MsSUFBSSxDQUFDNEMsa0JBQWtCLENBQUNFLGtCQUFrQjtnQkFDeEMsT0FBTzlCO1lBQ1Q7WUFFQSwyREFBMkQ7WUFDM0QsTUFBTW9FOytGQUFvQixDQUN4QkMsTUFDQUMsTUFDQUMsTUFDQUM7b0JBRUEsTUFBTUMsSUFBSSxNQUFNLDRCQUE0QjtvQkFDNUMsTUFBTUMsT0FBT0MsUUFBUUosT0FBT0Y7b0JBQzVCLE1BQU1PLE9BQU9ELFFBQVFILE9BQU9GO29CQUM1QixNQUFNTyxJQUNKQyxLQUFLQyxHQUFHLENBQUNMLE9BQU8sS0FBS0ksS0FBS0MsR0FBRyxDQUFDTCxPQUFPLEtBQ3JDSSxLQUFLRSxHQUFHLENBQUNMLFFBQVFOLFNBQ2ZTLEtBQUtFLEdBQUcsQ0FBQ0wsUUFBUUosU0FDakJPLEtBQUtDLEdBQUcsQ0FBQ0gsT0FBTyxLQUNoQkUsS0FBS0MsR0FBRyxDQUFDSCxPQUFPO29CQUNwQixNQUFNSyxJQUFJLElBQUlILEtBQUtJLEtBQUssQ0FBQ0osS0FBS0ssSUFBSSxDQUFDTixJQUFJQyxLQUFLSyxJQUFJLENBQUMsSUFBSU47b0JBQ3JELE1BQU1PLFdBQVdYLElBQUlRLEdBQUcsaUJBQWlCO29CQUN6QyxPQUFPRztnQkFDVDs7WUFFQSxNQUFNVDtxRkFBVSxDQUFDVTtvQkFDZixPQUFPQSxNQUFPUCxDQUFBQSxLQUFLUSxFQUFFLEdBQUcsR0FBRTtnQkFDNUI7O1lBRUEsb0NBQW9DO1lBQ3BDLE9BQU90RixrQkFBa0J1RixNQUFNOzZFQUFDLENBQUNDO29CQUMvQixJQUFJLENBQUNBLFNBQVNDLFFBQVEsSUFBSSxDQUFDRCxTQUFTRSxTQUFTLEVBQUUsT0FBTztvQkFFdEQsMERBQTBEO29CQUMxRCxNQUFNTixXQUFXaEIsa0JBQ2Z4QyxlQUFlK0QsR0FBRyxFQUNsQi9ELGVBQWVnRSxHQUFHLEVBQ2xCSixTQUFTQyxRQUFRLEVBQ2pCRCxTQUFTRSxTQUFTO29CQUdwQiwyQ0FBMkM7b0JBQzNDLE9BQU83RCxtQkFBbUIsUUFBUXVELFlBQVl2RDtnQkFDaEQ7O1FBQ0Y7b0VBQUc7UUFBQzdCO1FBQW1CNEI7UUFBZ0JDO1FBQWdCQztLQUFpQjtJQUV4RSx1RkFBdUY7SUFDdkYsTUFBTU0sbUJBQW1CbEQsOENBQU9BO3lEQUFDO1lBQy9CLE9BQU80QyxvQkFBb0JGLGlCQUN2QnVDLDZCQUNBbkU7UUFDTjt3REFBRztRQUNEOEI7UUFDQUY7UUFDQXVDO1FBQ0FuRTtLQUNEO0lBRUQsa0NBQWtDO0lBQ2xDLE1BQU02Rix5QkFBeUI1Ryw2Q0FBTUEsQ0FBc0I7SUFDM0QsTUFBTTZHLHVCQUF1QjdHLDZDQUFNQSxDQUFzQjtJQUN6RCx3Q0FBd0M7SUFDeENGLGdEQUFTQTt5Q0FBQztZQUNSLE1BQU1nSCxZQUFZekcsc0ZBQWdCQTtZQUNsQyxJQUFJeUcsV0FBVztnQkFDYkMsUUFBUUMsR0FBRyxDQUNULCtCQUE2RCxPQUE5QkMsT0FBT0MsSUFBSSxDQUFDSixXQUFXSyxNQUFNLEVBQUM7Z0JBRS9EbkQsc0JBQXNCOEM7Z0JBQ3RCN0MseUJBQXlCbUQsS0FBS0MsR0FBRztZQUNuQztRQUNGO3dDQUFHLEVBQUU7SUFFTCxxREFBcUQ7SUFDckR2SCxnREFBU0E7eUNBQUM7WUFDUixJQUFJbUgsT0FBT0MsSUFBSSxDQUFDaEcsb0JBQW9CaUcsTUFBTSxHQUFHLEdBQUc7Z0JBQzlDSixRQUFRQyxHQUFHLENBQ1QsK0JBQXNFLE9BQXZDQyxPQUFPQyxJQUFJLENBQUNoRyxvQkFBb0JpRyxNQUFNLEVBQUM7Z0JBRXhFL0csc0ZBQWdCQSxDQUFDYztZQUNuQjtRQUNGO3dDQUFHO1FBQUNBO0tBQW1CO0lBRXZCLGdEQUFnRDtJQUNoRHBCLGdEQUFTQTt5Q0FBQztZQUNSLHdEQUF3RDtZQUN4RCxNQUFNd0g7c0VBQXVCLENBQUNDO29CQUM1QiwrREFBK0Q7b0JBQy9ELElBQUksQ0FBQ3ZDLGdCQUFnQjt3QkFDbkJ3QztvQkFDRjtnQkFDRjs7WUFFQSxnQ0FBZ0M7WUFDaENaLHVCQUF1QmEsT0FBTyxHQUM1QnRILHNGQUFnQyxDQUFDbUg7WUFFbkMsOEJBQThCO1lBQzlCVCxxQkFBcUJZLE9BQU8sR0FBR3RILDhGQUF3QztpREFDckUsQ0FBQ3lIO29CQUNDaEQsa0JBQWtCZ0Q7b0JBQ2xCbEQsYUFBYXZFLHNGQUFnQztnQkFDL0M7O1lBR0YsK0RBQStEO1lBQy9EQSx5RkFBbUM7WUFFbkMscUJBQXFCO1lBQ3JCO2lEQUFPO29CQUNMLElBQUl5Ryx1QkFBdUJhLE9BQU8sRUFBRTt3QkFDbENiLHVCQUF1QmEsT0FBTztvQkFDaEM7b0JBQ0EsSUFBSVoscUJBQXFCWSxPQUFPLEVBQUU7d0JBQ2hDWixxQkFBcUJZLE9BQU87b0JBQzlCO2dCQUNGOztRQUNGO3dDQUFHO1FBQUN6QztLQUFlO0lBRW5CLHdDQUF3QztJQUN4QyxNQUFNN0QscUJBQXFCcEIsa0RBQVdBOytEQUNwQyxDQUFDK0g7WUFDQyx5Q0FBeUM7WUFDekMsTUFBTUMsaUJBQXFELENBQUM7WUFFNURELGlCQUFpQkUsT0FBTzt1RUFBQyxDQUFDekI7b0JBQ3hCLElBQUlBLFNBQVMwQixNQUFNLEVBQUU7d0JBQ25CRixjQUFjLENBQUN4QixTQUFTMEIsTUFBTSxDQUFDLEdBQUc7NEJBQ2hDLEdBQUcxQixRQUFROzRCQUNYLDREQUE0RDs0QkFDNUQwQixRQUFRMUIsU0FBUzBCLE1BQU07NEJBQ3ZCekIsVUFBVUQsU0FBU0MsUUFBUSxJQUFJOzRCQUMvQkMsV0FBV0YsU0FBU0UsU0FBUyxJQUFJOzRCQUNqQ3lCLFVBQVUzQixTQUFTMkIsUUFBUSxJQUFJOzRCQUMvQkMsVUFBVTVCLFNBQVM0QixRQUFRLElBQUk7NEJBQy9CQyxTQUFTN0IsU0FBUzZCLE9BQU8sSUFBSTs0QkFDN0JDLFdBQVc5QixTQUFTOEIsU0FBUyxJQUFJOzRCQUNqQ0MsY0FBYy9CLFNBQVMrQixZQUFZLElBQUlsQixLQUFLQyxHQUFHOzRCQUMvQ2tCLFVBQVVuQixLQUFLQyxHQUFHOzRCQUNsQm1CLGFBQWFwQixLQUFLQyxHQUFHO3dCQUN2QjtvQkFDRjtnQkFDRjs7WUFFQSxxREFBcUQ7WUFDckRyRDt1RUFBc0IsQ0FBQ3lFLGVBQ3JCbkksdUZBQWlCQSxDQUFDbUksY0FBY1Y7O1lBRWxDOUQseUJBQXlCbUQsS0FBS0MsR0FBRztZQUVqQyw0REFBNEQ7WUFDNUQsSUFBSXJHLG9CQUFvQitHLGNBQWMsQ0FBQy9HLGlCQUFpQmlILE1BQU0sQ0FBQyxFQUFFO2dCQUMvRCxNQUFNUyxrQkFBa0I7b0JBQ3RCLEdBQUcxSCxnQkFBZ0I7b0JBQ25CLEdBQUcrRyxjQUFjLENBQUMvRyxpQkFBaUJpSCxNQUFNLENBQUM7Z0JBQzVDO2dCQUNBbEUsb0JBQW9CMkU7WUFDdEI7UUFDRjs4REFDQTtRQUFDMUg7S0FBaUI7SUFHcEIsMEJBQTBCO0lBQzFCLE1BQU1rQixhQUFhbkMsa0RBQVdBO3VEQUFDO1lBQzdCUSx1RkFBaUJBO1lBQ2pCeUQsc0JBQXNCLENBQUM7WUFDdkJDLHlCQUF5QjtZQUN6Qlcsa0JBQWtCO1FBQ3BCO3NEQUFHLEVBQUU7SUFFTCxrREFBa0Q7SUFDbEQsTUFBTTRDLHdCQUF3QnpILGtEQUFXQTtrRUFBQztZQUN4QyxnREFBZ0Q7WUFDaEQsTUFBTTRJLG1CQUFtQnhJLGdHQUEwQyxDQUNqRW1CLGlCQUFpQnVIO1lBR25CLG1DQUFtQztZQUNuQyxNQUFNLEVBQUVDLE1BQU0sRUFBRXRILGFBQWF1SCxLQUFLLEVBQUUsR0FDbEM1SSwwRkFBb0M7WUFFdEMseUNBQXlDO1lBQ3pDZ0IsbUJBQW1Cd0g7WUFFbkIsK0RBQStEO1lBQy9ELElBQUksQ0FBQzNELGdCQUFnQjtnQkFDbkJsQixxQkFBcUI2RTtnQkFDckJuRSxnQkFBZ0JzRTtnQkFDaEJyRSxlQUFlc0U7WUFDakI7WUFFQXJFLGFBQWF2RSxzRkFBZ0M7UUFDL0M7aUVBQUc7UUFBQ21CO1FBQWVIO1FBQW9CNkQ7S0FBZTtJQUV0RCw4Q0FBOEM7SUFDOUNsRixnREFBU0E7eUNBQUM7WUFDUjBIO1FBQ0Y7d0NBQUc7UUFBQ2xHO1FBQWVrRztLQUFzQjtJQUV6QyxtREFBbUQ7SUFDbkQsTUFBTXBGLHlCQUF5QnJDLGtEQUFXQTttRUFDeEMsQ0FBQ2tKO1lBQ0MsbUNBQW1DO1lBQ25DaEUsa0JBQWtCO1lBRWxCOEIsUUFBUUMsR0FBRyxDQUNULGlDQUF5RCxPQUF4QmlDLGlCQUFpQjlCLE1BQU0sRUFBQztZQUczRCxtREFBbUQ7WUFDbkRoRyxtQkFBbUI4SDtZQUVuQiw4Q0FBOEM7WUFDOUNuRixxQkFBcUJtRjtZQUVyQixlQUFlO1lBQ2Z4RSxlQUFld0UsaUJBQWlCOUIsTUFBTTtZQUV0QyxzQ0FBc0M7WUFDdEMsTUFBTStCLGNBQWNELGlCQUFpQkUsTUFBTTt1RkFDekMsQ0FBQ0MsS0FBSzdDO29CQUNKLE1BQU04QyxRQUFROUMsU0FBUzhDLEtBQUssSUFBSTlDLFNBQVMrQyxhQUFhLElBQUk7b0JBQzFELElBQUksQ0FBQ0YsR0FBRyxDQUFDQyxNQUFNLEVBQUU7d0JBQ2ZELEdBQUcsQ0FBQ0MsTUFBTSxHQUFHOzRCQUNYQTs0QkFDQUUsT0FBTzs0QkFDUEMsY0FBY2pELFNBQVNpRCxZQUFZLElBQUk7NEJBQ3ZDLDRDQUE0Qzs0QkFDNUNDLE9BQU9KOzRCQUNQSyxhQUFhOzRCQUNiQyxZQUFZO3dCQUNkO29CQUNGO29CQUNBUCxHQUFHLENBQUNDLE1BQU0sQ0FBQ0UsS0FBSztvQkFDaEJILEdBQUcsQ0FBQ0MsTUFBTSxDQUFDSyxXQUFXO29CQUN0Qk4sR0FBRyxDQUFDQyxNQUFNLENBQUNNLFVBQVU7b0JBQ3JCLE9BQU9QO2dCQUNUO3NGQUNBLENBQUM7WUFHSCw4Q0FBOEM7WUFDOUMsTUFBTVEsYUFBYTNDLE9BQU80QyxNQUFNLENBQUNYLGFBQWFZLEdBQUc7c0ZBQUMsQ0FBQ1QsUUFBVzt3QkFDNURBLE9BQU9BLE1BQU1BLEtBQUs7d0JBQ2xCRSxPQUFPRixNQUFNRSxLQUFLO3dCQUNsQkMsY0FBY0gsTUFBTUcsWUFBWTt3QkFDaEMsaURBQWlEO3dCQUNqREMsT0FBT0osTUFBTUEsS0FBSzt3QkFDbEJLLGFBQWFMLE1BQU1FLEtBQUs7d0JBQ3hCSSxZQUFZTixNQUFNRSxLQUFLO29CQUN6Qjs7WUFFQS9FLGdCQUFnQm9GO1lBRWhCLHNDQUFzQztZQUN0Qy9FLGlCQUFpQixJQUFJdUMsT0FBTzJDLGtCQUFrQjtRQUNoRDtrRUFDQTtRQUFDNUk7S0FBbUI7SUFHdEIsZ0NBQWdDO0lBQ2hDLDBFQUEwRTtJQUUxRSxNQUFNVSxxQkFBcUIsT0FBTzJIO1FBQ2hDLG1EQUFtRDtRQUNuRHZFLGtCQUFrQjtRQUNsQlgsd0JBQXdCa0Y7UUFDeEJqRixpQkFBaUI7UUFDakJHLGFBQWE7UUFDYkcsaUJBQWlCO1FBRWpCLHNCQUFzQjtRQUN0QmYscUJBQXFCLEVBQUU7UUFDdkJVLGdCQUFnQixFQUFFO1FBQ2xCQyxlQUFlO1FBRWYscUJBQXFCO1FBQ3JCLElBQUkrRSxpQkFBaUIsTUFBTTtZQUN6QjlFLGFBQWE7WUFDYjtRQUNGO1FBRUEsMENBQTBDO1FBQzFDLElBQUlqQywwQkFBMEI7WUFDNUJzRSxRQUFRQyxHQUFHLENBQ1QsNERBQXlFLE9BQWJ3QztZQUU5RDlFLGFBQWE7WUFDYjtRQUNGO1FBRUEsSUFBSTtZQUNGLHlDQUF5QztZQUN6Q0Usa0JBQWtCLHdCQUFxQyxPQUFiNEUsY0FBYTtZQUV2RCx3REFBd0Q7WUFDeEQsd0VBQXdFO1lBRXhFLE1BQU1ySiwwR0FBb0QsQ0FDeERxSixjQUNBLENBQUNTO2dCQUNDLHFDQUFxQztnQkFDckMsSUFBSUEsU0FBU0MsT0FBTyxFQUFFO29CQUNwQnRGLGtCQUFrQnFGLFNBQVNDLE9BQU87Z0JBQ3BDO2dCQUVBLDhDQUE4QztnQkFDOUMsSUFBSUQsU0FBUzFELFFBQVEsRUFBRTtvQkFDckIsaUZBQWlGO29CQUNqRnpDLHFCQUFxQm1HLFNBQVMxRCxRQUFRO2dCQUN4QztnQkFFQSxxQkFBcUI7Z0JBQ3JCLElBQUkwRCxTQUFTbkIsTUFBTSxFQUFFO29CQUNuQnRFLGdCQUFnQnlGLFNBQVNuQixNQUFNO2dCQUNqQztnQkFFQSxxQkFBcUI7Z0JBQ3JCLElBQUltQixTQUFTbEIsS0FBSyxLQUFLRixXQUFXO29CQUNoQ3BFLGVBQWV3RixTQUFTbEIsS0FBSztnQkFDL0I7WUFDRjtZQUdGbEUsaUJBQWlCLElBQUl1QyxPQUFPMkMsa0JBQWtCO1FBQ2hELEVBQUUsT0FBT0ksT0FBTztZQUNkdEcsUUFDRSxnQ0FBeUYsT0FBekRzRyxpQkFBaUJDLFFBQVFELE1BQU1ELE9BQU8sR0FBRztZQUUzRXRGLGtCQUFrQjtRQUNwQixTQUFVO1lBQ1JGLGFBQWE7UUFDZjtJQUNGO0lBRUEseUJBQXlCO0lBQ3pCLE1BQU01QyxjQUFjLENBQUN1SDtRQUNuQjlFLGlCQUFpQjhFO0lBQ25CO0lBRUEsNEJBQTRCO0lBQzVCLE1BQU1wSSxpQkFBaUIsQ0FBQ3NGO1FBQ3RCeEMsb0JBQW9Cd0M7UUFFcEIsdUVBQXVFO1FBQ3ZFLElBQUlBLFlBQVlBLFNBQVMwQixNQUFNLElBQUkvRyxrQkFBa0IsQ0FBQ3FGLFNBQVMwQixNQUFNLENBQUMsRUFBRTtZQUN0RSxNQUFNb0MsbUJBQW1CO2dCQUN2QixHQUFHOUQsUUFBUTtnQkFDWCxHQUFHckYsa0JBQWtCLENBQUNxRixTQUFTMEIsTUFBTSxDQUFDO1lBQ3hDO1lBQ0FsRSxvQkFBb0JzRztRQUN0QjtJQUNGO0lBRUEsaUdBQWlHO0lBQ2pHLGdFQUFnRTtJQUNoRSxNQUFNQywwQkFBMEJ2SyxrREFBV0E7b0VBQ3pDLENBQUN3RDtZQUNDLE9BQU85Qyw4REFBdUJBLENBQUM4QztRQUNqQzttRUFDQSxFQUFFO0lBR0osdUJBQXVCO0lBQ3ZCLE1BQU14QixRQUFRO1FBQ1osTUFBTUYsbUJBQW1CO0lBQzNCO0lBRUEsMERBQTBEO0lBQzFELE1BQU1HLG1CQUFtQjtRQUN2QixJQUFJTixnQkFBaUIsQ0FBQ0wsd0JBQXdCLENBQUMyRCxnQkFBaUI7UUFFaEVMLGdCQUFnQjtRQUNoQkMsa0JBQWtCO1FBRWxCLElBQUk7WUFDRixtQkFBbUI7WUFDbkIsTUFBTXpFLGlHQUEyQztZQUVqRDBFLGlCQUFpQixJQUFJdUMsT0FBTzJDLGtCQUFrQjtZQUM5Q25GLGtCQUNFLHlCQUFrRCxPQUF6QjdELGtCQUFrQm9HLE1BQU0sRUFBQztRQUV0RCxFQUFFLE9BQU9nRCxPQUFPO1lBQ2R0RyxRQUNFLCtCQUF3RixPQUF6RHNHLGlCQUFpQkMsUUFBUUQsTUFBTUQsT0FBTyxHQUFHO1FBRTVFLFNBQVU7WUFDUk0sV0FBVztnQkFDVDdGLGdCQUFnQjtZQUNsQixHQUFHO1FBQ0w7SUFDRjtJQUVBLG1DQUFtQztJQUNuQyxNQUFNMUMsY0FBYztRQUNsQixJQUFJLENBQUVaLHdCQUF3QixDQUFDMkQsa0JBQW1CdEQsY0FBYztRQUVoRSxrRUFBa0U7UUFDbEUsNkJBQTZCO1FBQzdCLE1BQU0rSSxnQkFBZ0JELFdBQVc7WUFDL0I3RixnQkFBZ0I7WUFDaEJDLGtCQUFrQjtRQUNwQixHQUFHO1FBRUhELGdCQUFnQjtRQUVoQixJQUFJO1lBQ0YsaUNBQWlDO1lBQ2pDLE1BQU0rRixxQkFBcUJ2SywrRkFBeUM7WUFFcEUsaURBQWlEO1lBQ2pELE1BQU15SyxpQkFBaUJGLG1CQUFtQnBFLE1BQU0sQ0FDOUMsQ0FBQ0MsV0FBYUEsU0FBUzBCLE1BQU0sSUFBSTFCLFNBQVNDLFFBQVEsSUFBSUQsU0FBU0UsU0FBUztZQUcxRSxNQUFNb0UsbUJBQ0osQ0FBQy9GLHVCQUF1QnNDLEtBQUtDLEdBQUcsS0FBS3ZDLHNCQUFzQjtZQUU3RCxJQUFJZ0csVUFBVTtZQUVkLElBQUlGLGVBQWV6RCxNQUFNLEtBQUssS0FBSzBELGtCQUFrQjtnQkFDbkQsb0JBQW9CO2dCQUNwQmpHLGtCQUFrQjtnQkFFbEIsSUFBSTtvQkFDRixNQUFNekUsdUZBQWlDO29CQUN2QzRFLHVCQUF1QnFDLEtBQUtDLEdBQUc7b0JBQy9CeUQsVUFBVTtnQkFDWixFQUFFLE9BQU9YLE9BQU87b0JBQ2QsNkJBQTZCO29CQUM3QnBELFFBQVFpRSxJQUFJLENBQUM7Z0JBQ2Y7WUFDRixPQUFPO2dCQUNMLDBCQUEwQjtnQkFDMUIsTUFBTUMsY0FBY0wsZUFDakJkLEdBQUcsQ0FBQyxDQUFDdkQsV0FBYUEsU0FBUzBCLE1BQU0sRUFDakMzQixNQUFNLENBQUM0RTtnQkFFVixJQUFJRCxZQUFZOUQsTUFBTSxHQUFHLEdBQUc7b0JBQzFCdkMsa0JBQ0UsY0FBaUMsT0FBbkJxRyxZQUFZOUQsTUFBTSxFQUFDO29CQUduQyxJQUFJO3dCQUNGLE1BQU1oSCxvR0FBOEMsQ0FBQzhLO3dCQUNyREgsVUFBVTtvQkFDWixFQUFFLE9BQU9YLE9BQU87d0JBQ2QscUNBQXFDO3dCQUNyQ3BELFFBQVFpRSxJQUFJLENBQUM7d0JBQ2IsSUFBSTs0QkFDRixNQUFNN0ssdUZBQWlDOzRCQUN2QzRFLHVCQUF1QnFDLEtBQUtDLEdBQUc7NEJBQy9CeUQsVUFBVTt3QkFDWixFQUFFLE9BQU9NLGVBQWU7NEJBQ3RCLDZCQUE2Qjs0QkFDN0JyRSxRQUFRaUUsSUFBSSxDQUFDO3dCQUNmO29CQUNGO2dCQUNGO1lBQ0Y7WUFFQUssYUFBYVo7WUFFYiw0Q0FBNEM7WUFDNUMsSUFBSUssU0FBUztnQkFDWCxNQUFNUSxlQUFlbkwsK0ZBQXlDLEdBQUdnSCxNQUFNO2dCQUN2RXZDLGtCQUFrQiwwQkFBdUMsT0FBYjBHLGNBQWE7Z0JBQ3pEekcsaUJBQWlCLElBQUl1QyxPQUFPMkMsa0JBQWtCO1lBQ2hELE9BQU87Z0JBQ0xuRixrQkFBa0I7WUFDcEI7UUFDRixFQUFFLE9BQU91RixPQUFPO1lBQ2RrQixhQUFhWjtZQUViLGdFQUFnRTtZQUNoRSxJQUFJTixpQkFBaUJDLFNBQVNELE1BQU1ELE9BQU8sS0FBSyxXQUFXO2dCQUN6RHJHLFFBQVEseUJBQTBELE9BQWpDc0csTUFBTUQsT0FBTyxJQUFJO1lBQ3BEO1lBRUF0RixrQkFBa0I7UUFDcEIsU0FBVTtZQUNSeUcsYUFBYVo7WUFDYjlGLGdCQUFnQjtRQUNsQjtJQUNGO0lBRUEsTUFBTXhDLG9CQUFvQnBDLGtEQUFXQTs4REFBQztZQUNwQywyQkFBMkI7WUFDM0JrRixrQkFBa0I7WUFFbEIsMkJBQTJCO1lBQzNCbkIscUJBQXFCLEVBQUU7WUFDdkJVLGdCQUFnQixFQUFFO1lBQ2xCQyxlQUFlO1lBRWYscUVBQXFFO1lBQ3JFLElBQUlwRCxzQkFBc0I7Z0JBQ3hCLCtDQUErQztnQkFDL0NtSjswRUFBVzt3QkFDVHJLLDhGQUF3QyxDQUFDa0I7b0JBQzNDO3lFQUFHO1lBQ0w7UUFDRjs2REFBRztRQUFDQTtLQUFxQjtJQUV6Qix1QkFBdUI7SUFDdkIsTUFBTW1LLGVBQXVDO1FBQzNDN0s7UUFDQUM7UUFDQUM7UUFDQUM7UUFFQUM7UUFDQUM7UUFDQUM7UUFFQSxtQkFBbUI7UUFDbkJDO1FBQ0FDO1FBQ0FDO1FBRUFDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBRUFDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBRUFDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FlO1FBRUFkO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBRUEsd0JBQXdCO1FBQ3hCQztRQUNBQztRQUNBQztRQUNBRztRQUNBRjtRQUNBQztRQUNBRTtRQUNBQztRQUNBTTtRQUNBQztRQUVBLG1CQUFtQjtRQUNuQkw7UUFDQUU7UUFDQTlDLG1CQUFtQjhKO0lBQ3JCO0lBRUEscUJBQ0UsOERBQUM1SixtQkFBbUIrSyxRQUFRO1FBQUNDLE9BQU9GO2tCQUNqQzdIOzs7Ozs7QUFHUCxFQUFFO0dBbHBCV0Q7S0FBQUE7QUFvcEJiLGlDQUFpQztBQUMxQixNQUFNaUksd0JBQXdCOztJQUFNL0wsT0FBQUEsaURBQVVBLENBQUNjO0FBQWtCLEVBQUU7SUFBN0RpTDtBQUViLGlFQUFlakwsa0JBQWtCQSxFQUFDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXHNhdGhvXFxEb2N1bWVudHNcXFByb2plY3RzXFxhaXJjcmFmdC10cmFja2luZ1xcY29tcG9uZW50c1xcdHJhY2tpbmdcXGNvbnRleHRcXEVuaGFuY2VkTWFwQ29udGV4dC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiLy8gY29tcG9uZW50cy90cmFja2luZy9jb250ZXh0L0VuaGFuY2VkTWFwQ29udGV4dC50c3hcclxuaW1wb3J0IFJlYWN0LCB7XHJcbiAgY3JlYXRlQ29udGV4dCxcclxuICB1c2VDb250ZXh0LFxyXG4gIHVzZVN0YXRlLFxyXG4gIHVzZUVmZmVjdCxcclxuICB1c2VDYWxsYmFjayxcclxuICB1c2VSZWYsXHJcbiAgdXNlTWVtbyxcclxufSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBMIGZyb20gJ2xlYWZsZXQnO1xyXG5pbXBvcnQge1xyXG4gIFNlbGVjdE9wdGlvbixcclxuICBFeHRlbmRlZEFpcmNyYWZ0LFxyXG4gIEFpcmNyYWZ0UG9zaXRpb24sXHJcbiAgUmVnaW9uQ29kZSxcclxufSBmcm9tICdAL3R5cGVzL2Jhc2UnO1xyXG5pbXBvcnQgdHlwZSB7IENhY2hlZEFpcmNyYWZ0RGF0YSB9IGZyb20gJ0AvdHlwZXMvYmFzZSc7IC8vIEltcG9ydCB5b3VyIG5ldyB0eXBlXHJcbmltcG9ydCB0eXBlIHsgQWlyY3JhZnRNb2RlbCB9IGZyb20gJy4uLy4uLy4uL3R5cGVzL2FpcmNyYWZ0LW1vZGVscyc7XHJcbmltcG9ydCBvcGVuU2t5VHJhY2tpbmdTZXJ2aWNlIGZyb20gJ0AvbGliL3NlcnZpY2VzL29wZW5Ta3lUcmFja2luZ1NlcnZpY2UnO1xyXG5pbXBvcnQge1xyXG4gIHNhdmVBaXJjcmFmdERhdGEsXHJcbiAgbG9hZEFpcmNyYWZ0RGF0YSxcclxuICBtZXJnZUFpcmNyYWZ0RGF0YSxcclxuICBjbGVhckFpcmNyYWZ0RGF0YSxcclxufSBmcm9tICcuLi9wZXJzaXN0ZW5jZS9BaXJjcmFmdERhdGFQZXJzaXN0ZW5jZSc7XHJcbmltcG9ydCB0eXBlIHsgTGF0TG5nQm91bmRzRXhwcmVzc2lvbiB9IGZyb20gJ2xlYWZsZXQnO1xyXG5pbXBvcnQge1xyXG4gIE1BUF9DT05GSUcsXHJcbiAgZ2V0Qm91bmRzQnlSZWdpb24gYXMgY29uZmlnR2V0Qm91bmRzQnlSZWdpb24sXHJcbn0gZnJvbSAnLi4vLi4vLi4vY29uZmlnL21hcCc7XHJcblxyXG4vLyBEZWZpbmUgY29udGV4dCBpbnRlcmZhY2VcclxuaW50ZXJmYWNlIEVuaGFuY2VkTWFwQ29udGV4dFR5cGUge1xyXG4gIC8vIE1hcCBzdGF0ZVxyXG4gIG1hcEluc3RhbmNlOiBMLk1hcCB8IG51bGw7XHJcbiAgc2V0TWFwSW5zdGFuY2U6IChtYXA6IEwuTWFwIHwgbnVsbCkgPT4gdm9pZDtcclxuICB6b29tTGV2ZWw6IG51bWJlcjtcclxuICBzZXRab29tTGV2ZWw6ICh6b29tOiBudW1iZXIpID0+IHZvaWQ7XHJcblxyXG4gIC8vIEFpcmNyYWZ0IGRhdGFcclxuICBkaXNwbGF5ZWRBaXJjcmFmdDogRXh0ZW5kZWRBaXJjcmFmdFtdO1xyXG4gIHNlbGVjdGVkQWlyY3JhZnQ6IEV4dGVuZGVkQWlyY3JhZnQgfCBudWxsO1xyXG4gIHNlbGVjdEFpcmNyYWZ0OiAoYWlyY3JhZnQ6IEV4dGVuZGVkQWlyY3JhZnQgfCBudWxsKSA9PiB2b2lkO1xyXG5cclxuICAvLyBEYXRhIHBlcnNpc3RlbmNlXHJcbiAgY2FjaGVkQWlyY3JhZnREYXRhOiBSZWNvcmQ8c3RyaW5nLCBDYWNoZWRBaXJjcmFmdERhdGE+O1xyXG4gIHVwZGF0ZUFpcmNyYWZ0RGF0YTogKG5ld0FpcmNyYWZ0OiBFeHRlbmRlZEFpcmNyYWZ0W10pID0+IHZvaWQ7XHJcbiAgbGFzdFBlcnNpc3RlbmNlVXBkYXRlOiBudW1iZXIgfCBudWxsO1xyXG5cclxuICAvLyBTZWxlY3Rpb24gc3RhdGVcclxuICBzZWxlY3RlZE1hbnVmYWN0dXJlcjogc3RyaW5nIHwgbnVsbDtcclxuICBzZWxlY3RlZE1vZGVsOiBzdHJpbmcgfCBudWxsO1xyXG4gIGFjdGl2ZU1vZGVsczogQWlyY3JhZnRNb2RlbFtdO1xyXG4gIHRvdGFsQWN0aXZlOiBudW1iZXI7XHJcblxyXG4gIC8vIExvYWRpbmcgc3RhdGVcclxuICBpc0xvYWRpbmc6IGJvb2xlYW47XHJcbiAgaXNSZWZyZXNoaW5nOiBib29sZWFuO1xyXG4gIHRyYWNraW5nU3RhdHVzOiBzdHJpbmc7XHJcbiAgbGFzdFJlZnJlc2hlZDogc3RyaW5nIHwgbnVsbDtcclxuXHJcbiAgLy8gQWN0aW9uc1xyXG4gIHNlbGVjdE1hbnVmYWN0dXJlcjogKE1BTlVGQUNUVVJFUjogc3RyaW5nIHwgbnVsbCkgPT4gUHJvbWlzZTx2b2lkPjtcclxuICBzZWxlY3RNb2RlbDogKE1PREVMOiBzdHJpbmcgfCBudWxsKSA9PiB2b2lkO1xyXG4gIHJlc2V0OiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xyXG4gIHJlZnJlc2hQb3NpdGlvbnM6ICgpID0+IFByb21pc2U8dm9pZD47XHJcbiAgZnVsbFJlZnJlc2g6ICgpID0+IFByb21pc2U8dm9pZD47XHJcbiAgY2xlYXJDYWNoZTogKCkgPT4gdm9pZDtcclxuICBjbGVhckdlb2ZlbmNlRGF0YTogKCkgPT4gdm9pZDtcclxuICAvLyBBZGQgbmV3IGZ1bmN0aW9uIGZvciB1cGRhdGluZyBhaXJjcmFmdCBmcm9tIGdlb2ZlbmNlXHJcbiAgdXBkYXRlR2VvZmVuY2VBaXJjcmFmdDogKGdlb2ZlbmNlQWlyY3JhZnQ6IEV4dGVuZGVkQWlyY3JhZnRbXSkgPT4gdm9pZDtcclxuXHJcbiAgZmlsdGVyTW9kZTogJ21hbnVmYWN0dXJlcicgfCAnZ2VvZmVuY2UnIHwgJ2JvdGgnIHwgJ3JlZ2lvbicgfCAnb3duZXInO1xyXG4gIHNldEZpbHRlck1vZGU6IChcclxuICAgIG1vZGU6ICdtYW51ZmFjdHVyZXInIHwgJ2dlb2ZlbmNlJyB8ICdib3RoJyB8ICdyZWdpb24nIHwgJ293bmVyJ1xyXG4gICkgPT4gdm9pZDtcclxuICBibG9ja01hbnVmYWN0dXJlckFwaUNhbGxzOiBib29sZWFuO1xyXG4gIHNldEJsb2NrTWFudWZhY3R1cmVyQXBpQ2FsbHM6IChibG9jazogYm9vbGVhbikgPT4gdm9pZDtcclxuICBpc01hbnVmYWN0dXJlckFwaUJsb2NrZWQ6IGJvb2xlYW47XHJcbiAgc2V0SXNNYW51ZmFjdHVyZXJBcGlCbG9ja2VkOiAoYmxvY2tlZDogYm9vbGVhbikgPT4gdm9pZDtcclxuICBmaWx0ZXJlZEFpcmNyYWZ0OiBFeHRlbmRlZEFpcmNyYWZ0W107XHJcblxyXG4gIC8vIEdlb2ZlbmNpbmcgcHJvcGVydGllc1xyXG4gIGdlb2ZlbmNlQ2VudGVyOiB7IGxhdDogbnVtYmVyOyBsbmc6IG51bWJlciB9IHwgbnVsbDsgLy8gQ29ycmVjdGx5IHR5cGVkIGFzIHsgbGF0OiBudW1iZXI7IGxuZzogbnVtYmVyIH0gfCBudWxsXHJcbiAgZ2VvZmVuY2VSYWRpdXM6IG51bWJlciB8IG51bGw7IC8vIGluIGtpbG9tZXRlcnNcclxuICBpc0dlb2ZlbmNlQWN0aXZlOiBib29sZWFuO1xyXG4gIHNldEdlb2ZlbmNlQ2VudGVyOiAoY2VudGVyOiB7IGxhdDogbnVtYmVyOyBsbmc6IG51bWJlciB9IHwgbnVsbCkgPT4gdm9pZDtcclxuICBzZXRHZW9mZW5jZVJhZGl1czogKHJhZGl1czogbnVtYmVyIHwgbnVsbCkgPT4gdm9pZDtcclxuICB0b2dnbGVHZW9mZW5jZTogKCkgPT4gdm9pZDtcclxuICBjbGVhckdlb2ZlbmNlOiAoKSA9PiB7fTtcclxuICBnZW9mZW5jZUNvb3JkaW5hdGVzOiB7IGxhdDogbnVtYmVyOyBsbmc6IG51bWJlciB9IHwgbnVsbDtcclxuICBpc0dlb2ZlbmNlUGxhY2VtZW50TW9kZTogYm9vbGVhbjtcclxuICBzZXRJc0dlb2ZlbmNlUGxhY2VtZW50TW9kZTogKGlzUGxhY2VtZW50TW9kZTogYm9vbGVhbikgPT4gdm9pZDtcclxuXHJcbiAgLy8gUmVnaW9uIHNlbGVjdGlvbiBwcm9wZXJ0aWVzXHJcbiAgc2VsZWN0ZWRSZWdpb246IFJlZ2lvbkNvZGUgfCBzdHJpbmc7IC8vIEFsbG93IGJvdGggZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcclxuICBzZXRTZWxlY3RlZFJlZ2lvbjogKHJlZ2lvbjogUmVnaW9uQ29kZSB8IHN0cmluZykgPT4gdm9pZDtcclxuICBnZXRCb3VuZHNCeVJlZ2lvbjogKHJlZ2lvbjogc3RyaW5nKSA9PiBMYXRMbmdCb3VuZHNFeHByZXNzaW9uO1xyXG59XHJcblxyXG4vLyBDcmVhdGUgY29udGV4dCB3aXRoIGRlZmF1bHQgdmFsdWVzXHJcbmNvbnN0IEVuaGFuY2VkTWFwQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8RW5oYW5jZWRNYXBDb250ZXh0VHlwZT4oe1xyXG4gIG1hcEluc3RhbmNlOiBudWxsLFxyXG4gIHNldE1hcEluc3RhbmNlOiAoKSA9PiB7fSxcclxuICB6b29tTGV2ZWw6IDYsXHJcbiAgc2V0Wm9vbUxldmVsOiAoKSA9PiB7fSxcclxuICBkaXNwbGF5ZWRBaXJjcmFmdDogW10sXHJcbiAgc2VsZWN0ZWRBaXJjcmFmdDogbnVsbCxcclxuICBzZWxlY3RBaXJjcmFmdDogKCkgPT4ge30sXHJcblxyXG4gIC8vIERhdGEgcGVyc2lzdGVuY2UgZGVmYXVsdHNcclxuICBjYWNoZWRBaXJjcmFmdERhdGE6IHt9LFxyXG4gIHVwZGF0ZUFpcmNyYWZ0RGF0YTogKCkgPT4ge30sXHJcbiAgbGFzdFBlcnNpc3RlbmNlVXBkYXRlOiBudWxsLFxyXG5cclxuICBzZWxlY3RlZE1hbnVmYWN0dXJlcjogbnVsbCxcclxuICBzZWxlY3RlZE1vZGVsOiBudWxsLFxyXG4gIGFjdGl2ZU1vZGVsczogW10sXHJcbiAgdG90YWxBY3RpdmU6IDAsXHJcblxyXG4gIGlzTG9hZGluZzogZmFsc2UsXHJcbiAgaXNSZWZyZXNoaW5nOiBmYWxzZSxcclxuICB0cmFja2luZ1N0YXR1czogJycsXHJcbiAgbGFzdFJlZnJlc2hlZDogbnVsbCxcclxuXHJcbiAgc2VsZWN0TWFudWZhY3R1cmVyOiBhc3luYyAoKSA9PiB7fSxcclxuICBzZWxlY3RNb2RlbDogKCkgPT4ge30sXHJcbiAgcmVzZXQ6IGFzeW5jICgpID0+IHt9LFxyXG4gIHJlZnJlc2hQb3NpdGlvbnM6IGFzeW5jICgpID0+IHt9LFxyXG4gIGZ1bGxSZWZyZXNoOiBhc3luYyAoKSA9PiB7fSxcclxuICBjbGVhckNhY2hlOiAoKSA9PiB7fSxcclxuICBjbGVhckdlb2ZlbmNlRGF0YTogKCkgPT4ge30sXHJcbiAgLy8gQWRkIGRlZmF1bHQgZm9yIG5ldyBmdW5jdGlvblxyXG4gIHVwZGF0ZUdlb2ZlbmNlQWlyY3JhZnQ6ICgpID0+IHt9LFxyXG5cclxuICBmaWx0ZXJNb2RlOiAnbWFudWZhY3R1cmVyJyxcclxuICBzZXRGaWx0ZXJNb2RlOiAoKSA9PiB7fSxcclxuICBibG9ja01hbnVmYWN0dXJlckFwaUNhbGxzOiBmYWxzZSxcclxuICBzZXRCbG9ja01hbnVmYWN0dXJlckFwaUNhbGxzOiAoKSA9PiB7fSxcclxuICBpc01hbnVmYWN0dXJlckFwaUJsb2NrZWQ6IGZhbHNlLFxyXG4gIHNldElzTWFudWZhY3R1cmVyQXBpQmxvY2tlZDogKCkgPT4ge30sXHJcblxyXG4gIC8vIEdlb2ZlbmNpbmcgcHJvcGVydGllc1xyXG4gIGdlb2ZlbmNlQ2VudGVyOiBudWxsLFxyXG4gIGdlb2ZlbmNlUmFkaXVzOiAyNSwgLy8gRGVmYXVsdCB0byAyNWttLCBub3QgbnVsbFxyXG4gIGlzR2VvZmVuY2VBY3RpdmU6IGZhbHNlLFxyXG4gIHNldEdlb2ZlbmNlQ2VudGVyOiAoKSA9PiB7fSxcclxuICBzZXRHZW9mZW5jZVJhZGl1czogKCkgPT4ge30sXHJcbiAgZ2VvZmVuY2VDb29yZGluYXRlczogbnVsbCxcclxuICB0b2dnbGVHZW9mZW5jZTogKCkgPT4ge30sXHJcbiAgY2xlYXJHZW9mZW5jZTogKCkgPT4gKHt9KSxcclxuICBmaWx0ZXJlZEFpcmNyYWZ0OiBbXSxcclxuICBzZWxlY3RlZFJlZ2lvbjogUmVnaW9uQ29kZS5HTE9CQUwsXHJcbiAgc2V0U2VsZWN0ZWRSZWdpb246IChyZWdpb246IFJlZ2lvbkNvZGUgfCBzdHJpbmcpID0+IHt9LFxyXG4gIGdldEJvdW5kc0J5UmVnaW9uOiAocmVnaW9uOiBzdHJpbmcpID0+XHJcbiAgICBjb25maWdHZXRCb3VuZHNCeVJlZ2lvbignR0xPQkFMJykgYXMgTGF0TG5nQm91bmRzRXhwcmVzc2lvbixcclxuICBpc0dlb2ZlbmNlUGxhY2VtZW50TW9kZTogZmFsc2UsXHJcbiAgc2V0SXNHZW9mZW5jZVBsYWNlbWVudE1vZGU6ICgpID0+IHt9LFxyXG59KTtcclxuXHJcbi8vIFByb3BzIGZvciB0aGUgY29udGV4dCBwcm92aWRlclxyXG5pbnRlcmZhY2UgRW5oYW5jZWRNYXBQcm92aWRlclByb3BzIHtcclxuICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlO1xyXG4gIG1hbnVmYWN0dXJlcnM6IFNlbGVjdE9wdGlvbltdO1xyXG4gIG9uRXJyb3I6IChtZXNzYWdlOiBzdHJpbmcpID0+IHZvaWQ7XHJcbn1cclxuXHJcbi8vIEVuaGFuY2VkIE1hcCBQcm92aWRlciBjb21wb25lbnRcclxuZXhwb3J0IGNvbnN0IEVuaGFuY2VkTWFwUHJvdmlkZXI6IFJlYWN0LkZDPEVuaGFuY2VkTWFwUHJvdmlkZXJQcm9wcz4gPSAoe1xyXG4gIGNoaWxkcmVuLFxyXG4gIG1hbnVmYWN0dXJlcnMsXHJcbiAgb25FcnJvcixcclxufSkgPT4ge1xyXG4gIC8vIE1hcCBzdGF0ZVxyXG4gIGNvbnN0IFttYXBJbnN0YW5jZSwgc2V0TWFwSW5zdGFuY2VdID0gdXNlU3RhdGU8TC5NYXAgfCBudWxsPihudWxsKTtcclxuICBjb25zdCBbem9vbUxldmVsLCBzZXRab29tTGV2ZWxdID0gdXNlU3RhdGU8bnVtYmVyPig2KTtcclxuXHJcbiAgLy8gQWlyY3JhZnQgc3RhdGVcclxuICBjb25zdCBbZGlzcGxheWVkQWlyY3JhZnQsIHNldERpc3BsYXllZEFpcmNyYWZ0XSA9IHVzZVN0YXRlPFxyXG4gICAgRXh0ZW5kZWRBaXJjcmFmdFtdXHJcbiAgPihbXSk7XHJcbiAgY29uc3QgW3NlbGVjdGVkQWlyY3JhZnQsIHNldFNlbGVjdGVkQWlyY3JhZnRdID1cclxuICAgIHVzZVN0YXRlPEV4dGVuZGVkQWlyY3JhZnQgfCBudWxsPihudWxsKTtcclxuXHJcbiAgLy8gRGF0YSBwZXJzaXN0ZW5jZSBzdGF0ZVxyXG4gIGNvbnN0IFtjYWNoZWRBaXJjcmFmdERhdGEsIHNldENhY2hlZEFpcmNyYWZ0RGF0YV0gPSB1c2VTdGF0ZTxcclxuICAgIFJlY29yZDxzdHJpbmcsIENhY2hlZEFpcmNyYWZ0RGF0YT5cclxuICA+KHt9KTtcclxuICBjb25zdCBbbGFzdFBlcnNpc3RlbmNlVXBkYXRlLCBzZXRMYXN0UGVyc2lzdGVuY2VVcGRhdGVdID0gdXNlU3RhdGU8XHJcbiAgICBudW1iZXIgfCBudWxsXHJcbiAgPihudWxsKTtcclxuXHJcbiAgY29uc3QgW2dlb2ZlbmNlQ2VudGVyLCBzZXRHZW9mZW5jZUNlbnRlcl0gPSB1c2VTdGF0ZTx7XHJcbiAgICBsYXQ6IG51bWJlcjtcclxuICAgIGxuZzogbnVtYmVyO1xyXG4gIH0gfCBudWxsPihudWxsKTtcclxuXHJcbiAgY29uc3QgW3NlbGVjdGVkUmVnaW9uLCBzZXRTZWxlY3RlZFJlZ2lvbl0gPSB1c2VTdGF0ZTxSZWdpb25Db2RlIHwgc3RyaW5nPihcclxuICAgIFJlZ2lvbkNvZGUuR0xPQkFMXHJcbiAgKTtcclxuXHJcbiAgLy8gRGVyaXZlZCBzdGF0ZSBmb3IgZ2VvZmVuY2UgY29vcmRpbmF0ZXNcclxuICBjb25zdCBnZW9mZW5jZUNvb3JkaW5hdGVzID0gdXNlTWVtbygoKSA9PiBnZW9mZW5jZUNlbnRlciwgW2dlb2ZlbmNlQ2VudGVyXSk7XHJcbiAgY29uc3QgW2dlb2ZlbmNlUmFkaXVzLCBzZXRHZW9mZW5jZVJhZGl1c10gPSB1c2VTdGF0ZTxudW1iZXIgfCBudWxsPigyNSk7IC8vIERlZmF1bHQgMjVrbSByYWRpdXNcclxuICBjb25zdCBbaXNHZW9mZW5jZUFjdGl2ZSwgc2V0SXNHZW9mZW5jZUFjdGl2ZV0gPSB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XHJcbiAgY29uc3QgW2lzR2VvZmVuY2VQbGFjZW1lbnRNb2RlLCBzZXRJc0dlb2ZlbmNlUGxhY2VtZW50TW9kZV0gPVxyXG4gICAgdXNlU3RhdGU8Ym9vbGVhbj4oZmFsc2UpO1xyXG5cclxuICAvLyBBZGQgdGhpcyB0byB5b3VyIHN0YXRlIGRlY2xhcmF0aW9uc1xyXG4gIGNvbnN0IFthaXJjcmFmdFBvc2l0aW9ucywgc2V0QWlyY3JhZnRQb3NpdGlvbnNdID0gdXNlU3RhdGU8XHJcbiAgICBBaXJjcmFmdFBvc2l0aW9uW11cclxuICA+KFtdKTtcclxuICAvLyBUb2dnbGUgZ2VvZmVuY2UgYWN0aXZhdGlvblxyXG4gIGNvbnN0IHRvZ2dsZUdlb2ZlbmNlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgc2V0SXNHZW9mZW5jZUFjdGl2ZSgocHJldikgPT4gIXByZXYpO1xyXG4gIH0sIFtdKTtcclxuXHJcbiAgLy8gQ2xlYXIgZ2VvZmVuY2VcclxuICBjb25zdCBjbGVhckdlb2ZlbmNlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgc2V0R2VvZmVuY2VDZW50ZXIobnVsbCk7XHJcbiAgICBzZXRJc0dlb2ZlbmNlQWN0aXZlKGZhbHNlKTtcclxuICAgIHJldHVybiB7fTsgLy8gUmV0dXJuIGFuIGVtcHR5IG9iamVjdCB0byBtYXRjaCB0aGUgZXhwZWN0ZWQgdHlwZVxyXG4gIH0sIFtdKTtcclxuXHJcbiAgLy8gU2VsZWN0aW9uIHN0YXRlXHJcbiAgY29uc3QgW3NlbGVjdGVkTWFudWZhY3R1cmVyLCBzZXRTZWxlY3RlZE1hbnVmYWN0dXJlcl0gPSB1c2VTdGF0ZTxcclxuICAgIHN0cmluZyB8IG51bGxcclxuICA+KG51bGwpO1xyXG4gIGNvbnN0IFtzZWxlY3RlZE1vZGVsLCBzZXRTZWxlY3RlZE1vZGVsXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xyXG4gIGNvbnN0IFthY3RpdmVNb2RlbHMsIHNldEFjdGl2ZU1vZGVsc10gPSB1c2VTdGF0ZTxBaXJjcmFmdE1vZGVsW10+KFtdKTtcclxuICBjb25zdCBbdG90YWxBY3RpdmUsIHNldFRvdGFsQWN0aXZlXSA9IHVzZVN0YXRlPG51bWJlcj4oMCk7XHJcblxyXG4gIC8vIExvYWRpbmcgc3RhdGVcclxuICBjb25zdCBbaXNMb2FkaW5nLCBzZXRJc0xvYWRpbmddID0gdXNlU3RhdGU8Ym9vbGVhbj4oZmFsc2UpO1xyXG4gIGNvbnN0IFtpc1JlZnJlc2hpbmcsIHNldElzUmVmcmVzaGluZ10gPSB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XHJcbiAgY29uc3QgW3RyYWNraW5nU3RhdHVzLCBzZXRUcmFja2luZ1N0YXR1c10gPSB1c2VTdGF0ZTxzdHJpbmc+KCcnKTtcclxuICBjb25zdCBbbGFzdFJlZnJlc2hlZCwgc2V0TGFzdFJlZnJlc2hlZF0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcclxuICAvLyBBZGQgdGhpcyB3aXRoIHlvdXIgb3RoZXIgc3RhdGUgdmFyaWFibGVzXHJcbiAgY29uc3QgW2xhc3RGdWxsUmVmcmVzaFRpbWUsIHNldExhc3RGdWxsUmVmcmVzaFRpbWVdID0gdXNlU3RhdGU8bnVtYmVyIHwgbnVsbD4oXHJcbiAgICBudWxsXHJcbiAgKTtcclxuICBjb25zdCBbaXNNYW51ZmFjdHVyZXJBcGlCbG9ja2VkLCBzZXRJc01hbnVmYWN0dXJlckFwaUJsb2NrZWRdID1cclxuICAgIHVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKTtcclxuXHJcbiAgY29uc3QgW2ZpbHRlck1vZGUsIHNldEZpbHRlck1vZGVdID0gdXNlU3RhdGU8XHJcbiAgICAnbWFudWZhY3R1cmVyJyB8ICdnZW9mZW5jZScgfCAnYm90aCcgfCAncmVnaW9uJyB8ICdvd25lcidcclxuICA+KCdtYW51ZmFjdHVyZXInKTtcclxuICBjb25zdCBbYmxvY2tNYW51ZmFjdHVyZXJBcGlDYWxscywgc2V0QmxvY2tNYW51ZmFjdHVyZXJBcGlDYWxsc10gPVxyXG4gICAgdXNlU3RhdGU8Ym9vbGVhbj4oZmFsc2UpO1xyXG5cclxuICAvLyBGbGFnIHRvIHRyYWNrIGlmIHdlJ3JlIGluIGdlb2ZlbmNlIG1vZGVcclxuICBjb25zdCBbaXNHZW9mZW5jZU1vZGUsIHNldElzR2VvZmVuY2VNb2RlXSA9IHVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKTtcclxuXHJcbiAgLy8gRGVmaW5lIHRoZSBmaWx0ZXIgZnVuY3Rpb24gY29ycmVjdGx5XHJcbiAgY29uc3QgZmlsdGVyQWlyY3JhZnRCeUdlb2ZlbmNlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgaWYgKCFnZW9mZW5jZUNlbnRlciB8fCAhaXNHZW9mZW5jZUFjdGl2ZSkge1xyXG4gICAgICByZXR1cm4gZGlzcGxheWVkQWlyY3JhZnQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNhbGN1bGF0ZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcclxuICAgIGNvbnN0IGNhbGN1bGF0ZURpc3RhbmNlID0gKFxyXG4gICAgICBsYXQxOiBudW1iZXIsXHJcbiAgICAgIGxvbjE6IG51bWJlcixcclxuICAgICAgbGF0MjogbnVtYmVyLFxyXG4gICAgICBsb24yOiBudW1iZXJcclxuICAgICk6IG51bWJlciA9PiB7XHJcbiAgICAgIGNvbnN0IFIgPSA2MzcxOyAvLyBSYWRpdXMgb2YgdGhlIGVhcnRoIGluIGttXHJcbiAgICAgIGNvbnN0IGRMYXQgPSBkZWcycmFkKGxhdDIgLSBsYXQxKTtcclxuICAgICAgY29uc3QgZExvbiA9IGRlZzJyYWQobG9uMiAtIGxvbjEpO1xyXG4gICAgICBjb25zdCBhID1cclxuICAgICAgICBNYXRoLnNpbihkTGF0IC8gMikgKiBNYXRoLnNpbihkTGF0IC8gMikgK1xyXG4gICAgICAgIE1hdGguY29zKGRlZzJyYWQobGF0MSkpICpcclxuICAgICAgICAgIE1hdGguY29zKGRlZzJyYWQobGF0MikpICpcclxuICAgICAgICAgIE1hdGguc2luKGRMb24gLyAyKSAqXHJcbiAgICAgICAgICBNYXRoLnNpbihkTG9uIC8gMik7XHJcbiAgICAgIGNvbnN0IGMgPSAyICogTWF0aC5hdGFuMihNYXRoLnNxcnQoYSksIE1hdGguc3FydCgxIC0gYSkpO1xyXG4gICAgICBjb25zdCBkaXN0YW5jZSA9IFIgKiBjOyAvLyBEaXN0YW5jZSBpbiBrbVxyXG4gICAgICByZXR1cm4gZGlzdGFuY2U7XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IGRlZzJyYWQgPSAoZGVnOiBudW1iZXIpOiBudW1iZXIgPT4ge1xyXG4gICAgICByZXR1cm4gZGVnICogKE1hdGguUEkgLyAxODApO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBGaWx0ZXIgYWlyY3JhZnQgd2l0aGluIHRoZSByYWRpdXNcclxuICAgIHJldHVybiBkaXNwbGF5ZWRBaXJjcmFmdC5maWx0ZXIoKGFpcmNyYWZ0KSA9PiB7XHJcbiAgICAgIGlmICghYWlyY3JhZnQubGF0aXR1ZGUgfHwgIWFpcmNyYWZ0LmxvbmdpdHVkZSkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgLy8gQ2FsY3VsYXRlIGRpc3RhbmNlIGJldHdlZW4gYWlyY3JhZnQgYW5kIGdlb2ZlbmNlIGNlbnRlclxyXG4gICAgICBjb25zdCBkaXN0YW5jZSA9IGNhbGN1bGF0ZURpc3RhbmNlKFxyXG4gICAgICAgIGdlb2ZlbmNlQ2VudGVyLmxhdCxcclxuICAgICAgICBnZW9mZW5jZUNlbnRlci5sbmcsXHJcbiAgICAgICAgYWlyY3JhZnQubGF0aXR1ZGUsXHJcbiAgICAgICAgYWlyY3JhZnQubG9uZ2l0dWRlXHJcbiAgICAgICk7XHJcblxyXG4gICAgICAvLyBSZXR1cm4gdHJ1ZSBpZiBhaXJjcmFmdCBpcyB3aXRoaW4gcmFkaXVzXHJcbiAgICAgIHJldHVybiBnZW9mZW5jZVJhZGl1cyAhPT0gbnVsbCAmJiBkaXN0YW5jZSA8PSBnZW9mZW5jZVJhZGl1cztcclxuICAgIH0pO1xyXG4gIH0sIFtkaXNwbGF5ZWRBaXJjcmFmdCwgZ2VvZmVuY2VDZW50ZXIsIGdlb2ZlbmNlUmFkaXVzLCBpc0dlb2ZlbmNlQWN0aXZlXSk7XHJcblxyXG4gIC8vIFRoZW4gc2VwYXJhdGVseSwgZGVmaW5lIGZpbHRlcmVkQWlyY3JhZnQgLSBkb24ndCB0cnkgdG8gZG8gYm90aCBpbiB0aGUgc2FtZSBmdW5jdGlvblxyXG4gIGNvbnN0IGZpbHRlcmVkQWlyY3JhZnQgPSB1c2VNZW1vKCgpID0+IHtcclxuICAgIHJldHVybiBpc0dlb2ZlbmNlQWN0aXZlICYmIGdlb2ZlbmNlQ2VudGVyXHJcbiAgICAgID8gZmlsdGVyQWlyY3JhZnRCeUdlb2ZlbmNlKClcclxuICAgICAgOiBkaXNwbGF5ZWRBaXJjcmFmdDtcclxuICB9LCBbXHJcbiAgICBpc0dlb2ZlbmNlQWN0aXZlLFxyXG4gICAgZ2VvZmVuY2VDZW50ZXIsXHJcbiAgICBmaWx0ZXJBaXJjcmFmdEJ5R2VvZmVuY2UsXHJcbiAgICBkaXNwbGF5ZWRBaXJjcmFmdCxcclxuICBdKTtcclxuXHJcbiAgLy8gUmVmcyBmb3IgdHJhY2tpbmcgc3Vic2NyaXB0aW9uc1xyXG4gIGNvbnN0IHVuc3Vic2NyaWJlQWlyY3JhZnRSZWYgPSB1c2VSZWY8KCgpID0+IHZvaWQpIHwgbnVsbD4obnVsbCk7XHJcbiAgY29uc3QgdW5zdWJzY3JpYmVTdGF0dXNSZWYgPSB1c2VSZWY8KCgpID0+IHZvaWQpIHwgbnVsbD4obnVsbCk7XHJcbiAgLy8gTG9hZCBwZXJzaXN0ZWQgYWlyY3JhZnQgZGF0YSBvbiBtb3VudFxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBjb25zdCBzYXZlZERhdGEgPSBsb2FkQWlyY3JhZnREYXRhKCk7XHJcbiAgICBpZiAoc2F2ZWREYXRhKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgIGBbRW5oYW5jZWRNYXBDb250ZXh0XSBMb2FkZWQgJHtPYmplY3Qua2V5cyhzYXZlZERhdGEpLmxlbmd0aH0gYWlyY3JhZnQgZnJvbSBwZXJzaXN0ZW5jZWBcclxuICAgICAgKTtcclxuICAgICAgc2V0Q2FjaGVkQWlyY3JhZnREYXRhKHNhdmVkRGF0YSk7XHJcbiAgICAgIHNldExhc3RQZXJzaXN0ZW5jZVVwZGF0ZShEYXRlLm5vdygpKTtcclxuICAgIH1cclxuICB9LCBbXSk7XHJcblxyXG4gIC8vIFNhdmUgYWlyY3JhZnQgZGF0YSB3aGVuIGNhY2hlZEFpcmNyYWZ0RGF0YSBjaGFuZ2VzXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmIChPYmplY3Qua2V5cyhjYWNoZWRBaXJjcmFmdERhdGEpLmxlbmd0aCA+IDApIHtcclxuICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgYFtFbmhhbmNlZE1hcENvbnRleHRdIFNhdmluZyAke09iamVjdC5rZXlzKGNhY2hlZEFpcmNyYWZ0RGF0YSkubGVuZ3RofSBhaXJjcmFmdCB0byBwZXJzaXN0ZW5jZWBcclxuICAgICAgKTtcclxuICAgICAgc2F2ZUFpcmNyYWZ0RGF0YShjYWNoZWRBaXJjcmFmdERhdGEpO1xyXG4gICAgfVxyXG4gIH0sIFtjYWNoZWRBaXJjcmFmdERhdGFdKTtcclxuXHJcbiAgLy8gSW5pdGlhbGl6ZSB0cmFja2luZyBzZXJ2aWNlIGFuZCBzdWJzY3JpcHRpb25zXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIC8vIFN1YnNjcmliZSB0byB0cmFja2luZyB1cGRhdGVzIHRoYXQgaW5jbHVkZSB0cmFpbCBkYXRhXHJcbiAgICBjb25zdCBoYW5kbGVUcmFja2luZ1VwZGF0ZSA9IChkYXRhOiBhbnkpID0+IHtcclxuICAgICAgLy8gT25seSB1cGRhdGUgZGlzcGxheWVkIGFpcmNyYWZ0IGlmIHdlJ3JlIG5vdCBpbiBnZW9mZW5jZSBtb2RlXHJcbiAgICAgIGlmICghaXNHZW9mZW5jZU1vZGUpIHtcclxuICAgICAgICB1cGRhdGVBaXJjcmFmdERpc3BsYXkoKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBTdWJzY3JpYmUgdG8gYWlyY3JhZnQgdXBkYXRlc1xyXG4gICAgdW5zdWJzY3JpYmVBaXJjcmFmdFJlZi5jdXJyZW50ID1cclxuICAgICAgb3BlblNreVRyYWNraW5nU2VydmljZS5zdWJzY3JpYmUoaGFuZGxlVHJhY2tpbmdVcGRhdGUpO1xyXG5cclxuICAgIC8vIFN1YnNjcmliZSB0byBzdGF0dXMgdXBkYXRlc1xyXG4gICAgdW5zdWJzY3JpYmVTdGF0dXNSZWYuY3VycmVudCA9IG9wZW5Ta3lUcmFja2luZ1NlcnZpY2Uuc3Vic2NyaWJlVG9TdGF0dXMoXHJcbiAgICAgIChzdGF0dXM6IHN0cmluZykgPT4ge1xyXG4gICAgICAgIHNldFRyYWNraW5nU3RhdHVzKHN0YXR1cyk7XHJcbiAgICAgICAgc2V0SXNMb2FkaW5nKG9wZW5Ta3lUcmFja2luZ1NlcnZpY2UuaXNMb2FkaW5nKCkpO1xyXG4gICAgICB9XHJcbiAgICApO1xyXG5cclxuICAgIC8vIElNUE9SVEFOVDogQ2xlYXIgYW55IGV4aXN0aW5nIHRyYWNraW5nIHdoZW4gY29tcG9uZW50IG1vdW50c1xyXG4gICAgb3BlblNreVRyYWNraW5nU2VydmljZS5zdG9wVHJhY2tpbmcoKTtcclxuXHJcbiAgICAvLyBDbGVhbnVwIG9uIHVubW91bnRcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIGlmICh1bnN1YnNjcmliZUFpcmNyYWZ0UmVmLmN1cnJlbnQpIHtcclxuICAgICAgICB1bnN1YnNjcmliZUFpcmNyYWZ0UmVmLmN1cnJlbnQoKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodW5zdWJzY3JpYmVTdGF0dXNSZWYuY3VycmVudCkge1xyXG4gICAgICAgIHVuc3Vic2NyaWJlU3RhdHVzUmVmLmN1cnJlbnQoKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9LCBbaXNHZW9mZW5jZU1vZGVdKTtcclxuXHJcbiAgLy8gVXBkYXRlIGFpcmNyYWZ0IGRhdGEgd2l0aCBwZXJzaXN0ZW5jZVxyXG4gIGNvbnN0IHVwZGF0ZUFpcmNyYWZ0RGF0YSA9IHVzZUNhbGxiYWNrKFxyXG4gICAgKG5ld0FpcmNyYWZ0QXJyYXk6IEV4dGVuZGVkQWlyY3JhZnRbXSkgPT4ge1xyXG4gICAgICAvLyBDb252ZXJ0IHRvIGEgbWFwIGZvciBlYXNpZXIgcHJvY2Vzc2luZ1xyXG4gICAgICBjb25zdCBuZXdBaXJjcmFmdE1hcDogUmVjb3JkPHN0cmluZywgQ2FjaGVkQWlyY3JhZnREYXRhPiA9IHt9O1xyXG5cclxuICAgICAgbmV3QWlyY3JhZnRBcnJheS5mb3JFYWNoKChhaXJjcmFmdCkgPT4ge1xyXG4gICAgICAgIGlmIChhaXJjcmFmdC5JQ0FPMjQpIHtcclxuICAgICAgICAgIG5ld0FpcmNyYWZ0TWFwW2FpcmNyYWZ0LklDQU8yNF0gPSB7XHJcbiAgICAgICAgICAgIC4uLmFpcmNyYWZ0LFxyXG4gICAgICAgICAgICAvLyBFbnN1cmUgcmVxdWlyZWQgZmllbGRzIGZvciBDYWNoZWRBaXJjcmFmdERhdGEgYXJlIHByZXNlbnRcclxuICAgICAgICAgICAgSUNBTzI0OiBhaXJjcmFmdC5JQ0FPMjQsXHJcbiAgICAgICAgICAgIGxhdGl0dWRlOiBhaXJjcmFmdC5sYXRpdHVkZSB8fCAwLFxyXG4gICAgICAgICAgICBsb25naXR1ZGU6IGFpcmNyYWZ0LmxvbmdpdHVkZSB8fCAwLFxyXG4gICAgICAgICAgICBhbHRpdHVkZTogYWlyY3JhZnQuYWx0aXR1ZGUgfHwgMCxcclxuICAgICAgICAgICAgdmVsb2NpdHk6IGFpcmNyYWZ0LnZlbG9jaXR5IHx8IDAsXHJcbiAgICAgICAgICAgIGhlYWRpbmc6IGFpcmNyYWZ0LmhlYWRpbmcgfHwgMCxcclxuICAgICAgICAgICAgb25fZ3JvdW5kOiBhaXJjcmFmdC5vbl9ncm91bmQgfHwgZmFsc2UsXHJcbiAgICAgICAgICAgIGxhc3RfY29udGFjdDogYWlyY3JhZnQubGFzdF9jb250YWN0IHx8IERhdGUubm93KCksXHJcbiAgICAgICAgICAgIGxhc3RTZWVuOiBEYXRlLm5vdygpLFxyXG4gICAgICAgICAgICBsYXN0VXBkYXRlZDogRGF0ZS5ub3coKSxcclxuICAgICAgICAgIH0gYXMgQ2FjaGVkQWlyY3JhZnREYXRhO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBNZXJnZSB3aXRoIGV4aXN0aW5nIGNhY2hlZCBkYXRhIHRvIHByZXNlcnZlIGZpZWxkc1xyXG4gICAgICBzZXRDYWNoZWRBaXJjcmFmdERhdGEoKGN1cnJlbnRDYWNoZSkgPT5cclxuICAgICAgICBtZXJnZUFpcmNyYWZ0RGF0YShjdXJyZW50Q2FjaGUsIG5ld0FpcmNyYWZ0TWFwKVxyXG4gICAgICApO1xyXG4gICAgICBzZXRMYXN0UGVyc2lzdGVuY2VVcGRhdGUoRGF0ZS5ub3coKSk7XHJcblxyXG4gICAgICAvLyBJZiB0aGUgc2VsZWN0ZWQgYWlyY3JhZnQgaXMgdXBkYXRlZCwgdXBkYXRlIHRoZSBzZWxlY3Rpb25cclxuICAgICAgaWYgKHNlbGVjdGVkQWlyY3JhZnQgJiYgbmV3QWlyY3JhZnRNYXBbc2VsZWN0ZWRBaXJjcmFmdC5JQ0FPMjRdKSB7XHJcbiAgICAgICAgY29uc3QgdXBkYXRlZEFpcmNyYWZ0ID0ge1xyXG4gICAgICAgICAgLi4uc2VsZWN0ZWRBaXJjcmFmdCxcclxuICAgICAgICAgIC4uLm5ld0FpcmNyYWZ0TWFwW3NlbGVjdGVkQWlyY3JhZnQuSUNBTzI0XSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHNldFNlbGVjdGVkQWlyY3JhZnQodXBkYXRlZEFpcmNyYWZ0IGFzIEV4dGVuZGVkQWlyY3JhZnQpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgW3NlbGVjdGVkQWlyY3JhZnRdXHJcbiAgKTtcclxuXHJcbiAgLy8gQ2xlYXIgcGVyc2lzdGVuY2UgY2FjaGVcclxuICBjb25zdCBjbGVhckNhY2hlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgY2xlYXJBaXJjcmFmdERhdGEoKTtcclxuICAgIHNldENhY2hlZEFpcmNyYWZ0RGF0YSh7fSk7XHJcbiAgICBzZXRMYXN0UGVyc2lzdGVuY2VVcGRhdGUobnVsbCk7XHJcbiAgICBzZXRUcmFja2luZ1N0YXR1cygnQ2FjaGUgY2xlYXJlZCcpO1xyXG4gIH0sIFtdKTtcclxuXHJcbiAgLy8gVXBkYXRlIGFpcmNyYWZ0IGRpc3BsYXkgYmFzZWQgb24gc2VsZWN0ZWQgTU9ERUxcclxuICBjb25zdCB1cGRhdGVBaXJjcmFmdERpc3BsYXkgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAvLyBHZXQgZXh0ZW5kZWQgYWlyY3JhZnQgYmFzZWQgb24gc2VsZWN0ZWQgTU9ERUxcclxuICAgIGNvbnN0IGV4dGVuZGVkQWlyY3JhZnQgPSBvcGVuU2t5VHJhY2tpbmdTZXJ2aWNlLmdldEV4dGVuZGVkQWlyY3JhZnQoXHJcbiAgICAgIHNlbGVjdGVkTW9kZWwgfHwgdW5kZWZpbmVkXHJcbiAgICApO1xyXG5cclxuICAgIC8vIEdldCBNT0RFTCBzdGF0cyBmcm9tIHRoZSBzZXJ2aWNlXHJcbiAgICBjb25zdCB7IG1vZGVscywgdG90YWxBY3RpdmU6IHRvdGFsIH0gPVxyXG4gICAgICBvcGVuU2t5VHJhY2tpbmdTZXJ2aWNlLmdldE1vZGVsU3RhdHMoKTtcclxuXHJcbiAgICAvLyBFbmhhbmNlIGFpcmNyYWZ0IGRhdGEgd2l0aCBwZXJzaXN0ZW5jZVxyXG4gICAgdXBkYXRlQWlyY3JhZnREYXRhKGV4dGVuZGVkQWlyY3JhZnQgYXMgRXh0ZW5kZWRBaXJjcmFmdFtdKTtcclxuXHJcbiAgICAvLyBPbmx5IHVwZGF0ZSBkaXNwbGF5ZWQgYWlyY3JhZnQgaWYgd2UncmUgbm90IGluIGdlb2ZlbmNlIG1vZGVcclxuICAgIGlmICghaXNHZW9mZW5jZU1vZGUpIHtcclxuICAgICAgc2V0RGlzcGxheWVkQWlyY3JhZnQoZXh0ZW5kZWRBaXJjcmFmdCBhcyBFeHRlbmRlZEFpcmNyYWZ0W10pO1xyXG4gICAgICBzZXRBY3RpdmVNb2RlbHMobW9kZWxzKTtcclxuICAgICAgc2V0VG90YWxBY3RpdmUodG90YWwpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldElzTG9hZGluZyhvcGVuU2t5VHJhY2tpbmdTZXJ2aWNlLmlzTG9hZGluZygpKTtcclxuICB9LCBbc2VsZWN0ZWRNb2RlbCwgdXBkYXRlQWlyY3JhZnREYXRhLCBpc0dlb2ZlbmNlTW9kZV0pO1xyXG5cclxuICAvLyBVcGRhdGUgZGlzcGxheSB3aGVuIE1PREVMIHNlbGVjdGlvbiBjaGFuZ2VzXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIHVwZGF0ZUFpcmNyYWZ0RGlzcGxheSgpO1xyXG4gIH0sIFtzZWxlY3RlZE1vZGVsLCB1cGRhdGVBaXJjcmFmdERpc3BsYXldKTtcclxuXHJcbiAgLy8gTmV3IGZ1bmN0aW9uIHRvIGhhbmRsZSBnZW9mZW5jZSBhaXJjcmFmdCB1cGRhdGVzXHJcbiAgY29uc3QgdXBkYXRlR2VvZmVuY2VBaXJjcmFmdCA9IHVzZUNhbGxiYWNrKFxyXG4gICAgKGdlb2ZlbmNlQWlyY3JhZnQ6IEV4dGVuZGVkQWlyY3JhZnRbXSkgPT4ge1xyXG4gICAgICAvLyBNYXJrIHRoYXQgd2UncmUgaW4gZ2VvZmVuY2UgbW9kZVxyXG4gICAgICBzZXRJc0dlb2ZlbmNlTW9kZSh0cnVlKTtcclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgIGBbRW5oYW5jZWRNYXBDb250ZXh0XSBVcGRhdGluZyAke2dlb2ZlbmNlQWlyY3JhZnQubGVuZ3RofSBhaXJjcmFmdCBmcm9tIGdlb2ZlbmNlYFxyXG4gICAgICApO1xyXG5cclxuICAgICAgLy8gVXBkYXRlIHRoZSBjYWNoZWQgZGF0YSAoc2FtZSBhcyByZWd1bGFyIHVwZGF0ZXMpXHJcbiAgICAgIHVwZGF0ZUFpcmNyYWZ0RGF0YShnZW9mZW5jZUFpcmNyYWZ0KTtcclxuXHJcbiAgICAgIC8vIEFsc28gZGlyZWN0bHkgdXBkYXRlIHRoZSBkaXNwbGF5ZWQgYWlyY3JhZnRcclxuICAgICAgc2V0RGlzcGxheWVkQWlyY3JhZnQoZ2VvZmVuY2VBaXJjcmFmdCk7XHJcblxyXG4gICAgICAvLyBVcGRhdGUgc3RhdHNcclxuICAgICAgc2V0VG90YWxBY3RpdmUoZ2VvZmVuY2VBaXJjcmFmdC5sZW5ndGgpO1xyXG5cclxuICAgICAgLy8gRXh0cmFjdCBNT0RFTCBzdGF0cyBmb3IgdGhlIHNpZGViYXJcclxuICAgICAgY29uc3QgbW9kZWxDb3VudHMgPSBnZW9mZW5jZUFpcmNyYWZ0LnJlZHVjZShcclxuICAgICAgICAoYWNjLCBhaXJjcmFmdCkgPT4ge1xyXG4gICAgICAgICAgY29uc3QgTU9ERUwgPSBhaXJjcmFmdC5NT0RFTCB8fCBhaXJjcmFmdC5UWVBFX0FJUkNSQUZUIHx8ICdVbmtub3duJztcclxuICAgICAgICAgIGlmICghYWNjW01PREVMXSkge1xyXG4gICAgICAgICAgICBhY2NbTU9ERUxdID0ge1xyXG4gICAgICAgICAgICAgIE1PREVMLFxyXG4gICAgICAgICAgICAgIGNvdW50OiAwLFxyXG4gICAgICAgICAgICAgIE1BTlVGQUNUVVJFUjogYWlyY3JhZnQuTUFOVUZBQ1RVUkVSIHx8ICdVbmtub3duJyxcclxuICAgICAgICAgICAgICAvLyBBZGQgcmVxdWlyZWQgcHJvcGVydGllcyBmb3IgQWlyY3JhZnRNb2RlbFxyXG4gICAgICAgICAgICAgIGxhYmVsOiBNT0RFTCxcclxuICAgICAgICAgICAgICBhY3RpdmVDb3VudDogMCxcclxuICAgICAgICAgICAgICB0b3RhbENvdW50OiAwLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYWNjW01PREVMXS5jb3VudCsrO1xyXG4gICAgICAgICAgYWNjW01PREVMXS5hY3RpdmVDb3VudCsrO1xyXG4gICAgICAgICAgYWNjW01PREVMXS50b3RhbENvdW50Kys7XHJcbiAgICAgICAgICByZXR1cm4gYWNjO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge30gYXMgUmVjb3JkPHN0cmluZywgQWlyY3JhZnRNb2RlbD5cclxuICAgICAgKTtcclxuXHJcbiAgICAgIC8vIENvbnZlcnQgdG8gYXJyYXkgZm9yIHRoZSBhY3RpdmVNb2RlbHMgc3RhdGVcclxuICAgICAgY29uc3QgbW9kZWxBcnJheSA9IE9iamVjdC52YWx1ZXMobW9kZWxDb3VudHMpLm1hcCgoTU9ERUwpID0+ICh7XHJcbiAgICAgICAgTU9ERUw6IE1PREVMLk1PREVMLFxyXG4gICAgICAgIGNvdW50OiBNT0RFTC5jb3VudCxcclxuICAgICAgICBNQU5VRkFDVFVSRVI6IE1PREVMLk1BTlVGQUNUVVJFUixcclxuICAgICAgICAvLyBBZGQgcmVxdWlyZWQgcHJvcGVydGllcyBmb3IgQWlyY3JhZnRNb2RlbCB0eXBlXHJcbiAgICAgICAgbGFiZWw6IE1PREVMLk1PREVMLFxyXG4gICAgICAgIGFjdGl2ZUNvdW50OiBNT0RFTC5jb3VudCxcclxuICAgICAgICB0b3RhbENvdW50OiBNT0RFTC5jb3VudCxcclxuICAgICAgfSkpO1xyXG5cclxuICAgICAgc2V0QWN0aXZlTW9kZWxzKG1vZGVsQXJyYXkpO1xyXG5cclxuICAgICAgLy8gVXBkYXRlIHRoZSBsYXN0IHJlZnJlc2hlZCB0aW1lc3RhbXBcclxuICAgICAgc2V0TGFzdFJlZnJlc2hlZChuZXcgRGF0ZSgpLnRvTG9jYWxlVGltZVN0cmluZygpKTtcclxuICAgIH0sXHJcbiAgICBbdXBkYXRlQWlyY3JhZnREYXRhXVxyXG4gICk7XHJcblxyXG4gIC8vIEhhbmRsZSBNQU5VRkFDVFVSRVIgc2VsZWN0aW9uXHJcbiAgLy8gSW4geW91ciBFbmhhbmNlZE1hcENvbnRleHQudHN4IC0gbW9kaWZ5IHRoZSBzZWxlY3RNYW51ZmFjdHVyZXIgZnVuY3Rpb25cclxuXHJcbiAgY29uc3Qgc2VsZWN0TWFudWZhY3R1cmVyID0gYXN5bmMgKE1BTlVGQUNUVVJFUjogc3RyaW5nIHwgbnVsbCkgPT4ge1xyXG4gICAgLy8gRXhpdCBnZW9mZW5jZSBtb2RlIHdoZW4gc2VsZWN0aW5nIGEgTUFOVUZBQ1RVUkVSXHJcbiAgICBzZXRJc0dlb2ZlbmNlTW9kZShmYWxzZSk7XHJcbiAgICBzZXRTZWxlY3RlZE1hbnVmYWN0dXJlcihNQU5VRkFDVFVSRVIpO1xyXG4gICAgc2V0U2VsZWN0ZWRNb2RlbChudWxsKTtcclxuICAgIHNldElzTG9hZGluZyh0cnVlKTtcclxuICAgIHNldExhc3RSZWZyZXNoZWQobnVsbCk7XHJcblxyXG4gICAgLy8gQ2xlYXIgcHJldmlvdXMgZGF0YVxyXG4gICAgc2V0RGlzcGxheWVkQWlyY3JhZnQoW10pO1xyXG4gICAgc2V0QWN0aXZlTW9kZWxzKFtdKTtcclxuICAgIHNldFRvdGFsQWN0aXZlKDApO1xyXG5cclxuICAgIC8vIElmIG51bGwsIGp1c3QgZXhpdFxyXG4gICAgaWYgKE1BTlVGQUNUVVJFUiA9PT0gbnVsbCkge1xyXG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSWYgd2UncmUgYmxvY2tpbmcgQVBJIGNhbGxzLCBleGl0IGVhcmx5XHJcbiAgICBpZiAoaXNNYW51ZmFjdHVyZXJBcGlCbG9ja2VkKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgIGBbRW5oYW5jZWRNYXBDb250ZXh0XSBBUEkgY2FsbHMgYmxvY2tlZCBmb3IgbWFudWZhY3R1cmVyOiAke01BTlVGQUNUVVJFUn1gXHJcbiAgICAgICk7XHJcbiAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBTdGFydCB0cmFja2luZyB3aXRoIGEgcHJvZ3Jlc3MgaGFuZGxlclxyXG4gICAgICBzZXRUcmFja2luZ1N0YXR1cyhgTG9hZGluZyBhaXJjcmFmdCBmb3IgJHtNQU5VRkFDVFVSRVJ9Li4uYCk7XHJcblxyXG4gICAgICAvLyBVc2UgdGhlIGV4aXN0aW5nIHNlcnZpY2UgYnV0IHdpdGggYSBwcm9ncmVzcyBjYWxsYmFja1xyXG4gICAgICAvLyBJbiBFbmhhbmNlZE1hcENvbnRleHQudHN4LCBtb2RpZnkgeW91ciBjYWxsYmFjayB0byBoYW5kbGUgYm90aCB0eXBlczpcclxuXHJcbiAgICAgIGF3YWl0IG9wZW5Ta3lUcmFja2luZ1NlcnZpY2UudHJhY2tNYW51ZmFjdHVyZXJXaXRoUHJvZ3Jlc3MoXHJcbiAgICAgICAgTUFOVUZBQ1RVUkVSLFxyXG4gICAgICAgIChwcm9ncmVzcykgPT4ge1xyXG4gICAgICAgICAgLy8gVXBkYXRlIHRoZSB0cmFja2luZyBzdGF0dXMgbWVzc2FnZVxyXG4gICAgICAgICAgaWYgKHByb2dyZXNzLm1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgc2V0VHJhY2tpbmdTdGF0dXMocHJvZ3Jlc3MubWVzc2FnZSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gVXBkYXRlIGRpc3BsYXllZCBhaXJjcmFmdCBhcyB0aGV5J3JlIGxvYWRlZFxyXG4gICAgICAgICAgaWYgKHByb2dyZXNzLmFpcmNyYWZ0KSB7XHJcbiAgICAgICAgICAgIC8vIENhc3QgdGhlIGFpcmNyYWZ0IGFycmF5IHRvIEV4dGVuZGVkQWlyY3JhZnRbXSBzaW5jZSBvdXIgY29udGV4dCB1c2VzIHRoYXQgdHlwZVxyXG4gICAgICAgICAgICBzZXREaXNwbGF5ZWRBaXJjcmFmdChwcm9ncmVzcy5haXJjcmFmdCBhcyBFeHRlbmRlZEFpcmNyYWZ0W10pO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFVwZGF0ZSBtb2RlbCBzdGF0c1xyXG4gICAgICAgICAgaWYgKHByb2dyZXNzLm1vZGVscykge1xyXG4gICAgICAgICAgICBzZXRBY3RpdmVNb2RlbHMocHJvZ3Jlc3MubW9kZWxzKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBVcGRhdGUgdG90YWwgY291bnRcclxuICAgICAgICAgIGlmIChwcm9ncmVzcy50b3RhbCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHNldFRvdGFsQWN0aXZlKHByb2dyZXNzLnRvdGFsKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICk7XHJcblxyXG4gICAgICBzZXRMYXN0UmVmcmVzaGVkKG5ldyBEYXRlKCkudG9Mb2NhbGVUaW1lU3RyaW5nKCkpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgb25FcnJvcihcclxuICAgICAgICBgRXJyb3IgdHJhY2tpbmcgbWFudWZhY3R1cmVyOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWBcclxuICAgICAgKTtcclxuICAgICAgc2V0VHJhY2tpbmdTdGF0dXMoJ0Vycm9yIGxvYWRpbmcgYWlyY3JhZnQgZGF0YScpO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvLyBIYW5kbGUgTU9ERUwgc2VsZWN0aW9uXHJcbiAgY29uc3Qgc2VsZWN0TW9kZWwgPSAoTU9ERUw6IHN0cmluZyB8IG51bGwpID0+IHtcclxuICAgIHNldFNlbGVjdGVkTW9kZWwoTU9ERUwpO1xyXG4gIH07XHJcblxyXG4gIC8vIEhhbmRsZSBhaXJjcmFmdCBzZWxlY3Rpb25cclxuICBjb25zdCBzZWxlY3RBaXJjcmFmdCA9IChhaXJjcmFmdDogRXh0ZW5kZWRBaXJjcmFmdCB8IG51bGwpID0+IHtcclxuICAgIHNldFNlbGVjdGVkQWlyY3JhZnQoYWlyY3JhZnQpO1xyXG5cclxuICAgIC8vIElmIHNlbGVjdGluZyBhbiBhaXJjcmFmdCwgY2hlY2sgaWYgd2UgaGF2ZSBjYWNoZWQgZGF0YSB0byBlbmhhbmNlIGl0XHJcbiAgICBpZiAoYWlyY3JhZnQgJiYgYWlyY3JhZnQuSUNBTzI0ICYmIGNhY2hlZEFpcmNyYWZ0RGF0YVthaXJjcmFmdC5JQ0FPMjRdKSB7XHJcbiAgICAgIGNvbnN0IGVuaGFuY2VkQWlyY3JhZnQgPSB7XHJcbiAgICAgICAgLi4uYWlyY3JhZnQsXHJcbiAgICAgICAgLi4uY2FjaGVkQWlyY3JhZnREYXRhW2FpcmNyYWZ0LklDQU8yNF0sXHJcbiAgICAgIH07XHJcbiAgICAgIHNldFNlbGVjdGVkQWlyY3JhZnQoZW5oYW5jZWRBaXJjcmFmdCBhcyBFeHRlbmRlZEFpcmNyYWZ0KTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvLyBJZiB5b3UgZG9uJ3QgYWxyZWFkeSBoYXZlIGl0LCBhZGQgdGhpcyBmdW5jdGlvbiB0byBleHBvc2UgdGhlIG1hcCdzIGdldEJvdW5kc0J5UmVnaW9uIGZ1bmN0aW9uXHJcbiAgLy8gQ3JlYXRlIGEgd3JhcHBlZCBmdW5jdGlvbiB0aGF0IGNhbGxzIHlvdXIgbWFwIGNvbmZpZyBmdW5jdGlvblxyXG4gIGNvbnN0IGhhbmRsZUdldEJvdW5kc0J5UmVnaW9uID0gdXNlQ2FsbGJhY2soXHJcbiAgICAocmVnaW9uOiBzdHJpbmcpOiBMYXRMbmdCb3VuZHNFeHByZXNzaW9uID0+IHtcclxuICAgICAgcmV0dXJuIGNvbmZpZ0dldEJvdW5kc0J5UmVnaW9uKHJlZ2lvbik7XHJcbiAgICB9LFxyXG4gICAgW11cclxuICApO1xyXG5cclxuICAvLyBSZXNldCBhbGwgc2VsZWN0aW9uc1xyXG4gIGNvbnN0IHJlc2V0ID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgYXdhaXQgc2VsZWN0TWFudWZhY3R1cmVyKG51bGwpO1xyXG4gIH07XHJcblxyXG4gIC8vIE1ldGhvZCB0byByZWZyZXNoIG9ubHkgdGhlIHBvc2l0aW9ucyBvZiBhY3RpdmUgYWlyY3JhZnRcclxuICBjb25zdCByZWZyZXNoUG9zaXRpb25zID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgaWYgKGlzUmVmcmVzaGluZyB8fCAoIXNlbGVjdGVkTWFudWZhY3R1cmVyICYmICFpc0dlb2ZlbmNlTW9kZSkpIHJldHVybjtcclxuXHJcbiAgICBzZXRJc1JlZnJlc2hpbmcodHJ1ZSk7XHJcbiAgICBzZXRUcmFja2luZ1N0YXR1cygnVXBkYXRpbmcgYWlyY3JhZnQgcG9zaXRpb25zLi4uJyk7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gQ2FsbCB0aGUgc2VydmljZVxyXG4gICAgICBhd2FpdCBvcGVuU2t5VHJhY2tpbmdTZXJ2aWNlLnJlZnJlc2hQb3NpdGlvbnNPbmx5KCk7XHJcblxyXG4gICAgICBzZXRMYXN0UmVmcmVzaGVkKG5ldyBEYXRlKCkudG9Mb2NhbGVUaW1lU3RyaW5nKCkpO1xyXG4gICAgICBzZXRUcmFja2luZ1N0YXR1cyhcclxuICAgICAgICBgUG9zaXRpb25zIHVwZGF0ZWQgZm9yICR7ZGlzcGxheWVkQWlyY3JhZnQubGVuZ3RofSBhaXJjcmFmdGBcclxuICAgICAgKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIG9uRXJyb3IoXHJcbiAgICAgICAgYEVycm9yIHJlZnJlc2hpbmcgcG9zaXRpb25zOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWBcclxuICAgICAgKTtcclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgIHNldElzUmVmcmVzaGluZyhmYWxzZSk7XHJcbiAgICAgIH0sIDUwMCk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLy8gTWV0aG9kIGZvciBmdWxsIHRyYWNraW5nIHJlZnJlc2hcclxuICBjb25zdCBmdWxsUmVmcmVzaCA9IGFzeW5jICgpID0+IHtcclxuICAgIGlmICgoIXNlbGVjdGVkTWFudWZhY3R1cmVyICYmICFpc0dlb2ZlbmNlTW9kZSkgfHwgaXNSZWZyZXNoaW5nKSByZXR1cm47XHJcblxyXG4gICAgLy8gU2V0IGEgdGltZW91dCB0byBmb3JjZSBleGl0IGZyb20gbG9hZGluZyBzdGF0ZSBhZnRlciAxMCBzZWNvbmRzXHJcbiAgICAvLyBUaGlzIGlzIGEgc2FmZXR5IG1lY2hhbmlzbVxyXG4gICAgY29uc3Qgc2FmZXR5VGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICBzZXRJc1JlZnJlc2hpbmcoZmFsc2UpO1xyXG4gICAgICBzZXRUcmFja2luZ1N0YXR1cygnUmVmcmVzaCB0aW1lZCBvdXQnKTtcclxuICAgIH0sIDEwMDAwKTtcclxuXHJcbiAgICBzZXRJc1JlZnJlc2hpbmcodHJ1ZSk7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gR2V0IGN1cnJlbnRseSB0cmFja2VkIGFpcmNyYWZ0XHJcbiAgICAgIGNvbnN0IGFsbFRyYWNrZWRBaXJjcmFmdCA9IG9wZW5Ta3lUcmFja2luZ1NlcnZpY2UuZ2V0VHJhY2tlZEFpcmNyYWZ0KCk7XHJcblxyXG4gICAgICAvLyBHZXQgYWN0aXZlIGFpcmNyYWZ0ICh0aG9zZSB3aXRoIHBvc2l0aW9uIGRhdGEpXHJcbiAgICAgIGNvbnN0IGFjdGl2ZUFpcmNyYWZ0ID0gYWxsVHJhY2tlZEFpcmNyYWZ0LmZpbHRlcihcclxuICAgICAgICAoYWlyY3JhZnQpID0+IGFpcmNyYWZ0LklDQU8yNCAmJiBhaXJjcmFmdC5sYXRpdHVkZSAmJiBhaXJjcmFmdC5sb25naXR1ZGVcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGNvbnN0IG5lZWRzRnVsbFJlZnJlc2ggPVxyXG4gICAgICAgICFsYXN0RnVsbFJlZnJlc2hUaW1lIHx8IERhdGUubm93KCkgLSBsYXN0RnVsbFJlZnJlc2hUaW1lID4gMzYwMDAwMDtcclxuXHJcbiAgICAgIGxldCBzdWNjZXNzID0gZmFsc2U7XHJcblxyXG4gICAgICBpZiAoYWN0aXZlQWlyY3JhZnQubGVuZ3RoID09PSAwIHx8IG5lZWRzRnVsbFJlZnJlc2gpIHtcclxuICAgICAgICAvLyBEbyBhIGZ1bGwgcmVmcmVzaFxyXG4gICAgICAgIHNldFRyYWNraW5nU3RhdHVzKCdQZXJmb3JtaW5nIGZ1bGwgcmVmcmVzaC4uLicpO1xyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgYXdhaXQgb3BlblNreVRyYWNraW5nU2VydmljZS5yZWZyZXNoTm93KCk7XHJcbiAgICAgICAgICBzZXRMYXN0RnVsbFJlZnJlc2hUaW1lKERhdGUubm93KCkpO1xyXG4gICAgICAgICAgc3VjY2VzcyA9IHRydWU7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIC8vIFNpbGVudGx5IGhhbmRsZSB0aGlzIGVycm9yXHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ0Z1bGwgcmVmcmVzaCBmYWlsZWQnKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gRG8gYW4gb3B0aW1pemVkIHJlZnJlc2hcclxuICAgICAgICBjb25zdCBhY3RpdmVJY2FvcyA9IGFjdGl2ZUFpcmNyYWZ0XHJcbiAgICAgICAgICAubWFwKChhaXJjcmFmdCkgPT4gYWlyY3JhZnQuSUNBTzI0KVxyXG4gICAgICAgICAgLmZpbHRlcihCb29sZWFuKSBhcyBzdHJpbmdbXTtcclxuXHJcbiAgICAgICAgaWYgKGFjdGl2ZUljYW9zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIHNldFRyYWNraW5nU3RhdHVzKFxyXG4gICAgICAgICAgICBgUmVmcmVzaGluZyAke2FjdGl2ZUljYW9zLmxlbmd0aH0gYWN0aXZlIGFpcmNyYWZ0Li4uYFxyXG4gICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBhd2FpdCBvcGVuU2t5VHJhY2tpbmdTZXJ2aWNlLnJlZnJlc2hTcGVjaWZpY0FpcmNyYWZ0KGFjdGl2ZUljYW9zKTtcclxuICAgICAgICAgICAgc3VjY2VzcyA9IHRydWU7XHJcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAvLyBUcnkgZmFsbGluZyBiYWNrIHRvIGEgZnVsbCByZWZyZXNoXHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignT3B0aW1pemVkIHJlZnJlc2ggZmFpbGVkLCB0cnlpbmcgZnVsbCByZWZyZXNoJyk7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgYXdhaXQgb3BlblNreVRyYWNraW5nU2VydmljZS5yZWZyZXNoTm93KCk7XHJcbiAgICAgICAgICAgICAgc2V0TGFzdEZ1bGxSZWZyZXNoVGltZShEYXRlLm5vdygpKTtcclxuICAgICAgICAgICAgICBzdWNjZXNzID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZmFsbGJhY2tFcnJvcikge1xyXG4gICAgICAgICAgICAgIC8vIFNpbGVudGx5IGhhbmRsZSB0aGlzIGVycm9yXHJcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdGYWxsYmFjayByZWZyZXNoIGZhaWxlZCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBjbGVhclRpbWVvdXQoc2FmZXR5VGltZW91dCk7XHJcblxyXG4gICAgICAvLyBPbmx5IHVwZGF0ZSBpZiB0aGUgcmVmcmVzaCB3YXMgc3VjY2Vzc2Z1bFxyXG4gICAgICBpZiAoc3VjY2Vzcykge1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRDb3VudCA9IG9wZW5Ta3lUcmFja2luZ1NlcnZpY2UuZ2V0VHJhY2tlZEFpcmNyYWZ0KCkubGVuZ3RoO1xyXG4gICAgICAgIHNldFRyYWNraW5nU3RhdHVzKGBSZWZyZXNoIGNvbXBsZXRlZCB3aXRoICR7Y3VycmVudENvdW50fSBhaXJjcmFmdGApO1xyXG4gICAgICAgIHNldExhc3RSZWZyZXNoZWQobmV3IERhdGUoKS50b0xvY2FsZVRpbWVTdHJpbmcoKSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc2V0VHJhY2tpbmdTdGF0dXMoJ1JlZnJlc2ggZmFpbGVkJyk7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNsZWFyVGltZW91dChzYWZldHlUaW1lb3V0KTtcclxuXHJcbiAgICAgIC8vIE9ubHkgc2hvdyBlcnJvcnMgdG8gdGhlIHVzZXIgaWYgdGhleSBhcHBlYXIgdG8gYmUgc2lnbmlmaWNhbnRcclxuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubWVzc2FnZSAhPT0gJ2Fib3J0ZWQnKSB7XHJcbiAgICAgICAgb25FcnJvcihgRXJyb3IgZHVyaW5nIHJlZnJlc2g6ICR7ZXJyb3IubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcid9YCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHNldFRyYWNraW5nU3RhdHVzKCdFcnJvciBkdXJpbmcgcmVmcmVzaCcpO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgY2xlYXJUaW1lb3V0KHNhZmV0eVRpbWVvdXQpO1xyXG4gICAgICBzZXRJc1JlZnJlc2hpbmcoZmFsc2UpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGNvbnN0IGNsZWFyR2VvZmVuY2VEYXRhID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgLy8gUmVzZXQgZ2VvZmVuY2UgbW9kZSBmbGFnXHJcbiAgICBzZXRJc0dlb2ZlbmNlTW9kZShmYWxzZSk7XHJcblxyXG4gICAgLy8gQ2xlYXIgZGlzcGxheWVkIGFpcmNyYWZ0XHJcbiAgICBzZXREaXNwbGF5ZWRBaXJjcmFmdChbXSk7XHJcbiAgICBzZXRBY3RpdmVNb2RlbHMoW10pO1xyXG4gICAgc2V0VG90YWxBY3RpdmUoMCk7XHJcblxyXG4gICAgLy8gSWYgdGhlcmUgd2FzIGEgcHJldmlvdXNseSBzZWxlY3RlZCBNQU5VRkFDVFVSRVIsIHdlIGNhbiByZXN0b3JlIGl0XHJcbiAgICBpZiAoc2VsZWN0ZWRNYW51ZmFjdHVyZXIpIHtcclxuICAgICAgLy8gU21hbGwgZGVsYXkgdG8gZW5zdXJlIHN0YXRlIHVwZGF0ZXMgcHJvcGVybHlcclxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgb3BlblNreVRyYWNraW5nU2VydmljZS50cmFja01hbnVmYWN0dXJlcihzZWxlY3RlZE1hbnVmYWN0dXJlcik7XHJcbiAgICAgIH0sIDEwMCk7XHJcbiAgICB9XHJcbiAgfSwgW3NlbGVjdGVkTWFudWZhY3R1cmVyXSk7XHJcblxyXG4gIC8vIENyZWF0ZSBjb250ZXh0IHZhbHVlXHJcbiAgY29uc3QgY29udGV4dFZhbHVlOiBFbmhhbmNlZE1hcENvbnRleHRUeXBlID0ge1xyXG4gICAgbWFwSW5zdGFuY2UsXHJcbiAgICBzZXRNYXBJbnN0YW5jZSxcclxuICAgIHpvb21MZXZlbCxcclxuICAgIHNldFpvb21MZXZlbCxcclxuXHJcbiAgICBkaXNwbGF5ZWRBaXJjcmFmdCxcclxuICAgIHNlbGVjdGVkQWlyY3JhZnQsXHJcbiAgICBzZWxlY3RBaXJjcmFmdCxcclxuXHJcbiAgICAvLyBEYXRhIHBlcnNpc3RlbmNlXHJcbiAgICBjYWNoZWRBaXJjcmFmdERhdGEsXHJcbiAgICB1cGRhdGVBaXJjcmFmdERhdGEsXHJcbiAgICBsYXN0UGVyc2lzdGVuY2VVcGRhdGUsXHJcblxyXG4gICAgc2VsZWN0ZWRNYW51ZmFjdHVyZXIsXHJcbiAgICBzZWxlY3RlZE1vZGVsLFxyXG4gICAgYWN0aXZlTW9kZWxzLFxyXG4gICAgdG90YWxBY3RpdmUsXHJcblxyXG4gICAgaXNMb2FkaW5nLFxyXG4gICAgaXNSZWZyZXNoaW5nLFxyXG4gICAgdHJhY2tpbmdTdGF0dXMsXHJcbiAgICBsYXN0UmVmcmVzaGVkLFxyXG5cclxuICAgIHNlbGVjdE1hbnVmYWN0dXJlcixcclxuICAgIHNlbGVjdE1vZGVsLFxyXG4gICAgcmVzZXQsXHJcbiAgICByZWZyZXNoUG9zaXRpb25zLFxyXG4gICAgZnVsbFJlZnJlc2gsXHJcbiAgICBjbGVhckNhY2hlLFxyXG4gICAgY2xlYXJHZW9mZW5jZURhdGEsXHJcbiAgICB1cGRhdGVHZW9mZW5jZUFpcmNyYWZ0LFxyXG4gICAgZmlsdGVyZWRBaXJjcmFmdCxcclxuXHJcbiAgICBmaWx0ZXJNb2RlLFxyXG4gICAgc2V0RmlsdGVyTW9kZSxcclxuICAgIGJsb2NrTWFudWZhY3R1cmVyQXBpQ2FsbHMsXHJcbiAgICBzZXRCbG9ja01hbnVmYWN0dXJlckFwaUNhbGxzLFxyXG4gICAgaXNNYW51ZmFjdHVyZXJBcGlCbG9ja2VkLFxyXG4gICAgc2V0SXNNYW51ZmFjdHVyZXJBcGlCbG9ja2VkLFxyXG5cclxuICAgIC8vIEdlb2ZlbmNpbmcgcHJvcGVydGllc1xyXG4gICAgZ2VvZmVuY2VDZW50ZXIsXHJcbiAgICBnZW9mZW5jZVJhZGl1cyxcclxuICAgIGlzR2VvZmVuY2VBY3RpdmUsXHJcbiAgICBnZW9mZW5jZUNvb3JkaW5hdGVzLFxyXG4gICAgc2V0R2VvZmVuY2VDZW50ZXIsXHJcbiAgICBzZXRHZW9mZW5jZVJhZGl1cyxcclxuICAgIHRvZ2dsZUdlb2ZlbmNlLFxyXG4gICAgY2xlYXJHZW9mZW5jZSxcclxuICAgIGlzR2VvZmVuY2VQbGFjZW1lbnRNb2RlLFxyXG4gICAgc2V0SXNHZW9mZW5jZVBsYWNlbWVudE1vZGUsXHJcblxyXG4gICAgLy8gUmVnaW9uIHNlbGVjdGlvblxyXG4gICAgc2VsZWN0ZWRSZWdpb24sXHJcbiAgICBzZXRTZWxlY3RlZFJlZ2lvbixcclxuICAgIGdldEJvdW5kc0J5UmVnaW9uOiBoYW5kbGVHZXRCb3VuZHNCeVJlZ2lvbixcclxuICB9O1xyXG5cclxuICByZXR1cm4gKFxyXG4gICAgPEVuaGFuY2VkTWFwQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17Y29udGV4dFZhbHVlfT5cclxuICAgICAge2NoaWxkcmVufVxyXG4gICAgPC9FbmhhbmNlZE1hcENvbnRleHQuUHJvdmlkZXI+XHJcbiAgKTtcclxufTtcclxuXHJcbi8vIEN1c3RvbSBob29rIHRvIHVzZSB0aGUgY29udGV4dFxyXG5leHBvcnQgY29uc3QgdXNlRW5oYW5jZWRNYXBDb250ZXh0ID0gKCkgPT4gdXNlQ29udGV4dChFbmhhbmNlZE1hcENvbnRleHQpO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgRW5oYW5jZWRNYXBDb250ZXh0O1xyXG4iXSwibmFtZXMiOlsiUmVhY3QiLCJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlQ2FsbGJhY2siLCJ1c2VSZWYiLCJ1c2VNZW1vIiwiUmVnaW9uQ29kZSIsIm9wZW5Ta3lUcmFja2luZ1NlcnZpY2UiLCJzYXZlQWlyY3JhZnREYXRhIiwibG9hZEFpcmNyYWZ0RGF0YSIsIm1lcmdlQWlyY3JhZnREYXRhIiwiY2xlYXJBaXJjcmFmdERhdGEiLCJnZXRCb3VuZHNCeVJlZ2lvbiIsImNvbmZpZ0dldEJvdW5kc0J5UmVnaW9uIiwiRW5oYW5jZWRNYXBDb250ZXh0IiwibWFwSW5zdGFuY2UiLCJzZXRNYXBJbnN0YW5jZSIsInpvb21MZXZlbCIsInNldFpvb21MZXZlbCIsImRpc3BsYXllZEFpcmNyYWZ0Iiwic2VsZWN0ZWRBaXJjcmFmdCIsInNlbGVjdEFpcmNyYWZ0IiwiY2FjaGVkQWlyY3JhZnREYXRhIiwidXBkYXRlQWlyY3JhZnREYXRhIiwibGFzdFBlcnNpc3RlbmNlVXBkYXRlIiwic2VsZWN0ZWRNYW51ZmFjdHVyZXIiLCJzZWxlY3RlZE1vZGVsIiwiYWN0aXZlTW9kZWxzIiwidG90YWxBY3RpdmUiLCJpc0xvYWRpbmciLCJpc1JlZnJlc2hpbmciLCJ0cmFja2luZ1N0YXR1cyIsImxhc3RSZWZyZXNoZWQiLCJzZWxlY3RNYW51ZmFjdHVyZXIiLCJzZWxlY3RNb2RlbCIsInJlc2V0IiwicmVmcmVzaFBvc2l0aW9ucyIsImZ1bGxSZWZyZXNoIiwiY2xlYXJDYWNoZSIsImNsZWFyR2VvZmVuY2VEYXRhIiwidXBkYXRlR2VvZmVuY2VBaXJjcmFmdCIsImZpbHRlck1vZGUiLCJzZXRGaWx0ZXJNb2RlIiwiYmxvY2tNYW51ZmFjdHVyZXJBcGlDYWxscyIsInNldEJsb2NrTWFudWZhY3R1cmVyQXBpQ2FsbHMiLCJpc01hbnVmYWN0dXJlckFwaUJsb2NrZWQiLCJzZXRJc01hbnVmYWN0dXJlckFwaUJsb2NrZWQiLCJnZW9mZW5jZUNlbnRlciIsImdlb2ZlbmNlUmFkaXVzIiwiaXNHZW9mZW5jZUFjdGl2ZSIsInNldEdlb2ZlbmNlQ2VudGVyIiwic2V0R2VvZmVuY2VSYWRpdXMiLCJnZW9mZW5jZUNvb3JkaW5hdGVzIiwidG9nZ2xlR2VvZmVuY2UiLCJjbGVhckdlb2ZlbmNlIiwiZmlsdGVyZWRBaXJjcmFmdCIsInNlbGVjdGVkUmVnaW9uIiwiR0xPQkFMIiwic2V0U2VsZWN0ZWRSZWdpb24iLCJyZWdpb24iLCJpc0dlb2ZlbmNlUGxhY2VtZW50TW9kZSIsInNldElzR2VvZmVuY2VQbGFjZW1lbnRNb2RlIiwiRW5oYW5jZWRNYXBQcm92aWRlciIsImNoaWxkcmVuIiwibWFudWZhY3R1cmVycyIsIm9uRXJyb3IiLCJzZXREaXNwbGF5ZWRBaXJjcmFmdCIsInNldFNlbGVjdGVkQWlyY3JhZnQiLCJzZXRDYWNoZWRBaXJjcmFmdERhdGEiLCJzZXRMYXN0UGVyc2lzdGVuY2VVcGRhdGUiLCJzZXRJc0dlb2ZlbmNlQWN0aXZlIiwiYWlyY3JhZnRQb3NpdGlvbnMiLCJzZXRBaXJjcmFmdFBvc2l0aW9ucyIsInByZXYiLCJzZXRTZWxlY3RlZE1hbnVmYWN0dXJlciIsInNldFNlbGVjdGVkTW9kZWwiLCJzZXRBY3RpdmVNb2RlbHMiLCJzZXRUb3RhbEFjdGl2ZSIsInNldElzTG9hZGluZyIsInNldElzUmVmcmVzaGluZyIsInNldFRyYWNraW5nU3RhdHVzIiwic2V0TGFzdFJlZnJlc2hlZCIsImxhc3RGdWxsUmVmcmVzaFRpbWUiLCJzZXRMYXN0RnVsbFJlZnJlc2hUaW1lIiwiaXNHZW9mZW5jZU1vZGUiLCJzZXRJc0dlb2ZlbmNlTW9kZSIsImZpbHRlckFpcmNyYWZ0QnlHZW9mZW5jZSIsImNhbGN1bGF0ZURpc3RhbmNlIiwibGF0MSIsImxvbjEiLCJsYXQyIiwibG9uMiIsIlIiLCJkTGF0IiwiZGVnMnJhZCIsImRMb24iLCJhIiwiTWF0aCIsInNpbiIsImNvcyIsImMiLCJhdGFuMiIsInNxcnQiLCJkaXN0YW5jZSIsImRlZyIsIlBJIiwiZmlsdGVyIiwiYWlyY3JhZnQiLCJsYXRpdHVkZSIsImxvbmdpdHVkZSIsImxhdCIsImxuZyIsInVuc3Vic2NyaWJlQWlyY3JhZnRSZWYiLCJ1bnN1YnNjcmliZVN0YXR1c1JlZiIsInNhdmVkRGF0YSIsImNvbnNvbGUiLCJsb2ciLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwiRGF0ZSIsIm5vdyIsImhhbmRsZVRyYWNraW5nVXBkYXRlIiwiZGF0YSIsInVwZGF0ZUFpcmNyYWZ0RGlzcGxheSIsImN1cnJlbnQiLCJzdWJzY3JpYmUiLCJzdWJzY3JpYmVUb1N0YXR1cyIsInN0YXR1cyIsInN0b3BUcmFja2luZyIsIm5ld0FpcmNyYWZ0QXJyYXkiLCJuZXdBaXJjcmFmdE1hcCIsImZvckVhY2giLCJJQ0FPMjQiLCJhbHRpdHVkZSIsInZlbG9jaXR5IiwiaGVhZGluZyIsIm9uX2dyb3VuZCIsImxhc3RfY29udGFjdCIsImxhc3RTZWVuIiwibGFzdFVwZGF0ZWQiLCJjdXJyZW50Q2FjaGUiLCJ1cGRhdGVkQWlyY3JhZnQiLCJleHRlbmRlZEFpcmNyYWZ0IiwiZ2V0RXh0ZW5kZWRBaXJjcmFmdCIsInVuZGVmaW5lZCIsIm1vZGVscyIsInRvdGFsIiwiZ2V0TW9kZWxTdGF0cyIsImdlb2ZlbmNlQWlyY3JhZnQiLCJtb2RlbENvdW50cyIsInJlZHVjZSIsImFjYyIsIk1PREVMIiwiVFlQRV9BSVJDUkFGVCIsImNvdW50IiwiTUFOVUZBQ1RVUkVSIiwibGFiZWwiLCJhY3RpdmVDb3VudCIsInRvdGFsQ291bnQiLCJtb2RlbEFycmF5IiwidmFsdWVzIiwibWFwIiwidG9Mb2NhbGVUaW1lU3RyaW5nIiwidHJhY2tNYW51ZmFjdHVyZXJXaXRoUHJvZ3Jlc3MiLCJwcm9ncmVzcyIsIm1lc3NhZ2UiLCJlcnJvciIsIkVycm9yIiwiZW5oYW5jZWRBaXJjcmFmdCIsImhhbmRsZUdldEJvdW5kc0J5UmVnaW9uIiwicmVmcmVzaFBvc2l0aW9uc09ubHkiLCJzZXRUaW1lb3V0Iiwic2FmZXR5VGltZW91dCIsImFsbFRyYWNrZWRBaXJjcmFmdCIsImdldFRyYWNrZWRBaXJjcmFmdCIsImFjdGl2ZUFpcmNyYWZ0IiwibmVlZHNGdWxsUmVmcmVzaCIsInN1Y2Nlc3MiLCJyZWZyZXNoTm93Iiwid2FybiIsImFjdGl2ZUljYW9zIiwiQm9vbGVhbiIsInJlZnJlc2hTcGVjaWZpY0FpcmNyYWZ0IiwiZmFsbGJhY2tFcnJvciIsImNsZWFyVGltZW91dCIsImN1cnJlbnRDb3VudCIsInRyYWNrTWFudWZhY3R1cmVyIiwiY29udGV4dFZhbHVlIiwiUHJvdmlkZXIiLCJ2YWx1ZSIsInVzZUVuaGFuY2VkTWFwQ29udGV4dCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/tracking/context/EnhancedMapContext.tsx\n"));

/***/ })

});
"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "(pages-dir-browser)/./components/tracking/context/EnhancedMapContext.tsx":
/*!************************************************************!*\
  !*** ./components/tracking/context/EnhancedMapContext.tsx ***!
  \************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EnhancedMapProvider: () => (/* binding */ EnhancedMapProvider),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   useEnhancedMapContext: () => (/* binding */ useEnhancedMapContext)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _types_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/types/base */ \"(pages-dir-browser)/./types/base.ts\");\n/* harmony import */ var _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/services/openSkyTrackingService */ \"(pages-dir-browser)/./lib/services/openSkyTrackingService.ts\");\n/* harmony import */ var _persistence_AircraftDataPersistence__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../persistence/AircraftDataPersistence */ \"(pages-dir-browser)/./components/tracking/persistence/AircraftDataPersistence.ts\");\n/* harmony import */ var _config_map__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../config/map */ \"(pages-dir-browser)/./config/map.ts\");\n// components/tracking/context/EnhancedMapContext.tsx\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n\n\n// Create context with default values\nconst EnhancedMapContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({\n    mapInstance: null,\n    setMapInstance: ()=>{},\n    zoomLevel: 6,\n    setZoomLevel: ()=>{},\n    displayedAircraft: [],\n    selectedAircraft: null,\n    selectAircraft: ()=>{},\n    // Data persistence defaults\n    cachedAircraftData: {},\n    updateAircraftData: ()=>{},\n    lastPersistenceUpdate: null,\n    selectedManufacturer: null,\n    selectedModel: null,\n    activeModels: [],\n    totalActive: 0,\n    isLoading: false,\n    isRefreshing: false,\n    trackingStatus: '',\n    lastRefreshed: null,\n    selectManufacturer: async ()=>{},\n    selectModel: ()=>{},\n    reset: async ()=>{},\n    refreshPositions: async ()=>{},\n    fullRefresh: async ()=>{},\n    clearCache: ()=>{},\n    clearGeofenceData: ()=>{},\n    // Add default for new function\n    updateGeofenceAircraft: ()=>{},\n    filterMode: 'manufacturer',\n    setFilterMode: ()=>{},\n    blockManufacturerApiCalls: false,\n    setBlockManufacturerApiCalls: ()=>{},\n    isManufacturerApiBlocked: false,\n    setIsManufacturerApiBlocked: ()=>{},\n    // Geofencing properties\n    geofenceCenter: null,\n    geofenceRadius: 25,\n    isGeofenceActive: false,\n    setGeofenceCenter: ()=>{},\n    setGeofenceRadius: ()=>{},\n    geofenceCoordinates: null,\n    toggleGeofence: ()=>{},\n    clearGeofence: ()=>({}),\n    filteredAircraft: [],\n    selectedRegion: _types_base__WEBPACK_IMPORTED_MODULE_2__.RegionCode.GLOBAL,\n    setSelectedRegion: (region)=>{},\n    getBoundsByRegion: (region)=>(0,_config_map__WEBPACK_IMPORTED_MODULE_5__.getBoundsByRegion)('GLOBAL'),\n    isGeofencePlacementMode: false,\n    setIsGeofencePlacementMode: ()=>{},\n    setPanelPosition: ()=>{}\n});\n// Enhanced Map Provider component\nconst EnhancedMapProvider = (param)=>{\n    let { children, manufacturers, onError } = param;\n    _s();\n    // Map state\n    const [mapInstance, setMapInstance] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [zoomLevel, setZoomLevel] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(6);\n    // Aircraft state\n    const [displayedAircraft, setDisplayedAircraft] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [selectedAircraft, setSelectedAircraft] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // Data persistence state\n    const [cachedAircraftData, setCachedAircraftData] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const [lastPersistenceUpdate, setLastPersistenceUpdate] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [geofenceCenter, setGeofenceCenter] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [selectedRegion, setSelectedRegion] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(_types_base__WEBPACK_IMPORTED_MODULE_2__.RegionCode.GLOBAL);\n    // Derived state for geofence coordinates\n    const geofenceCoordinates = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"EnhancedMapProvider.useMemo[geofenceCoordinates]\": ()=>geofenceCenter\n    }[\"EnhancedMapProvider.useMemo[geofenceCoordinates]\"], [\n        geofenceCenter\n    ]);\n    const [geofenceRadius, setGeofenceRadius] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(25); // Default 25km radius\n    const [isGeofenceActive, setIsGeofenceActive] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [isGeofencePlacementMode, setIsGeofencePlacementMode] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Add this to your state declarations\n    const [aircraftPositions, setAircraftPositions] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    // Toggle geofence activation\n    const toggleGeofence = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"EnhancedMapProvider.useCallback[toggleGeofence]\": ()=>{\n            setIsGeofenceActive({\n                \"EnhancedMapProvider.useCallback[toggleGeofence]\": (prev)=>!prev\n            }[\"EnhancedMapProvider.useCallback[toggleGeofence]\"]);\n        }\n    }[\"EnhancedMapProvider.useCallback[toggleGeofence]\"], []);\n    // Clear geofence\n    const clearGeofence = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"EnhancedMapProvider.useCallback[clearGeofence]\": ()=>{\n            setGeofenceCenter(null);\n            setIsGeofenceActive(false);\n            return {}; // Return an empty object to match the expected type\n        }\n    }[\"EnhancedMapProvider.useCallback[clearGeofence]\"], []);\n    // Selection state\n    const [selectedManufacturer, setSelectedManufacturer] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [selectedModel, setSelectedModel] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [activeModels, setActiveModels] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [totalActive, setTotalActive] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    // Loading state\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [isRefreshing, setIsRefreshing] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [trackingStatus, setTrackingStatus] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');\n    const [lastRefreshed, setLastRefreshed] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // Add this with your other state variables\n    const [lastFullRefreshTime, setLastFullRefreshTime] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [isManufacturerApiBlocked, setIsManufacturerApiBlocked] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [filterMode, setFilterMode] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('manufacturer');\n    const [blockManufacturerApiCalls, setBlockManufacturerApiCalls] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Flag to track if we're in geofence mode\n    const [isGeofenceMode, setIsGeofenceMode] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Define the filter function correctly\n    const filterAircraftByGeofence = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"EnhancedMapProvider.useCallback[filterAircraftByGeofence]\": ()=>{\n            if (!geofenceCenter || !isGeofenceActive) {\n                return displayedAircraft;\n            }\n            // Helper function to calculate distance between two points\n            const calculateDistance = {\n                \"EnhancedMapProvider.useCallback[filterAircraftByGeofence].calculateDistance\": (lat1, lon1, lat2, lon2)=>{\n                    const R = 6371; // Radius of the earth in km\n                    const dLat = deg2rad(lat2 - lat1);\n                    const dLon = deg2rad(lon2 - lon1);\n                    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * Math.sin(dLon / 2) * Math.sin(dLon / 2);\n                    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n                    const distance = R * c; // Distance in km\n                    return distance;\n                }\n            }[\"EnhancedMapProvider.useCallback[filterAircraftByGeofence].calculateDistance\"];\n            const deg2rad = {\n                \"EnhancedMapProvider.useCallback[filterAircraftByGeofence].deg2rad\": (deg)=>{\n                    return deg * (Math.PI / 180);\n                }\n            }[\"EnhancedMapProvider.useCallback[filterAircraftByGeofence].deg2rad\"];\n            // Filter aircraft within the radius\n            return displayedAircraft.filter({\n                \"EnhancedMapProvider.useCallback[filterAircraftByGeofence]\": (aircraft)=>{\n                    if (!aircraft.latitude || !aircraft.longitude) return false;\n                    // Calculate distance between aircraft and geofence center\n                    const distance = calculateDistance(geofenceCenter.lat, geofenceCenter.lng, aircraft.latitude, aircraft.longitude);\n                    // Return true if aircraft is within radius\n                    return geofenceRadius !== null && distance <= geofenceRadius;\n                }\n            }[\"EnhancedMapProvider.useCallback[filterAircraftByGeofence]\"]);\n        }\n    }[\"EnhancedMapProvider.useCallback[filterAircraftByGeofence]\"], [\n        displayedAircraft,\n        geofenceCenter,\n        geofenceRadius,\n        isGeofenceActive\n    ]);\n    // Then separately, define filteredAircraft - don't try to do both in the same function\n    const filteredAircraft = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"EnhancedMapProvider.useMemo[filteredAircraft]\": ()=>{\n            return isGeofenceActive && geofenceCenter ? filterAircraftByGeofence() : displayedAircraft;\n        }\n    }[\"EnhancedMapProvider.useMemo[filteredAircraft]\"], [\n        isGeofenceActive,\n        geofenceCenter,\n        filterAircraftByGeofence,\n        displayedAircraft\n    ]);\n    // Refs for tracking subscriptions\n    const unsubscribeAircraftRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const unsubscribeStatusRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Load persisted aircraft data on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"EnhancedMapProvider.useEffect\": ()=>{\n            const savedData = (0,_persistence_AircraftDataPersistence__WEBPACK_IMPORTED_MODULE_4__.loadAircraftData)();\n            if (savedData) {\n                console.log(\"[EnhancedMapContext] Loaded \".concat(Object.keys(savedData).length, \" aircraft from persistence\"));\n                setCachedAircraftData(savedData);\n                setLastPersistenceUpdate(Date.now());\n            }\n        }\n    }[\"EnhancedMapProvider.useEffect\"], []);\n    // Save aircraft data when cachedAircraftData changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"EnhancedMapProvider.useEffect\": ()=>{\n            if (Object.keys(cachedAircraftData).length > 0) {\n                console.log(\"[EnhancedMapContext] Saving \".concat(Object.keys(cachedAircraftData).length, \" aircraft to persistence\"));\n                (0,_persistence_AircraftDataPersistence__WEBPACK_IMPORTED_MODULE_4__.saveAircraftData)(cachedAircraftData);\n            }\n        }\n    }[\"EnhancedMapProvider.useEffect\"], [\n        cachedAircraftData\n    ]);\n    // Initialize tracking service and subscriptions\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"EnhancedMapProvider.useEffect\": ()=>{\n            // Subscribe to tracking updates that include trail data\n            const handleTrackingUpdate = {\n                \"EnhancedMapProvider.useEffect.handleTrackingUpdate\": (data)=>{\n                    // Only update displayed aircraft if we're not in geofence mode\n                    if (!isGeofenceMode) {\n                        updateAircraftDisplay();\n                    }\n                }\n            }[\"EnhancedMapProvider.useEffect.handleTrackingUpdate\"];\n            // Subscribe to aircraft updates\n            unsubscribeAircraftRef.current = _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].subscribe(handleTrackingUpdate);\n            // Subscribe to status updates\n            unsubscribeStatusRef.current = _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].subscribeToStatus({\n                \"EnhancedMapProvider.useEffect\": (status)=>{\n                    setTrackingStatus(status);\n                    setIsLoading(_lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].isLoading());\n                }\n            }[\"EnhancedMapProvider.useEffect\"]);\n            // IMPORTANT: Clear any existing tracking when component mounts\n            _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].stopTracking();\n            // Cleanup on unmount\n            return ({\n                \"EnhancedMapProvider.useEffect\": ()=>{\n                    if (unsubscribeAircraftRef.current) {\n                        unsubscribeAircraftRef.current();\n                    }\n                    if (unsubscribeStatusRef.current) {\n                        unsubscribeStatusRef.current();\n                    }\n                }\n            })[\"EnhancedMapProvider.useEffect\"];\n        }\n    }[\"EnhancedMapProvider.useEffect\"], [\n        isGeofenceMode\n    ]);\n    // Update aircraft data with persistence\n    const updateAircraftData = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"EnhancedMapProvider.useCallback[updateAircraftData]\": (newAircraftArray)=>{\n            // Convert to a map for easier processing\n            const newAircraftMap = {};\n            newAircraftArray.forEach({\n                \"EnhancedMapProvider.useCallback[updateAircraftData]\": (aircraft)=>{\n                    if (aircraft.ICAO24) {\n                        newAircraftMap[aircraft.ICAO24] = {\n                            ...aircraft,\n                            // Ensure required fields for CachedAircraftData are present\n                            ICAO24: aircraft.ICAO24,\n                            latitude: aircraft.latitude || 0,\n                            longitude: aircraft.longitude || 0,\n                            altitude: aircraft.altitude || 0,\n                            velocity: aircraft.velocity || 0,\n                            heading: aircraft.heading || 0,\n                            on_ground: aircraft.on_ground || false,\n                            last_contact: aircraft.last_contact || Date.now(),\n                            lastSeen: Date.now(),\n                            lastUpdated: Date.now()\n                        };\n                    }\n                }\n            }[\"EnhancedMapProvider.useCallback[updateAircraftData]\"]);\n            // Merge with existing cached data to preserve fields\n            setCachedAircraftData({\n                \"EnhancedMapProvider.useCallback[updateAircraftData]\": (currentCache)=>(0,_persistence_AircraftDataPersistence__WEBPACK_IMPORTED_MODULE_4__.mergeAircraftData)(currentCache, newAircraftMap)\n            }[\"EnhancedMapProvider.useCallback[updateAircraftData]\"]);\n            setLastPersistenceUpdate(Date.now());\n            // If the selected aircraft is updated, update the selection\n            if (selectedAircraft && newAircraftMap[selectedAircraft.ICAO24]) {\n                const updatedAircraft = {\n                    ...selectedAircraft,\n                    ...newAircraftMap[selectedAircraft.ICAO24]\n                };\n                setSelectedAircraft(updatedAircraft);\n            }\n        }\n    }[\"EnhancedMapProvider.useCallback[updateAircraftData]\"], [\n        selectedAircraft\n    ]);\n    // Clear persistence cache\n    const clearCache = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"EnhancedMapProvider.useCallback[clearCache]\": ()=>{\n            (0,_persistence_AircraftDataPersistence__WEBPACK_IMPORTED_MODULE_4__.clearAircraftData)();\n            setCachedAircraftData({});\n            setLastPersistenceUpdate(null);\n            setTrackingStatus('Cache cleared');\n        }\n    }[\"EnhancedMapProvider.useCallback[clearCache]\"], []);\n    // Update aircraft display based on selected MODEL\n    const updateAircraftDisplay = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"EnhancedMapProvider.useCallback[updateAircraftDisplay]\": ()=>{\n            // Get extended aircraft based on selected MODEL\n            const extendedAircraft = _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].getExtendedAircraft(selectedModel || undefined);\n            // Get MODEL stats from the service\n            const { models, totalActive: total } = _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].getModelStats();\n            // Enhance aircraft data with persistence\n            updateAircraftData(extendedAircraft);\n            // Only update displayed aircraft if we're not in geofence mode\n            if (!isGeofenceMode) {\n                setDisplayedAircraft(extendedAircraft);\n                setActiveModels(models);\n                setTotalActive(total);\n            }\n            setIsLoading(_lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].isLoading());\n        }\n    }[\"EnhancedMapProvider.useCallback[updateAircraftDisplay]\"], [\n        selectedModel,\n        updateAircraftData,\n        isGeofenceMode\n    ]);\n    // Update display when MODEL selection changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"EnhancedMapProvider.useEffect\": ()=>{\n            updateAircraftDisplay();\n        }\n    }[\"EnhancedMapProvider.useEffect\"], [\n        selectedModel,\n        updateAircraftDisplay\n    ]);\n    // New function to handle geofence aircraft updates\n    const updateGeofenceAircraft = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"EnhancedMapProvider.useCallback[updateGeofenceAircraft]\": (geofenceAircraft)=>{\n            // Mark that we're in geofence mode\n            setIsGeofenceMode(true);\n            console.log(\"[EnhancedMapContext] Updating \".concat(geofenceAircraft.length, \" aircraft from geofence\"));\n            // Update the cached data (same as regular updates)\n            updateAircraftData(geofenceAircraft);\n            // Also directly update the displayed aircraft\n            setDisplayedAircraft(geofenceAircraft);\n            // Update stats\n            setTotalActive(geofenceAircraft.length);\n            // Extract MODEL stats for the sidebar\n            const modelCounts = geofenceAircraft.reduce({\n                \"EnhancedMapProvider.useCallback[updateGeofenceAircraft].modelCounts\": (acc, aircraft)=>{\n                    const MODEL = aircraft.MODEL || aircraft.TYPE_AIRCRAFT || 'Unknown';\n                    if (!acc[MODEL]) {\n                        acc[MODEL] = {\n                            MODEL,\n                            count: 0,\n                            MANUFACTURER: aircraft.MANUFACTURER || 'Unknown',\n                            // Add required properties for AircraftModel\n                            label: MODEL,\n                            activeCount: 0,\n                            totalCount: 0\n                        };\n                    }\n                    acc[MODEL].count++;\n                    acc[MODEL].activeCount++;\n                    acc[MODEL].totalCount++;\n                    return acc;\n                }\n            }[\"EnhancedMapProvider.useCallback[updateGeofenceAircraft].modelCounts\"], {});\n            // Convert to array for the activeModels state\n            const modelArray = Object.values(modelCounts).map({\n                \"EnhancedMapProvider.useCallback[updateGeofenceAircraft].modelArray\": (MODEL)=>({\n                        MODEL: MODEL.MODEL,\n                        count: MODEL.count,\n                        MANUFACTURER: MODEL.MANUFACTURER,\n                        // Add required properties for AircraftModel type\n                        label: MODEL.MODEL,\n                        activeCount: MODEL.count,\n                        totalCount: MODEL.count\n                    })\n            }[\"EnhancedMapProvider.useCallback[updateGeofenceAircraft].modelArray\"]);\n            setActiveModels(modelArray);\n            // Update the last refreshed timestamp\n            setLastRefreshed(new Date().toLocaleTimeString());\n        }\n    }[\"EnhancedMapProvider.useCallback[updateGeofenceAircraft]\"], [\n        updateAircraftData\n    ]);\n    // Handle MANUFACTURER selection\n    // In your EnhancedMapContext.tsx - modify the selectManufacturer function\n    const selectManufacturer = async (MANUFACTURER)=>{\n        // Exit geofence mode when selecting a MANUFACTURER\n        setIsGeofenceMode(false);\n        setSelectedManufacturer(MANUFACTURER);\n        setSelectedModel(null);\n        setIsLoading(true);\n        setLastRefreshed(null);\n        // Clear previous data\n        setDisplayedAircraft([]);\n        setActiveModels([]);\n        setTotalActive(0);\n        // If null, just exit\n        if (MANUFACTURER === null) {\n            setIsLoading(false);\n            return;\n        }\n        // If we're blocking API calls, exit early\n        if (isManufacturerApiBlocked) {\n            console.log(\"[EnhancedMapContext] API calls blocked for manufacturer: \".concat(MANUFACTURER));\n            setIsLoading(false);\n            return;\n        }\n        try {\n            // Start tracking with a progress handler\n            setTrackingStatus(\"Loading aircraft for \".concat(MANUFACTURER, \"...\"));\n            // Use the existing service but with a progress callback\n            // In EnhancedMapContext.tsx, modify your callback to handle both types:\n            await _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].trackManufacturerWithProgress(MANUFACTURER, (progress)=>{\n                // Update the tracking status message\n                if (progress.message) {\n                    setTrackingStatus(progress.message);\n                }\n                // Update displayed aircraft as they're loaded\n                if (progress.aircraft) {\n                    // Cast the aircraft array to ExtendedAircraft[] since our context uses that type\n                    setDisplayedAircraft(progress.aircraft);\n                }\n                // Update model stats\n                if (progress.models) {\n                    setActiveModels(progress.models);\n                }\n                // Update total count\n                if (progress.total !== undefined) {\n                    setTotalActive(progress.total);\n                }\n            });\n            setLastRefreshed(new Date().toLocaleTimeString());\n        } catch (error) {\n            onError(\"Error tracking manufacturer: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n            setTrackingStatus('Error loading aircraft data');\n        } finally{\n            setIsLoading(false);\n        }\n    };\n    // Handle MODEL selection\n    const selectModel = (MODEL)=>{\n        setSelectedModel(MODEL);\n    };\n    // Handle aircraft selection\n    const selectAircraft = (aircraft)=>{\n        setSelectedAircraft(aircraft);\n        // If selecting an aircraft, check if we have cached data to enhance it\n        if (aircraft && aircraft.ICAO24 && cachedAircraftData[aircraft.ICAO24]) {\n            const enhancedAircraft = {\n                ...aircraft,\n                ...cachedAircraftData[aircraft.ICAO24]\n            };\n            setSelectedAircraft(enhancedAircraft);\n        }\n    };\n    // If you don't already have it, add this function to expose the map's getBoundsByRegion function\n    // Create a wrapped function that calls your map config function\n    const handleGetBoundsByRegion = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"EnhancedMapProvider.useCallback[handleGetBoundsByRegion]\": (region)=>{\n            return (0,_config_map__WEBPACK_IMPORTED_MODULE_5__.getBoundsByRegion)(region);\n        }\n    }[\"EnhancedMapProvider.useCallback[handleGetBoundsByRegion]\"], []);\n    // Reset all selections\n    const reset = async ()=>{\n        await selectManufacturer(null);\n    };\n    // Method to refresh only the positions of active aircraft\n    const refreshPositions = async ()=>{\n        if (isRefreshing || !selectedManufacturer && !isGeofenceMode) return;\n        setIsRefreshing(true);\n        setTrackingStatus('Updating aircraft positions...');\n        try {\n            // Call the service\n            await _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].refreshPositionsOnly();\n            setLastRefreshed(new Date().toLocaleTimeString());\n            setTrackingStatus(\"Positions updated for \".concat(displayedAircraft.length, \" aircraft\"));\n        } catch (error) {\n            onError(\"Error refreshing positions: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        } finally{\n            setTimeout(()=>{\n                setIsRefreshing(false);\n            }, 500);\n        }\n    };\n    // Method for full tracking refresh\n    const fullRefresh = async ()=>{\n        if (!selectedManufacturer && !isGeofenceMode || isRefreshing) return;\n        // Set a timeout to force exit from loading state after 10 seconds\n        // This is a safety mechanism\n        const safetyTimeout = setTimeout(()=>{\n            setIsRefreshing(false);\n            setTrackingStatus('Refresh timed out');\n        }, 10000);\n        setIsRefreshing(true);\n        try {\n            // Get currently tracked aircraft\n            const allTrackedAircraft = _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].getTrackedAircraft();\n            // Get active aircraft (those with position data)\n            const activeAircraft = allTrackedAircraft.filter((aircraft)=>aircraft.ICAO24 && aircraft.latitude && aircraft.longitude);\n            const needsFullRefresh = !lastFullRefreshTime || Date.now() - lastFullRefreshTime > 3600000;\n            let success = false;\n            if (activeAircraft.length === 0 || needsFullRefresh) {\n                // Do a full refresh\n                setTrackingStatus('Performing full refresh...');\n                try {\n                    await _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].refreshNow();\n                    setLastFullRefreshTime(Date.now());\n                    success = true;\n                } catch (error) {\n                    // Silently handle this error\n                    console.warn('Full refresh failed');\n                }\n            } else {\n                // Do an optimized refresh\n                const activeIcaos = activeAircraft.map((aircraft)=>aircraft.ICAO24).filter(Boolean);\n                if (activeIcaos.length > 0) {\n                    setTrackingStatus(\"Refreshing \".concat(activeIcaos.length, \" active aircraft...\"));\n                    try {\n                        await _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].refreshSpecificAircraft(activeIcaos);\n                        success = true;\n                    } catch (error) {\n                        // Try falling back to a full refresh\n                        console.warn('Optimized refresh failed, trying full refresh');\n                        try {\n                            await _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].refreshNow();\n                            setLastFullRefreshTime(Date.now());\n                            success = true;\n                        } catch (fallbackError) {\n                            // Silently handle this error\n                            console.warn('Fallback refresh failed');\n                        }\n                    }\n                }\n            }\n            clearTimeout(safetyTimeout);\n            // Only update if the refresh was successful\n            if (success) {\n                const currentCount = _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].getTrackedAircraft().length;\n                setTrackingStatus(\"Refresh completed with \".concat(currentCount, \" aircraft\"));\n                setLastRefreshed(new Date().toLocaleTimeString());\n            } else {\n                setTrackingStatus('Refresh failed');\n            }\n        } catch (error) {\n            clearTimeout(safetyTimeout);\n            // Only show errors to the user if they appear to be significant\n            if (error instanceof Error && error.message !== 'aborted') {\n                onError(\"Error during refresh: \".concat(error.message || 'Unknown error'));\n            }\n            setTrackingStatus('Error during refresh');\n        } finally{\n            clearTimeout(safetyTimeout);\n            setIsRefreshing(false);\n        }\n    };\n    const clearGeofenceData = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"EnhancedMapProvider.useCallback[clearGeofenceData]\": ()=>{\n            // Reset geofence mode flag\n            setIsGeofenceMode(false);\n            // Clear displayed aircraft\n            setDisplayedAircraft([]);\n            setActiveModels([]);\n            setTotalActive(0);\n            // If there was a previously selected MANUFACTURER, we can restore it\n            if (selectedManufacturer) {\n                // Small delay to ensure state updates properly\n                setTimeout({\n                    \"EnhancedMapProvider.useCallback[clearGeofenceData]\": ()=>{\n                        _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].trackManufacturer(selectedManufacturer);\n                    }\n                }[\"EnhancedMapProvider.useCallback[clearGeofenceData]\"], 100);\n            }\n        }\n    }[\"EnhancedMapProvider.useCallback[clearGeofenceData]\"], [\n        selectedManufacturer\n    ]);\n    // Create context value\n    const contextValue = {\n        mapInstance,\n        setMapInstance,\n        zoomLevel,\n        setZoomLevel,\n        displayedAircraft,\n        selectedAircraft,\n        selectAircraft,\n        // Data persistence\n        cachedAircraftData,\n        updateAircraftData,\n        lastPersistenceUpdate,\n        selectedManufacturer,\n        selectedModel,\n        activeModels,\n        totalActive,\n        isLoading,\n        isRefreshing,\n        trackingStatus,\n        lastRefreshed,\n        selectManufacturer,\n        selectModel,\n        reset,\n        refreshPositions,\n        fullRefresh,\n        clearCache,\n        clearGeofenceData,\n        updateGeofenceAircraft,\n        filteredAircraft,\n        filterMode,\n        setFilterMode,\n        blockManufacturerApiCalls,\n        setBlockManufacturerApiCalls,\n        isManufacturerApiBlocked,\n        setIsManufacturerApiBlocked,\n        // Geofencing properties\n        geofenceCenter,\n        geofenceRadius,\n        isGeofenceActive,\n        geofenceCoordinates,\n        setGeofenceCenter,\n        setGeofenceRadius,\n        toggleGeofence,\n        clearGeofence,\n        isGeofencePlacementMode,\n        setIsGeofencePlacementMode,\n        // Region selection\n        selectedRegion,\n        setSelectedRegion,\n        getBoundsByRegion: handleGetBoundsByRegion\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(EnhancedMapContext.Provider, {\n        value: contextValue,\n        children: children\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\satho\\\\Documents\\\\Projects\\\\aircraft-tracking\\\\components\\\\tracking\\\\context\\\\EnhancedMapContext.tsx\",\n        lineNumber: 827,\n        columnNumber: 5\n    }, undefined);\n};\n_s(EnhancedMapProvider, \"ft4R0gMInmgVu/GQ1zBkgSrD/lQ=\");\n_c = EnhancedMapProvider;\n// Custom hook to use the context\nconst useEnhancedMapContext = ()=>{\n    _s1();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(EnhancedMapContext);\n};\n_s1(useEnhancedMapContext, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EnhancedMapContext);\nvar _c;\n$RefreshReg$(_c, \"EnhancedMapProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvdHJhY2tpbmcvY29udGV4dC9FbmhhbmNlZE1hcENvbnRleHQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUEscURBQXFEOzs7QUFTdEM7QUFPTztBQUdxRDtBQU0zQjtBQUtuQjtBQXlFN0IscUNBQXFDO0FBQ3JDLE1BQU1nQixtQ0FBcUJmLG9EQUFhQSxDQUF5QjtJQUMvRGdCLGFBQWE7SUFDYkMsZ0JBQWdCLEtBQU87SUFDdkJDLFdBQVc7SUFDWEMsY0FBYyxLQUFPO0lBQ3JCQyxtQkFBbUIsRUFBRTtJQUNyQkMsa0JBQWtCO0lBQ2xCQyxnQkFBZ0IsS0FBTztJQUV2Qiw0QkFBNEI7SUFDNUJDLG9CQUFvQixDQUFDO0lBQ3JCQyxvQkFBb0IsS0FBTztJQUMzQkMsdUJBQXVCO0lBRXZCQyxzQkFBc0I7SUFDdEJDLGVBQWU7SUFDZkMsY0FBYyxFQUFFO0lBQ2hCQyxhQUFhO0lBRWJDLFdBQVc7SUFDWEMsY0FBYztJQUNkQyxnQkFBZ0I7SUFDaEJDLGVBQWU7SUFFZkMsb0JBQW9CLFdBQWE7SUFDakNDLGFBQWEsS0FBTztJQUNwQkMsT0FBTyxXQUFhO0lBQ3BCQyxrQkFBa0IsV0FBYTtJQUMvQkMsYUFBYSxXQUFhO0lBQzFCQyxZQUFZLEtBQU87SUFDbkJDLG1CQUFtQixLQUFPO0lBQzFCLCtCQUErQjtJQUMvQkMsd0JBQXdCLEtBQU87SUFFL0JDLFlBQVk7SUFDWkMsZUFBZSxLQUFPO0lBQ3RCQywyQkFBMkI7SUFDM0JDLDhCQUE4QixLQUFPO0lBQ3JDQywwQkFBMEI7SUFDMUJDLDZCQUE2QixLQUFPO0lBRXBDLHdCQUF3QjtJQUN4QkMsZ0JBQWdCO0lBQ2hCQyxnQkFBZ0I7SUFDaEJDLGtCQUFrQjtJQUNsQkMsbUJBQW1CLEtBQU87SUFDMUJDLG1CQUFtQixLQUFPO0lBQzFCQyxxQkFBcUI7SUFDckJDLGdCQUFnQixLQUFPO0lBQ3ZCQyxlQUFlLElBQU8sRUFBQztJQUN2QkMsa0JBQWtC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MkJBQTJCO1lBQzNCbUYsa0JBQWtCO1lBRWxCLDJCQUEyQjtZQUMzQm5CLHFCQUFxQixFQUFFO1lBQ3ZCVSxnQkFBZ0IsRUFBRTtZQUNsQkMsZUFBZTtZQUVmLHFFQUFxRTtZQUNyRSxJQUFJckQsc0JBQXNCO2dCQUN4QiwrQ0FBK0M7Z0JBQy9Db0o7MEVBQVc7d0JBQ1R0Syw4RkFBd0MsQ0FBQ2tCO29CQUMzQzt5RUFBRztZQUNMO1FBQ0Y7NkRBQUc7UUFBQ0E7S0FBcUI7SUFFekIsdUJBQXVCO0lBQ3ZCLE1BQU1vSyxlQUF1QztRQUMzQzlLO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBRUFDO1FBQ0FDO1FBQ0FDO1FBRUEsbUJBQW1CO1FBQ25CQztRQUNBQztRQUNBQztRQUVBQztRQUNBQztRQUNBQztRQUNBQztRQUVBQztRQUNBQztRQUNBQztRQUNBQztRQUVBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBZTtRQUVBZDtRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUVBLHdCQUF3QjtRQUN4QkM7UUFDQUM7UUFDQUM7UUFDQUc7UUFDQUY7UUFDQUM7UUFDQUU7UUFDQUM7UUFDQU07UUFDQUM7UUFFQSxtQkFBbUI7UUFDbkJMO1FBQ0FFO1FBQ0E5QyxtQkFBbUIrSjtJQUNyQjtJQUVBLHFCQUNFLDhEQUFDN0osbUJBQW1CZ0wsUUFBUTtRQUFDQyxPQUFPRjtrQkFDakM3SDs7Ozs7O0FBR1AsRUFBRTtHQWxwQldEO0tBQUFBO0FBb3BCYixpQ0FBaUM7QUFDMUIsTUFBTWlJLHdCQUF3Qjs7SUFBTWhNLE9BQUFBLGlEQUFVQSxDQUFDYztBQUFrQixFQUFFO0lBQTdEa0w7QUFFYixpRUFBZWxMLGtCQUFrQkEsRUFBQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxzYXRob1xcRG9jdW1lbnRzXFxQcm9qZWN0c1xcYWlyY3JhZnQtdHJhY2tpbmdcXGNvbXBvbmVudHNcXHRyYWNraW5nXFxjb250ZXh0XFxFbmhhbmNlZE1hcENvbnRleHQudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGNvbXBvbmVudHMvdHJhY2tpbmcvY29udGV4dC9FbmhhbmNlZE1hcENvbnRleHQudHN4XHJcbmltcG9ydCBSZWFjdCwge1xyXG4gIGNyZWF0ZUNvbnRleHQsXHJcbiAgdXNlQ29udGV4dCxcclxuICB1c2VTdGF0ZSxcclxuICB1c2VFZmZlY3QsXHJcbiAgdXNlQ2FsbGJhY2ssXHJcbiAgdXNlUmVmLFxyXG4gIHVzZU1lbW8sXHJcbn0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgTCBmcm9tICdsZWFmbGV0JztcclxuaW1wb3J0IHtcclxuICBTZWxlY3RPcHRpb24sXHJcbiAgRXh0ZW5kZWRBaXJjcmFmdCxcclxuICBBaXJjcmFmdFBvc2l0aW9uLFxyXG4gIFJlZ2lvbkNvZGUsXHJcbn0gZnJvbSAnQC90eXBlcy9iYXNlJztcclxuaW1wb3J0IHR5cGUgeyBDYWNoZWRBaXJjcmFmdERhdGEgfSBmcm9tICdAL3R5cGVzL2Jhc2UnOyAvLyBJbXBvcnQgeW91ciBuZXcgdHlwZVxyXG5pbXBvcnQgdHlwZSB7IEFpcmNyYWZ0TW9kZWwgfSBmcm9tICcuLi8uLi8uLi90eXBlcy9haXJjcmFmdC1tb2RlbHMnO1xyXG5pbXBvcnQgb3BlblNreVRyYWNraW5nU2VydmljZSBmcm9tICdAL2xpYi9zZXJ2aWNlcy9vcGVuU2t5VHJhY2tpbmdTZXJ2aWNlJztcclxuaW1wb3J0IHtcclxuICBzYXZlQWlyY3JhZnREYXRhLFxyXG4gIGxvYWRBaXJjcmFmdERhdGEsXHJcbiAgbWVyZ2VBaXJjcmFmdERhdGEsXHJcbiAgY2xlYXJBaXJjcmFmdERhdGEsXHJcbn0gZnJvbSAnLi4vcGVyc2lzdGVuY2UvQWlyY3JhZnREYXRhUGVyc2lzdGVuY2UnO1xyXG5pbXBvcnQgdHlwZSB7IExhdExuZ0JvdW5kc0V4cHJlc3Npb24gfSBmcm9tICdsZWFmbGV0JztcclxuaW1wb3J0IHtcclxuICBNQVBfQ09ORklHLFxyXG4gIGdldEJvdW5kc0J5UmVnaW9uIGFzIGNvbmZpZ0dldEJvdW5kc0J5UmVnaW9uLFxyXG59IGZyb20gJy4uLy4uLy4uL2NvbmZpZy9tYXAnO1xyXG5cclxuLy8gRGVmaW5lIGNvbnRleHQgaW50ZXJmYWNlXHJcbmludGVyZmFjZSBFbmhhbmNlZE1hcENvbnRleHRUeXBlIHtcclxuICAvLyBNYXAgc3RhdGVcclxuICBtYXBJbnN0YW5jZTogTC5NYXAgfCBudWxsO1xyXG4gIHNldE1hcEluc3RhbmNlOiAobWFwOiBMLk1hcCB8IG51bGwpID0+IHZvaWQ7XHJcbiAgem9vbUxldmVsOiBudW1iZXI7XHJcbiAgc2V0Wm9vbUxldmVsOiAoem9vbTogbnVtYmVyKSA9PiB2b2lkO1xyXG5cclxuICAvLyBBaXJjcmFmdCBkYXRhXHJcbiAgZGlzcGxheWVkQWlyY3JhZnQ6IEV4dGVuZGVkQWlyY3JhZnRbXTtcclxuICBzZWxlY3RlZEFpcmNyYWZ0OiBFeHRlbmRlZEFpcmNyYWZ0IHwgbnVsbDtcclxuICBzZWxlY3RBaXJjcmFmdDogKGFpcmNyYWZ0OiBFeHRlbmRlZEFpcmNyYWZ0IHwgbnVsbCkgPT4gdm9pZDtcclxuXHJcbiAgLy8gRGF0YSBwZXJzaXN0ZW5jZVxyXG4gIGNhY2hlZEFpcmNyYWZ0RGF0YTogUmVjb3JkPHN0cmluZywgQ2FjaGVkQWlyY3JhZnREYXRhPjtcclxuICB1cGRhdGVBaXJjcmFmdERhdGE6IChuZXdBaXJjcmFmdDogRXh0ZW5kZWRBaXJjcmFmdFtdKSA9PiB2b2lkO1xyXG4gIGxhc3RQZXJzaXN0ZW5jZVVwZGF0ZTogbnVtYmVyIHwgbnVsbDtcclxuXHJcbiAgLy8gU2VsZWN0aW9uIHN0YXRlXHJcbiAgc2VsZWN0ZWRNYW51ZmFjdHVyZXI6IHN0cmluZyB8IG51bGw7XHJcbiAgc2VsZWN0ZWRNb2RlbDogc3RyaW5nIHwgbnVsbDtcclxuICBhY3RpdmVNb2RlbHM6IEFpcmNyYWZ0TW9kZWxbXTtcclxuICB0b3RhbEFjdGl2ZTogbnVtYmVyO1xyXG5cclxuICAvLyBMb2FkaW5nIHN0YXRlXHJcbiAgaXNMb2FkaW5nOiBib29sZWFuO1xyXG4gIGlzUmVmcmVzaGluZzogYm9vbGVhbjtcclxuICB0cmFja2luZ1N0YXR1czogc3RyaW5nO1xyXG4gIGxhc3RSZWZyZXNoZWQ6IHN0cmluZyB8IG51bGw7XHJcblxyXG4gIC8vIEFjdGlvbnNcclxuICBzZWxlY3RNYW51ZmFjdHVyZXI6IChNQU5VRkFDVFVSRVI6IHN0cmluZyB8IG51bGwpID0+IFByb21pc2U8dm9pZD47XHJcbiAgc2VsZWN0TW9kZWw6IChNT0RFTDogc3RyaW5nIHwgbnVsbCkgPT4gdm9pZDtcclxuICByZXNldDogKCkgPT4gUHJvbWlzZTx2b2lkPjtcclxuICByZWZyZXNoUG9zaXRpb25zOiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xyXG4gIGZ1bGxSZWZyZXNoOiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xyXG4gIGNsZWFyQ2FjaGU6ICgpID0+IHZvaWQ7XHJcbiAgY2xlYXJHZW9mZW5jZURhdGE6ICgpID0+IHZvaWQ7XHJcbiAgLy8gQWRkIG5ldyBmdW5jdGlvbiBmb3IgdXBkYXRpbmcgYWlyY3JhZnQgZnJvbSBnZW9mZW5jZVxyXG4gIHVwZGF0ZUdlb2ZlbmNlQWlyY3JhZnQ6IChnZW9mZW5jZUFpcmNyYWZ0OiBFeHRlbmRlZEFpcmNyYWZ0W10pID0+IHZvaWQ7XHJcblxyXG4gIGZpbHRlck1vZGU6ICdtYW51ZmFjdHVyZXInIHwgJ2dlb2ZlbmNlJyB8ICdib3RoJyB8ICdyZWdpb24nIHwgJ293bmVyJztcclxuICBzZXRGaWx0ZXJNb2RlOiAoXHJcbiAgICBtb2RlOiAnbWFudWZhY3R1cmVyJyB8ICdnZW9mZW5jZScgfCAnYm90aCcgfCAncmVnaW9uJyB8ICdvd25lcidcclxuICApID0+IHZvaWQ7XHJcbiAgYmxvY2tNYW51ZmFjdHVyZXJBcGlDYWxsczogYm9vbGVhbjtcclxuICBzZXRCbG9ja01hbnVmYWN0dXJlckFwaUNhbGxzOiAoYmxvY2s6IGJvb2xlYW4pID0+IHZvaWQ7XHJcbiAgaXNNYW51ZmFjdHVyZXJBcGlCbG9ja2VkOiBib29sZWFuO1xyXG4gIHNldElzTWFudWZhY3R1cmVyQXBpQmxvY2tlZDogKGJsb2NrZWQ6IGJvb2xlYW4pID0+IHZvaWQ7XHJcbiAgZmlsdGVyZWRBaXJjcmFmdDogRXh0ZW5kZWRBaXJjcmFmdFtdO1xyXG5cclxuICAvLyBHZW9mZW5jaW5nIHByb3BlcnRpZXNcclxuICBnZW9mZW5jZUNlbnRlcjogeyBsYXQ6IG51bWJlcjsgbG5nOiBudW1iZXIgfSB8IG51bGw7IC8vIENvcnJlY3RseSB0eXBlZCBhcyB7IGxhdDogbnVtYmVyOyBsbmc6IG51bWJlciB9IHwgbnVsbFxyXG4gIGdlb2ZlbmNlUmFkaXVzOiBudW1iZXIgfCBudWxsOyAvLyBpbiBraWxvbWV0ZXJzXHJcbiAgaXNHZW9mZW5jZUFjdGl2ZTogYm9vbGVhbjtcclxuICBzZXRHZW9mZW5jZUNlbnRlcjogKGNlbnRlcjogeyBsYXQ6IG51bWJlcjsgbG5nOiBudW1iZXIgfSB8IG51bGwpID0+IHZvaWQ7XHJcbiAgc2V0R2VvZmVuY2VSYWRpdXM6IChyYWRpdXM6IG51bWJlciB8IG51bGwpID0+IHZvaWQ7XHJcbiAgdG9nZ2xlR2VvZmVuY2U6ICgpID0+IHZvaWQ7XHJcbiAgY2xlYXJHZW9mZW5jZTogKCkgPT4ge307XHJcbiAgZ2VvZmVuY2VDb29yZGluYXRlczogeyBsYXQ6IG51bWJlcjsgbG5nOiBudW1iZXIgfSB8IG51bGw7XHJcbiAgaXNHZW9mZW5jZVBsYWNlbWVudE1vZGU6IGJvb2xlYW47XHJcbiAgc2V0SXNHZW9mZW5jZVBsYWNlbWVudE1vZGU6IChpc1BsYWNlbWVudE1vZGU6IGJvb2xlYW4pID0+IHZvaWQ7XHJcblxyXG4gIHNldFBhbmVsUG9zaXRpb246IChwb3NpdGlvbjogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9KSA9PiB2b2lkO1xyXG5cclxuICAvLyBSZWdpb24gc2VsZWN0aW9uIHByb3BlcnRpZXNcclxuICBzZWxlY3RlZFJlZ2lvbjogUmVnaW9uQ29kZSB8IHN0cmluZzsgLy8gQWxsb3cgYm90aCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxyXG4gIHNldFNlbGVjdGVkUmVnaW9uOiAocmVnaW9uOiBSZWdpb25Db2RlIHwgc3RyaW5nKSA9PiB2b2lkO1xyXG4gIGdldEJvdW5kc0J5UmVnaW9uOiAocmVnaW9uOiBzdHJpbmcpID0+IExhdExuZ0JvdW5kc0V4cHJlc3Npb247XHJcbn1cclxuXHJcbi8vIENyZWF0ZSBjb250ZXh0IHdpdGggZGVmYXVsdCB2YWx1ZXNcclxuY29uc3QgRW5oYW5jZWRNYXBDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxFbmhhbmNlZE1hcENvbnRleHRUeXBlPih7XHJcbiAgbWFwSW5zdGFuY2U6IG51bGwsXHJcbiAgc2V0TWFwSW5zdGFuY2U6ICgpID0+IHt9LFxyXG4gIHpvb21MZXZlbDogNixcclxuICBzZXRab29tTGV2ZWw6ICgpID0+IHt9LFxyXG4gIGRpc3BsYXllZEFpcmNyYWZ0OiBbXSxcclxuICBzZWxlY3RlZEFpcmNyYWZ0OiBudWxsLFxyXG4gIHNlbGVjdEFpcmNyYWZ0OiAoKSA9PiB7fSxcclxuXHJcbiAgLy8gRGF0YSBwZXJzaXN0ZW5jZSBkZWZhdWx0c1xyXG4gIGNhY2hlZEFpcmNyYWZ0RGF0YToge30sXHJcbiAgdXBkYXRlQWlyY3JhZnREYXRhOiAoKSA9PiB7fSxcclxuICBsYXN0UGVyc2lzdGVuY2VVcGRhdGU6IG51bGwsXHJcblxyXG4gIHNlbGVjdGVkTWFudWZhY3R1cmVyOiBudWxsLFxyXG4gIHNlbGVjdGVkTW9kZWw6IG51bGwsXHJcbiAgYWN0aXZlTW9kZWxzOiBbXSxcclxuICB0b3RhbEFjdGl2ZTogMCxcclxuXHJcbiAgaXNMb2FkaW5nOiBmYWxzZSxcclxuICBpc1JlZnJlc2hpbmc6IGZhbHNlLFxyXG4gIHRyYWNraW5nU3RhdHVzOiAnJyxcclxuICBsYXN0UmVmcmVzaGVkOiBudWxsLFxyXG5cclxuICBzZWxlY3RNYW51ZmFjdHVyZXI6IGFzeW5jICgpID0+IHt9LFxyXG4gIHNlbGVjdE1vZGVsOiAoKSA9PiB7fSxcclxuICByZXNldDogYXN5bmMgKCkgPT4ge30sXHJcbiAgcmVmcmVzaFBvc2l0aW9uczogYXN5bmMgKCkgPT4ge30sXHJcbiAgZnVsbFJlZnJlc2g6IGFzeW5jICgpID0+IHt9LFxyXG4gIGNsZWFyQ2FjaGU6ICgpID0+IHt9LFxyXG4gIGNsZWFyR2VvZmVuY2VEYXRhOiAoKSA9PiB7fSxcclxuICAvLyBBZGQgZGVmYXVsdCBmb3IgbmV3IGZ1bmN0aW9uXHJcbiAgdXBkYXRlR2VvZmVuY2VBaXJjcmFmdDogKCkgPT4ge30sXHJcblxyXG4gIGZpbHRlck1vZGU6ICdtYW51ZmFjdHVyZXInLFxyXG4gIHNldEZpbHRlck1vZGU6ICgpID0+IHt9LFxyXG4gIGJsb2NrTWFudWZhY3R1cmVyQXBpQ2FsbHM6IGZhbHNlLFxyXG4gIHNldEJsb2NrTWFudWZhY3R1cmVyQXBpQ2FsbHM6ICgpID0+IHt9LFxyXG4gIGlzTWFudWZhY3R1cmVyQXBpQmxvY2tlZDogZmFsc2UsXHJcbiAgc2V0SXNNYW51ZmFjdHVyZXJBcGlCbG9ja2VkOiAoKSA9PiB7fSxcclxuXHJcbiAgLy8gR2VvZmVuY2luZyBwcm9wZXJ0aWVzXHJcbiAgZ2VvZmVuY2VDZW50ZXI6IG51bGwsXHJcbiAgZ2VvZmVuY2VSYWRpdXM6IDI1LCAvLyBEZWZhdWx0IHRvIDI1a20sIG5vdCBudWxsXHJcbiAgaXNHZW9mZW5jZUFjdGl2ZTogZmFsc2UsXHJcbiAgc2V0R2VvZmVuY2VDZW50ZXI6ICgpID0+IHt9LFxyXG4gIHNldEdlb2ZlbmNlUmFkaXVzOiAoKSA9PiB7fSxcclxuICBnZW9mZW5jZUNvb3JkaW5hdGVzOiBudWxsLFxyXG4gIHRvZ2dsZUdlb2ZlbmNlOiAoKSA9PiB7fSxcclxuICBjbGVhckdlb2ZlbmNlOiAoKSA9PiAoe30pLFxyXG4gIGZpbHRlcmVkQWlyY3JhZnQ6IFtdLFxyXG4gIHNlbGVjdGVkUmVnaW9uOiBSZWdpb25Db2RlLkdMT0JBTCxcclxuICBzZXRTZWxlY3RlZFJlZ2lvbjogKHJlZ2lvbjogUmVnaW9uQ29kZSB8IHN0cmluZykgPT4ge30sXHJcbiAgZ2V0Qm91bmRzQnlSZWdpb246IChyZWdpb246IHN0cmluZykgPT5cclxuICAgIGNvbmZpZ0dldEJvdW5kc0J5UmVnaW9uKCdHTE9CQUwnKSBhcyBMYXRMbmdCb3VuZHNFeHByZXNzaW9uLFxyXG4gIGlzR2VvZmVuY2VQbGFjZW1lbnRNb2RlOiBmYWxzZSxcclxuICBzZXRJc0dlb2ZlbmNlUGxhY2VtZW50TW9kZTogKCkgPT4ge30sXHJcbiAgc2V0UGFuZWxQb3NpdGlvbjogKCkgPT4ge30sXHJcbn0pO1xyXG5cclxuLy8gUHJvcHMgZm9yIHRoZSBjb250ZXh0IHByb3ZpZGVyXHJcbmludGVyZmFjZSBFbmhhbmNlZE1hcFByb3ZpZGVyUHJvcHMge1xyXG4gIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGU7XHJcbiAgbWFudWZhY3R1cmVyczogU2VsZWN0T3B0aW9uW107XHJcbiAgb25FcnJvcjogKG1lc3NhZ2U6IHN0cmluZykgPT4gdm9pZDtcclxufVxyXG5cclxuLy8gRW5oYW5jZWQgTWFwIFByb3ZpZGVyIGNvbXBvbmVudFxyXG5leHBvcnQgY29uc3QgRW5oYW5jZWRNYXBQcm92aWRlcjogUmVhY3QuRkM8RW5oYW5jZWRNYXBQcm92aWRlclByb3BzPiA9ICh7XHJcbiAgY2hpbGRyZW4sXHJcbiAgbWFudWZhY3R1cmVycyxcclxuICBvbkVycm9yLFxyXG59KSA9PiB7XHJcbiAgLy8gTWFwIHN0YXRlXHJcbiAgY29uc3QgW21hcEluc3RhbmNlLCBzZXRNYXBJbnN0YW5jZV0gPSB1c2VTdGF0ZTxMLk1hcCB8IG51bGw+KG51bGwpO1xyXG4gIGNvbnN0IFt6b29tTGV2ZWwsIHNldFpvb21MZXZlbF0gPSB1c2VTdGF0ZTxudW1iZXI+KDYpO1xyXG5cclxuICAvLyBBaXJjcmFmdCBzdGF0ZVxyXG4gIGNvbnN0IFtkaXNwbGF5ZWRBaXJjcmFmdCwgc2V0RGlzcGxheWVkQWlyY3JhZnRdID0gdXNlU3RhdGU8XHJcbiAgICBFeHRlbmRlZEFpcmNyYWZ0W11cclxuICA+KFtdKTtcclxuICBjb25zdCBbc2VsZWN0ZWRBaXJjcmFmdCwgc2V0U2VsZWN0ZWRBaXJjcmFmdF0gPVxyXG4gICAgdXNlU3RhdGU8RXh0ZW5kZWRBaXJjcmFmdCB8IG51bGw+KG51bGwpO1xyXG5cclxuICAvLyBEYXRhIHBlcnNpc3RlbmNlIHN0YXRlXHJcbiAgY29uc3QgW2NhY2hlZEFpcmNyYWZ0RGF0YSwgc2V0Q2FjaGVkQWlyY3JhZnREYXRhXSA9IHVzZVN0YXRlPFxyXG4gICAgUmVjb3JkPHN0cmluZywgQ2FjaGVkQWlyY3JhZnREYXRhPlxyXG4gID4oe30pO1xyXG4gIGNvbnN0IFtsYXN0UGVyc2lzdGVuY2VVcGRhdGUsIHNldExhc3RQZXJzaXN0ZW5jZVVwZGF0ZV0gPSB1c2VTdGF0ZTxcclxuICAgIG51bWJlciB8IG51bGxcclxuICA+KG51bGwpO1xyXG5cclxuICBjb25zdCBbZ2VvZmVuY2VDZW50ZXIsIHNldEdlb2ZlbmNlQ2VudGVyXSA9IHVzZVN0YXRlPHtcclxuICAgIGxhdDogbnVtYmVyO1xyXG4gICAgbG5nOiBudW1iZXI7XHJcbiAgfSB8IG51bGw+KG51bGwpO1xyXG5cclxuICBjb25zdCBbc2VsZWN0ZWRSZWdpb24sIHNldFNlbGVjdGVkUmVnaW9uXSA9IHVzZVN0YXRlPFJlZ2lvbkNvZGUgfCBzdHJpbmc+KFxyXG4gICAgUmVnaW9uQ29kZS5HTE9CQUxcclxuICApO1xyXG5cclxuICAvLyBEZXJpdmVkIHN0YXRlIGZvciBnZW9mZW5jZSBjb29yZGluYXRlc1xyXG4gIGNvbnN0IGdlb2ZlbmNlQ29vcmRpbmF0ZXMgPSB1c2VNZW1vKCgpID0+IGdlb2ZlbmNlQ2VudGVyLCBbZ2VvZmVuY2VDZW50ZXJdKTtcclxuICBjb25zdCBbZ2VvZmVuY2VSYWRpdXMsIHNldEdlb2ZlbmNlUmFkaXVzXSA9IHVzZVN0YXRlPG51bWJlciB8IG51bGw+KDI1KTsgLy8gRGVmYXVsdCAyNWttIHJhZGl1c1xyXG4gIGNvbnN0IFtpc0dlb2ZlbmNlQWN0aXZlLCBzZXRJc0dlb2ZlbmNlQWN0aXZlXSA9IHVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKTtcclxuICBjb25zdCBbaXNHZW9mZW5jZVBsYWNlbWVudE1vZGUsIHNldElzR2VvZmVuY2VQbGFjZW1lbnRNb2RlXSA9XHJcbiAgICB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XHJcblxyXG4gIC8vIEFkZCB0aGlzIHRvIHlvdXIgc3RhdGUgZGVjbGFyYXRpb25zXHJcbiAgY29uc3QgW2FpcmNyYWZ0UG9zaXRpb25zLCBzZXRBaXJjcmFmdFBvc2l0aW9uc10gPSB1c2VTdGF0ZTxcclxuICAgIEFpcmNyYWZ0UG9zaXRpb25bXVxyXG4gID4oW10pO1xyXG4gIC8vIFRvZ2dsZSBnZW9mZW5jZSBhY3RpdmF0aW9uXHJcbiAgY29uc3QgdG9nZ2xlR2VvZmVuY2UgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICBzZXRJc0dlb2ZlbmNlQWN0aXZlKChwcmV2KSA9PiAhcHJldik7XHJcbiAgfSwgW10pO1xyXG5cclxuICAvLyBDbGVhciBnZW9mZW5jZVxyXG4gIGNvbnN0IGNsZWFyR2VvZmVuY2UgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICBzZXRHZW9mZW5jZUNlbnRlcihudWxsKTtcclxuICAgIHNldElzR2VvZmVuY2VBY3RpdmUoZmFsc2UpO1xyXG4gICAgcmV0dXJuIHt9OyAvLyBSZXR1cm4gYW4gZW1wdHkgb2JqZWN0IHRvIG1hdGNoIHRoZSBleHBlY3RlZCB0eXBlXHJcbiAgfSwgW10pO1xyXG5cclxuICAvLyBTZWxlY3Rpb24gc3RhdGVcclxuICBjb25zdCBbc2VsZWN0ZWRNYW51ZmFjdHVyZXIsIHNldFNlbGVjdGVkTWFudWZhY3R1cmVyXSA9IHVzZVN0YXRlPFxyXG4gICAgc3RyaW5nIHwgbnVsbFxyXG4gID4obnVsbCk7XHJcbiAgY29uc3QgW3NlbGVjdGVkTW9kZWwsIHNldFNlbGVjdGVkTW9kZWxdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XHJcbiAgY29uc3QgW2FjdGl2ZU1vZGVscywgc2V0QWN0aXZlTW9kZWxzXSA9IHVzZVN0YXRlPEFpcmNyYWZ0TW9kZWxbXT4oW10pO1xyXG4gIGNvbnN0IFt0b3RhbEFjdGl2ZSwgc2V0VG90YWxBY3RpdmVdID0gdXNlU3RhdGU8bnVtYmVyPigwKTtcclxuXHJcbiAgLy8gTG9hZGluZyBzdGF0ZVxyXG4gIGNvbnN0IFtpc0xvYWRpbmcsIHNldElzTG9hZGluZ10gPSB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XHJcbiAgY29uc3QgW2lzUmVmcmVzaGluZywgc2V0SXNSZWZyZXNoaW5nXSA9IHVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKTtcclxuICBjb25zdCBbdHJhY2tpbmdTdGF0dXMsIHNldFRyYWNraW5nU3RhdHVzXSA9IHVzZVN0YXRlPHN0cmluZz4oJycpO1xyXG4gIGNvbnN0IFtsYXN0UmVmcmVzaGVkLCBzZXRMYXN0UmVmcmVzaGVkXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xyXG4gIC8vIEFkZCB0aGlzIHdpdGggeW91ciBvdGhlciBzdGF0ZSB2YXJpYWJsZXNcclxuICBjb25zdCBbbGFzdEZ1bGxSZWZyZXNoVGltZSwgc2V0TGFzdEZ1bGxSZWZyZXNoVGltZV0gPSB1c2VTdGF0ZTxudW1iZXIgfCBudWxsPihcclxuICAgIG51bGxcclxuICApO1xyXG4gIGNvbnN0IFtpc01hbnVmYWN0dXJlckFwaUJsb2NrZWQsIHNldElzTWFudWZhY3R1cmVyQXBpQmxvY2tlZF0gPVxyXG4gICAgdXNlU3RhdGU8Ym9vbGVhbj4oZmFsc2UpO1xyXG5cclxuICBjb25zdCBbZmlsdGVyTW9kZSwgc2V0RmlsdGVyTW9kZV0gPSB1c2VTdGF0ZTxcclxuICAgICdtYW51ZmFjdHVyZXInIHwgJ2dlb2ZlbmNlJyB8ICdib3RoJyB8ICdyZWdpb24nIHwgJ293bmVyJ1xyXG4gID4oJ21hbnVmYWN0dXJlcicpO1xyXG4gIGNvbnN0IFtibG9ja01hbnVmYWN0dXJlckFwaUNhbGxzLCBzZXRCbG9ja01hbnVmYWN0dXJlckFwaUNhbGxzXSA9XHJcbiAgICB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XHJcblxyXG4gIC8vIEZsYWcgdG8gdHJhY2sgaWYgd2UncmUgaW4gZ2VvZmVuY2UgbW9kZVxyXG4gIGNvbnN0IFtpc0dlb2ZlbmNlTW9kZSwgc2V0SXNHZW9mZW5jZU1vZGVdID0gdXNlU3RhdGU8Ym9vbGVhbj4oZmFsc2UpO1xyXG5cclxuICAvLyBEZWZpbmUgdGhlIGZpbHRlciBmdW5jdGlvbiBjb3JyZWN0bHlcclxuICBjb25zdCBmaWx0ZXJBaXJjcmFmdEJ5R2VvZmVuY2UgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICBpZiAoIWdlb2ZlbmNlQ2VudGVyIHx8ICFpc0dlb2ZlbmNlQWN0aXZlKSB7XHJcbiAgICAgIHJldHVybiBkaXNwbGF5ZWRBaXJjcmFmdDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gY2FsY3VsYXRlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xyXG4gICAgY29uc3QgY2FsY3VsYXRlRGlzdGFuY2UgPSAoXHJcbiAgICAgIGxhdDE6IG51bWJlcixcclxuICAgICAgbG9uMTogbnVtYmVyLFxyXG4gICAgICBsYXQyOiBudW1iZXIsXHJcbiAgICAgIGxvbjI6IG51bWJlclxyXG4gICAgKTogbnVtYmVyID0+IHtcclxuICAgICAgY29uc3QgUiA9IDYzNzE7IC8vIFJhZGl1cyBvZiB0aGUgZWFydGggaW4ga21cclxuICAgICAgY29uc3QgZExhdCA9IGRlZzJyYWQobGF0MiAtIGxhdDEpO1xyXG4gICAgICBjb25zdCBkTG9uID0gZGVnMnJhZChsb24yIC0gbG9uMSk7XHJcbiAgICAgIGNvbnN0IGEgPVxyXG4gICAgICAgIE1hdGguc2luKGRMYXQgLyAyKSAqIE1hdGguc2luKGRMYXQgLyAyKSArXHJcbiAgICAgICAgTWF0aC5jb3MoZGVnMnJhZChsYXQxKSkgKlxyXG4gICAgICAgICAgTWF0aC5jb3MoZGVnMnJhZChsYXQyKSkgKlxyXG4gICAgICAgICAgTWF0aC5zaW4oZExvbiAvIDIpICpcclxuICAgICAgICAgIE1hdGguc2luKGRMb24gLyAyKTtcclxuICAgICAgY29uc3QgYyA9IDIgKiBNYXRoLmF0YW4yKE1hdGguc3FydChhKSwgTWF0aC5zcXJ0KDEgLSBhKSk7XHJcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gUiAqIGM7IC8vIERpc3RhbmNlIGluIGttXHJcbiAgICAgIHJldHVybiBkaXN0YW5jZTtcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgZGVnMnJhZCA9IChkZWc6IG51bWJlcik6IG51bWJlciA9PiB7XHJcbiAgICAgIHJldHVybiBkZWcgKiAoTWF0aC5QSSAvIDE4MCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEZpbHRlciBhaXJjcmFmdCB3aXRoaW4gdGhlIHJhZGl1c1xyXG4gICAgcmV0dXJuIGRpc3BsYXllZEFpcmNyYWZ0LmZpbHRlcigoYWlyY3JhZnQpID0+IHtcclxuICAgICAgaWYgKCFhaXJjcmFmdC5sYXRpdHVkZSB8fCAhYWlyY3JhZnQubG9uZ2l0dWRlKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAvLyBDYWxjdWxhdGUgZGlzdGFuY2UgYmV0d2VlbiBhaXJjcmFmdCBhbmQgZ2VvZmVuY2UgY2VudGVyXHJcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gY2FsY3VsYXRlRGlzdGFuY2UoXHJcbiAgICAgICAgZ2VvZmVuY2VDZW50ZXIubGF0LFxyXG4gICAgICAgIGdlb2ZlbmNlQ2VudGVyLmxuZyxcclxuICAgICAgICBhaXJjcmFmdC5sYXRpdHVkZSxcclxuICAgICAgICBhaXJjcmFmdC5sb25naXR1ZGVcclxuICAgICAgKTtcclxuXHJcbiAgICAgIC8vIFJldHVybiB0cnVlIGlmIGFpcmNyYWZ0IGlzIHdpdGhpbiByYWRpdXNcclxuICAgICAgcmV0dXJuIGdlb2ZlbmNlUmFkaXVzICE9PSBudWxsICYmIGRpc3RhbmNlIDw9IGdlb2ZlbmNlUmFkaXVzO1xyXG4gICAgfSk7XHJcbiAgfSwgW2Rpc3BsYXllZEFpcmNyYWZ0LCBnZW9mZW5jZUNlbnRlciwgZ2VvZmVuY2VSYWRpdXMsIGlzR2VvZmVuY2VBY3RpdmVdKTtcclxuXHJcbiAgLy8gVGhlbiBzZXBhcmF0ZWx5LCBkZWZpbmUgZmlsdGVyZWRBaXJjcmFmdCAtIGRvbid0IHRyeSB0byBkbyBib3RoIGluIHRoZSBzYW1lIGZ1bmN0aW9uXHJcbiAgY29uc3QgZmlsdGVyZWRBaXJjcmFmdCA9IHVzZU1lbW8oKCkgPT4ge1xyXG4gICAgcmV0dXJuIGlzR2VvZmVuY2VBY3RpdmUgJiYgZ2VvZmVuY2VDZW50ZXJcclxuICAgICAgPyBmaWx0ZXJBaXJjcmFmdEJ5R2VvZmVuY2UoKVxyXG4gICAgICA6IGRpc3BsYXllZEFpcmNyYWZ0O1xyXG4gIH0sIFtcclxuICAgIGlzR2VvZmVuY2VBY3RpdmUsXHJcbiAgICBnZW9mZW5jZUNlbnRlcixcclxuICAgIGZpbHRlckFpcmNyYWZ0QnlHZW9mZW5jZSxcclxuICAgIGRpc3BsYXllZEFpcmNyYWZ0LFxyXG4gIF0pO1xyXG5cclxuICAvLyBSZWZzIGZvciB0cmFja2luZyBzdWJzY3JpcHRpb25zXHJcbiAgY29uc3QgdW5zdWJzY3JpYmVBaXJjcmFmdFJlZiA9IHVzZVJlZjwoKCkgPT4gdm9pZCkgfCBudWxsPihudWxsKTtcclxuICBjb25zdCB1bnN1YnNjcmliZVN0YXR1c1JlZiA9IHVzZVJlZjwoKCkgPT4gdm9pZCkgfCBudWxsPihudWxsKTtcclxuICAvLyBMb2FkIHBlcnNpc3RlZCBhaXJjcmFmdCBkYXRhIG9uIG1vdW50XHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGNvbnN0IHNhdmVkRGF0YSA9IGxvYWRBaXJjcmFmdERhdGEoKTtcclxuICAgIGlmIChzYXZlZERhdGEpIHtcclxuICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgYFtFbmhhbmNlZE1hcENvbnRleHRdIExvYWRlZCAke09iamVjdC5rZXlzKHNhdmVkRGF0YSkubGVuZ3RofSBhaXJjcmFmdCBmcm9tIHBlcnNpc3RlbmNlYFxyXG4gICAgICApO1xyXG4gICAgICBzZXRDYWNoZWRBaXJjcmFmdERhdGEoc2F2ZWREYXRhKTtcclxuICAgICAgc2V0TGFzdFBlcnNpc3RlbmNlVXBkYXRlKERhdGUubm93KCkpO1xyXG4gICAgfVxyXG4gIH0sIFtdKTtcclxuXHJcbiAgLy8gU2F2ZSBhaXJjcmFmdCBkYXRhIHdoZW4gY2FjaGVkQWlyY3JhZnREYXRhIGNoYW5nZXNcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKE9iamVjdC5rZXlzKGNhY2hlZEFpcmNyYWZ0RGF0YSkubGVuZ3RoID4gMCkge1xyXG4gICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICBgW0VuaGFuY2VkTWFwQ29udGV4dF0gU2F2aW5nICR7T2JqZWN0LmtleXMoY2FjaGVkQWlyY3JhZnREYXRhKS5sZW5ndGh9IGFpcmNyYWZ0IHRvIHBlcnNpc3RlbmNlYFxyXG4gICAgICApO1xyXG4gICAgICBzYXZlQWlyY3JhZnREYXRhKGNhY2hlZEFpcmNyYWZ0RGF0YSk7XHJcbiAgICB9XHJcbiAgfSwgW2NhY2hlZEFpcmNyYWZ0RGF0YV0pO1xyXG5cclxuICAvLyBJbml0aWFsaXplIHRyYWNraW5nIHNlcnZpY2UgYW5kIHN1YnNjcmlwdGlvbnNcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgLy8gU3Vic2NyaWJlIHRvIHRyYWNraW5nIHVwZGF0ZXMgdGhhdCBpbmNsdWRlIHRyYWlsIGRhdGFcclxuICAgIGNvbnN0IGhhbmRsZVRyYWNraW5nVXBkYXRlID0gKGRhdGE6IGFueSkgPT4ge1xyXG4gICAgICAvLyBPbmx5IHVwZGF0ZSBkaXNwbGF5ZWQgYWlyY3JhZnQgaWYgd2UncmUgbm90IGluIGdlb2ZlbmNlIG1vZGVcclxuICAgICAgaWYgKCFpc0dlb2ZlbmNlTW9kZSkge1xyXG4gICAgICAgIHVwZGF0ZUFpcmNyYWZ0RGlzcGxheSgpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFN1YnNjcmliZSB0byBhaXJjcmFmdCB1cGRhdGVzXHJcbiAgICB1bnN1YnNjcmliZUFpcmNyYWZ0UmVmLmN1cnJlbnQgPVxyXG4gICAgICBvcGVuU2t5VHJhY2tpbmdTZXJ2aWNlLnN1YnNjcmliZShoYW5kbGVUcmFja2luZ1VwZGF0ZSk7XHJcblxyXG4gICAgLy8gU3Vic2NyaWJlIHRvIHN0YXR1cyB1cGRhdGVzXHJcbiAgICB1bnN1YnNjcmliZVN0YXR1c1JlZi5jdXJyZW50ID0gb3BlblNreVRyYWNraW5nU2VydmljZS5zdWJzY3JpYmVUb1N0YXR1cyhcclxuICAgICAgKHN0YXR1czogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgc2V0VHJhY2tpbmdTdGF0dXMoc3RhdHVzKTtcclxuICAgICAgICBzZXRJc0xvYWRpbmcob3BlblNreVRyYWNraW5nU2VydmljZS5pc0xvYWRpbmcoKSk7XHJcbiAgICAgIH1cclxuICAgICk7XHJcblxyXG4gICAgLy8gSU1QT1JUQU5UOiBDbGVhciBhbnkgZXhpc3RpbmcgdHJhY2tpbmcgd2hlbiBjb21wb25lbnQgbW91bnRzXHJcbiAgICBvcGVuU2t5VHJhY2tpbmdTZXJ2aWNlLnN0b3BUcmFja2luZygpO1xyXG5cclxuICAgIC8vIENsZWFudXAgb24gdW5tb3VudFxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgaWYgKHVuc3Vic2NyaWJlQWlyY3JhZnRSZWYuY3VycmVudCkge1xyXG4gICAgICAgIHVuc3Vic2NyaWJlQWlyY3JhZnRSZWYuY3VycmVudCgpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh1bnN1YnNjcmliZVN0YXR1c1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgdW5zdWJzY3JpYmVTdGF0dXNSZWYuY3VycmVudCgpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH0sIFtpc0dlb2ZlbmNlTW9kZV0pO1xyXG5cclxuICAvLyBVcGRhdGUgYWlyY3JhZnQgZGF0YSB3aXRoIHBlcnNpc3RlbmNlXHJcbiAgY29uc3QgdXBkYXRlQWlyY3JhZnREYXRhID0gdXNlQ2FsbGJhY2soXHJcbiAgICAobmV3QWlyY3JhZnRBcnJheTogRXh0ZW5kZWRBaXJjcmFmdFtdKSA9PiB7XHJcbiAgICAgIC8vIENvbnZlcnQgdG8gYSBtYXAgZm9yIGVhc2llciBwcm9jZXNzaW5nXHJcbiAgICAgIGNvbnN0IG5ld0FpcmNyYWZ0TWFwOiBSZWNvcmQ8c3RyaW5nLCBDYWNoZWRBaXJjcmFmdERhdGE+ID0ge307XHJcblxyXG4gICAgICBuZXdBaXJjcmFmdEFycmF5LmZvckVhY2goKGFpcmNyYWZ0KSA9PiB7XHJcbiAgICAgICAgaWYgKGFpcmNyYWZ0LklDQU8yNCkge1xyXG4gICAgICAgICAgbmV3QWlyY3JhZnRNYXBbYWlyY3JhZnQuSUNBTzI0XSA9IHtcclxuICAgICAgICAgICAgLi4uYWlyY3JhZnQsXHJcbiAgICAgICAgICAgIC8vIEVuc3VyZSByZXF1aXJlZCBmaWVsZHMgZm9yIENhY2hlZEFpcmNyYWZ0RGF0YSBhcmUgcHJlc2VudFxyXG4gICAgICAgICAgICBJQ0FPMjQ6IGFpcmNyYWZ0LklDQU8yNCxcclxuICAgICAgICAgICAgbGF0aXR1ZGU6IGFpcmNyYWZ0LmxhdGl0dWRlIHx8IDAsXHJcbiAgICAgICAgICAgIGxvbmdpdHVkZTogYWlyY3JhZnQubG9uZ2l0dWRlIHx8IDAsXHJcbiAgICAgICAgICAgIGFsdGl0dWRlOiBhaXJjcmFmdC5hbHRpdHVkZSB8fCAwLFxyXG4gICAgICAgICAgICB2ZWxvY2l0eTogYWlyY3JhZnQudmVsb2NpdHkgfHwgMCxcclxuICAgICAgICAgICAgaGVhZGluZzogYWlyY3JhZnQuaGVhZGluZyB8fCAwLFxyXG4gICAgICAgICAgICBvbl9ncm91bmQ6IGFpcmNyYWZ0Lm9uX2dyb3VuZCB8fCBmYWxzZSxcclxuICAgICAgICAgICAgbGFzdF9jb250YWN0OiBhaXJjcmFmdC5sYXN0X2NvbnRhY3QgfHwgRGF0ZS5ub3coKSxcclxuICAgICAgICAgICAgbGFzdFNlZW46IERhdGUubm93KCksXHJcbiAgICAgICAgICAgIGxhc3RVcGRhdGVkOiBEYXRlLm5vdygpLFxyXG4gICAgICAgICAgfSBhcyBDYWNoZWRBaXJjcmFmdERhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIE1lcmdlIHdpdGggZXhpc3RpbmcgY2FjaGVkIGRhdGEgdG8gcHJlc2VydmUgZmllbGRzXHJcbiAgICAgIHNldENhY2hlZEFpcmNyYWZ0RGF0YSgoY3VycmVudENhY2hlKSA9PlxyXG4gICAgICAgIG1lcmdlQWlyY3JhZnREYXRhKGN1cnJlbnRDYWNoZSwgbmV3QWlyY3JhZnRNYXApXHJcbiAgICAgICk7XHJcbiAgICAgIHNldExhc3RQZXJzaXN0ZW5jZVVwZGF0ZShEYXRlLm5vdygpKTtcclxuXHJcbiAgICAgIC8vIElmIHRoZSBzZWxlY3RlZCBhaXJjcmFmdCBpcyB1cGRhdGVkLCB1cGRhdGUgdGhlIHNlbGVjdGlvblxyXG4gICAgICBpZiAoc2VsZWN0ZWRBaXJjcmFmdCAmJiBuZXdBaXJjcmFmdE1hcFtzZWxlY3RlZEFpcmNyYWZ0LklDQU8yNF0pIHtcclxuICAgICAgICBjb25zdCB1cGRhdGVkQWlyY3JhZnQgPSB7XHJcbiAgICAgICAgICAuLi5zZWxlY3RlZEFpcmNyYWZ0LFxyXG4gICAgICAgICAgLi4ubmV3QWlyY3JhZnRNYXBbc2VsZWN0ZWRBaXJjcmFmdC5JQ0FPMjRdLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgc2V0U2VsZWN0ZWRBaXJjcmFmdCh1cGRhdGVkQWlyY3JhZnQgYXMgRXh0ZW5kZWRBaXJjcmFmdCk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBbc2VsZWN0ZWRBaXJjcmFmdF1cclxuICApO1xyXG5cclxuICAvLyBDbGVhciBwZXJzaXN0ZW5jZSBjYWNoZVxyXG4gIGNvbnN0IGNsZWFyQ2FjaGUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICBjbGVhckFpcmNyYWZ0RGF0YSgpO1xyXG4gICAgc2V0Q2FjaGVkQWlyY3JhZnREYXRhKHt9KTtcclxuICAgIHNldExhc3RQZXJzaXN0ZW5jZVVwZGF0ZShudWxsKTtcclxuICAgIHNldFRyYWNraW5nU3RhdHVzKCdDYWNoZSBjbGVhcmVkJyk7XHJcbiAgfSwgW10pO1xyXG5cclxuICAvLyBVcGRhdGUgYWlyY3JhZnQgZGlzcGxheSBiYXNlZCBvbiBzZWxlY3RlZCBNT0RFTFxyXG4gIGNvbnN0IHVwZGF0ZUFpcmNyYWZ0RGlzcGxheSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgIC8vIEdldCBleHRlbmRlZCBhaXJjcmFmdCBiYXNlZCBvbiBzZWxlY3RlZCBNT0RFTFxyXG4gICAgY29uc3QgZXh0ZW5kZWRBaXJjcmFmdCA9IG9wZW5Ta3lUcmFja2luZ1NlcnZpY2UuZ2V0RXh0ZW5kZWRBaXJjcmFmdChcclxuICAgICAgc2VsZWN0ZWRNb2RlbCB8fCB1bmRlZmluZWRcclxuICAgICk7XHJcblxyXG4gICAgLy8gR2V0IE1PREVMIHN0YXRzIGZyb20gdGhlIHNlcnZpY2VcclxuICAgIGNvbnN0IHsgbW9kZWxzLCB0b3RhbEFjdGl2ZTogdG90YWwgfSA9XHJcbiAgICAgIG9wZW5Ta3lUcmFja2luZ1NlcnZpY2UuZ2V0TW9kZWxTdGF0cygpO1xyXG5cclxuICAgIC8vIEVuaGFuY2UgYWlyY3JhZnQgZGF0YSB3aXRoIHBlcnNpc3RlbmNlXHJcbiAgICB1cGRhdGVBaXJjcmFmdERhdGEoZXh0ZW5kZWRBaXJjcmFmdCBhcyBFeHRlbmRlZEFpcmNyYWZ0W10pO1xyXG5cclxuICAgIC8vIE9ubHkgdXBkYXRlIGRpc3BsYXllZCBhaXJjcmFmdCBpZiB3ZSdyZSBub3QgaW4gZ2VvZmVuY2UgbW9kZVxyXG4gICAgaWYgKCFpc0dlb2ZlbmNlTW9kZSkge1xyXG4gICAgICBzZXREaXNwbGF5ZWRBaXJjcmFmdChleHRlbmRlZEFpcmNyYWZ0IGFzIEV4dGVuZGVkQWlyY3JhZnRbXSk7XHJcbiAgICAgIHNldEFjdGl2ZU1vZGVscyhtb2RlbHMpO1xyXG4gICAgICBzZXRUb3RhbEFjdGl2ZSh0b3RhbCk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0SXNMb2FkaW5nKG9wZW5Ta3lUcmFja2luZ1NlcnZpY2UuaXNMb2FkaW5nKCkpO1xyXG4gIH0sIFtzZWxlY3RlZE1vZGVsLCB1cGRhdGVBaXJjcmFmdERhdGEsIGlzR2VvZmVuY2VNb2RlXSk7XHJcblxyXG4gIC8vIFVwZGF0ZSBkaXNwbGF5IHdoZW4gTU9ERUwgc2VsZWN0aW9uIGNoYW5nZXNcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgdXBkYXRlQWlyY3JhZnREaXNwbGF5KCk7XHJcbiAgfSwgW3NlbGVjdGVkTW9kZWwsIHVwZGF0ZUFpcmNyYWZ0RGlzcGxheV0pO1xyXG5cclxuICAvLyBOZXcgZnVuY3Rpb24gdG8gaGFuZGxlIGdlb2ZlbmNlIGFpcmNyYWZ0IHVwZGF0ZXNcclxuICBjb25zdCB1cGRhdGVHZW9mZW5jZUFpcmNyYWZ0ID0gdXNlQ2FsbGJhY2soXHJcbiAgICAoZ2VvZmVuY2VBaXJjcmFmdDogRXh0ZW5kZWRBaXJjcmFmdFtdKSA9PiB7XHJcbiAgICAgIC8vIE1hcmsgdGhhdCB3ZSdyZSBpbiBnZW9mZW5jZSBtb2RlXHJcbiAgICAgIHNldElzR2VvZmVuY2VNb2RlKHRydWUpO1xyXG5cclxuICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgYFtFbmhhbmNlZE1hcENvbnRleHRdIFVwZGF0aW5nICR7Z2VvZmVuY2VBaXJjcmFmdC5sZW5ndGh9IGFpcmNyYWZ0IGZyb20gZ2VvZmVuY2VgXHJcbiAgICAgICk7XHJcblxyXG4gICAgICAvLyBVcGRhdGUgdGhlIGNhY2hlZCBkYXRhIChzYW1lIGFzIHJlZ3VsYXIgdXBkYXRlcylcclxuICAgICAgdXBkYXRlQWlyY3JhZnREYXRhKGdlb2ZlbmNlQWlyY3JhZnQpO1xyXG5cclxuICAgICAgLy8gQWxzbyBkaXJlY3RseSB1cGRhdGUgdGhlIGRpc3BsYXllZCBhaXJjcmFmdFxyXG4gICAgICBzZXREaXNwbGF5ZWRBaXJjcmFmdChnZW9mZW5jZUFpcmNyYWZ0KTtcclxuXHJcbiAgICAgIC8vIFVwZGF0ZSBzdGF0c1xyXG4gICAgICBzZXRUb3RhbEFjdGl2ZShnZW9mZW5jZUFpcmNyYWZ0Lmxlbmd0aCk7XHJcblxyXG4gICAgICAvLyBFeHRyYWN0IE1PREVMIHN0YXRzIGZvciB0aGUgc2lkZWJhclxyXG4gICAgICBjb25zdCBtb2RlbENvdW50cyA9IGdlb2ZlbmNlQWlyY3JhZnQucmVkdWNlKFxyXG4gICAgICAgIChhY2MsIGFpcmNyYWZ0KSA9PiB7XHJcbiAgICAgICAgICBjb25zdCBNT0RFTCA9IGFpcmNyYWZ0Lk1PREVMIHx8IGFpcmNyYWZ0LlRZUEVfQUlSQ1JBRlQgfHwgJ1Vua25vd24nO1xyXG4gICAgICAgICAgaWYgKCFhY2NbTU9ERUxdKSB7XHJcbiAgICAgICAgICAgIGFjY1tNT0RFTF0gPSB7XHJcbiAgICAgICAgICAgICAgTU9ERUwsXHJcbiAgICAgICAgICAgICAgY291bnQ6IDAsXHJcbiAgICAgICAgICAgICAgTUFOVUZBQ1RVUkVSOiBhaXJjcmFmdC5NQU5VRkFDVFVSRVIgfHwgJ1Vua25vd24nLFxyXG4gICAgICAgICAgICAgIC8vIEFkZCByZXF1aXJlZCBwcm9wZXJ0aWVzIGZvciBBaXJjcmFmdE1vZGVsXHJcbiAgICAgICAgICAgICAgbGFiZWw6IE1PREVMLFxyXG4gICAgICAgICAgICAgIGFjdGl2ZUNvdW50OiAwLFxyXG4gICAgICAgICAgICAgIHRvdGFsQ291bnQ6IDAsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBhY2NbTU9ERUxdLmNvdW50Kys7XHJcbiAgICAgICAgICBhY2NbTU9ERUxdLmFjdGl2ZUNvdW50Kys7XHJcbiAgICAgICAgICBhY2NbTU9ERUxdLnRvdGFsQ291bnQrKztcclxuICAgICAgICAgIHJldHVybiBhY2M7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7fSBhcyBSZWNvcmQ8c3RyaW5nLCBBaXJjcmFmdE1vZGVsPlxyXG4gICAgICApO1xyXG5cclxuICAgICAgLy8gQ29udmVydCB0byBhcnJheSBmb3IgdGhlIGFjdGl2ZU1vZGVscyBzdGF0ZVxyXG4gICAgICBjb25zdCBtb2RlbEFycmF5ID0gT2JqZWN0LnZhbHVlcyhtb2RlbENvdW50cykubWFwKChNT0RFTCkgPT4gKHtcclxuICAgICAgICBNT0RFTDogTU9ERUwuTU9ERUwsXHJcbiAgICAgICAgY291bnQ6IE1PREVMLmNvdW50LFxyXG4gICAgICAgIE1BTlVGQUNUVVJFUjogTU9ERUwuTUFOVUZBQ1RVUkVSLFxyXG4gICAgICAgIC8vIEFkZCByZXF1aXJlZCBwcm9wZXJ0aWVzIGZvciBBaXJjcmFmdE1vZGVsIHR5cGVcclxuICAgICAgICBsYWJlbDogTU9ERUwuTU9ERUwsXHJcbiAgICAgICAgYWN0aXZlQ291bnQ6IE1PREVMLmNvdW50LFxyXG4gICAgICAgIHRvdGFsQ291bnQ6IE1PREVMLmNvdW50LFxyXG4gICAgICB9KSk7XHJcblxyXG4gICAgICBzZXRBY3RpdmVNb2RlbHMobW9kZWxBcnJheSk7XHJcblxyXG4gICAgICAvLyBVcGRhdGUgdGhlIGxhc3QgcmVmcmVzaGVkIHRpbWVzdGFtcFxyXG4gICAgICBzZXRMYXN0UmVmcmVzaGVkKG5ldyBEYXRlKCkudG9Mb2NhbGVUaW1lU3RyaW5nKCkpO1xyXG4gICAgfSxcclxuICAgIFt1cGRhdGVBaXJjcmFmdERhdGFdXHJcbiAgKTtcclxuXHJcbiAgLy8gSGFuZGxlIE1BTlVGQUNUVVJFUiBzZWxlY3Rpb25cclxuICAvLyBJbiB5b3VyIEVuaGFuY2VkTWFwQ29udGV4dC50c3ggLSBtb2RpZnkgdGhlIHNlbGVjdE1hbnVmYWN0dXJlciBmdW5jdGlvblxyXG5cclxuICBjb25zdCBzZWxlY3RNYW51ZmFjdHVyZXIgPSBhc3luYyAoTUFOVUZBQ1RVUkVSOiBzdHJpbmcgfCBudWxsKSA9PiB7XHJcbiAgICAvLyBFeGl0IGdlb2ZlbmNlIG1vZGUgd2hlbiBzZWxlY3RpbmcgYSBNQU5VRkFDVFVSRVJcclxuICAgIHNldElzR2VvZmVuY2VNb2RlKGZhbHNlKTtcclxuICAgIHNldFNlbGVjdGVkTWFudWZhY3R1cmVyKE1BTlVGQUNUVVJFUik7XHJcbiAgICBzZXRTZWxlY3RlZE1vZGVsKG51bGwpO1xyXG4gICAgc2V0SXNMb2FkaW5nKHRydWUpO1xyXG4gICAgc2V0TGFzdFJlZnJlc2hlZChudWxsKTtcclxuXHJcbiAgICAvLyBDbGVhciBwcmV2aW91cyBkYXRhXHJcbiAgICBzZXREaXNwbGF5ZWRBaXJjcmFmdChbXSk7XHJcbiAgICBzZXRBY3RpdmVNb2RlbHMoW10pO1xyXG4gICAgc2V0VG90YWxBY3RpdmUoMCk7XHJcblxyXG4gICAgLy8gSWYgbnVsbCwganVzdCBleGl0XHJcbiAgICBpZiAoTUFOVUZBQ1RVUkVSID09PSBudWxsKSB7XHJcbiAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJZiB3ZSdyZSBibG9ja2luZyBBUEkgY2FsbHMsIGV4aXQgZWFybHlcclxuICAgIGlmIChpc01hbnVmYWN0dXJlckFwaUJsb2NrZWQpIHtcclxuICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgYFtFbmhhbmNlZE1hcENvbnRleHRdIEFQSSBjYWxscyBibG9ja2VkIGZvciBtYW51ZmFjdHVyZXI6ICR7TUFOVUZBQ1RVUkVSfWBcclxuICAgICAgKTtcclxuICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIFN0YXJ0IHRyYWNraW5nIHdpdGggYSBwcm9ncmVzcyBoYW5kbGVyXHJcbiAgICAgIHNldFRyYWNraW5nU3RhdHVzKGBMb2FkaW5nIGFpcmNyYWZ0IGZvciAke01BTlVGQUNUVVJFUn0uLi5gKTtcclxuXHJcbiAgICAgIC8vIFVzZSB0aGUgZXhpc3Rpbmcgc2VydmljZSBidXQgd2l0aCBhIHByb2dyZXNzIGNhbGxiYWNrXHJcbiAgICAgIC8vIEluIEVuaGFuY2VkTWFwQ29udGV4dC50c3gsIG1vZGlmeSB5b3VyIGNhbGxiYWNrIHRvIGhhbmRsZSBib3RoIHR5cGVzOlxyXG5cclxuICAgICAgYXdhaXQgb3BlblNreVRyYWNraW5nU2VydmljZS50cmFja01hbnVmYWN0dXJlcldpdGhQcm9ncmVzcyhcclxuICAgICAgICBNQU5VRkFDVFVSRVIsXHJcbiAgICAgICAgKHByb2dyZXNzKSA9PiB7XHJcbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIHRyYWNraW5nIHN0YXR1cyBtZXNzYWdlXHJcbiAgICAgICAgICBpZiAocHJvZ3Jlc3MubWVzc2FnZSkge1xyXG4gICAgICAgICAgICBzZXRUcmFja2luZ1N0YXR1cyhwcm9ncmVzcy5tZXNzYWdlKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBVcGRhdGUgZGlzcGxheWVkIGFpcmNyYWZ0IGFzIHRoZXkncmUgbG9hZGVkXHJcbiAgICAgICAgICBpZiAocHJvZ3Jlc3MuYWlyY3JhZnQpIHtcclxuICAgICAgICAgICAgLy8gQ2FzdCB0aGUgYWlyY3JhZnQgYXJyYXkgdG8gRXh0ZW5kZWRBaXJjcmFmdFtdIHNpbmNlIG91ciBjb250ZXh0IHVzZXMgdGhhdCB0eXBlXHJcbiAgICAgICAgICAgIHNldERpc3BsYXllZEFpcmNyYWZ0KHByb2dyZXNzLmFpcmNyYWZ0IGFzIEV4dGVuZGVkQWlyY3JhZnRbXSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gVXBkYXRlIG1vZGVsIHN0YXRzXHJcbiAgICAgICAgICBpZiAocHJvZ3Jlc3MubW9kZWxzKSB7XHJcbiAgICAgICAgICAgIHNldEFjdGl2ZU1vZGVscyhwcm9ncmVzcy5tb2RlbHMpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFVwZGF0ZSB0b3RhbCBjb3VudFxyXG4gICAgICAgICAgaWYgKHByb2dyZXNzLnRvdGFsICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgc2V0VG90YWxBY3RpdmUocHJvZ3Jlc3MudG90YWwpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgKTtcclxuXHJcbiAgICAgIHNldExhc3RSZWZyZXNoZWQobmV3IERhdGUoKS50b0xvY2FsZVRpbWVTdHJpbmcoKSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBvbkVycm9yKFxyXG4gICAgICAgIGBFcnJvciB0cmFja2luZyBtYW51ZmFjdHVyZXI6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YFxyXG4gICAgICApO1xyXG4gICAgICBzZXRUcmFja2luZ1N0YXR1cygnRXJyb3IgbG9hZGluZyBhaXJjcmFmdCBkYXRhJyk7XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8vIEhhbmRsZSBNT0RFTCBzZWxlY3Rpb25cclxuICBjb25zdCBzZWxlY3RNb2RlbCA9IChNT0RFTDogc3RyaW5nIHwgbnVsbCkgPT4ge1xyXG4gICAgc2V0U2VsZWN0ZWRNb2RlbChNT0RFTCk7XHJcbiAgfTtcclxuXHJcbiAgLy8gSGFuZGxlIGFpcmNyYWZ0IHNlbGVjdGlvblxyXG4gIGNvbnN0IHNlbGVjdEFpcmNyYWZ0ID0gKGFpcmNyYWZ0OiBFeHRlbmRlZEFpcmNyYWZ0IHwgbnVsbCkgPT4ge1xyXG4gICAgc2V0U2VsZWN0ZWRBaXJjcmFmdChhaXJjcmFmdCk7XHJcblxyXG4gICAgLy8gSWYgc2VsZWN0aW5nIGFuIGFpcmNyYWZ0LCBjaGVjayBpZiB3ZSBoYXZlIGNhY2hlZCBkYXRhIHRvIGVuaGFuY2UgaXRcclxuICAgIGlmIChhaXJjcmFmdCAmJiBhaXJjcmFmdC5JQ0FPMjQgJiYgY2FjaGVkQWlyY3JhZnREYXRhW2FpcmNyYWZ0LklDQU8yNF0pIHtcclxuICAgICAgY29uc3QgZW5oYW5jZWRBaXJjcmFmdCA9IHtcclxuICAgICAgICAuLi5haXJjcmFmdCxcclxuICAgICAgICAuLi5jYWNoZWRBaXJjcmFmdERhdGFbYWlyY3JhZnQuSUNBTzI0XSxcclxuICAgICAgfTtcclxuICAgICAgc2V0U2VsZWN0ZWRBaXJjcmFmdChlbmhhbmNlZEFpcmNyYWZ0IGFzIEV4dGVuZGVkQWlyY3JhZnQpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8vIElmIHlvdSBkb24ndCBhbHJlYWR5IGhhdmUgaXQsIGFkZCB0aGlzIGZ1bmN0aW9uIHRvIGV4cG9zZSB0aGUgbWFwJ3MgZ2V0Qm91bmRzQnlSZWdpb24gZnVuY3Rpb25cclxuICAvLyBDcmVhdGUgYSB3cmFwcGVkIGZ1bmN0aW9uIHRoYXQgY2FsbHMgeW91ciBtYXAgY29uZmlnIGZ1bmN0aW9uXHJcbiAgY29uc3QgaGFuZGxlR2V0Qm91bmRzQnlSZWdpb24gPSB1c2VDYWxsYmFjayhcclxuICAgIChyZWdpb246IHN0cmluZyk6IExhdExuZ0JvdW5kc0V4cHJlc3Npb24gPT4ge1xyXG4gICAgICByZXR1cm4gY29uZmlnR2V0Qm91bmRzQnlSZWdpb24ocmVnaW9uKTtcclxuICAgIH0sXHJcbiAgICBbXVxyXG4gICk7XHJcblxyXG4gIC8vIFJlc2V0IGFsbCBzZWxlY3Rpb25zXHJcbiAgY29uc3QgcmVzZXQgPSBhc3luYyAoKSA9PiB7XHJcbiAgICBhd2FpdCBzZWxlY3RNYW51ZmFjdHVyZXIobnVsbCk7XHJcbiAgfTtcclxuXHJcbiAgLy8gTWV0aG9kIHRvIHJlZnJlc2ggb25seSB0aGUgcG9zaXRpb25zIG9mIGFjdGl2ZSBhaXJjcmFmdFxyXG4gIGNvbnN0IHJlZnJlc2hQb3NpdGlvbnMgPSBhc3luYyAoKSA9PiB7XHJcbiAgICBpZiAoaXNSZWZyZXNoaW5nIHx8ICghc2VsZWN0ZWRNYW51ZmFjdHVyZXIgJiYgIWlzR2VvZmVuY2VNb2RlKSkgcmV0dXJuO1xyXG5cclxuICAgIHNldElzUmVmcmVzaGluZyh0cnVlKTtcclxuICAgIHNldFRyYWNraW5nU3RhdHVzKCdVcGRhdGluZyBhaXJjcmFmdCBwb3NpdGlvbnMuLi4nKTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBDYWxsIHRoZSBzZXJ2aWNlXHJcbiAgICAgIGF3YWl0IG9wZW5Ta3lUcmFja2luZ1NlcnZpY2UucmVmcmVzaFBvc2l0aW9uc09ubHkoKTtcclxuXHJcbiAgICAgIHNldExhc3RSZWZyZXNoZWQobmV3IERhdGUoKS50b0xvY2FsZVRpbWVTdHJpbmcoKSk7XHJcbiAgICAgIHNldFRyYWNraW5nU3RhdHVzKFxyXG4gICAgICAgIGBQb3NpdGlvbnMgdXBkYXRlZCBmb3IgJHtkaXNwbGF5ZWRBaXJjcmFmdC5sZW5ndGh9IGFpcmNyYWZ0YFxyXG4gICAgICApO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgb25FcnJvcihcclxuICAgICAgICBgRXJyb3IgcmVmcmVzaGluZyBwb3NpdGlvbnM6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YFxyXG4gICAgICApO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgc2V0SXNSZWZyZXNoaW5nKGZhbHNlKTtcclxuICAgICAgfSwgNTAwKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvLyBNZXRob2QgZm9yIGZ1bGwgdHJhY2tpbmcgcmVmcmVzaFxyXG4gIGNvbnN0IGZ1bGxSZWZyZXNoID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgaWYgKCghc2VsZWN0ZWRNYW51ZmFjdHVyZXIgJiYgIWlzR2VvZmVuY2VNb2RlKSB8fCBpc1JlZnJlc2hpbmcpIHJldHVybjtcclxuXHJcbiAgICAvLyBTZXQgYSB0aW1lb3V0IHRvIGZvcmNlIGV4aXQgZnJvbSBsb2FkaW5nIHN0YXRlIGFmdGVyIDEwIHNlY29uZHNcclxuICAgIC8vIFRoaXMgaXMgYSBzYWZldHkgbWVjaGFuaXNtXHJcbiAgICBjb25zdCBzYWZldHlUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgIHNldElzUmVmcmVzaGluZyhmYWxzZSk7XHJcbiAgICAgIHNldFRyYWNraW5nU3RhdHVzKCdSZWZyZXNoIHRpbWVkIG91dCcpO1xyXG4gICAgfSwgMTAwMDApO1xyXG5cclxuICAgIHNldElzUmVmcmVzaGluZyh0cnVlKTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBHZXQgY3VycmVudGx5IHRyYWNrZWQgYWlyY3JhZnRcclxuICAgICAgY29uc3QgYWxsVHJhY2tlZEFpcmNyYWZ0ID0gb3BlblNreVRyYWNraW5nU2VydmljZS5nZXRUcmFja2VkQWlyY3JhZnQoKTtcclxuXHJcbiAgICAgIC8vIEdldCBhY3RpdmUgYWlyY3JhZnQgKHRob3NlIHdpdGggcG9zaXRpb24gZGF0YSlcclxuICAgICAgY29uc3QgYWN0aXZlQWlyY3JhZnQgPSBhbGxUcmFja2VkQWlyY3JhZnQuZmlsdGVyKFxyXG4gICAgICAgIChhaXJjcmFmdCkgPT4gYWlyY3JhZnQuSUNBTzI0ICYmIGFpcmNyYWZ0LmxhdGl0dWRlICYmIGFpcmNyYWZ0LmxvbmdpdHVkZVxyXG4gICAgICApO1xyXG5cclxuICAgICAgY29uc3QgbmVlZHNGdWxsUmVmcmVzaCA9XHJcbiAgICAgICAgIWxhc3RGdWxsUmVmcmVzaFRpbWUgfHwgRGF0ZS5ub3coKSAtIGxhc3RGdWxsUmVmcmVzaFRpbWUgPiAzNjAwMDAwO1xyXG5cclxuICAgICAgbGV0IHN1Y2Nlc3MgPSBmYWxzZTtcclxuXHJcbiAgICAgIGlmIChhY3RpdmVBaXJjcmFmdC5sZW5ndGggPT09IDAgfHwgbmVlZHNGdWxsUmVmcmVzaCkge1xyXG4gICAgICAgIC8vIERvIGEgZnVsbCByZWZyZXNoXHJcbiAgICAgICAgc2V0VHJhY2tpbmdTdGF0dXMoJ1BlcmZvcm1pbmcgZnVsbCByZWZyZXNoLi4uJyk7XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBhd2FpdCBvcGVuU2t5VHJhY2tpbmdTZXJ2aWNlLnJlZnJlc2hOb3coKTtcclxuICAgICAgICAgIHNldExhc3RGdWxsUmVmcmVzaFRpbWUoRGF0ZS5ub3coKSk7XHJcbiAgICAgICAgICBzdWNjZXNzID0gdHJ1ZTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgLy8gU2lsZW50bHkgaGFuZGxlIHRoaXMgZXJyb3JcclxuICAgICAgICAgIGNvbnNvbGUud2FybignRnVsbCByZWZyZXNoIGZhaWxlZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBEbyBhbiBvcHRpbWl6ZWQgcmVmcmVzaFxyXG4gICAgICAgIGNvbnN0IGFjdGl2ZUljYW9zID0gYWN0aXZlQWlyY3JhZnRcclxuICAgICAgICAgIC5tYXAoKGFpcmNyYWZ0KSA9PiBhaXJjcmFmdC5JQ0FPMjQpXHJcbiAgICAgICAgICAuZmlsdGVyKEJvb2xlYW4pIGFzIHN0cmluZ1tdO1xyXG5cclxuICAgICAgICBpZiAoYWN0aXZlSWNhb3MubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgc2V0VHJhY2tpbmdTdGF0dXMoXHJcbiAgICAgICAgICAgIGBSZWZyZXNoaW5nICR7YWN0aXZlSWNhb3MubGVuZ3RofSBhY3RpdmUgYWlyY3JhZnQuLi5gXHJcbiAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGF3YWl0IG9wZW5Ta3lUcmFja2luZ1NlcnZpY2UucmVmcmVzaFNwZWNpZmljQWlyY3JhZnQoYWN0aXZlSWNhb3MpO1xyXG4gICAgICAgICAgICBzdWNjZXNzID0gdHJ1ZTtcclxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIC8vIFRyeSBmYWxsaW5nIGJhY2sgdG8gYSBmdWxsIHJlZnJlc2hcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdPcHRpbWl6ZWQgcmVmcmVzaCBmYWlsZWQsIHRyeWluZyBmdWxsIHJlZnJlc2gnKTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICBhd2FpdCBvcGVuU2t5VHJhY2tpbmdTZXJ2aWNlLnJlZnJlc2hOb3coKTtcclxuICAgICAgICAgICAgICBzZXRMYXN0RnVsbFJlZnJlc2hUaW1lKERhdGUubm93KCkpO1xyXG4gICAgICAgICAgICAgIHN1Y2Nlc3MgPSB0cnVlO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChmYWxsYmFja0Vycm9yKSB7XHJcbiAgICAgICAgICAgICAgLy8gU2lsZW50bHkgaGFuZGxlIHRoaXMgZXJyb3JcclxuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZhbGxiYWNrIHJlZnJlc2ggZmFpbGVkJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNsZWFyVGltZW91dChzYWZldHlUaW1lb3V0KTtcclxuXHJcbiAgICAgIC8vIE9ubHkgdXBkYXRlIGlmIHRoZSByZWZyZXNoIHdhcyBzdWNjZXNzZnVsXHJcbiAgICAgIGlmIChzdWNjZXNzKSB7XHJcbiAgICAgICAgY29uc3QgY3VycmVudENvdW50ID0gb3BlblNreVRyYWNraW5nU2VydmljZS5nZXRUcmFja2VkQWlyY3JhZnQoKS5sZW5ndGg7XHJcbiAgICAgICAgc2V0VHJhY2tpbmdTdGF0dXMoYFJlZnJlc2ggY29tcGxldGVkIHdpdGggJHtjdXJyZW50Q291bnR9IGFpcmNyYWZ0YCk7XHJcbiAgICAgICAgc2V0TGFzdFJlZnJlc2hlZChuZXcgRGF0ZSgpLnRvTG9jYWxlVGltZVN0cmluZygpKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzZXRUcmFja2luZ1N0YXR1cygnUmVmcmVzaCBmYWlsZWQnKTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY2xlYXJUaW1lb3V0KHNhZmV0eVRpbWVvdXQpO1xyXG5cclxuICAgICAgLy8gT25seSBzaG93IGVycm9ycyB0byB0aGUgdXNlciBpZiB0aGV5IGFwcGVhciB0byBiZSBzaWduaWZpY2FudFxyXG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5tZXNzYWdlICE9PSAnYWJvcnRlZCcpIHtcclxuICAgICAgICBvbkVycm9yKGBFcnJvciBkdXJpbmcgcmVmcmVzaDogJHtlcnJvci5tZXNzYWdlIHx8ICdVbmtub3duIGVycm9yJ31gKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgc2V0VHJhY2tpbmdTdGF0dXMoJ0Vycm9yIGR1cmluZyByZWZyZXNoJyk7XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICBjbGVhclRpbWVvdXQoc2FmZXR5VGltZW91dCk7XHJcbiAgICAgIHNldElzUmVmcmVzaGluZyhmYWxzZSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgY2xlYXJHZW9mZW5jZURhdGEgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAvLyBSZXNldCBnZW9mZW5jZSBtb2RlIGZsYWdcclxuICAgIHNldElzR2VvZmVuY2VNb2RlKGZhbHNlKTtcclxuXHJcbiAgICAvLyBDbGVhciBkaXNwbGF5ZWQgYWlyY3JhZnRcclxuICAgIHNldERpc3BsYXllZEFpcmNyYWZ0KFtdKTtcclxuICAgIHNldEFjdGl2ZU1vZGVscyhbXSk7XHJcbiAgICBzZXRUb3RhbEFjdGl2ZSgwKTtcclxuXHJcbiAgICAvLyBJZiB0aGVyZSB3YXMgYSBwcmV2aW91c2x5IHNlbGVjdGVkIE1BTlVGQUNUVVJFUiwgd2UgY2FuIHJlc3RvcmUgaXRcclxuICAgIGlmIChzZWxlY3RlZE1hbnVmYWN0dXJlcikge1xyXG4gICAgICAvLyBTbWFsbCBkZWxheSB0byBlbnN1cmUgc3RhdGUgdXBkYXRlcyBwcm9wZXJseVxyXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICBvcGVuU2t5VHJhY2tpbmdTZXJ2aWNlLnRyYWNrTWFudWZhY3R1cmVyKHNlbGVjdGVkTWFudWZhY3R1cmVyKTtcclxuICAgICAgfSwgMTAwKTtcclxuICAgIH1cclxuICB9LCBbc2VsZWN0ZWRNYW51ZmFjdHVyZXJdKTtcclxuXHJcbiAgLy8gQ3JlYXRlIGNvbnRleHQgdmFsdWVcclxuICBjb25zdCBjb250ZXh0VmFsdWU6IEVuaGFuY2VkTWFwQ29udGV4dFR5cGUgPSB7XHJcbiAgICBtYXBJbnN0YW5jZSxcclxuICAgIHNldE1hcEluc3RhbmNlLFxyXG4gICAgem9vbUxldmVsLFxyXG4gICAgc2V0Wm9vbUxldmVsLFxyXG5cclxuICAgIGRpc3BsYXllZEFpcmNyYWZ0LFxyXG4gICAgc2VsZWN0ZWRBaXJjcmFmdCxcclxuICAgIHNlbGVjdEFpcmNyYWZ0LFxyXG5cclxuICAgIC8vIERhdGEgcGVyc2lzdGVuY2VcclxuICAgIGNhY2hlZEFpcmNyYWZ0RGF0YSxcclxuICAgIHVwZGF0ZUFpcmNyYWZ0RGF0YSxcclxuICAgIGxhc3RQZXJzaXN0ZW5jZVVwZGF0ZSxcclxuXHJcbiAgICBzZWxlY3RlZE1hbnVmYWN0dXJlcixcclxuICAgIHNlbGVjdGVkTW9kZWwsXHJcbiAgICBhY3RpdmVNb2RlbHMsXHJcbiAgICB0b3RhbEFjdGl2ZSxcclxuXHJcbiAgICBpc0xvYWRpbmcsXHJcbiAgICBpc1JlZnJlc2hpbmcsXHJcbiAgICB0cmFja2luZ1N0YXR1cyxcclxuICAgIGxhc3RSZWZyZXNoZWQsXHJcblxyXG4gICAgc2VsZWN0TWFudWZhY3R1cmVyLFxyXG4gICAgc2VsZWN0TW9kZWwsXHJcbiAgICByZXNldCxcclxuICAgIHJlZnJlc2hQb3NpdGlvbnMsXHJcbiAgICBmdWxsUmVmcmVzaCxcclxuICAgIGNsZWFyQ2FjaGUsXHJcbiAgICBjbGVhckdlb2ZlbmNlRGF0YSxcclxuICAgIHVwZGF0ZUdlb2ZlbmNlQWlyY3JhZnQsXHJcbiAgICBmaWx0ZXJlZEFpcmNyYWZ0LFxyXG5cclxuICAgIGZpbHRlck1vZGUsXHJcbiAgICBzZXRGaWx0ZXJNb2RlLFxyXG4gICAgYmxvY2tNYW51ZmFjdHVyZXJBcGlDYWxscyxcclxuICAgIHNldEJsb2NrTWFudWZhY3R1cmVyQXBpQ2FsbHMsXHJcbiAgICBpc01hbnVmYWN0dXJlckFwaUJsb2NrZWQsXHJcbiAgICBzZXRJc01hbnVmYWN0dXJlckFwaUJsb2NrZWQsXHJcblxyXG4gICAgLy8gR2VvZmVuY2luZyBwcm9wZXJ0aWVzXHJcbiAgICBnZW9mZW5jZUNlbnRlcixcclxuICAgIGdlb2ZlbmNlUmFkaXVzLFxyXG4gICAgaXNHZW9mZW5jZUFjdGl2ZSxcclxuICAgIGdlb2ZlbmNlQ29vcmRpbmF0ZXMsXHJcbiAgICBzZXRHZW9mZW5jZUNlbnRlcixcclxuICAgIHNldEdlb2ZlbmNlUmFkaXVzLFxyXG4gICAgdG9nZ2xlR2VvZmVuY2UsXHJcbiAgICBjbGVhckdlb2ZlbmNlLFxyXG4gICAgaXNHZW9mZW5jZVBsYWNlbWVudE1vZGUsXHJcbiAgICBzZXRJc0dlb2ZlbmNlUGxhY2VtZW50TW9kZSxcclxuXHJcbiAgICAvLyBSZWdpb24gc2VsZWN0aW9uXHJcbiAgICBzZWxlY3RlZFJlZ2lvbixcclxuICAgIHNldFNlbGVjdGVkUmVnaW9uLFxyXG4gICAgZ2V0Qm91bmRzQnlSZWdpb246IGhhbmRsZUdldEJvdW5kc0J5UmVnaW9uLFxyXG4gIH07XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8RW5oYW5jZWRNYXBDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtjb250ZXh0VmFsdWV9PlxyXG4gICAgICB7Y2hpbGRyZW59XHJcbiAgICA8L0VuaGFuY2VkTWFwQ29udGV4dC5Qcm92aWRlcj5cclxuICApO1xyXG59O1xyXG5cclxuLy8gQ3VzdG9tIGhvb2sgdG8gdXNlIHRoZSBjb250ZXh0XHJcbmV4cG9ydCBjb25zdCB1c2VFbmhhbmNlZE1hcENvbnRleHQgPSAoKSA9PiB1c2VDb250ZXh0KEVuaGFuY2VkTWFwQ29udGV4dCk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBFbmhhbmNlZE1hcENvbnRleHQ7XHJcbiJdLCJuYW1lcyI6WyJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VDYWxsYmFjayIsInVzZVJlZiIsInVzZU1lbW8iLCJSZWdpb25Db2RlIiwib3BlblNreVRyYWNraW5nU2VydmljZSIsInNhdmVBaXJjcmFmdERhdGEiLCJsb2FkQWlyY3JhZnREYXRhIiwibWVyZ2VBaXJjcmFmdERhdGEiLCJjbGVhckFpcmNyYWZ0RGF0YSIsImdldEJvdW5kc0J5UmVnaW9uIiwiY29uZmlnR2V0Qm91bmRzQnlSZWdpb24iLCJFbmhhbmNlZE1hcENvbnRleHQiLCJtYXBJbnN0YW5jZSIsInNldE1hcEluc3RhbmNlIiwiem9vbUxldmVsIiwic2V0Wm9vbUxldmVsIiwiZGlzcGxheWVkQWlyY3JhZnQiLCJzZWxlY3RlZEFpcmNyYWZ0Iiwic2VsZWN0QWlyY3JhZnQiLCJjYWNoZWRBaXJjcmFmdERhdGEiLCJ1cGRhdGVBaXJjcmFmdERhdGEiLCJsYXN0UGVyc2lzdGVuY2VVcGRhdGUiLCJzZWxlY3RlZE1hbnVmYWN0dXJlciIsInNlbGVjdGVkTW9kZWwiLCJhY3RpdmVNb2RlbHMiLCJ0b3RhbEFjdGl2ZSIsImlzTG9hZGluZyIsImlzUmVmcmVzaGluZyIsInRyYWNraW5nU3RhdHVzIiwibGFzdFJlZnJlc2hlZCIsInNlbGVjdE1hbnVmYWN0dXJlciIsInNlbGVjdE1vZGVsIiwicmVzZXQiLCJyZWZyZXNoUG9zaXRpb25zIiwiZnVsbFJlZnJlc2giLCJjbGVhckNhY2hlIiwiY2xlYXJHZW9mZW5jZURhdGEiLCJ1cGRhdGVHZW9mZW5jZUFpcmNyYWZ0IiwiZmlsdGVyTW9kZSIsInNldEZpbHRlck1vZGUiLCJibG9ja01hbnVmYWN0dXJlckFwaUNhbGxzIiwic2V0QmxvY2tNYW51ZmFjdHVyZXJBcGlDYWxscyIsImlzTWFudWZhY3R1cmVyQXBpQmxvY2tlZCIsInNldElzTWFudWZhY3R1cmVyQXBpQmxvY2tlZCIsImdlb2ZlbmNlQ2VudGVyIiwiZ2VvZmVuY2VSYWRpdXMiLCJpc0dlb2ZlbmNlQWN0aXZlIiwic2V0R2VvZmVuY2VDZW50ZXIiLCJzZXRHZW9mZW5jZVJhZGl1cyIsImdlb2ZlbmNlQ29vcmRpbmF0ZXMiLCJ0b2dnbGVHZW9mZW5jZSIsImNsZWFyR2VvZmVuY2UiLCJmaWx0ZXJlZEFpcmNyYWZ0Iiwic2VsZWN0ZWRSZWdpb24iLCJHTE9CQUwiLCJzZXRTZWxlY3RlZFJlZ2lvbiIsInJlZ2lvbiIsImlzR2VvZmVuY2VQbGFjZW1lbnRNb2RlIiwic2V0SXNHZW9mZW5jZVBsYWNlbWVudE1vZGUiLCJzZXRQYW5lbFBvc2l0aW9uIiwiRW5oYW5jZWRNYXBQcm92aWRlciIsImNoaWxkcmVuIiwibWFudWZhY3R1cmVycyIsIm9uRXJyb3IiLCJzZXREaXNwbGF5ZWRBaXJjcmFmdCIsInNldFNlbGVjdGVkQWlyY3JhZnQiLCJzZXRDYWNoZWRBaXJjcmFmdERhdGEiLCJzZXRMYXN0UGVyc2lzdGVuY2VVcGRhdGUiLCJzZXRJc0dlb2ZlbmNlQWN0aXZlIiwiYWlyY3JhZnRQb3NpdGlvbnMiLCJzZXRBaXJjcmFmdFBvc2l0aW9ucyIsInByZXYiLCJzZXRTZWxlY3RlZE1hbnVmYWN0dXJlciIsInNldFNlbGVjdGVkTW9kZWwiLCJzZXRBY3RpdmVNb2RlbHMiLCJzZXRUb3RhbEFjdGl2ZSIsInNldElzTG9hZGluZyIsInNldElzUmVmcmVzaGluZyIsInNldFRyYWNraW5nU3RhdHVzIiwic2V0TGFzdFJlZnJlc2hlZCIsImxhc3RGdWxsUmVmcmVzaFRpbWUiLCJzZXRMYXN0RnVsbFJlZnJlc2hUaW1lIiwiaXNHZW9mZW5jZU1vZGUiLCJzZXRJc0dlb2ZlbmNlTW9kZSIsImZpbHRlckFpcmNyYWZ0QnlHZW9mZW5jZSIsImNhbGN1bGF0ZURpc3RhbmNlIiwibGF0MSIsImxvbjEiLCJsYXQyIiwibG9uMiIsIlIiLCJkTGF0IiwiZGVnMnJhZCIsImRMb24iLCJhIiwiTWF0aCIsInNpbiIsImNvcyIsImMiLCJhdGFuMiIsInNxcnQiLCJkaXN0YW5jZSIsImRlZyIsIlBJIiwiZmlsdGVyIiwiYWlyY3JhZnQiLCJsYXRpdHVkZSIsImxvbmdpdHVkZSIsImxhdCIsImxuZyIsInVuc3Vic2NyaWJlQWlyY3JhZnRSZWYiLCJ1bnN1YnNjcmliZVN0YXR1c1JlZiIsInNhdmVkRGF0YSIsImNvbnNvbGUiLCJsb2ciLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwiRGF0ZSIsIm5vdyIsImhhbmRsZVRyYWNraW5nVXBkYXRlIiwiZGF0YSIsInVwZGF0ZUFpcmNyYWZ0RGlzcGxheSIsImN1cnJlbnQiLCJzdWJzY3JpYmUiLCJzdWJzY3JpYmVUb1N0YXR1cyIsInN0YXR1cyIsInN0b3BUcmFja2luZyIsIm5ld0FpcmNyYWZ0QXJyYXkiLCJuZXdBaXJjcmFmdE1hcCIsImZvckVhY2giLCJJQ0FPMjQiLCJhbHRpdHVkZSIsInZlbG9jaXR5IiwiaGVhZGluZyIsIm9uX2dyb3VuZCIsImxhc3RfY29udGFjdCIsImxhc3RTZWVuIiwibGFzdFVwZGF0ZWQiLCJjdXJyZW50Q2FjaGUiLCJ1cGRhdGVkQWlyY3JhZnQiLCJleHRlbmRlZEFpcmNyYWZ0IiwiZ2V0RXh0ZW5kZWRBaXJjcmFmdCIsInVuZGVmaW5lZCIsIm1vZGVscyIsInRvdGFsIiwiZ2V0TW9kZWxTdGF0cyIsImdlb2ZlbmNlQWlyY3JhZnQiLCJtb2RlbENvdW50cyIsInJlZHVjZSIsImFjYyIsIk1PREVMIiwiVFlQRV9BSVJDUkFGVCIsImNvdW50IiwiTUFOVUZBQ1RVUkVSIiwibGFiZWwiLCJhY3RpdmVDb3VudCIsInRvdGFsQ291bnQiLCJtb2RlbEFycmF5IiwidmFsdWVzIiwibWFwIiwidG9Mb2NhbGVUaW1lU3RyaW5nIiwidHJhY2tNYW51ZmFjdHVyZXJXaXRoUHJvZ3Jlc3MiLCJwcm9ncmVzcyIsIm1lc3NhZ2UiLCJlcnJvciIsIkVycm9yIiwiZW5oYW5jZWRBaXJjcmFmdCIsImhhbmRsZUdldEJvdW5kc0J5UmVnaW9uIiwicmVmcmVzaFBvc2l0aW9uc09ubHkiLCJzZXRUaW1lb3V0Iiwic2FmZXR5VGltZW91dCIsImFsbFRyYWNrZWRBaXJjcmFmdCIsImdldFRyYWNrZWRBaXJjcmFmdCIsImFjdGl2ZUFpcmNyYWZ0IiwibmVlZHNGdWxsUmVmcmVzaCIsInN1Y2Nlc3MiLCJyZWZyZXNoTm93Iiwid2FybiIsImFjdGl2ZUljYW9zIiwiQm9vbGVhbiIsInJlZnJlc2hTcGVjaWZpY0FpcmNyYWZ0IiwiZmFsbGJhY2tFcnJvciIsImNsZWFyVGltZW91dCIsImN1cnJlbnRDb3VudCIsInRyYWNrTWFudWZhY3R1cmVyIiwiY29udGV4dFZhbHVlIiwiUHJvdmlkZXIiLCJ2YWx1ZSIsInVzZUVuaGFuY2VkTWFwQ29udGV4dCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/tracking/context/EnhancedMapContext.tsx\n"));

/***/ })

});
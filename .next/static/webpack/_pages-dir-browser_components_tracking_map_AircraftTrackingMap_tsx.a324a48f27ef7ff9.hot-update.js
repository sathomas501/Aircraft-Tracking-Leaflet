"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_pages-dir-browser_components_tracking_map_AircraftTrackingMap_tsx",{

/***/ "(pages-dir-browser)/./components/tracking/hooks/useFilterLogic.ts":
/*!*****************************************************!*\
  !*** ./components/tracking/hooks/useFilterLogic.ts ***!
  \*****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useFilterLogic: () => (/* binding */ useFilterLogic)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _types_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/types/base */ \"(pages-dir-browser)/./types/base.ts\");\n/* harmony import */ var _context_EnhancedMapContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../context/EnhancedMapContext */ \"(pages-dir-browser)/./components/tracking/context/EnhancedMapContext.tsx\");\n/* harmony import */ var _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/services/openSkyTrackingService */ \"(pages-dir-browser)/./lib/services/openSkyTrackingService.ts\");\n/* harmony import */ var _lib_services_MapboxService__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../lib/services/MapboxService */ \"(pages-dir-browser)/./lib/services/MapboxService.ts\");\n/* harmony import */ var _lib_utils_geofenceAdapter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/lib/utils/geofenceAdapter */ \"(pages-dir-browser)/./lib/utils/geofenceAdapter.ts\");\n/* harmony import */ var _lib_utils_geofenceEnricher__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/lib/utils/geofenceEnricher */ \"(pages-dir-browser)/./lib/utils/geofenceEnricher.ts\");\n/* harmony import */ var _lib_services_geofencing__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../lib/services/geofencing */ \"(pages-dir-browser)/./lib/services/geofencing.ts\");\n/* harmony import */ var _hooks_useGeolocation__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../hooks/useGeolocation */ \"(pages-dir-browser)/./components/tracking/hooks/useGeolocation.ts\");\n/* harmony import */ var _config_map__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../config/map */ \"(pages-dir-browser)/./config/map.ts\");\n\n\n\n\n\n\n\n\n\n\n\nfunction useFilterLogic() {\n    // Get context state and functions\n    const { selectedManufacturer, selectedModel, totalActive, selectManufacturer, selectModel, reset, fullRefresh, refreshPositions, mapInstance, updateAircraftData, clearGeofenceData, updateGeofenceAircraft, blockManufacturerApiCalls, setBlockManufacturerApiCalls, isManufacturerApiBlocked, setIsManufacturerApiBlocked, geofenceCenter, setGeofenceCenter, toggleGeofence, clearGeofence, displayedAircraft } = (0,_context_EnhancedMapContext__WEBPACK_IMPORTED_MODULE_2__.useEnhancedMapContext)();\n    // Get geolocation hook\n    const { getCurrentPosition } = (0,_hooks_useGeolocation__WEBPACK_IMPORTED_MODULE_8__.useGeolocation)();\n    // Local state\n    const [localLoading, setLocalLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [filterMode, setFilterMode] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [activeDropdown, setActiveDropdown] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [manufacturerSearchTerm, setManufacturerSearchTerm] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)('');\n    const [isRefreshing, setIsRefreshing] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [isRateLimited, setIsRateLimited] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [rateLimitTimer, setRateLimitTimer] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [isGeofencePanelOpen, setIsGeofencePanelOpen] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    // Geofence state\n    const [isGettingLocation, setIsGettingLocation] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [geofenceLocation, setGeofenceLocation] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)('');\n    const [geofenceRadius, setGeofenceRadius] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(25);\n    const [geofenceCoordinates, setGeofenceCoordinates] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [geofenceAircraft, setGeofenceAircraft] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [geofenceEnabled, setGeofenceEnabled] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [isGeofenceActive, setIsGeofenceActive] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [isSearchReady, setIsSearchReady] = react__WEBPACK_IMPORTED_MODULE_0___default().useState(false);\n    // Region state\n    const [activeRegion, setActiveRegion] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [regionOutline, setRegionOutline] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [selectedRegion, setSelectedRegion] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(_types_base__WEBPACK_IMPORTED_MODULE_1__.RegionCode.GLOBAL);\n    // Combined mode state\n    const [combinedModeReady, setCombinedModeReady] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    // Owner filter state\n    const allOwnerTypes = [\n        'individual',\n        'partnership',\n        'corp-owner',\n        'co-owned',\n        'llc',\n        'non-citizen-corp',\n        'airline',\n        'freight',\n        'medical',\n        'media',\n        'historical',\n        'flying-club',\n        'emergency',\n        'local-govt',\n        'education',\n        'federal-govt',\n        'flight-school',\n        'leasing-corp',\n        'military',\n        'unknown'\n    ];\n    const [ownerFilters, setOwnerFilters] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([\n        ...allOwnerTypes\n    ]);\n    // Refs for dropdown handling\n    const dropdownRefs = {\n        filter: (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),\n        manufacturer: (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),\n        model: (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),\n        location: (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),\n        region: (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),\n        owner: (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),\n        actions: (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null)\n    };\n    // Effects\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect({\n        \"useFilterLogic.useEffect\": ()=>{\n            if (geofenceCoordinates) {\n                setIsSearchReady(true);\n            }\n        }\n    }[\"useFilterLogic.useEffect\"], [\n        geofenceCoordinates\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useFilterLogic.useEffect\": ()=>{\n            if (isRateLimited && rateLimitTimer) {\n                const timer = setTimeout({\n                    \"useFilterLogic.useEffect.timer\": ()=>{\n                        setIsRateLimited(false);\n                        setRateLimitTimer(null);\n                        console.log('Rate limit timer expired, resuming API calls');\n                    }\n                }[\"useFilterLogic.useEffect.timer\"], rateLimitTimer * 1000);\n                return ({\n                    \"useFilterLogic.useEffect\": ()=>clearTimeout(timer)\n                })[\"useFilterLogic.useEffect\"];\n            }\n        }\n    }[\"useFilterLogic.useEffect\"], [\n        isRateLimited,\n        rateLimitTimer\n    ]);\n    // Effect to sync geofence state\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useFilterLogic.useEffect\": ()=>{\n            // Update internal state when geofence is toggled externally\n            if (isGeofenceActive !== geofenceEnabled) {\n                setGeofenceEnabled(isGeofenceActive);\n            }\n        }\n    }[\"useFilterLogic.useEffect\"], [\n        isGeofenceActive\n    ]);\n    // Close dropdown when clicking outside\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useFilterLogic.useEffect\": ()=>{\n            const handleClickOutside = {\n                \"useFilterLogic.useEffect.handleClickOutside\": (event)=>{\n                    // Check if click is outside of all dropdowns\n                    const isOutsideAll = Object.values(dropdownRefs).every({\n                        \"useFilterLogic.useEffect.handleClickOutside.isOutsideAll\": (ref)=>!ref.current || !ref.current.contains(event.target)\n                    }[\"useFilterLogic.useEffect.handleClickOutside.isOutsideAll\"]);\n                    if (isOutsideAll) {\n                        setActiveDropdown(null);\n                    }\n                }\n            }[\"useFilterLogic.useEffect.handleClickOutside\"];\n            document.addEventListener('mousedown', handleClickOutside);\n            return ({\n                \"useFilterLogic.useEffect\": ()=>{\n                    document.removeEventListener('mousedown', handleClickOutside);\n                }\n            })[\"useFilterLogic.useEffect\"];\n        }\n    }[\"useFilterLogic.useEffect\"], []);\n    // Clean up region outline when component unmounts\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useFilterLogic.useEffect\": ()=>{\n            return ({\n                \"useFilterLogic.useEffect\": ()=>{\n                    if (regionOutline) {\n                        regionOutline.remove();\n                    }\n                }\n            })[\"useFilterLogic.useEffect\"];\n        }\n    }[\"useFilterLogic.useEffect\"], [\n        regionOutline\n    ]);\n    // Effect to handle map click for geofence\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useFilterLogic.useEffect\": ()=>{\n            const handleMapGeofenceClick = {\n                \"useFilterLogic.useEffect.handleMapGeofenceClick\": async (event)=>{\n                    try {\n                        // Cast the event to the proper type\n                        const customEvent = event;\n                        const { lat, lng } = customEvent.detail;\n                        // First update coordinates immediately\n                        setGeofenceCoordinates({\n                            lat,\n                            lng\n                        });\n                        // Then start an async operation to get the location name\n                        console.log(\"Getting location name for: \".concat(lat, \", \").concat(lng));\n                        // Temporarily show coordinates while fetching the name\n                        setGeofenceLocation(\"\".concat(lat.toFixed(6), \", \").concat(lng.toFixed(6)));\n                        // Get the friendly name asynchronously\n                        const locationName = await _lib_services_MapboxService__WEBPACK_IMPORTED_MODULE_4__.MapboxService.getLocationNameFromCoordinates(lat, lng);\n                        console.log(\"Got location name: \".concat(locationName));\n                        // Update with the friendly name once we have it\n                        if (locationName !== null) {\n                            setGeofenceLocation(locationName);\n                        }\n                        // Open the location dropdown if needed\n                        if (activeDropdown !== 'location') {\n                            setActiveDropdown('location');\n                        }\n                    } catch (error) {\n                        console.error('Error handling map click:', error);\n                    // Keep the coordinates display if there was an error\n                    }\n                }\n            }[\"useFilterLogic.useEffect.handleMapGeofenceClick\"];\n            // Add the event listener - use the standard event listener pattern\n            document.addEventListener('map-geofence-click', handleMapGeofenceClick);\n            // Clean up\n            return ({\n                \"useFilterLogic.useEffect\": ()=>{\n                    document.removeEventListener('map-geofence-click', handleMapGeofenceClick);\n                }\n            })[\"useFilterLogic.useEffect\"];\n        }\n    }[\"useFilterLogic.useEffect\"], [\n        setGeofenceLocation,\n        setGeofenceCoordinates,\n        setActiveDropdown,\n        activeDropdown\n    ]);\n    const toggleDropdown = (type, event)=>{\n        event.stopPropagation();\n        setActiveDropdown((prevState)=>prevState === type ? null : type);\n        // If opening the geofence panel, close any active dropdown\n        if (type === 'geofence' && activeDropdown) {\n            setActiveDropdown(null);\n        }\n    };\n    const handleRateLimit = function() {\n        let retryAfter = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 30;\n        setIsRateLimited(true);\n        setRateLimitTimer(retryAfter);\n        console.log(\"Rate limited by API. Retry after \".concat(retryAfter, \"s\"));\n        // Block all API calls\n        _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].setBlockAllApiCalls(true);\n        setBlockManufacturerApiCalls(true);\n        // Show notification to user\n        if (retryAfter > 0) {\n            alert(\"Aircraft data refresh rate limited. Please wait \".concat(retryAfter, \" seconds before trying again.\"));\n        }\n    };\n    /**\r\n   * Toggle filter mode\r\n   */ const toggleFilterMode = (mode)=>{\n        setFilterMode(mode);\n        setActiveDropdown(null);\n        // Apply appropriate filters based on new mode\n        if (mode === 'region') {\n            // Block API calls in region mode\n            _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].setBlockAllApiCalls(true);\n            // Apply region filtering if we already have data\n            if (displayedAircraft && displayedAircraft.length > 0) {\n                filterAircraftByRegion(selectedRegion.toString());\n            }\n            // Clear manufacturer selection from the UI\n            selectManufacturer(null);\n            selectModel(null);\n            // If geofence is active, restore the full geofence data\n            if (geofenceCoordinates && geofenceAircraft.length > 0) {\n                updateGeofenceAircraft(geofenceAircraft);\n            }\n        } else if (mode === 'owner') {\n            // Filter displayed aircraft by owner type\n            if (displayedAircraft && displayedAircraft.length > 0) {\n                // First filter for valid coordinates\n                const aircraftWithValidCoords = displayedAircraft.filter((plane)=>typeof plane.latitude === 'number' && typeof plane.longitude === 'number' && !isNaN(plane.latitude) && !isNaN(plane.longitude));\n                // Apply owner type filter\n                let filteredByOwner = ownerFilters.length === 0 ? aircraftWithValidCoords : aircraftWithValidCoords.filter((aircraft)=>ownerFilters.includes(getAircraftOwnerType(aircraft)));\n                // Update display with filtered aircraft\n                if (clearGeofenceData) {\n                    clearGeofenceData();\n                }\n                updateGeofenceAircraft(filteredByOwner);\n            }\n        } else if (mode === 'both') {\n            // Both mode - BLOCK API CALLS\n            _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].setBlockAllApiCalls(true);\n            if (selectedManufacturer && isGeofenceActive && geofenceAircraft.length > 0) {\n                applyCombinedFilters();\n            } else {\n                // If one is missing, prompt the user\n                if (!selectedManufacturer && isGeofenceActive) {\n                    alert('Please select a manufacturer to use combined filter mode');\n                } else if (selectedManufacturer && !isGeofenceActive) {\n                    alert('Please set a location to use combined filter mode');\n                } else {\n                    alert('Please select both a manufacturer and location to use combined filter mode');\n                }\n            }\n        }\n    };\n    // Owner filter methods\n    const getAircraftOwnerType = (aircraft)=>{\n        const ownerType = aircraft.TYPE_REGISTRANT || 0;\n        return ownerTypeToString(ownerType);\n    };\n    const ownerTypeToString = (type)=>{\n        const typeNum = typeof type === 'string' ? parseInt(type, 10) : type;\n        const ownerTypeMap = {\n            1: 'individual',\n            2: 'partnership',\n            3: 'corp-owner',\n            4: 'co-owned',\n            7: 'llc',\n            8: 'non-citizen-corp',\n            9: 'airline',\n            10: 'freight',\n            11: 'medical',\n            12: 'media',\n            13: 'historical',\n            14: 'flying-club',\n            15: 'emergency',\n            16: 'local-govt',\n            17: 'education',\n            18: 'federal-govt',\n            19: 'flight-school',\n            20: 'leasing-corp',\n            21: 'military'\n        };\n        return ownerTypeMap[typeNum] || 'unknown';\n    };\n    const applyOwnerTypeFilter = (filters)=>{\n        // Skip filtering if all types are selected or none are selected\n        if (filters.length === 0 || filters.length === allOwnerTypes.length) {\n            return;\n        }\n        // Filter the aircraft based on selected owner types\n        if (displayedAircraft && displayedAircraft.length > 0) {\n            const filteredAircraft = displayedAircraft.filter((aircraft)=>{\n                const ownerType = getAircraftOwnerType(aircraft);\n                return filters.includes(ownerType);\n            });\n            // Update the displayed aircraft\n            if (clearGeofenceData) {\n                clearGeofenceData();\n            }\n            updateGeofenceAircraft(filteredAircraft);\n        }\n    };\n    const handleOwnerFilterChange = (updatedFilters)=>{\n        setOwnerFilters(updatedFilters);\n        // Apply the filter to your aircraft data\n        applyOwnerTypeFilter(updatedFilters);\n    };\n    const resetOwnerFilters = ()=>{\n        setOwnerFilters([\n            ...allOwnerTypes\n        ]);\n    };\n    // Region filter methods\n    const filterAircraftByRegion = (region)=>{\n        if (!displayedAircraft || displayedAircraft.length === 0) return;\n        setLocalLoading(true);\n        try {\n            // Get the bounds for the selected region\n            const boundsExpression = (0,_config_map__WEBPACK_IMPORTED_MODULE_9__.getBoundsByRegion)(region);\n            // Ensure bounds is in the correct format\n            if (!Array.isArray(boundsExpression) || boundsExpression.length !== 2) {\n                console.error(\"Invalid bounds format for region: \".concat(region), boundsExpression);\n                setLocalLoading(false);\n                return;\n            }\n            // Extract coordinates - Leaflet uses [lat, lng] format\n            const [[minLat, minLng], [maxLat, maxLng]] = boundsExpression;\n            console.log(\"Filtering by region: \".concat(region, \" with bounds:\"), {\n                minLat,\n                minLng,\n                maxLat,\n                maxLng\n            });\n            // Filter aircraft based on coordinates within the bounds\n            const filteredAircraft = displayedAircraft.filter((aircraft)=>{\n                // Check if aircraft has valid coordinates\n                if (typeof aircraft.latitude !== 'number' || typeof aircraft.longitude !== 'number' || isNaN(aircraft.latitude) || isNaN(aircraft.longitude)) {\n                    return false;\n                }\n                // Check if coordinates are within the bounds\n                return aircraft.latitude >= minLat && aircraft.latitude <= maxLat && aircraft.longitude >= minLng && aircraft.longitude <= maxLng;\n            });\n            // Update the display with filtered aircraft\n            if (clearGeofenceData) {\n                clearGeofenceData();\n            }\n            updateGeofenceAircraft(filteredAircraft);\n            console.log(\"Filtered to \".concat(filteredAircraft.length, \" aircraft in \").concat(region, \" region (out of \").concat(displayedAircraft.length, \" total)\"));\n        } catch (error) {\n            console.error('Error filtering aircraft by region:', error);\n        } finally{\n            setLocalLoading(false);\n        }\n    };\n    const handleRegionSelect = async (region)=>{\n        setActiveRegion(region);\n        setSelectedRegion(region);\n        setLocalLoading(true);\n        try {\n            // Set map bounds based on region\n            if (mapInstance) {\n                const bounds = (0,_config_map__WEBPACK_IMPORTED_MODULE_9__.getBoundsByRegion)(region);\n                // Get the appropriate zoom level for this region from your config\n                const zoomLevel = (0,_config_map__WEBPACK_IMPORTED_MODULE_9__.getZoomLevelForRegion)(region);\n                // First, set the appropriate zoom level\n                mapInstance.setZoom(zoomLevel);\n                // Then fit bounds with padding\n                const options = {\n                    padding: _config_map__WEBPACK_IMPORTED_MODULE_9__.MAP_CONFIG.PADDING.DEFAULT\n                };\n                mapInstance.fitBounds(bounds, options);\n                mapInstance.invalidateSize();\n                drawRegionOutline(region);\n            }\n            // Instead of immediately fetching aircraft data,\n            // just store the region selection for later use\n            console.log(\"Region selected. Waiting for manufacturer selection...\");\n            // Optionally, you could fetch just the count of aircraft in this region\n            // to give the user an idea of the data volume\n            const countResponse = await fetch(\"/api/tracking/region-count?region=\".concat(region));\n            if (countResponse.ok) {\n                const countData = await countResponse.json();\n                console.log(\"\".concat(countData.count, \" aircraft available in this region\"));\n            }\n            // Clear any previous aircraft data\n            if (clearGeofenceData) {\n                clearGeofenceData();\n            }\n        } catch (error) {\n            console.error('Error in region selection:', error);\n        } finally{\n            setLocalLoading(false);\n            setActiveDropdown(null);\n        }\n    };\n    const drawRegionOutline = (region)=>{\n        if (!mapInstance) return;\n        // Clear any existing outline\n        if (regionOutline) {\n            regionOutline.remove();\n        }\n        // Get the bounds for the selected region\n        const bounds = (0,_config_map__WEBPACK_IMPORTED_MODULE_9__.getBoundsByRegion)(region);\n        // Create a polygon from the bounds\n        const L = __webpack_require__(/*! leaflet */ \"(pages-dir-browser)/./node_modules/leaflet/dist/leaflet-src.js\");\n        const rectangle = L.rectangle(bounds, {\n            color: '#4f46e5',\n            weight: 3,\n            opacity: 0.7,\n            fill: true,\n            fillColor: '#4f46e5',\n            fillOpacity: 0.1,\n            dashArray: '5, 10',\n            interactive: false\n        });\n        // Add to map\n        rectangle.addTo(mapInstance);\n        // Update the state to include both the rectangle and the label\n        setRegionOutline({\n            remove: ()=>{\n                rectangle.remove();\n            }\n        });\n    };\n    // Geofence methods\n    // Fixed getUserLocation function\n    const getUserLocation = async ()=>{\n        if (isRateLimited) {\n            alert(\"Rate limited. Please wait \".concat(rateLimitTimer || 30, \" seconds before trying to get location.\"));\n            return;\n        }\n        setIsGettingLocation(true);\n        try {\n            const position = await getCurrentPosition();\n            if (position) {\n                const { latitude, longitude } = position.coords;\n                // Update state with coordinates\n                setGeofenceCoordinates({\n                    lat: latitude,\n                    lng: longitude\n                });\n                setGeofenceCenter({\n                    lat: latitude,\n                    lng: longitude\n                });\n                // Update the location display with coordinates\n                setGeofenceLocation(\"\".concat(latitude.toFixed(6), \", \").concat(longitude.toFixed(6)));\n                // Automatically trigger the geofence search\n                try {\n                    const fetchedAircraft = await (0,_lib_services_geofencing__WEBPACK_IMPORTED_MODULE_7__.getAircraftNearLocation)(latitude, longitude, geofenceRadius);\n                    if (fetchedAircraft.length === 0) {\n                        alert(\"No aircraft found near your current location. Try increasing the radius.\");\n                        setIsGettingLocation(false);\n                        return;\n                    }\n                    // Process the aircraft data\n                    const adaptedAircraft = (0,_lib_utils_geofenceAdapter__WEBPACK_IMPORTED_MODULE_5__.adaptGeofenceAircraft)(fetchedAircraft);\n                    const enrichedAircraft = await (0,_lib_utils_geofenceEnricher__WEBPACK_IMPORTED_MODULE_6__.enrichGeofenceAircraft)(adaptedAircraft);\n                    // Save to local state\n                    setGeofenceAircraft(enrichedAircraft);\n                    // Clear existing aircraft data\n                    if (clearGeofenceData) {\n                        clearGeofenceData();\n                    }\n                    // Update the map with new aircraft\n                    updateGeofenceAircraft(enrichedAircraft);\n                    setIsGeofenceActive(true);\n                    // Center the map on user's location - SIMPLIFIED ZOOM LOGIC\n                    if (mapInstance) {\n                        // Don't modify zoom if it's already at an appropriate level\n                        const currentZoom = mapInstance.getZoom();\n                        const targetZoom = currentZoom <= 7 ? 9 : currentZoom;\n                        // Set the view directly to the user's location\n                        mapInstance.setView([\n                            latitude,\n                            longitude\n                        ], targetZoom);\n                        // Make sure the map reflects changes\n                        mapInstance.invalidateSize();\n                    }\n                    // If in geofence mode, ensure the filter mode is set correctly\n                    if (filterMode !== 'geofence' && filterMode !== 'both') {\n                        setFilterMode('geofence');\n                    }\n                } catch (error) {\n                    var _error_message;\n                    if (((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes('rate limit')) || error.status === 429) {\n                        handleRateLimit(30);\n                        // Still update the location even if we couldn't get aircraft\n                        if (mapInstance) {\n                            mapInstance.setView([\n                                latitude,\n                                longitude\n                            ], 9);\n                            mapInstance.invalidateSize();\n                        }\n                    } else {\n                        throw error;\n                    }\n                }\n                // Close the dropdown after selection\n                setActiveDropdown(null);\n            }\n        } catch (error) {\n            console.error('Error getting user location:', error);\n            alert('Unable to access your location. Please make sure location services are enabled in your browser.');\n        } finally{\n            setIsGettingLocation(false);\n        }\n    };\n    const processGeofenceSearch = async ()=>{\n        if (!geofenceLocation) return;\n        // Check if rate limited\n        if (isRateLimited) {\n            alert(\"Rate limited. Please wait \".concat(rateLimitTimer || 30, \" seconds before searching again.\"));\n            return;\n        }\n        // Block API calls while doing geofence search in combined mode\n        if (filterMode === 'both') {\n            _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].setBlockAllApiCalls(true);\n            setBlockManufacturerApiCalls(true);\n        }\n        // Set loading state\n        setLocalLoading(true);\n        try {\n            console.log('Searching for aircraft near location: \"'.concat(geofenceLocation, '\"'));\n            // This will handle Postal codes, place names, addresses, POIs, etc.\n            let fetchedAircraft;\n            try {\n                fetchedAircraft = await (0,_lib_services_geofencing__WEBPACK_IMPORTED_MODULE_7__.getAircraftNearSearchedLocation)(geofenceLocation, geofenceRadius);\n            } catch (error) {\n                var _error_message;\n                if (((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes('rate limit')) || error.status === 429) {\n                    const retryAfter = 30; // Default to 30 seconds if not specified\n                    handleRateLimit(retryAfter);\n                    setLocalLoading(false);\n                    return;\n                }\n                throw error;\n            }\n            // Get coordinates for the map\n            let locations;\n            try {\n                locations = await _lib_services_MapboxService__WEBPACK_IMPORTED_MODULE_4__.MapboxService.searchLocationWithMapbox(geofenceLocation, 1);\n            } catch (error) {\n                console.error('Error searching location with Mapbox:', error);\n                // Continue with aircraft data if available\n                locations = [];\n            }\n            let coordinates = null;\n            if (locations.length > 0) {\n                coordinates = {\n                    lat: locations[0].lat,\n                    lng: locations[0].lng\n                };\n                // Save the formatted location name\n                setGeofenceLocation(locations[0].name);\n            } else if (fetchedAircraft.length > 0 && fetchedAircraft[0].latitude && fetchedAircraft[0].longitude) {\n                // Fallback to first aircraft position\n                coordinates = {\n                    lat: fetchedAircraft[0].latitude,\n                    lng: fetchedAircraft[0].longitude\n                };\n            }\n            if (fetchedAircraft.length === 0) {\n                alert(\"No aircraft found near \".concat(geofenceLocation, \". Try increasing the radius or searching in a different area.\"));\n                setLocalLoading(false);\n                return;\n            }\n            // Update state with the coordinates\n            if (coordinates) {\n                setGeofenceCoordinates(coordinates);\n                setGeofenceCenter(coordinates);\n                setGeofenceRadius(geofenceRadius);\n            }\n            if (!isGeofenceActive) {\n                toggleGeofence();\n            } else if (!coordinates) {\n                throw new Error('Could not determine coordinates for the location');\n            }\n            console.log(\"Found \".concat(fetchedAircraft.length, \" aircraft in the area, preparing for display...\"));\n            // Ensure the data is in the right format\n            const adaptedAircraft = fetchedAircraft[0].MANUFACTURER !== undefined ? fetchedAircraft // Already in the right format\n             : (0,_lib_utils_geofenceAdapter__WEBPACK_IMPORTED_MODULE_5__.adaptGeofenceAircraft)(fetchedAircraft); // Needs adaptation\n            // Enrich with static data\n            console.log('Enriching geofence aircraft with static data...');\n            const enrichedAircraft = await (0,_lib_utils_geofenceEnricher__WEBPACK_IMPORTED_MODULE_6__.enrichGeofenceAircraft)(adaptedAircraft);\n            // Save the FULL set to local state\n            setGeofenceAircraft(enrichedAircraft);\n            setIsGeofenceActive(true);\n            // Clear existing aircraft data\n            if (clearGeofenceData) {\n                clearGeofenceData();\n            }\n            // If we're in combined mode and have a manufacturer, apply the combined filter\n            if (filterMode === 'both' && selectedManufacturer) {\n                // Make sure API calls remain blocked\n                _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].setBlockAllApiCalls(true);\n                setBlockManufacturerApiCalls(true);\n                setTimeout(()=>{\n                    applyCombinedFilters();\n                }, 100);\n            } else {\n                // Just show all aircraft in the geofence\n                updateGeofenceAircraft(enrichedAircraft);\n                // Center the map - SIMPLIFIED ZOOM LOGIC\n                if (mapInstance && coordinates) {\n                    // Get current zoom level\n                    const currentZoom = mapInstance.getZoom();\n                    // Use appropriate zoom level based on current view\n                    const targetZoom = currentZoom <= 7 ? 9 : currentZoom;\n                    // Set view to the coordinates\n                    mapInstance.setView([\n                        coordinates.lat,\n                        coordinates.lng\n                    ], targetZoom);\n                    // Ensure map is updated\n                    mapInstance.invalidateSize();\n                }\n            }\n            // Close dropdown after search\n            setActiveDropdown(null);\n        } catch (error) {\n            var _error_message1;\n            console.error('Error in geofence search:', error);\n            if (((_error_message1 = error.message) === null || _error_message1 === void 0 ? void 0 : _error_message1.includes('rate limit')) || error.status === 429) {\n                handleRateLimit(30);\n            } else {\n                alert(\"Error: \".concat(error instanceof Error ? error.message : 'Unknown error occurred'));\n            }\n        } finally{\n            setLocalLoading(false);\n        }\n    };\n    /**\r\n   * STEP 3: Fix toggleGeofenceState to better handle manually clicking the button\r\n   */ const toggleGeofenceState = (enabled)=>{\n        console.log('toggleGeofenceState called with:', enabled);\n        console.log('Current geofenceCoordinates:', geofenceCoordinates);\n        if (enabled) {\n            // Check if we have valid coordinates\n            if (geofenceCoordinates && typeof geofenceCoordinates.lat === 'number' && typeof geofenceCoordinates.lng === 'number' && !isNaN(geofenceCoordinates.lat) && !isNaN(geofenceCoordinates.lng)) {\n                console.log('Valid coordinates found, enabling geofence');\n                // Set flags first\n                setGeofenceEnabled(true);\n                setIsGeofenceActive(true);\n                // Call context toggle function if available\n                if (typeof toggleGeofence === 'function') {\n                    toggleGeofence();\n                }\n                // Display aircraft if we have them\n                if (geofenceAircraft && geofenceAircraft.length > 0) {\n                    console.log(\"Showing \".concat(geofenceAircraft.length, \" aircraft in geofence\"));\n                    updateGeofenceAircraft(geofenceAircraft);\n                } else {\n                    // No aircraft data yet, trigger a search\n                    console.log('No aircraft data yet, triggering search');\n                    setTimeout(()=>{\n                        processGeofenceSearch();\n                    }, 100);\n                }\n            } else {\n                // No valid coordinates\n                console.warn('No valid coordinates, showing alert');\n                alert('Please set a location before enabling geofence.\\n\\nClick anywhere on the map to set a location.');\n                setGeofenceEnabled(false);\n                setIsGeofenceActive(false);\n            }\n        } else {\n            // Disabling geofence\n            console.log('Disabling geofence');\n            setGeofenceEnabled(false);\n            setIsGeofenceActive(false);\n            // Clear geofence data if function available\n            if (typeof clearGeofenceData === 'function') {\n                clearGeofenceData();\n            }\n        }\n    };\n    // Manufacturer filter methods\n    const selectManufacturerAndClose = (value)=>{\n        // Close dropdown\n        setActiveDropdown(null);\n        setManufacturerSearchTerm('');\n        // If clearing the selection\n        if (value === '') {\n            selectManufacturer(null);\n            return;\n        }\n        // Set the manufacturer selection\n        selectManufacturer(value);\n        // If region is already selected, fetch filtered data\n        if (activeRegion !== null) {\n            fetchAircraftByRegionAndManufacturer(activeRegion, value);\n        } else {\n            // Otherwise, just proceed with manufacturer-only filtering as before\n            fetchManufacturerData(value);\n        }\n    };\n    const fetchManufacturerData = (manufacturer)=>{\n        if (isRateLimited) {\n            console.log(\"Skipping data fetch - rate limited for \".concat(rateLimitTimer, \"s\"));\n            return;\n        }\n        console.log(\"Fetching data for manufacturer: \".concat(manufacturer));\n        try {\n            // If you have a context function for this, call it after a slight delay\n            if (typeof refreshPositions === 'function') {\n                // Apply a small delay to prevent overwhelming the API\n                setTimeout(()=>{\n                    refreshPositions().catch((error)=>{\n                        var _error_message;\n                        if (((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes('rate limit')) || error.status === 429) {\n                            handleRateLimit(30);\n                        } else {\n                            console.error('Error fetching manufacturer data:', error);\n                        }\n                    });\n                }, 200);\n            }\n        } catch (error) {\n            var _error_message;\n            if (((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes('rate limit')) || error.status === 429) {\n                handleRateLimit(30);\n            } else {\n                console.error('Error scheduling manufacturer data fetch:', error);\n            }\n        }\n    };\n    const fetchAircraftByRegionAndManufacturer = async function(region, manufacturer) {\n        let page = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, limit = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 500;\n        if (!region || !manufacturer) {\n            console.log('Both region and manufacturer must be selected');\n            return;\n        }\n        setLocalLoading(true);\n        try {\n            const response = await fetch(\"/api/tracking/filtered-aircraft?region=\".concat(region, \"&manufacturer=\").concat(encodeURIComponent(manufacturer), \"&page=\").concat(page, \"&limit=\").concat(limit));\n            const data = await response.json();\n            const aircraftData = data.aircraft || [];\n            if (!response.ok) {\n                throw new Error(\"API error: \".concat(response.statusText));\n            }\n            // Process the filtered aircraft data\n            if (aircraftData.length > 0) {\n                const extendedAircraft = aircraftData.map((aircraft)=>{\n                    var _aircraft_OPERATOR;\n                    var _aircraft_OPERATOR_toLowerCase_includes;\n                    return {\n                        ...aircraft,\n                        type: aircraft.TYPE_AIRCRAFT || 'Unknown',\n                        isGovernment: (_aircraft_OPERATOR_toLowerCase_includes = (_aircraft_OPERATOR = aircraft.OPERATOR) === null || _aircraft_OPERATOR === void 0 ? void 0 : _aircraft_OPERATOR.toLowerCase().includes('government')) !== null && _aircraft_OPERATOR_toLowerCase_includes !== void 0 ? _aircraft_OPERATOR_toLowerCase_includes : false,\n                        REGION: aircraft.REGION,\n                        zoomLevel: undefined\n                    };\n                });\n                // Update the map\n                updateGeofenceAircraft(extendedAircraft);\n            } else {\n                console.log(\"No aircraft found for manufacturer \".concat(manufacturer, \" in region \").concat(region));\n            }\n        } catch (error) {\n            console.error('Error fetching filtered aircraft:', error);\n        } finally{\n            setLocalLoading(false);\n        }\n    };\n    // Model selection methods\n    const handleModelSelect = (value)=>{\n        selectModel(value === '' ? null : value);\n        setActiveDropdown(null);\n        // If in combined mode, reapply the filter\n        if (filterMode === 'both' && isGeofenceActive && selectedManufacturer) {\n            setTimeout(()=>{\n                applyCombinedFilters();\n            }, 100);\n        }\n    };\n    // Combined filter methods\n    const applyCombinedFilters = ()=>{\n        if (!selectedManufacturer || !isGeofenceActive || geofenceAircraft.length === 0) {\n            return;\n        }\n        setLocalLoading(true);\n        try {\n            console.log(\"Filtering \".concat(geofenceAircraft.length, \" aircraft by \").concat(selectedManufacturer));\n            // Filter the aircraft by manufacturer\n            let filteredAircraft = geofenceAircraft.filter((aircraft)=>{\n                var _aircraft_MANUFACTURER;\n                return ((_aircraft_MANUFACTURER = aircraft.MANUFACTURER) === null || _aircraft_MANUFACTURER === void 0 ? void 0 : _aircraft_MANUFACTURER.toLowerCase()) === selectedManufacturer.toLowerCase();\n            });\n            // Further filter by model if selected\n            if (selectedModel) {\n                filteredAircraft = filteredAircraft.filter((aircraft)=>{\n                    var _aircraft_MODEL;\n                    return ((_aircraft_MODEL = aircraft.MODEL) === null || _aircraft_MODEL === void 0 ? void 0 : _aircraft_MODEL.toLowerCase()) === selectedModel.toLowerCase();\n                });\n            }\n            console.log(\"Found \".concat(filteredAircraft.length, \" matching aircraft\"));\n            if (filteredAircraft.length === 0) {\n                alert(\"No \".concat(selectedManufacturer, \" aircraft found in this area.\"));\n                return;\n            }\n            // Clear display data\n            if (clearGeofenceData) {\n                clearGeofenceData();\n            }\n            // Update the display\n            updateGeofenceAircraft(filteredAircraft);\n        } catch (error) {\n            console.error('Error filtering aircraft:', error);\n        } finally{\n            setLocalLoading(false);\n        }\n    };\n    // Reset all filters\n    const clearAllFilters = ()=>{\n        console.log('Clearing all filters...');\n        // 1. Reset filter mode\n        setFilterMode('manufacturer');\n        // 2. Unblock API calls that might have been blocked\n        _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].setBlockAllApiCalls(false);\n        setBlockManufacturerApiCalls(false);\n        setIsManufacturerApiBlocked(false);\n        // 3. Clear manufacturer selection\n        selectManufacturer(null);\n        selectModel(null);\n        // 4. Clear geofence\n        setGeofenceLocation('');\n        setGeofenceCoordinates(null);\n        setGeofenceAircraft([]);\n        setGeofenceEnabled(false);\n        setIsGeofenceActive(false);\n        if (typeof clearGeofence === 'function') {\n            clearGeofence();\n        }\n        if (typeof clearGeofenceData === 'function') {\n            clearGeofenceData();\n        }\n        // 5. Reset owner filters to select all\n        setOwnerFilters([\n            ...allOwnerTypes\n        ]);\n        // 6. Clear region filter properly\n        setActiveRegion(null);\n        setSelectedRegion(_types_base__WEBPACK_IMPORTED_MODULE_1__.RegionCode.GLOBAL);\n        // Clear region outline from map\n        if (regionOutline) {\n            try {\n                // Handle different possible object structures\n                if (typeof regionOutline.remove === 'function') {\n                    regionOutline.remove();\n                } else if (regionOutline.rectangle && typeof regionOutline.rectangle.remove === 'function') {\n                    regionOutline.rectangle.remove();\n                }\n                // Clear any labels associated with the region\n                if (regionOutline.label && typeof regionOutline.label.remove === 'function') {\n                    regionOutline.label.remove();\n                }\n            } catch (error) {\n                console.error('Error removing region outline:', error);\n            }\n            // Always reset the region outline state\n            setRegionOutline(null);\n        }\n        // 7. Reset map view to global\n        if (mapInstance) {\n            // Use the predefined center and zoom level from your map config\n            mapInstance.setView(_config_map__WEBPACK_IMPORTED_MODULE_9__.MAP_CONFIG.CENTER, _config_map__WEBPACK_IMPORTED_MODULE_9__.MAP_CONFIG.DEFAULT_ZOOM);\n            mapInstance.invalidateSize();\n        }\n        // 8. Reset to initial aircraft data\n        if (typeof reset === 'function') {\n            reset();\n        } else if (typeof fullRefresh === 'function') {\n            fullRefresh();\n        }\n        // 9. Close any open dropdown\n        setActiveDropdown(null);\n        // 10. Reset rate limiting states\n        setIsRateLimited(false);\n        setRateLimitTimer(null);\n        // 11. Clear combined mode state\n        setCombinedModeReady(false);\n        // 12. Reset search terms\n        setManufacturerSearchTerm('');\n        // 13. Dispatch a custom event that other components can listen for\n        const clearEvent = new CustomEvent('ribbon-filters-cleared');\n        document.dispatchEvent(clearEvent);\n        console.log('All filters cleared successfully');\n    };\n    // Calculate combined loading state\n    const combinedLoading = localLoading;\n    return {\n        // State\n        filterMode,\n        activeDropdown,\n        selectedManufacturer,\n        selectedModel,\n        geofenceLocation,\n        geofenceRadius,\n        isGeofenceActive,\n        geofenceCoordinates,\n        activeRegion,\n        ownerFilters,\n        allOwnerTypes,\n        manufacturerSearchTerm,\n        combinedLoading,\n        isGettingLocation,\n        dropdownRefs,\n        localLoading,\n        isRateLimited,\n        selectedRegion,\n        isRefreshing,\n        isGeofencePlacementMode: false,\n        // Methods\n        toggleDropdown,\n        toggleFilterMode,\n        selectManufacturerAndClose,\n        handleModelSelect,\n        getUserLocation,\n        processGeofenceSearch,\n        handleOwnerFilterChange,\n        handleRegionSelect,\n        setManufacturerSearchTerm,\n        setGeofenceLocation,\n        setGeofenceRadius,\n        toggleGeofenceState,\n        clearAllFilters,\n        applyCombinedFilters,\n        getAircraftOwnerType,\n        refreshWithFilters: ()=>{\n            // Implement refresh logic here\n            if (typeof refreshPositions === 'function') {\n                refreshPositions().catch((error)=>{\n                    console.error('Error refreshing positions:', error);\n                });\n            }\n        },\n        setActiveDropdown,\n        setGeofenceCoordinates,\n        setGeofenceCenter,\n        updateGeofenceAircraft\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvdHJhY2tpbmcvaG9va3MvdXNlRmlsdGVyTG9naWMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQW9EO0FBQzFCO0FBQ2dCO0FBRTRCO0FBQ0s7QUFDUDtBQUNBO0FBQ0U7QUFJNUI7QUFDZTtBQUs1QjtBQVd0QixTQUFTZ0I7SUFDZCxrQ0FBa0M7SUFDbEMsTUFBTSxFQUNKQyxvQkFBb0IsRUFDcEJDLGFBQWEsRUFDYkMsV0FBVyxFQUNYQyxrQkFBa0IsRUFDbEJDLFdBQVcsRUFDWEMsS0FBSyxFQUNMQyxXQUFXLEVBQ1hDLGdCQUFnQixFQUNoQkMsV0FBVyxFQUNYQyxrQkFBa0IsRUFDbEJDLGlCQUFpQixFQUNqQkMsc0JBQXNCLEVBQ3RCQyx5QkFBeUIsRUFDekJDLDRCQUE0QixFQUM1QkMsd0JBQXdCLEVBQ3hCQywyQkFBMkIsRUFDM0JDLGNBQWMsRUFDZEMsaUJBQWlCLEVBQ2pCQyxjQUFjLEVBQ2RDLGFBQWEsRUFDYkMsaUJBQWlCLEVBQ2xCLEdBQUdoQyxrRkFBcUJBO0lBRXpCLHVCQUF1QjtJQUN2QixNQUFNLEVBQUVpQyxrQkFBa0IsRUFBRSxHQUFHMUIscUVBQWNBO0lBRTdDLGNBQWM7SUFDZCxNQUFNLENBQUMyQixjQUFjQyxnQkFBZ0IsR0FBR3hDLCtDQUFRQSxDQUFDO0lBQ2pELE1BQU0sQ0FBQ3lDLFlBQVlDLGNBQWMsR0FBRzFDLCtDQUFRQSxDQUFvQjtJQUNoRSxNQUFNLENBQUMyQyxnQkFBZ0JDLGtCQUFrQixHQUFHNUMsK0NBQVFBLENBQWdCO0lBQ3BFLE1BQU0sQ0FBQzZDLHdCQUF3QkMsMEJBQTBCLEdBQUc5QywrQ0FBUUEsQ0FBQztJQUNyRSxNQUFNLENBQUMrQyxjQUFjQyxnQkFBZ0IsR0FBR2hELCtDQUFRQSxDQUFDO0lBQ2pELE1BQU0sQ0FBQ2lELGVBQWVDLGlCQUFpQixHQUFHbEQsK0NBQVFBLENBQUM7SUFDbkQsTUFBTSxDQUFDbUQsZ0JBQWdCQyxrQkFB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VTtRQUNWM0g7UUFDQVE7UUFDQXNGO1FBQ0FtQjtRQUNBMUM7UUFDQVk7UUFDQW5EO1FBQ0FVO1FBQ0FuSDtRQUNBWTtRQUNBRTtRQUNBc0o7UUFDQXdCO1FBQ0E3RjtRQUNBRDtRQUVBdUcsb0JBQW9CO1lBQ2xCLCtCQUErQjtZQUMvQixJQUFJLE9BQU8zTixxQkFBcUIsWUFBWTtnQkFDMUNBLG1CQUFtQmlNLEtBQUssQ0FBQyxDQUFDbkc7b0JBQ3hCekIsUUFBUXlCLEtBQUssQ0FBQywrQkFBK0JBO2dCQUMvQztZQUNGO1FBQ0Y7UUFDQTFFO1FBRUFrQjtRQUNBNUI7UUFDQU47SUFDRjtBQUNGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXHNhdGhvXFxEb2N1bWVudHNcXFByb2plY3RzXFxhaXJjcmFmdC10cmFja2luZ1xcY29tcG9uZW50c1xcdHJhY2tpbmdcXGhvb2tzXFx1c2VGaWx0ZXJMb2dpYy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlUmVmLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7IFJlZ2lvbkNvZGUgfSBmcm9tICdAL3R5cGVzL2Jhc2UnO1xyXG5pbXBvcnQgdHlwZSB7IEV4dGVuZGVkQWlyY3JhZnQgfSBmcm9tICdAL3R5cGVzL2Jhc2UnO1xyXG5pbXBvcnQgeyB1c2VFbmhhbmNlZE1hcENvbnRleHQgfSBmcm9tICcuLi9jb250ZXh0L0VuaGFuY2VkTWFwQ29udGV4dCc7XHJcbmltcG9ydCBvcGVuU2t5VHJhY2tpbmdTZXJ2aWNlIGZyb20gJ0AvbGliL3NlcnZpY2VzL29wZW5Ta3lUcmFja2luZ1NlcnZpY2UnO1xyXG5pbXBvcnQgeyBNYXBib3hTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vLi4vbGliL3NlcnZpY2VzL01hcGJveFNlcnZpY2UnO1xyXG5pbXBvcnQgeyBhZGFwdEdlb2ZlbmNlQWlyY3JhZnQgfSBmcm9tICdAL2xpYi91dGlscy9nZW9mZW5jZUFkYXB0ZXInO1xyXG5pbXBvcnQgeyBlbnJpY2hHZW9mZW5jZUFpcmNyYWZ0IH0gZnJvbSAnQC9saWIvdXRpbHMvZ2VvZmVuY2VFbnJpY2hlcic7XHJcbmltcG9ydCB7XHJcbiAgZ2V0QWlyY3JhZnROZWFyTG9jYXRpb24sXHJcbiAgZ2V0QWlyY3JhZnROZWFyU2VhcmNoZWRMb2NhdGlvbixcclxufSBmcm9tICcuLi8uLi8uLi9saWIvc2VydmljZXMvZ2VvZmVuY2luZyc7XHJcbmltcG9ydCB7IHVzZUdlb2xvY2F0aW9uIH0gZnJvbSAnLi4vaG9va3MvdXNlR2VvbG9jYXRpb24nO1xyXG5pbXBvcnQge1xyXG4gIE1BUF9DT05GSUcsXHJcbiAgZ2V0Qm91bmRzQnlSZWdpb24sXHJcbiAgZ2V0Wm9vbUxldmVsRm9yUmVnaW9uLFxyXG59IGZyb20gJy4uLy4uLy4uL2NvbmZpZy9tYXAnO1xyXG5cclxudHlwZSBNYXBHZW9mZW5jZUNsaWNrRXZlbnQgPSBDdXN0b21FdmVudDx7IGxhdDogbnVtYmVyOyBsbmc6IG51bWJlciB9PjtcclxuXHJcbmV4cG9ydCB0eXBlIEZpbHRlck1vZGUgPVxyXG4gIHwgJ21hbnVmYWN0dXJlcidcclxuICB8ICdnZW9mZW5jZSdcclxuICB8ICdib3RoJ1xyXG4gIHwgJ293bmVyJ1xyXG4gIHwgJ3JlZ2lvbic7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlRmlsdGVyTG9naWMoKSB7XHJcbiAgLy8gR2V0IGNvbnRleHQgc3RhdGUgYW5kIGZ1bmN0aW9uc1xyXG4gIGNvbnN0IHtcclxuICAgIHNlbGVjdGVkTWFudWZhY3R1cmVyLFxyXG4gICAgc2VsZWN0ZWRNb2RlbCxcclxuICAgIHRvdGFsQWN0aXZlLFxyXG4gICAgc2VsZWN0TWFudWZhY3R1cmVyLFxyXG4gICAgc2VsZWN0TW9kZWwsXHJcbiAgICByZXNldCxcclxuICAgIGZ1bGxSZWZyZXNoLFxyXG4gICAgcmVmcmVzaFBvc2l0aW9ucyxcclxuICAgIG1hcEluc3RhbmNlLFxyXG4gICAgdXBkYXRlQWlyY3JhZnREYXRhLFxyXG4gICAgY2xlYXJHZW9mZW5jZURhdGEsXHJcbiAgICB1cGRhdGVHZW9mZW5jZUFpcmNyYWZ0LFxyXG4gICAgYmxvY2tNYW51ZmFjdHVyZXJBcGlDYWxscyxcclxuICAgIHNldEJsb2NrTWFudWZhY3R1cmVyQXBpQ2FsbHMsXHJcbiAgICBpc01hbnVmYWN0dXJlckFwaUJsb2NrZWQsXHJcbiAgICBzZXRJc01hbnVmYWN0dXJlckFwaUJsb2NrZWQsXHJcbiAgICBnZW9mZW5jZUNlbnRlcixcclxuICAgIHNldEdlb2ZlbmNlQ2VudGVyLFxyXG4gICAgdG9nZ2xlR2VvZmVuY2UsXHJcbiAgICBjbGVhckdlb2ZlbmNlLFxyXG4gICAgZGlzcGxheWVkQWlyY3JhZnQsXHJcbiAgfSA9IHVzZUVuaGFuY2VkTWFwQ29udGV4dCgpO1xyXG5cclxuICAvLyBHZXQgZ2VvbG9jYXRpb24gaG9va1xyXG4gIGNvbnN0IHsgZ2V0Q3VycmVudFBvc2l0aW9uIH0gPSB1c2VHZW9sb2NhdGlvbigpO1xyXG5cclxuICAvLyBMb2NhbCBzdGF0ZVxyXG4gIGNvbnN0IFtsb2NhbExvYWRpbmcsIHNldExvY2FsTG9hZGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgY29uc3QgW2ZpbHRlck1vZGUsIHNldEZpbHRlck1vZGVdID0gdXNlU3RhdGU8RmlsdGVyTW9kZSB8IG51bGw+KG51bGwpO1xyXG4gIGNvbnN0IFthY3RpdmVEcm9wZG93biwgc2V0QWN0aXZlRHJvcGRvd25dID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XHJcbiAgY29uc3QgW21hbnVmYWN0dXJlclNlYXJjaFRlcm0sIHNldE1hbnVmYWN0dXJlclNlYXJjaFRlcm1dID0gdXNlU3RhdGUoJycpO1xyXG4gIGNvbnN0IFtpc1JlZnJlc2hpbmcsIHNldElzUmVmcmVzaGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgY29uc3QgW2lzUmF0ZUxpbWl0ZWQsIHNldElzUmF0ZUxpbWl0ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gIGNvbnN0IFtyYXRlTGltaXRUaW1lciwgc2V0UmF0ZUxpbWl0VGltZXJdID0gdXNlU3RhdGU8bnVtYmVyIHwgbnVsbD4obnVsbCk7XHJcbiAgY29uc3QgW2lzR2VvZmVuY2VQYW5lbE9wZW4sIHNldElzR2VvZmVuY2VQYW5lbE9wZW5dID0gdXNlU3RhdGUoZmFsc2UpO1xyXG5cclxuICAvLyBHZW9mZW5jZSBzdGF0ZVxyXG4gIGNvbnN0IFtpc0dldHRpbmdMb2NhdGlvbiwgc2V0SXNHZXR0aW5nTG9jYXRpb25dID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gIGNvbnN0IFtnZW9mZW5jZUxvY2F0aW9uLCBzZXRHZW9mZW5jZUxvY2F0aW9uXSA9IHVzZVN0YXRlPHN0cmluZz4oJycpO1xyXG4gIGNvbnN0IFtnZW9mZW5jZVJhZGl1cywgc2V0R2VvZmVuY2VSYWRpdXNdID0gdXNlU3RhdGU8bnVtYmVyPigyNSk7XHJcbiAgY29uc3QgW2dlb2ZlbmNlQ29vcmRpbmF0ZXMsIHNldEdlb2ZlbmNlQ29vcmRpbmF0ZXNdID0gdXNlU3RhdGU8e1xyXG4gICAgbGF0OiBudW1iZXI7XHJcbiAgICBsbmc6IG51bWJlcjtcclxuICB9IHwgbnVsbD4obnVsbCk7XHJcbiAgY29uc3QgW2dlb2ZlbmNlQWlyY3JhZnQsIHNldEdlb2ZlbmNlQWlyY3JhZnRdID0gdXNlU3RhdGU8RXh0ZW5kZWRBaXJjcmFmdFtdPihcclxuICAgIFtdXHJcbiAgKTtcclxuICBjb25zdCBbZ2VvZmVuY2VFbmFibGVkLCBzZXRHZW9mZW5jZUVuYWJsZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gIGNvbnN0IFtpc0dlb2ZlbmNlQWN0aXZlLCBzZXRJc0dlb2ZlbmNlQWN0aXZlXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICBjb25zdCBbaXNTZWFyY2hSZWFkeSwgc2V0SXNTZWFyY2hSZWFkeV0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XHJcblxyXG4gIC8vIFJlZ2lvbiBzdGF0ZVxyXG4gIGNvbnN0IFthY3RpdmVSZWdpb24sIHNldEFjdGl2ZVJlZ2lvbl0gPSB1c2VTdGF0ZTxSZWdpb25Db2RlIHwgc3RyaW5nIHwgbnVsbD4oXHJcbiAgICBudWxsXHJcbiAgKTtcclxuICBjb25zdCBbcmVnaW9uT3V0bGluZSwgc2V0UmVnaW9uT3V0bGluZV0gPSB1c2VTdGF0ZTxhbnk+KG51bGwpO1xyXG4gIGNvbnN0IFtzZWxlY3RlZFJlZ2lvbiwgc2V0U2VsZWN0ZWRSZWdpb25dID0gdXNlU3RhdGU8bnVtYmVyPihcclxuICAgIFJlZ2lvbkNvZGUuR0xPQkFMXHJcbiAgKTtcclxuXHJcbiAgLy8gQ29tYmluZWQgbW9kZSBzdGF0ZVxyXG4gIGNvbnN0IFtjb21iaW5lZE1vZGVSZWFkeSwgc2V0Q29tYmluZWRNb2RlUmVhZHldID0gdXNlU3RhdGU8Ym9vbGVhbj4oZmFsc2UpO1xyXG5cclxuICAvLyBPd25lciBmaWx0ZXIgc3RhdGVcclxuICBjb25zdCBhbGxPd25lclR5cGVzID0gW1xyXG4gICAgJ2luZGl2aWR1YWwnLFxyXG4gICAgJ3BhcnRuZXJzaGlwJyxcclxuICAgICdjb3JwLW93bmVyJyxcclxuICAgICdjby1vd25lZCcsXHJcbiAgICAnbGxjJyxcclxuICAgICdub24tY2l0aXplbi1jb3JwJyxcclxuICAgICdhaXJsaW5lJyxcclxuICAgICdmcmVpZ2h0JyxcclxuICAgICdtZWRpY2FsJyxcclxuICAgICdtZWRpYScsXHJcbiAgICAnaGlzdG9yaWNhbCcsXHJcbiAgICAnZmx5aW5nLWNsdWInLFxyXG4gICAgJ2VtZXJnZW5jeScsXHJcbiAgICAnbG9jYWwtZ292dCcsXHJcbiAgICAnZWR1Y2F0aW9uJyxcclxuICAgICdmZWRlcmFsLWdvdnQnLFxyXG4gICAgJ2ZsaWdodC1zY2hvb2wnLFxyXG4gICAgJ2xlYXNpbmctY29ycCcsXHJcbiAgICAnbWlsaXRhcnknLFxyXG4gICAgJ3Vua25vd24nLFxyXG4gIF07XHJcblxyXG4gIGNvbnN0IFtvd25lckZpbHRlcnMsIHNldE93bmVyRmlsdGVyc10gPSB1c2VTdGF0ZTxzdHJpbmdbXT4oW1xyXG4gICAgLi4uYWxsT3duZXJUeXBlcyxcclxuICBdKTtcclxuXHJcbiAgLy8gUmVmcyBmb3IgZHJvcGRvd24gaGFuZGxpbmdcclxuICBjb25zdCBkcm9wZG93blJlZnMgPSB7XHJcbiAgICBmaWx0ZXI6IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCksXHJcbiAgICBtYW51ZmFjdHVyZXI6IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCksXHJcbiAgICBtb2RlbDogdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKSxcclxuICAgIGxvY2F0aW9uOiB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpLFxyXG4gICAgcmVnaW9uOiB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpLFxyXG4gICAgb3duZXI6IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCksXHJcbiAgICBhY3Rpb25zOiB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpLFxyXG4gIH07XHJcblxyXG4gIC8vIEVmZmVjdHNcclxuXHJcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmIChnZW9mZW5jZUNvb3JkaW5hdGVzKSB7XHJcbiAgICAgIHNldElzU2VhcmNoUmVhZHkodHJ1ZSk7XHJcbiAgICB9XHJcbiAgfSwgW2dlb2ZlbmNlQ29vcmRpbmF0ZXNdKTtcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmIChpc1JhdGVMaW1pdGVkICYmIHJhdGVMaW1pdFRpbWVyKSB7XHJcbiAgICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgc2V0SXNSYXRlTGltaXRlZChmYWxzZSk7XHJcbiAgICAgICAgc2V0UmF0ZUxpbWl0VGltZXIobnVsbCk7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1JhdGUgbGltaXQgdGltZXIgZXhwaXJlZCwgcmVzdW1pbmcgQVBJIGNhbGxzJyk7XHJcbiAgICAgIH0sIHJhdGVMaW1pdFRpbWVyICogMTAwMCk7XHJcblxyXG4gICAgICByZXR1cm4gKCkgPT4gY2xlYXJUaW1lb3V0KHRpbWVyKTtcclxuICAgIH1cclxuICB9LCBbaXNSYXRlTGltaXRlZCwgcmF0ZUxpbWl0VGltZXJdKTtcclxuXHJcbiAgLy8gRWZmZWN0IHRvIHN5bmMgZ2VvZmVuY2Ugc3RhdGVcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgLy8gVXBkYXRlIGludGVybmFsIHN0YXRlIHdoZW4gZ2VvZmVuY2UgaXMgdG9nZ2xlZCBleHRlcm5hbGx5XHJcbiAgICBpZiAoaXNHZW9mZW5jZUFjdGl2ZSAhPT0gZ2VvZmVuY2VFbmFibGVkKSB7XHJcbiAgICAgIHNldEdlb2ZlbmNlRW5hYmxlZChpc0dlb2ZlbmNlQWN0aXZlKTtcclxuICAgIH1cclxuICB9LCBbaXNHZW9mZW5jZUFjdGl2ZV0pO1xyXG5cclxuICAvLyBDbG9zZSBkcm9wZG93biB3aGVuIGNsaWNraW5nIG91dHNpZGVcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgY29uc3QgaGFuZGxlQ2xpY2tPdXRzaWRlID0gKGV2ZW50OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgIC8vIENoZWNrIGlmIGNsaWNrIGlzIG91dHNpZGUgb2YgYWxsIGRyb3Bkb3duc1xyXG4gICAgICBjb25zdCBpc091dHNpZGVBbGwgPSBPYmplY3QudmFsdWVzKGRyb3Bkb3duUmVmcykuZXZlcnkoXHJcbiAgICAgICAgKHJlZikgPT4gIXJlZi5jdXJyZW50IHx8ICFyZWYuY3VycmVudC5jb250YWlucyhldmVudC50YXJnZXQgYXMgTm9kZSlcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGlmIChpc091dHNpZGVBbGwpIHtcclxuICAgICAgICBzZXRBY3RpdmVEcm9wZG93bihudWxsKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBoYW5kbGVDbGlja091dHNpZGUpO1xyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgaGFuZGxlQ2xpY2tPdXRzaWRlKTtcclxuICAgIH07XHJcbiAgfSwgW10pO1xyXG5cclxuICAvLyBDbGVhbiB1cCByZWdpb24gb3V0bGluZSB3aGVuIGNvbXBvbmVudCB1bm1vdW50c1xyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBpZiAocmVnaW9uT3V0bGluZSkge1xyXG4gICAgICAgIHJlZ2lvbk91dGxpbmUucmVtb3ZlKCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfSwgW3JlZ2lvbk91dGxpbmVdKTtcclxuXHJcbiAgLy8gRWZmZWN0IHRvIGhhbmRsZSBtYXAgY2xpY2sgZm9yIGdlb2ZlbmNlXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGNvbnN0IGhhbmRsZU1hcEdlb2ZlbmNlQ2xpY2sgPSBhc3luYyAoZXZlbnQ6IEV2ZW50KSA9PiB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgLy8gQ2FzdCB0aGUgZXZlbnQgdG8gdGhlIHByb3BlciB0eXBlXHJcbiAgICAgICAgY29uc3QgY3VzdG9tRXZlbnQgPSBldmVudCBhcyBDdXN0b21FdmVudDx7IGxhdDogbnVtYmVyOyBsbmc6IG51bWJlciB9PjtcclxuICAgICAgICBjb25zdCB7IGxhdCwgbG5nIH0gPSBjdXN0b21FdmVudC5kZXRhaWw7XHJcblxyXG4gICAgICAgIC8vIEZpcnN0IHVwZGF0ZSBjb29yZGluYXRlcyBpbW1lZGlhdGVseVxyXG4gICAgICAgIHNldEdlb2ZlbmNlQ29vcmRpbmF0ZXMoeyBsYXQsIGxuZyB9KTtcclxuXHJcbiAgICAgICAgLy8gVGhlbiBzdGFydCBhbiBhc3luYyBvcGVyYXRpb24gdG8gZ2V0IHRoZSBsb2NhdGlvbiBuYW1lXHJcbiAgICAgICAgY29uc29sZS5sb2coYEdldHRpbmcgbG9jYXRpb24gbmFtZSBmb3I6ICR7bGF0fSwgJHtsbmd9YCk7XHJcblxyXG4gICAgICAgIC8vIFRlbXBvcmFyaWx5IHNob3cgY29vcmRpbmF0ZXMgd2hpbGUgZmV0Y2hpbmcgdGhlIG5hbWVcclxuICAgICAgICBzZXRHZW9mZW5jZUxvY2F0aW9uKGAke2xhdC50b0ZpeGVkKDYpfSwgJHtsbmcudG9GaXhlZCg2KX1gKTtcclxuXHJcbiAgICAgICAgLy8gR2V0IHRoZSBmcmllbmRseSBuYW1lIGFzeW5jaHJvbm91c2x5XHJcbiAgICAgICAgY29uc3QgbG9jYXRpb25OYW1lID0gYXdhaXQgTWFwYm94U2VydmljZS5nZXRMb2NhdGlvbk5hbWVGcm9tQ29vcmRpbmF0ZXMoXHJcbiAgICAgICAgICBsYXQsXHJcbiAgICAgICAgICBsbmdcclxuICAgICAgICApO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGBHb3QgbG9jYXRpb24gbmFtZTogJHtsb2NhdGlvbk5hbWV9YCk7XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSB3aXRoIHRoZSBmcmllbmRseSBuYW1lIG9uY2Ugd2UgaGF2ZSBpdFxyXG4gICAgICAgIGlmIChsb2NhdGlvbk5hbWUgIT09IG51bGwpIHtcclxuICAgICAgICAgIHNldEdlb2ZlbmNlTG9jYXRpb24obG9jYXRpb25OYW1lKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE9wZW4gdGhlIGxvY2F0aW9uIGRyb3Bkb3duIGlmIG5lZWRlZFxyXG4gICAgICAgIGlmIChhY3RpdmVEcm9wZG93biAhPT0gJ2xvY2F0aW9uJykge1xyXG4gICAgICAgICAgc2V0QWN0aXZlRHJvcGRvd24oJ2xvY2F0aW9uJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGhhbmRsaW5nIG1hcCBjbGljazonLCBlcnJvcik7XHJcbiAgICAgICAgLy8gS2VlcCB0aGUgY29vcmRpbmF0ZXMgZGlzcGxheSBpZiB0aGVyZSB3YXMgYW4gZXJyb3JcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBBZGQgdGhlIGV2ZW50IGxpc3RlbmVyIC0gdXNlIHRoZSBzdGFuZGFyZCBldmVudCBsaXN0ZW5lciBwYXR0ZXJuXHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFxyXG4gICAgICAnbWFwLWdlb2ZlbmNlLWNsaWNrJyxcclxuICAgICAgaGFuZGxlTWFwR2VvZmVuY2VDbGljayBhcyBFdmVudExpc3RlbmVyXHJcbiAgICApO1xyXG5cclxuICAgIC8vIENsZWFuIHVwXHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFxyXG4gICAgICAgICdtYXAtZ2VvZmVuY2UtY2xpY2snLFxyXG4gICAgICAgIGhhbmRsZU1hcEdlb2ZlbmNlQ2xpY2sgYXMgRXZlbnRMaXN0ZW5lclxyXG4gICAgICApO1xyXG4gICAgfTtcclxuICB9LCBbXHJcbiAgICBzZXRHZW9mZW5jZUxvY2F0aW9uLFxyXG4gICAgc2V0R2VvZmVuY2VDb29yZGluYXRlcyxcclxuICAgIHNldEFjdGl2ZURyb3Bkb3duLFxyXG4gICAgYWN0aXZlRHJvcGRvd24sXHJcbiAgXSk7XHJcblxyXG4gIC8vIE1haW4gbWV0aG9kc1xyXG4gIC8vIFRvZ2dsZSBkcm9wZG93biBmdW5jdGlvblxyXG4gIGludGVyZmFjZSBUb2dnbGVEcm9wZG93bkV2ZW50XHJcbiAgICBleHRlbmRzIFJlYWN0Lk1vdXNlRXZlbnQ8SFRNTERpdkVsZW1lbnQsIE1vdXNlRXZlbnQ+IHtcclxuICAgIHN0b3BQcm9wYWdhdGlvbjogKCkgPT4gdm9pZDtcclxuICB9XHJcblxyXG4gIHR5cGUgRHJvcGRvd25UeXBlID1cclxuICAgIHwgJ2ZpbHRlcidcclxuICAgIHwgJ21hbnVmYWN0dXJlcidcclxuICAgIHwgJ21vZGVsJ1xyXG4gICAgfCAnbG9jYXRpb24nXHJcbiAgICB8ICdyZWdpb24nXHJcbiAgICB8ICdvd25lcidcclxuICAgIHwgJ2FjdGlvbnMnXHJcbiAgICB8ICdnZW9mZW5jZSc7XHJcblxyXG4gIGNvbnN0IHRvZ2dsZURyb3Bkb3duID0gKFxyXG4gICAgdHlwZTogRHJvcGRvd25UeXBlLFxyXG4gICAgZXZlbnQ6IFRvZ2dsZURyb3Bkb3duRXZlbnRcclxuICApOiB2b2lkID0+IHtcclxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgc2V0QWN0aXZlRHJvcGRvd24oKHByZXZTdGF0ZSkgPT4gKHByZXZTdGF0ZSA9PT0gdHlwZSA/IG51bGwgOiB0eXBlKSk7XHJcblxyXG4gICAgLy8gSWYgb3BlbmluZyB0aGUgZ2VvZmVuY2UgcGFuZWwsIGNsb3NlIGFueSBhY3RpdmUgZHJvcGRvd25cclxuICAgIGlmICh0eXBlID09PSAnZ2VvZmVuY2UnICYmIGFjdGl2ZURyb3Bkb3duKSB7XHJcbiAgICAgIHNldEFjdGl2ZURyb3Bkb3duKG51bGwpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGNvbnN0IGhhbmRsZVJhdGVMaW1pdCA9IChyZXRyeUFmdGVyOiBudW1iZXIgPSAzMCkgPT4ge1xyXG4gICAgc2V0SXNSYXRlTGltaXRlZCh0cnVlKTtcclxuICAgIHNldFJhdGVMaW1pdFRpbWVyKHJldHJ5QWZ0ZXIpO1xyXG4gICAgY29uc29sZS5sb2coYFJhdGUgbGltaXRlZCBieSBBUEkuIFJldHJ5IGFmdGVyICR7cmV0cnlBZnRlcn1zYCk7XHJcblxyXG4gICAgLy8gQmxvY2sgYWxsIEFQSSBjYWxsc1xyXG4gICAgb3BlblNreVRyYWNraW5nU2VydmljZS5zZXRCbG9ja0FsbEFwaUNhbGxzKHRydWUpO1xyXG4gICAgc2V0QmxvY2tNYW51ZmFjdHVyZXJBcGlDYWxscyh0cnVlKTtcclxuXHJcbiAgICAvLyBTaG93IG5vdGlmaWNhdGlvbiB0byB1c2VyXHJcbiAgICBpZiAocmV0cnlBZnRlciA+IDApIHtcclxuICAgICAgYWxlcnQoXHJcbiAgICAgICAgYEFpcmNyYWZ0IGRhdGEgcmVmcmVzaCByYXRlIGxpbWl0ZWQuIFBsZWFzZSB3YWl0ICR7cmV0cnlBZnRlcn0gc2Vjb25kcyBiZWZvcmUgdHJ5aW5nIGFnYWluLmBcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBUb2dnbGUgZmlsdGVyIG1vZGVcclxuICAgKi9cclxuICBjb25zdCB0b2dnbGVGaWx0ZXJNb2RlID0gKG1vZGU6IEZpbHRlck1vZGUpID0+IHtcclxuICAgIHNldEZpbHRlck1vZGUobW9kZSk7XHJcbiAgICBzZXRBY3RpdmVEcm9wZG93bihudWxsKTtcclxuXHJcbiAgICAvLyBBcHBseSBhcHByb3ByaWF0ZSBmaWx0ZXJzIGJhc2VkIG9uIG5ldyBtb2RlXHJcbiAgICBpZiAobW9kZSA9PT0gJ3JlZ2lvbicpIHtcclxuICAgICAgLy8gQmxvY2sgQVBJIGNhbGxzIGluIHJlZ2lvbiBtb2RlXHJcbiAgICAgIG9wZW5Ta3lUcmFja2luZ1NlcnZpY2Uuc2V0QmxvY2tBbGxBcGlDYWxscyh0cnVlKTtcclxuXHJcbiAgICAgIC8vIEFwcGx5IHJlZ2lvbiBmaWx0ZXJpbmcgaWYgd2UgYWxyZWFkeSBoYXZlIGRhdGFcclxuICAgICAgaWYgKGRpc3BsYXllZEFpcmNyYWZ0ICYmIGRpc3BsYXllZEFpcmNyYWZ0Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICBmaWx0ZXJBaXJjcmFmdEJ5UmVnaW9uKHNlbGVjdGVkUmVnaW9uLnRvU3RyaW5nKCkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDbGVhciBtYW51ZmFjdHVyZXIgc2VsZWN0aW9uIGZyb20gdGhlIFVJXHJcbiAgICAgIHNlbGVjdE1hbnVmYWN0dXJlcihudWxsKTtcclxuICAgICAgc2VsZWN0TW9kZWwobnVsbCk7XHJcblxyXG4gICAgICAvLyBJZiBnZW9mZW5jZSBpcyBhY3RpdmUsIHJlc3RvcmUgdGhlIGZ1bGwgZ2VvZmVuY2UgZGF0YVxyXG4gICAgICBpZiAoZ2VvZmVuY2VDb29yZGluYXRlcyAmJiBnZW9mZW5jZUFpcmNyYWZ0Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICB1cGRhdGVHZW9mZW5jZUFpcmNyYWZ0KGdlb2ZlbmNlQWlyY3JhZnQpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdvd25lcicpIHtcclxuICAgICAgLy8gRmlsdGVyIGRpc3BsYXllZCBhaXJjcmFmdCBieSBvd25lciB0eXBlXHJcbiAgICAgIGlmIChkaXNwbGF5ZWRBaXJjcmFmdCAmJiBkaXNwbGF5ZWRBaXJjcmFmdC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgLy8gRmlyc3QgZmlsdGVyIGZvciB2YWxpZCBjb29yZGluYXRlc1xyXG4gICAgICAgIGNvbnN0IGFpcmNyYWZ0V2l0aFZhbGlkQ29vcmRzID0gZGlzcGxheWVkQWlyY3JhZnQuZmlsdGVyKFxyXG4gICAgICAgICAgKHBsYW5lKSA9PlxyXG4gICAgICAgICAgICB0eXBlb2YgcGxhbmUubGF0aXR1ZGUgPT09ICdudW1iZXInICYmXHJcbiAgICAgICAgICAgIHR5cGVvZiBwbGFuZS5sb25naXR1ZGUgPT09ICdudW1iZXInICYmXHJcbiAgICAgICAgICAgICFpc05hTihwbGFuZS5sYXRpdHVkZSkgJiZcclxuICAgICAgICAgICAgIWlzTmFOKHBsYW5lLmxvbmdpdHVkZSlcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyBBcHBseSBvd25lciB0eXBlIGZpbHRlclxyXG4gICAgICAgIGxldCBmaWx0ZXJlZEJ5T3duZXIgPVxyXG4gICAgICAgICAgb3duZXJGaWx0ZXJzLmxlbmd0aCA9PT0gMFxyXG4gICAgICAgICAgICA/IGFpcmNyYWZ0V2l0aFZhbGlkQ29vcmRzXHJcbiAgICAgICAgICAgIDogYWlyY3JhZnRXaXRoVmFsaWRDb29yZHMuZmlsdGVyKChhaXJjcmFmdCkgPT5cclxuICAgICAgICAgICAgICAgIG93bmVyRmlsdGVycy5pbmNsdWRlcyhnZXRBaXJjcmFmdE93bmVyVHlwZShhaXJjcmFmdCkpXHJcbiAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIGRpc3BsYXkgd2l0aCBmaWx0ZXJlZCBhaXJjcmFmdFxyXG4gICAgICAgIGlmIChjbGVhckdlb2ZlbmNlRGF0YSkge1xyXG4gICAgICAgICAgY2xlYXJHZW9mZW5jZURhdGEoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdXBkYXRlR2VvZmVuY2VBaXJjcmFmdChmaWx0ZXJlZEJ5T3duZXIpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdib3RoJykge1xyXG4gICAgICAvLyBCb3RoIG1vZGUgLSBCTE9DSyBBUEkgQ0FMTFNcclxuICAgICAgb3BlblNreVRyYWNraW5nU2VydmljZS5zZXRCbG9ja0FsbEFwaUNhbGxzKHRydWUpO1xyXG5cclxuICAgICAgaWYgKFxyXG4gICAgICAgIHNlbGVjdGVkTWFudWZhY3R1cmVyICYmXHJcbiAgICAgICAgaXNHZW9mZW5jZUFjdGl2ZSAmJlxyXG4gICAgICAgIGdlb2ZlbmNlQWlyY3JhZnQubGVuZ3RoID4gMFxyXG4gICAgICApIHtcclxuICAgICAgICBhcHBseUNvbWJpbmVkRmlsdGVycygpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIElmIG9uZSBpcyBtaXNzaW5nLCBwcm9tcHQgdGhlIHVzZXJcclxuICAgICAgICBpZiAoIXNlbGVjdGVkTWFudWZhY3R1cmVyICYmIGlzR2VvZmVuY2VBY3RpdmUpIHtcclxuICAgICAgICAgIGFsZXJ0KCdQbGVhc2Ugc2VsZWN0IGEgbWFudWZhY3R1cmVyIHRvIHVzZSBjb21iaW5lZCBmaWx0ZXIgbW9kZScpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoc2VsZWN0ZWRNYW51ZmFjdHVyZXIgJiYgIWlzR2VvZmVuY2VBY3RpdmUpIHtcclxuICAgICAgICAgIGFsZXJ0KCdQbGVhc2Ugc2V0IGEgbG9jYXRpb24gdG8gdXNlIGNvbWJpbmVkIGZpbHRlciBtb2RlJyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGFsZXJ0KFxyXG4gICAgICAgICAgICAnUGxlYXNlIHNlbGVjdCBib3RoIGEgbWFudWZhY3R1cmVyIGFuZCBsb2NhdGlvbiB0byB1c2UgY29tYmluZWQgZmlsdGVyIG1vZGUnXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8vIE93bmVyIGZpbHRlciBtZXRob2RzXHJcbiAgY29uc3QgZ2V0QWlyY3JhZnRPd25lclR5cGUgPSAoYWlyY3JhZnQ6IEV4dGVuZGVkQWlyY3JhZnQpOiBzdHJpbmcgPT4ge1xyXG4gICAgY29uc3Qgb3duZXJUeXBlID0gYWlyY3JhZnQuVFlQRV9SRUdJU1RSQU5UIHx8IDA7XHJcbiAgICByZXR1cm4gb3duZXJUeXBlVG9TdHJpbmcob3duZXJUeXBlKTtcclxuICB9O1xyXG5cclxuICBjb25zdCBvd25lclR5cGVUb1N0cmluZyA9ICh0eXBlOiBudW1iZXIgfCBzdHJpbmcpOiBzdHJpbmcgPT4ge1xyXG4gICAgY29uc3QgdHlwZU51bSA9IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyA/IHBhcnNlSW50KHR5cGUsIDEwKSA6IHR5cGU7XHJcblxyXG4gICAgY29uc3Qgb3duZXJUeXBlTWFwOiBSZWNvcmQ8bnVtYmVyLCBzdHJpbmc+ID0ge1xyXG4gICAgICAxOiAnaW5kaXZpZHVhbCcsXHJcbiAgICAgIDI6ICdwYXJ0bmVyc2hpcCcsXHJcbiAgICAgIDM6ICdjb3JwLW93bmVyJyxcclxuICAgICAgNDogJ2NvLW93bmVkJyxcclxuICAgICAgNzogJ2xsYycsXHJcbiAgICAgIDg6ICdub24tY2l0aXplbi1jb3JwJyxcclxuICAgICAgOTogJ2FpcmxpbmUnLFxyXG4gICAgICAxMDogJ2ZyZWlnaHQnLFxyXG4gICAgICAxMTogJ21lZGljYWwnLFxyXG4gICAgICAxMjogJ21lZGlhJyxcclxuICAgICAgMTM6ICdoaXN0b3JpY2FsJyxcclxuICAgICAgMTQ6ICdmbHlpbmctY2x1YicsXHJcbiAgICAgIDE1OiAnZW1lcmdlbmN5JyxcclxuICAgICAgMTY6ICdsb2NhbC1nb3Z0JyxcclxuICAgICAgMTc6ICdlZHVjYXRpb24nLFxyXG4gICAgICAxODogJ2ZlZGVyYWwtZ292dCcsXHJcbiAgICAgIDE5OiAnZmxpZ2h0LXNjaG9vbCcsXHJcbiAgICAgIDIwOiAnbGVhc2luZy1jb3JwJyxcclxuICAgICAgMjE6ICdtaWxpdGFyeScsXHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBvd25lclR5cGVNYXBbdHlwZU51bV0gfHwgJ3Vua25vd24nO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IGFwcGx5T3duZXJUeXBlRmlsdGVyID0gKGZpbHRlcnM6IHN0cmluZ1tdKSA9PiB7XHJcbiAgICAvLyBTa2lwIGZpbHRlcmluZyBpZiBhbGwgdHlwZXMgYXJlIHNlbGVjdGVkIG9yIG5vbmUgYXJlIHNlbGVjdGVkXHJcbiAgICBpZiAoZmlsdGVycy5sZW5ndGggPT09IDAgfHwgZmlsdGVycy5sZW5ndGggPT09IGFsbE93bmVyVHlwZXMubGVuZ3RoKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBGaWx0ZXIgdGhlIGFpcmNyYWZ0IGJhc2VkIG9uIHNlbGVjdGVkIG93bmVyIHR5cGVzXHJcbiAgICBpZiAoZGlzcGxheWVkQWlyY3JhZnQgJiYgZGlzcGxheWVkQWlyY3JhZnQubGVuZ3RoID4gMCkge1xyXG4gICAgICBjb25zdCBmaWx0ZXJlZEFpcmNyYWZ0ID0gZGlzcGxheWVkQWlyY3JhZnQuZmlsdGVyKChhaXJjcmFmdCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IG93bmVyVHlwZSA9IGdldEFpcmNyYWZ0T3duZXJUeXBlKGFpcmNyYWZ0KTtcclxuICAgICAgICByZXR1cm4gZmlsdGVycy5pbmNsdWRlcyhvd25lclR5cGUpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIFVwZGF0ZSB0aGUgZGlzcGxheWVkIGFpcmNyYWZ0XHJcbiAgICAgIGlmIChjbGVhckdlb2ZlbmNlRGF0YSkge1xyXG4gICAgICAgIGNsZWFyR2VvZmVuY2VEYXRhKCk7XHJcbiAgICAgIH1cclxuICAgICAgdXBkYXRlR2VvZmVuY2VBaXJjcmFmdChmaWx0ZXJlZEFpcmNyYWZ0KTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBjb25zdCBoYW5kbGVPd25lckZpbHRlckNoYW5nZSA9ICh1cGRhdGVkRmlsdGVyczogc3RyaW5nW10pID0+IHtcclxuICAgIHNldE93bmVyRmlsdGVycyh1cGRhdGVkRmlsdGVycyk7XHJcbiAgICAvLyBBcHBseSB0aGUgZmlsdGVyIHRvIHlvdXIgYWlyY3JhZnQgZGF0YVxyXG4gICAgYXBwbHlPd25lclR5cGVGaWx0ZXIodXBkYXRlZEZpbHRlcnMpO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IHJlc2V0T3duZXJGaWx0ZXJzID0gKCkgPT4ge1xyXG4gICAgc2V0T3duZXJGaWx0ZXJzKFsuLi5hbGxPd25lclR5cGVzXSk7XHJcbiAgfTtcclxuXHJcbiAgLy8gUmVnaW9uIGZpbHRlciBtZXRob2RzXHJcbiAgY29uc3QgZmlsdGVyQWlyY3JhZnRCeVJlZ2lvbiA9IChyZWdpb246IHN0cmluZykgPT4ge1xyXG4gICAgaWYgKCFkaXNwbGF5ZWRBaXJjcmFmdCB8fCBkaXNwbGF5ZWRBaXJjcmFmdC5sZW5ndGggPT09IDApIHJldHVybjtcclxuICAgIHNldExvY2FsTG9hZGluZyh0cnVlKTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBHZXQgdGhlIGJvdW5kcyBmb3IgdGhlIHNlbGVjdGVkIHJlZ2lvblxyXG4gICAgICBjb25zdCBib3VuZHNFeHByZXNzaW9uID0gZ2V0Qm91bmRzQnlSZWdpb24ocmVnaW9uKTtcclxuXHJcbiAgICAgIC8vIEVuc3VyZSBib3VuZHMgaXMgaW4gdGhlIGNvcnJlY3QgZm9ybWF0XHJcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShib3VuZHNFeHByZXNzaW9uKSB8fCBib3VuZHNFeHByZXNzaW9uLmxlbmd0aCAhPT0gMikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXHJcbiAgICAgICAgICBgSW52YWxpZCBib3VuZHMgZm9ybWF0IGZvciByZWdpb246ICR7cmVnaW9ufWAsXHJcbiAgICAgICAgICBib3VuZHNFeHByZXNzaW9uXHJcbiAgICAgICAgKTtcclxuICAgICAgICBzZXRMb2NhbExvYWRpbmcoZmFsc2UpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRXh0cmFjdCBjb29yZGluYXRlcyAtIExlYWZsZXQgdXNlcyBbbGF0LCBsbmddIGZvcm1hdFxyXG4gICAgICBjb25zdCBbW21pbkxhdCwgbWluTG5nXSwgW21heExhdCwgbWF4TG5nXV0gPSBib3VuZHNFeHByZXNzaW9uO1xyXG5cclxuICAgICAgY29uc29sZS5sb2coYEZpbHRlcmluZyBieSByZWdpb246ICR7cmVnaW9ufSB3aXRoIGJvdW5kczpgLCB7XHJcbiAgICAgICAgbWluTGF0LFxyXG4gICAgICAgIG1pbkxuZyxcclxuICAgICAgICBtYXhMYXQsXHJcbiAgICAgICAgbWF4TG5nLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIEZpbHRlciBhaXJjcmFmdCBiYXNlZCBvbiBjb29yZGluYXRlcyB3aXRoaW4gdGhlIGJvdW5kc1xyXG4gICAgICBjb25zdCBmaWx0ZXJlZEFpcmNyYWZ0ID0gZGlzcGxheWVkQWlyY3JhZnQuZmlsdGVyKChhaXJjcmFmdCkgPT4ge1xyXG4gICAgICAgIC8vIENoZWNrIGlmIGFpcmNyYWZ0IGhhcyB2YWxpZCBjb29yZGluYXRlc1xyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgIHR5cGVvZiBhaXJjcmFmdC5sYXRpdHVkZSAhPT0gJ251bWJlcicgfHxcclxuICAgICAgICAgIHR5cGVvZiBhaXJjcmFmdC5sb25naXR1ZGUgIT09ICdudW1iZXInIHx8XHJcbiAgICAgICAgICBpc05hTihhaXJjcmFmdC5sYXRpdHVkZSkgfHxcclxuICAgICAgICAgIGlzTmFOKGFpcmNyYWZ0LmxvbmdpdHVkZSlcclxuICAgICAgICApIHtcclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENoZWNrIGlmIGNvb3JkaW5hdGVzIGFyZSB3aXRoaW4gdGhlIGJvdW5kc1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICBhaXJjcmFmdC5sYXRpdHVkZSA+PSBtaW5MYXQgJiZcclxuICAgICAgICAgIGFpcmNyYWZ0LmxhdGl0dWRlIDw9IG1heExhdCAmJlxyXG4gICAgICAgICAgYWlyY3JhZnQubG9uZ2l0dWRlID49IG1pbkxuZyAmJlxyXG4gICAgICAgICAgYWlyY3JhZnQubG9uZ2l0dWRlIDw9IG1heExuZ1xyXG4gICAgICAgICk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gVXBkYXRlIHRoZSBkaXNwbGF5IHdpdGggZmlsdGVyZWQgYWlyY3JhZnRcclxuICAgICAgaWYgKGNsZWFyR2VvZmVuY2VEYXRhKSB7XHJcbiAgICAgICAgY2xlYXJHZW9mZW5jZURhdGEoKTtcclxuICAgICAgfVxyXG4gICAgICB1cGRhdGVHZW9mZW5jZUFpcmNyYWZ0KGZpbHRlcmVkQWlyY3JhZnQpO1xyXG4gICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICBgRmlsdGVyZWQgdG8gJHtmaWx0ZXJlZEFpcmNyYWZ0Lmxlbmd0aH0gYWlyY3JhZnQgaW4gJHtyZWdpb259IHJlZ2lvbiAob3V0IG9mICR7ZGlzcGxheWVkQWlyY3JhZnQubGVuZ3RofSB0b3RhbClgXHJcbiAgICAgICk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmaWx0ZXJpbmcgYWlyY3JhZnQgYnkgcmVnaW9uOicsIGVycm9yKTtcclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgIHNldExvY2FsTG9hZGluZyhmYWxzZSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgaGFuZGxlUmVnaW9uU2VsZWN0ID0gYXN5bmMgKHJlZ2lvbjogUmVnaW9uQ29kZSkgPT4ge1xyXG4gICAgc2V0QWN0aXZlUmVnaW9uKHJlZ2lvbik7XHJcbiAgICBzZXRTZWxlY3RlZFJlZ2lvbihyZWdpb24pO1xyXG4gICAgc2V0TG9jYWxMb2FkaW5nKHRydWUpO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIFNldCBtYXAgYm91bmRzIGJhc2VkIG9uIHJlZ2lvblxyXG4gICAgICBpZiAobWFwSW5zdGFuY2UpIHtcclxuICAgICAgICBjb25zdCBib3VuZHMgPSBnZXRCb3VuZHNCeVJlZ2lvbihyZWdpb24pO1xyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIGFwcHJvcHJpYXRlIHpvb20gbGV2ZWwgZm9yIHRoaXMgcmVnaW9uIGZyb20geW91ciBjb25maWdcclxuICAgICAgICBjb25zdCB6b29tTGV2ZWwgPSBnZXRab29tTGV2ZWxGb3JSZWdpb24ocmVnaW9uKTtcclxuXHJcbiAgICAgICAgLy8gRmlyc3QsIHNldCB0aGUgYXBwcm9wcmlhdGUgem9vbSBsZXZlbFxyXG4gICAgICAgIG1hcEluc3RhbmNlLnNldFpvb20oem9vbUxldmVsKTtcclxuXHJcbiAgICAgICAgLy8gVGhlbiBmaXQgYm91bmRzIHdpdGggcGFkZGluZ1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICBwYWRkaW5nOiBNQVBfQ09ORklHLlBBRERJTkcuREVGQVVMVCxcclxuICAgICAgICAgIC8vIERvbid0IHNldCBtYXhab29tIGhlcmUgYXMgd2Ugd2FudCB0aGUgcmVnaW9uIHRvIGJlIHByb3Blcmx5IGRpc3BsYXllZFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIG1hcEluc3RhbmNlLmZpdEJvdW5kcyhib3VuZHMgYXMgYW55LCBvcHRpb25zKTtcclxuICAgICAgICBtYXBJbnN0YW5jZS5pbnZhbGlkYXRlU2l6ZSgpO1xyXG4gICAgICAgIGRyYXdSZWdpb25PdXRsaW5lKHJlZ2lvbik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEluc3RlYWQgb2YgaW1tZWRpYXRlbHkgZmV0Y2hpbmcgYWlyY3JhZnQgZGF0YSxcclxuICAgICAgLy8ganVzdCBzdG9yZSB0aGUgcmVnaW9uIHNlbGVjdGlvbiBmb3IgbGF0ZXIgdXNlXHJcbiAgICAgIGNvbnNvbGUubG9nKGBSZWdpb24gc2VsZWN0ZWQuIFdhaXRpbmcgZm9yIG1hbnVmYWN0dXJlciBzZWxlY3Rpb24uLi5gKTtcclxuXHJcbiAgICAgIC8vIE9wdGlvbmFsbHksIHlvdSBjb3VsZCBmZXRjaCBqdXN0IHRoZSBjb3VudCBvZiBhaXJjcmFmdCBpbiB0aGlzIHJlZ2lvblxyXG4gICAgICAvLyB0byBnaXZlIHRoZSB1c2VyIGFuIGlkZWEgb2YgdGhlIGRhdGEgdm9sdW1lXHJcbiAgICAgIGNvbnN0IGNvdW50UmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcclxuICAgICAgICBgL2FwaS90cmFja2luZy9yZWdpb24tY291bnQ/cmVnaW9uPSR7cmVnaW9ufWBcclxuICAgICAgKTtcclxuICAgICAgaWYgKGNvdW50UmVzcG9uc2Uub2spIHtcclxuICAgICAgICBjb25zdCBjb3VudERhdGEgPSBhd2FpdCBjb3VudFJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhgJHtjb3VudERhdGEuY291bnR9IGFpcmNyYWZ0IGF2YWlsYWJsZSBpbiB0aGlzIHJlZ2lvbmApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDbGVhciBhbnkgcHJldmlvdXMgYWlyY3JhZnQgZGF0YVxyXG4gICAgICBpZiAoY2xlYXJHZW9mZW5jZURhdGEpIHtcclxuICAgICAgICBjbGVhckdlb2ZlbmNlRGF0YSgpO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiByZWdpb24gc2VsZWN0aW9uOicsIGVycm9yKTtcclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgIHNldExvY2FsTG9hZGluZyhmYWxzZSk7XHJcbiAgICAgIHNldEFjdGl2ZURyb3Bkb3duKG51bGwpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGNvbnN0IGRyYXdSZWdpb25PdXRsaW5lID0gKHJlZ2lvbjogUmVnaW9uQ29kZSkgPT4ge1xyXG4gICAgaWYgKCFtYXBJbnN0YW5jZSkgcmV0dXJuO1xyXG5cclxuICAgIC8vIENsZWFyIGFueSBleGlzdGluZyBvdXRsaW5lXHJcbiAgICBpZiAocmVnaW9uT3V0bGluZSkge1xyXG4gICAgICByZWdpb25PdXRsaW5lLnJlbW92ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEdldCB0aGUgYm91bmRzIGZvciB0aGUgc2VsZWN0ZWQgcmVnaW9uXHJcbiAgICBjb25zdCBib3VuZHMgPSBnZXRCb3VuZHNCeVJlZ2lvbihyZWdpb24pIGFzIFtcclxuICAgICAgW251bWJlciwgbnVtYmVyXSxcclxuICAgICAgW251bWJlciwgbnVtYmVyXSxcclxuICAgIF07XHJcblxyXG4gICAgLy8gQ3JlYXRlIGEgcG9seWdvbiBmcm9tIHRoZSBib3VuZHNcclxuICAgIGNvbnN0IEwgPSByZXF1aXJlKCdsZWFmbGV0Jyk7XHJcbiAgICBjb25zdCByZWN0YW5nbGUgPSBMLnJlY3RhbmdsZShib3VuZHMsIHtcclxuICAgICAgY29sb3I6ICcjNGY0NmU1JywgLy8gSW5kaWdvIGNvbG9yIG1hdGNoaW5nIHlvdXIgVUlcclxuICAgICAgd2VpZ2h0OiAzLFxyXG4gICAgICBvcGFjaXR5OiAwLjcsXHJcbiAgICAgIGZpbGw6IHRydWUsXHJcbiAgICAgIGZpbGxDb2xvcjogJyM0ZjQ2ZTUnLFxyXG4gICAgICBmaWxsT3BhY2l0eTogMC4xLFxyXG4gICAgICBkYXNoQXJyYXk6ICc1LCAxMCcsIC8vIE9wdGlvbmFsOiBjcmVhdGVzIGEgZGFzaGVkIGxpbmVcclxuICAgICAgaW50ZXJhY3RpdmU6IGZhbHNlLCAvLyBQcmV2ZW50cyB0aGUgcmVjdGFuZ2xlIGZyb20gY2FwdHVyaW5nIG1vdXNlIGV2ZW50c1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gQWRkIHRvIG1hcFxyXG4gICAgcmVjdGFuZ2xlLmFkZFRvKG1hcEluc3RhbmNlKTtcclxuXHJcbiAgICAvLyBVcGRhdGUgdGhlIHN0YXRlIHRvIGluY2x1ZGUgYm90aCB0aGUgcmVjdGFuZ2xlIGFuZCB0aGUgbGFiZWxcclxuICAgIHNldFJlZ2lvbk91dGxpbmUoe1xyXG4gICAgICByZW1vdmU6ICgpID0+IHtcclxuICAgICAgICByZWN0YW5nbGUucmVtb3ZlKCk7XHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvLyBHZW9mZW5jZSBtZXRob2RzXHJcbiAgLy8gRml4ZWQgZ2V0VXNlckxvY2F0aW9uIGZ1bmN0aW9uXHJcbiAgY29uc3QgZ2V0VXNlckxvY2F0aW9uID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgaWYgKGlzUmF0ZUxpbWl0ZWQpIHtcclxuICAgICAgYWxlcnQoXHJcbiAgICAgICAgYFJhdGUgbGltaXRlZC4gUGxlYXNlIHdhaXQgJHtyYXRlTGltaXRUaW1lciB8fCAzMH0gc2Vjb25kcyBiZWZvcmUgdHJ5aW5nIHRvIGdldCBsb2NhdGlvbi5gXHJcbiAgICAgICk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBzZXRJc0dldHRpbmdMb2NhdGlvbih0cnVlKTtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gYXdhaXQgZ2V0Q3VycmVudFBvc2l0aW9uKCk7XHJcblxyXG4gICAgICBpZiAocG9zaXRpb24pIHtcclxuICAgICAgICBjb25zdCB7IGxhdGl0dWRlLCBsb25naXR1ZGUgfSA9IHBvc2l0aW9uLmNvb3JkcztcclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIHN0YXRlIHdpdGggY29vcmRpbmF0ZXNcclxuICAgICAgICBzZXRHZW9mZW5jZUNvb3JkaW5hdGVzKHsgbGF0OiBsYXRpdHVkZSwgbG5nOiBsb25naXR1ZGUgfSk7XHJcbiAgICAgICAgc2V0R2VvZmVuY2VDZW50ZXIoeyBsYXQ6IGxhdGl0dWRlLCBsbmc6IGxvbmdpdHVkZSB9KTtcclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBsb2NhdGlvbiBkaXNwbGF5IHdpdGggY29vcmRpbmF0ZXNcclxuICAgICAgICBzZXRHZW9mZW5jZUxvY2F0aW9uKGAke2xhdGl0dWRlLnRvRml4ZWQoNil9LCAke2xvbmdpdHVkZS50b0ZpeGVkKDYpfWApO1xyXG5cclxuICAgICAgICAvLyBBdXRvbWF0aWNhbGx5IHRyaWdnZXIgdGhlIGdlb2ZlbmNlIHNlYXJjaFxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zdCBmZXRjaGVkQWlyY3JhZnQgPSBhd2FpdCBnZXRBaXJjcmFmdE5lYXJMb2NhdGlvbihcclxuICAgICAgICAgICAgbGF0aXR1ZGUsXHJcbiAgICAgICAgICAgIGxvbmdpdHVkZSxcclxuICAgICAgICAgICAgZ2VvZmVuY2VSYWRpdXNcclxuICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgaWYgKGZldGNoZWRBaXJjcmFmdC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgYWxlcnQoXHJcbiAgICAgICAgICAgICAgYE5vIGFpcmNyYWZ0IGZvdW5kIG5lYXIgeW91ciBjdXJyZW50IGxvY2F0aW9uLiBUcnkgaW5jcmVhc2luZyB0aGUgcmFkaXVzLmBcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgc2V0SXNHZXR0aW5nTG9jYXRpb24oZmFsc2UpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUHJvY2VzcyB0aGUgYWlyY3JhZnQgZGF0YVxyXG4gICAgICAgICAgY29uc3QgYWRhcHRlZEFpcmNyYWZ0ID0gYWRhcHRHZW9mZW5jZUFpcmNyYWZ0KGZldGNoZWRBaXJjcmFmdCk7XHJcbiAgICAgICAgICBjb25zdCBlbnJpY2hlZEFpcmNyYWZ0ID1cclxuICAgICAgICAgICAgYXdhaXQgZW5yaWNoR2VvZmVuY2VBaXJjcmFmdChhZGFwdGVkQWlyY3JhZnQpO1xyXG5cclxuICAgICAgICAgIC8vIFNhdmUgdG8gbG9jYWwgc3RhdGVcclxuICAgICAgICAgIHNldEdlb2ZlbmNlQWlyY3JhZnQoZW5yaWNoZWRBaXJjcmFmdCk7XHJcblxyXG4gICAgICAgICAgLy8gQ2xlYXIgZXhpc3RpbmcgYWlyY3JhZnQgZGF0YVxyXG4gICAgICAgICAgaWYgKGNsZWFyR2VvZmVuY2VEYXRhKSB7XHJcbiAgICAgICAgICAgIGNsZWFyR2VvZmVuY2VEYXRhKCk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gVXBkYXRlIHRoZSBtYXAgd2l0aCBuZXcgYWlyY3JhZnRcclxuICAgICAgICAgIHVwZGF0ZUdlb2ZlbmNlQWlyY3JhZnQoZW5yaWNoZWRBaXJjcmFmdCk7XHJcbiAgICAgICAgICBzZXRJc0dlb2ZlbmNlQWN0aXZlKHRydWUpO1xyXG5cclxuICAgICAgICAgIC8vIENlbnRlciB0aGUgbWFwIG9uIHVzZXIncyBsb2NhdGlvbiAtIFNJTVBMSUZJRUQgWk9PTSBMT0dJQ1xyXG4gICAgICAgICAgaWYgKG1hcEluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIC8vIERvbid0IG1vZGlmeSB6b29tIGlmIGl0J3MgYWxyZWFkeSBhdCBhbiBhcHByb3ByaWF0ZSBsZXZlbFxyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50Wm9vbSA9IG1hcEluc3RhbmNlLmdldFpvb20oKTtcclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0Wm9vbSA9IGN1cnJlbnRab29tIDw9IDcgPyA5IDogY3VycmVudFpvb207XHJcblxyXG4gICAgICAgICAgICAvLyBTZXQgdGhlIHZpZXcgZGlyZWN0bHkgdG8gdGhlIHVzZXIncyBsb2NhdGlvblxyXG4gICAgICAgICAgICBtYXBJbnN0YW5jZS5zZXRWaWV3KFtsYXRpdHVkZSwgbG9uZ2l0dWRlXSwgdGFyZ2V0Wm9vbSk7XHJcblxyXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIG1hcCByZWZsZWN0cyBjaGFuZ2VzXHJcbiAgICAgICAgICAgIG1hcEluc3RhbmNlLmludmFsaWRhdGVTaXplKCk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gSWYgaW4gZ2VvZmVuY2UgbW9kZSwgZW5zdXJlIHRoZSBmaWx0ZXIgbW9kZSBpcyBzZXQgY29ycmVjdGx5XHJcbiAgICAgICAgICBpZiAoZmlsdGVyTW9kZSAhPT0gJ2dlb2ZlbmNlJyAmJiBmaWx0ZXJNb2RlICE9PSAnYm90aCcpIHtcclxuICAgICAgICAgICAgc2V0RmlsdGVyTW9kZSgnZ2VvZmVuY2UnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICAgICAgICBpZiAoZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ3JhdGUgbGltaXQnKSB8fCBlcnJvci5zdGF0dXMgPT09IDQyOSkge1xyXG4gICAgICAgICAgICBoYW5kbGVSYXRlTGltaXQoMzApO1xyXG4gICAgICAgICAgICAvLyBTdGlsbCB1cGRhdGUgdGhlIGxvY2F0aW9uIGV2ZW4gaWYgd2UgY291bGRuJ3QgZ2V0IGFpcmNyYWZ0XHJcbiAgICAgICAgICAgIGlmIChtYXBJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgIG1hcEluc3RhbmNlLnNldFZpZXcoW2xhdGl0dWRlLCBsb25naXR1ZGVdLCA5KTtcclxuICAgICAgICAgICAgICBtYXBJbnN0YW5jZS5pbnZhbGlkYXRlU2l6ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENsb3NlIHRoZSBkcm9wZG93biBhZnRlciBzZWxlY3Rpb25cclxuICAgICAgICBzZXRBY3RpdmVEcm9wZG93bihudWxsKTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyB1c2VyIGxvY2F0aW9uOicsIGVycm9yKTtcclxuICAgICAgYWxlcnQoXHJcbiAgICAgICAgJ1VuYWJsZSB0byBhY2Nlc3MgeW91ciBsb2NhdGlvbi4gUGxlYXNlIG1ha2Ugc3VyZSBsb2NhdGlvbiBzZXJ2aWNlcyBhcmUgZW5hYmxlZCBpbiB5b3VyIGJyb3dzZXIuJ1xyXG4gICAgICApO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgc2V0SXNHZXR0aW5nTG9jYXRpb24oZmFsc2UpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGNvbnN0IHByb2Nlc3NHZW9mZW5jZVNlYXJjaCA9IGFzeW5jICgpID0+IHtcclxuICAgIGlmICghZ2VvZmVuY2VMb2NhdGlvbikgcmV0dXJuO1xyXG5cclxuICAgIC8vIENoZWNrIGlmIHJhdGUgbGltaXRlZFxyXG4gICAgaWYgKGlzUmF0ZUxpbWl0ZWQpIHtcclxuICAgICAgYWxlcnQoXHJcbiAgICAgICAgYFJhdGUgbGltaXRlZC4gUGxlYXNlIHdhaXQgJHtyYXRlTGltaXRUaW1lciB8fCAzMH0gc2Vjb25kcyBiZWZvcmUgc2VhcmNoaW5nIGFnYWluLmBcclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEJsb2NrIEFQSSBjYWxscyB3aGlsZSBkb2luZyBnZW9mZW5jZSBzZWFyY2ggaW4gY29tYmluZWQgbW9kZVxyXG4gICAgaWYgKGZpbHRlck1vZGUgPT09ICdib3RoJykge1xyXG4gICAgICBvcGVuU2t5VHJhY2tpbmdTZXJ2aWNlLnNldEJsb2NrQWxsQXBpQ2FsbHModHJ1ZSk7XHJcbiAgICAgIHNldEJsb2NrTWFudWZhY3R1cmVyQXBpQ2FsbHModHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU2V0IGxvYWRpbmcgc3RhdGVcclxuICAgIHNldExvY2FsTG9hZGluZyh0cnVlKTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICBgU2VhcmNoaW5nIGZvciBhaXJjcmFmdCBuZWFyIGxvY2F0aW9uOiBcIiR7Z2VvZmVuY2VMb2NhdGlvbn1cImBcclxuICAgICAgKTtcclxuXHJcbiAgICAgIC8vIFRoaXMgd2lsbCBoYW5kbGUgUG9zdGFsIGNvZGVzLCBwbGFjZSBuYW1lcywgYWRkcmVzc2VzLCBQT0lzLCBldGMuXHJcbiAgICAgIGxldCBmZXRjaGVkQWlyY3JhZnQ7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgZmV0Y2hlZEFpcmNyYWZ0ID0gYXdhaXQgZ2V0QWlyY3JhZnROZWFyU2VhcmNoZWRMb2NhdGlvbihcclxuICAgICAgICAgIGdlb2ZlbmNlTG9jYXRpb24sXHJcbiAgICAgICAgICBnZW9mZW5jZVJhZGl1c1xyXG4gICAgICAgICk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgICAgICBpZiAoZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ3JhdGUgbGltaXQnKSB8fCBlcnJvci5zdGF0dXMgPT09IDQyOSkge1xyXG4gICAgICAgICAgY29uc3QgcmV0cnlBZnRlciA9IDMwOyAvLyBEZWZhdWx0IHRvIDMwIHNlY29uZHMgaWYgbm90IHNwZWNpZmllZFxyXG4gICAgICAgICAgaGFuZGxlUmF0ZUxpbWl0KHJldHJ5QWZ0ZXIpO1xyXG4gICAgICAgICAgc2V0TG9jYWxMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEdldCBjb29yZGluYXRlcyBmb3IgdGhlIG1hcFxyXG4gICAgICBsZXQgbG9jYXRpb25zOiB7IGxhdDogbnVtYmVyOyBsbmc6IG51bWJlcjsgbmFtZTogc3RyaW5nIH1bXTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBsb2NhdGlvbnMgPSBhd2FpdCBNYXBib3hTZXJ2aWNlLnNlYXJjaExvY2F0aW9uV2l0aE1hcGJveChcclxuICAgICAgICAgIGdlb2ZlbmNlTG9jYXRpb24sXHJcbiAgICAgICAgICAxXHJcbiAgICAgICAgKTtcclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzZWFyY2hpbmcgbG9jYXRpb24gd2l0aCBNYXBib3g6JywgZXJyb3IpO1xyXG4gICAgICAgIC8vIENvbnRpbnVlIHdpdGggYWlyY3JhZnQgZGF0YSBpZiBhdmFpbGFibGVcclxuICAgICAgICBsb2NhdGlvbnMgPSBbXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IGNvb3JkaW5hdGVzOiB7IGxhdDogbnVtYmVyOyBsbmc6IG51bWJlciB9IHwgbnVsbCA9IG51bGw7XHJcblxyXG4gICAgICBpZiAobG9jYXRpb25zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBjb29yZGluYXRlcyA9IHtcclxuICAgICAgICAgIGxhdDogbG9jYXRpb25zWzBdLmxhdCxcclxuICAgICAgICAgIGxuZzogbG9jYXRpb25zWzBdLmxuZyxcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIFNhdmUgdGhlIGZvcm1hdHRlZCBsb2NhdGlvbiBuYW1lXHJcbiAgICAgICAgc2V0R2VvZmVuY2VMb2NhdGlvbihsb2NhdGlvbnNbMF0ubmFtZSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgICAgZmV0Y2hlZEFpcmNyYWZ0Lmxlbmd0aCA+IDAgJiZcclxuICAgICAgICBmZXRjaGVkQWlyY3JhZnRbMF0ubGF0aXR1ZGUgJiZcclxuICAgICAgICBmZXRjaGVkQWlyY3JhZnRbMF0ubG9uZ2l0dWRlXHJcbiAgICAgICkge1xyXG4gICAgICAgIC8vIEZhbGxiYWNrIHRvIGZpcnN0IGFpcmNyYWZ0IHBvc2l0aW9uXHJcbiAgICAgICAgY29vcmRpbmF0ZXMgPSB7XHJcbiAgICAgICAgICBsYXQ6IGZldGNoZWRBaXJjcmFmdFswXS5sYXRpdHVkZSxcclxuICAgICAgICAgIGxuZzogZmV0Y2hlZEFpcmNyYWZ0WzBdLmxvbmdpdHVkZSxcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoZmV0Y2hlZEFpcmNyYWZ0Lmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIGFsZXJ0KFxyXG4gICAgICAgICAgYE5vIGFpcmNyYWZ0IGZvdW5kIG5lYXIgJHtnZW9mZW5jZUxvY2F0aW9ufS4gVHJ5IGluY3JlYXNpbmcgdGhlIHJhZGl1cyBvciBzZWFyY2hpbmcgaW4gYSBkaWZmZXJlbnQgYXJlYS5gXHJcbiAgICAgICAgKTtcclxuICAgICAgICBzZXRMb2NhbExvYWRpbmcoZmFsc2UpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVXBkYXRlIHN0YXRlIHdpdGggdGhlIGNvb3JkaW5hdGVzXHJcbiAgICAgIGlmIChjb29yZGluYXRlcykge1xyXG4gICAgICAgIHNldEdlb2ZlbmNlQ29vcmRpbmF0ZXMoY29vcmRpbmF0ZXMpO1xyXG4gICAgICAgIHNldEdlb2ZlbmNlQ2VudGVyKGNvb3JkaW5hdGVzKTtcclxuICAgICAgICBzZXRHZW9mZW5jZVJhZGl1cyhnZW9mZW5jZVJhZGl1cyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFpc0dlb2ZlbmNlQWN0aXZlKSB7XHJcbiAgICAgICAgdG9nZ2xlR2VvZmVuY2UoKTtcclxuICAgICAgfSBlbHNlIGlmICghY29vcmRpbmF0ZXMpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBkZXRlcm1pbmUgY29vcmRpbmF0ZXMgZm9yIHRoZSBsb2NhdGlvbicpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICBgRm91bmQgJHtmZXRjaGVkQWlyY3JhZnQubGVuZ3RofSBhaXJjcmFmdCBpbiB0aGUgYXJlYSwgcHJlcGFyaW5nIGZvciBkaXNwbGF5Li4uYFxyXG4gICAgICApO1xyXG5cclxuICAgICAgLy8gRW5zdXJlIHRoZSBkYXRhIGlzIGluIHRoZSByaWdodCBmb3JtYXRcclxuICAgICAgY29uc3QgYWRhcHRlZEFpcmNyYWZ0ID1cclxuICAgICAgICBmZXRjaGVkQWlyY3JhZnRbMF0uTUFOVUZBQ1RVUkVSICE9PSB1bmRlZmluZWRcclxuICAgICAgICAgID8gZmV0Y2hlZEFpcmNyYWZ0IC8vIEFscmVhZHkgaW4gdGhlIHJpZ2h0IGZvcm1hdFxyXG4gICAgICAgICAgOiBhZGFwdEdlb2ZlbmNlQWlyY3JhZnQoZmV0Y2hlZEFpcmNyYWZ0KTsgLy8gTmVlZHMgYWRhcHRhdGlvblxyXG5cclxuICAgICAgLy8gRW5yaWNoIHdpdGggc3RhdGljIGRhdGFcclxuICAgICAgY29uc29sZS5sb2coJ0VucmljaGluZyBnZW9mZW5jZSBhaXJjcmFmdCB3aXRoIHN0YXRpYyBkYXRhLi4uJyk7XHJcbiAgICAgIGNvbnN0IGVucmljaGVkQWlyY3JhZnQgPSBhd2FpdCBlbnJpY2hHZW9mZW5jZUFpcmNyYWZ0KGFkYXB0ZWRBaXJjcmFmdCk7XHJcblxyXG4gICAgICAvLyBTYXZlIHRoZSBGVUxMIHNldCB0byBsb2NhbCBzdGF0ZVxyXG4gICAgICBzZXRHZW9mZW5jZUFpcmNyYWZ0KGVucmljaGVkQWlyY3JhZnQpO1xyXG4gICAgICBzZXRJc0dlb2ZlbmNlQWN0aXZlKHRydWUpO1xyXG5cclxuICAgICAgLy8gQ2xlYXIgZXhpc3RpbmcgYWlyY3JhZnQgZGF0YVxyXG4gICAgICBpZiAoY2xlYXJHZW9mZW5jZURhdGEpIHtcclxuICAgICAgICBjbGVhckdlb2ZlbmNlRGF0YSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBJZiB3ZSdyZSBpbiBjb21iaW5lZCBtb2RlIGFuZCBoYXZlIGEgbWFudWZhY3R1cmVyLCBhcHBseSB0aGUgY29tYmluZWQgZmlsdGVyXHJcbiAgICAgIGlmIChmaWx0ZXJNb2RlID09PSAnYm90aCcgJiYgc2VsZWN0ZWRNYW51ZmFjdHVyZXIpIHtcclxuICAgICAgICAvLyBNYWtlIHN1cmUgQVBJIGNhbGxzIHJlbWFpbiBibG9ja2VkXHJcbiAgICAgICAgb3BlblNreVRyYWNraW5nU2VydmljZS5zZXRCbG9ja0FsbEFwaUNhbGxzKHRydWUpO1xyXG4gICAgICAgIHNldEJsb2NrTWFudWZhY3R1cmVyQXBpQ2FsbHModHJ1ZSk7XHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICBhcHBseUNvbWJpbmVkRmlsdGVycygpO1xyXG4gICAgICAgIH0sIDEwMCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gSnVzdCBzaG93IGFsbCBhaXJjcmFmdCBpbiB0aGUgZ2VvZmVuY2VcclxuICAgICAgICB1cGRhdGVHZW9mZW5jZUFpcmNyYWZ0KGVucmljaGVkQWlyY3JhZnQpO1xyXG5cclxuICAgICAgICAvLyBDZW50ZXIgdGhlIG1hcCAtIFNJTVBMSUZJRUQgWk9PTSBMT0dJQ1xyXG4gICAgICAgIGlmIChtYXBJbnN0YW5jZSAmJiBjb29yZGluYXRlcykge1xyXG4gICAgICAgICAgLy8gR2V0IGN1cnJlbnQgem9vbSBsZXZlbFxyXG4gICAgICAgICAgY29uc3QgY3VycmVudFpvb20gPSBtYXBJbnN0YW5jZS5nZXRab29tKCk7XHJcbiAgICAgICAgICAvLyBVc2UgYXBwcm9wcmlhdGUgem9vbSBsZXZlbCBiYXNlZCBvbiBjdXJyZW50IHZpZXdcclxuICAgICAgICAgIGNvbnN0IHRhcmdldFpvb20gPSBjdXJyZW50Wm9vbSA8PSA3ID8gOSA6IGN1cnJlbnRab29tO1xyXG5cclxuICAgICAgICAgIC8vIFNldCB2aWV3IHRvIHRoZSBjb29yZGluYXRlc1xyXG4gICAgICAgICAgbWFwSW5zdGFuY2Uuc2V0VmlldyhbY29vcmRpbmF0ZXMubGF0LCBjb29yZGluYXRlcy5sbmddLCB0YXJnZXRab29tKTtcclxuXHJcbiAgICAgICAgICAvLyBFbnN1cmUgbWFwIGlzIHVwZGF0ZWRcclxuICAgICAgICAgIG1hcEluc3RhbmNlLmludmFsaWRhdGVTaXplKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDbG9zZSBkcm9wZG93biBhZnRlciBzZWFyY2hcclxuICAgICAgc2V0QWN0aXZlRHJvcGRvd24obnVsbCk7XHJcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGdlb2ZlbmNlIHNlYXJjaDonLCBlcnJvcik7XHJcbiAgICAgIGlmIChlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygncmF0ZSBsaW1pdCcpIHx8IGVycm9yLnN0YXR1cyA9PT0gNDI5KSB7XHJcbiAgICAgICAgaGFuZGxlUmF0ZUxpbWl0KDMwKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBhbGVydChcclxuICAgICAgICAgIGBFcnJvcjogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yIG9jY3VycmVkJ31gXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgc2V0TG9jYWxMb2FkaW5nKGZhbHNlKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBTVEVQIDM6IEZpeCB0b2dnbGVHZW9mZW5jZVN0YXRlIHRvIGJldHRlciBoYW5kbGUgbWFudWFsbHkgY2xpY2tpbmcgdGhlIGJ1dHRvblxyXG4gICAqL1xyXG4gIGNvbnN0IHRvZ2dsZUdlb2ZlbmNlU3RhdGUgPSAoZW5hYmxlZDogYm9vbGVhbikgPT4ge1xyXG4gICAgY29uc29sZS5sb2coJ3RvZ2dsZUdlb2ZlbmNlU3RhdGUgY2FsbGVkIHdpdGg6JywgZW5hYmxlZCk7XHJcbiAgICBjb25zb2xlLmxvZygnQ3VycmVudCBnZW9mZW5jZUNvb3JkaW5hdGVzOicsIGdlb2ZlbmNlQ29vcmRpbmF0ZXMpO1xyXG5cclxuICAgIGlmIChlbmFibGVkKSB7XHJcbiAgICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgdmFsaWQgY29vcmRpbmF0ZXNcclxuICAgICAgaWYgKFxyXG4gICAgICAgIGdlb2ZlbmNlQ29vcmRpbmF0ZXMgJiZcclxuICAgICAgICB0eXBlb2YgZ2VvZmVuY2VDb29yZGluYXRlcy5sYXQgPT09ICdudW1iZXInICYmXHJcbiAgICAgICAgdHlwZW9mIGdlb2ZlbmNlQ29vcmRpbmF0ZXMubG5nID09PSAnbnVtYmVyJyAmJlxyXG4gICAgICAgICFpc05hTihnZW9mZW5jZUNvb3JkaW5hdGVzLmxhdCkgJiZcclxuICAgICAgICAhaXNOYU4oZ2VvZmVuY2VDb29yZGluYXRlcy5sbmcpXHJcbiAgICAgICkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdWYWxpZCBjb29yZGluYXRlcyBmb3VuZCwgZW5hYmxpbmcgZ2VvZmVuY2UnKTtcclxuXHJcbiAgICAgICAgLy8gU2V0IGZsYWdzIGZpcnN0XHJcbiAgICAgICAgc2V0R2VvZmVuY2VFbmFibGVkKHRydWUpO1xyXG4gICAgICAgIHNldElzR2VvZmVuY2VBY3RpdmUodHJ1ZSk7XHJcblxyXG4gICAgICAgIC8vIENhbGwgY29udGV4dCB0b2dnbGUgZnVuY3Rpb24gaWYgYXZhaWxhYmxlXHJcbiAgICAgICAgaWYgKHR5cGVvZiB0b2dnbGVHZW9mZW5jZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgdG9nZ2xlR2VvZmVuY2UoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERpc3BsYXkgYWlyY3JhZnQgaWYgd2UgaGF2ZSB0aGVtXHJcbiAgICAgICAgaWYgKGdlb2ZlbmNlQWlyY3JhZnQgJiYgZ2VvZmVuY2VBaXJjcmFmdC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgICAgYFNob3dpbmcgJHtnZW9mZW5jZUFpcmNyYWZ0Lmxlbmd0aH0gYWlyY3JhZnQgaW4gZ2VvZmVuY2VgXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgdXBkYXRlR2VvZmVuY2VBaXJjcmFmdChnZW9mZW5jZUFpcmNyYWZ0KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gTm8gYWlyY3JhZnQgZGF0YSB5ZXQsIHRyaWdnZXIgYSBzZWFyY2hcclxuICAgICAgICAgIGNvbnNvbGUubG9nKCdObyBhaXJjcmFmdCBkYXRhIHlldCwgdHJpZ2dlcmluZyBzZWFyY2gnKTtcclxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICBwcm9jZXNzR2VvZmVuY2VTZWFyY2goKTtcclxuICAgICAgICAgIH0sIDEwMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIE5vIHZhbGlkIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgY29uc29sZS53YXJuKCdObyB2YWxpZCBjb29yZGluYXRlcywgc2hvd2luZyBhbGVydCcpO1xyXG4gICAgICAgIGFsZXJ0KFxyXG4gICAgICAgICAgJ1BsZWFzZSBzZXQgYSBsb2NhdGlvbiBiZWZvcmUgZW5hYmxpbmcgZ2VvZmVuY2UuXFxuXFxuQ2xpY2sgYW55d2hlcmUgb24gdGhlIG1hcCB0byBzZXQgYSBsb2NhdGlvbi4nXHJcbiAgICAgICAgKTtcclxuICAgICAgICBzZXRHZW9mZW5jZUVuYWJsZWQoZmFsc2UpO1xyXG4gICAgICAgIHNldElzR2VvZmVuY2VBY3RpdmUoZmFsc2UpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBEaXNhYmxpbmcgZ2VvZmVuY2VcclxuICAgICAgY29uc29sZS5sb2coJ0Rpc2FibGluZyBnZW9mZW5jZScpO1xyXG4gICAgICBzZXRHZW9mZW5jZUVuYWJsZWQoZmFsc2UpO1xyXG4gICAgICBzZXRJc0dlb2ZlbmNlQWN0aXZlKGZhbHNlKTtcclxuXHJcbiAgICAgIC8vIENsZWFyIGdlb2ZlbmNlIGRhdGEgaWYgZnVuY3Rpb24gYXZhaWxhYmxlXHJcbiAgICAgIGlmICh0eXBlb2YgY2xlYXJHZW9mZW5jZURhdGEgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICBjbGVhckdlb2ZlbmNlRGF0YSgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLy8gTWFudWZhY3R1cmVyIGZpbHRlciBtZXRob2RzXHJcbiAgY29uc3Qgc2VsZWN0TWFudWZhY3R1cmVyQW5kQ2xvc2UgPSAodmFsdWU6IHN0cmluZykgPT4ge1xyXG4gICAgLy8gQ2xvc2UgZHJvcGRvd25cclxuICAgIHNldEFjdGl2ZURyb3Bkb3duKG51bGwpO1xyXG4gICAgc2V0TWFudWZhY3R1cmVyU2VhcmNoVGVybSgnJyk7XHJcblxyXG4gICAgLy8gSWYgY2xlYXJpbmcgdGhlIHNlbGVjdGlvblxyXG4gICAgaWYgKHZhbHVlID09PSAnJykge1xyXG4gICAgICBzZWxlY3RNYW51ZmFjdHVyZXIobnVsbCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTZXQgdGhlIG1hbnVmYWN0dXJlciBzZWxlY3Rpb25cclxuICAgIHNlbGVjdE1hbnVmYWN0dXJlcih2YWx1ZSk7XHJcblxyXG4gICAgLy8gSWYgcmVnaW9uIGlzIGFscmVhZHkgc2VsZWN0ZWQsIGZldGNoIGZpbHRlcmVkIGRhdGFcclxuICAgIGlmIChhY3RpdmVSZWdpb24gIT09IG51bGwpIHtcclxuICAgICAgZmV0Y2hBaXJjcmFmdEJ5UmVnaW9uQW5kTWFudWZhY3R1cmVyKGFjdGl2ZVJlZ2lvbiBhcyBSZWdpb25Db2RlLCB2YWx1ZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBPdGhlcndpc2UsIGp1c3QgcHJvY2VlZCB3aXRoIG1hbnVmYWN0dXJlci1vbmx5IGZpbHRlcmluZyBhcyBiZWZvcmVcclxuICAgICAgZmV0Y2hNYW51ZmFjdHVyZXJEYXRhKHZhbHVlKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBjb25zdCBmZXRjaE1hbnVmYWN0dXJlckRhdGEgPSAobWFudWZhY3R1cmVyOiBzdHJpbmcpID0+IHtcclxuICAgIGlmIChpc1JhdGVMaW1pdGVkKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGBTa2lwcGluZyBkYXRhIGZldGNoIC0gcmF0ZSBsaW1pdGVkIGZvciAke3JhdGVMaW1pdFRpbWVyfXNgKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnNvbGUubG9nKGBGZXRjaGluZyBkYXRhIGZvciBtYW51ZmFjdHVyZXI6ICR7bWFudWZhY3R1cmVyfWApO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIElmIHlvdSBoYXZlIGEgY29udGV4dCBmdW5jdGlvbiBmb3IgdGhpcywgY2FsbCBpdCBhZnRlciBhIHNsaWdodCBkZWxheVxyXG4gICAgICBpZiAodHlwZW9mIHJlZnJlc2hQb3NpdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAvLyBBcHBseSBhIHNtYWxsIGRlbGF5IHRvIHByZXZlbnQgb3ZlcndoZWxtaW5nIHRoZSBBUElcclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgIHJlZnJlc2hQb3NpdGlvbnMoKS5jYXRjaCgoZXJyb3I6IGFueSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ3JhdGUgbGltaXQnKSB8fCBlcnJvci5zdGF0dXMgPT09IDQyOSkge1xyXG4gICAgICAgICAgICAgIGhhbmRsZVJhdGVMaW1pdCgzMCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgbWFudWZhY3R1cmVyIGRhdGE6JywgZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9LCAyMDApO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICAgIGlmIChlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygncmF0ZSBsaW1pdCcpIHx8IGVycm9yLnN0YXR1cyA9PT0gNDI5KSB7XHJcbiAgICAgICAgaGFuZGxlUmF0ZUxpbWl0KDMwKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzY2hlZHVsaW5nIG1hbnVmYWN0dXJlciBkYXRhIGZldGNoOicsIGVycm9yKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGNvbnN0IGZldGNoQWlyY3JhZnRCeVJlZ2lvbkFuZE1hbnVmYWN0dXJlciA9IGFzeW5jIChcclxuICAgIHJlZ2lvbjogUmVnaW9uQ29kZSxcclxuICAgIG1hbnVmYWN0dXJlcjogc3RyaW5nLFxyXG4gICAgcGFnZTogbnVtYmVyID0gMSxcclxuICAgIGxpbWl0OiBudW1iZXIgPSA1MDBcclxuICApID0+IHtcclxuICAgIGlmICghcmVnaW9uIHx8ICFtYW51ZmFjdHVyZXIpIHtcclxuICAgICAgY29uc29sZS5sb2coJ0JvdGggcmVnaW9uIGFuZCBtYW51ZmFjdHVyZXIgbXVzdCBiZSBzZWxlY3RlZCcpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgc2V0TG9jYWxMb2FkaW5nKHRydWUpO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXHJcbiAgICAgICAgYC9hcGkvdHJhY2tpbmcvZmlsdGVyZWQtYWlyY3JhZnQ/cmVnaW9uPSR7cmVnaW9ufSZtYW51ZmFjdHVyZXI9JHtlbmNvZGVVUklDb21wb25lbnQobWFudWZhY3R1cmVyKX0mcGFnZT0ke3BhZ2V9JmxpbWl0PSR7bGltaXR9YFxyXG4gICAgICApO1xyXG5cclxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgY29uc3QgYWlyY3JhZnREYXRhID0gZGF0YS5haXJjcmFmdCB8fCBbXTtcclxuXHJcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFQSSBlcnJvcjogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBQcm9jZXNzIHRoZSBmaWx0ZXJlZCBhaXJjcmFmdCBkYXRhXHJcbiAgICAgIGlmIChhaXJjcmFmdERhdGEubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIC8vIFRyYW5zZm9ybSB0byBFeHRlbmRlZEFpcmNyYWZ0XHJcbiAgICAgICAgaW50ZXJmYWNlIEFpcmNyYWZ0RGF0YSB7XHJcbiAgICAgICAgICBUWVBFX0FJUkNSQUZUPzogc3RyaW5nO1xyXG4gICAgICAgICAgT1BFUkFUT1I/OiBzdHJpbmc7XHJcbiAgICAgICAgICBSRUdJT046IG51bWJlcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGV4dGVuZGVkQWlyY3JhZnQ6IEV4dGVuZGVkQWlyY3JhZnRbXSA9IGFpcmNyYWZ0RGF0YS5tYXAoXHJcbiAgICAgICAgICAoYWlyY3JhZnQ6IEFpcmNyYWZ0RGF0YSkgPT4gKHtcclxuICAgICAgICAgICAgLi4uYWlyY3JhZnQsXHJcbiAgICAgICAgICAgIHR5cGU6IGFpcmNyYWZ0LlRZUEVfQUlSQ1JBRlQgfHwgJ1Vua25vd24nLFxyXG4gICAgICAgICAgICBpc0dvdmVybm1lbnQ6XHJcbiAgICAgICAgICAgICAgYWlyY3JhZnQuT1BFUkFUT1I/LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2dvdmVybm1lbnQnKSA/PyBmYWxzZSxcclxuICAgICAgICAgICAgUkVHSU9OOiBhaXJjcmFmdC5SRUdJT04sXHJcbiAgICAgICAgICAgIHpvb21MZXZlbDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgfSlcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyBVcGRhdGUgdGhlIG1hcFxyXG4gICAgICAgIHVwZGF0ZUdlb2ZlbmNlQWlyY3JhZnQoZXh0ZW5kZWRBaXJjcmFmdCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICBgTm8gYWlyY3JhZnQgZm91bmQgZm9yIG1hbnVmYWN0dXJlciAke21hbnVmYWN0dXJlcn0gaW4gcmVnaW9uICR7cmVnaW9ufWBcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBmaWx0ZXJlZCBhaXJjcmFmdDonLCBlcnJvcik7XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICBzZXRMb2NhbExvYWRpbmcoZmFsc2UpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8vIE1vZGVsIHNlbGVjdGlvbiBtZXRob2RzXHJcbiAgY29uc3QgaGFuZGxlTW9kZWxTZWxlY3QgPSAodmFsdWU6IHN0cmluZykgPT4ge1xyXG4gICAgc2VsZWN0TW9kZWwodmFsdWUgPT09ICcnID8gbnVsbCA6IHZhbHVlKTtcclxuICAgIHNldEFjdGl2ZURyb3Bkb3duKG51bGwpO1xyXG5cclxuICAgIC8vIElmIGluIGNvbWJpbmVkIG1vZGUsIHJlYXBwbHkgdGhlIGZpbHRlclxyXG4gICAgaWYgKGZpbHRlck1vZGUgPT09ICdib3RoJyAmJiBpc0dlb2ZlbmNlQWN0aXZlICYmIHNlbGVjdGVkTWFudWZhY3R1cmVyKSB7XHJcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgIGFwcGx5Q29tYmluZWRGaWx0ZXJzKCk7XHJcbiAgICAgIH0sIDEwMCk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLy8gQ29tYmluZWQgZmlsdGVyIG1ldGhvZHNcclxuICBjb25zdCBhcHBseUNvbWJpbmVkRmlsdGVycyA9ICgpID0+IHtcclxuICAgIGlmIChcclxuICAgICAgIXNlbGVjdGVkTWFudWZhY3R1cmVyIHx8XHJcbiAgICAgICFpc0dlb2ZlbmNlQWN0aXZlIHx8XHJcbiAgICAgIGdlb2ZlbmNlQWlyY3JhZnQubGVuZ3RoID09PSAwXHJcbiAgICApIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHNldExvY2FsTG9hZGluZyh0cnVlKTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICBgRmlsdGVyaW5nICR7Z2VvZmVuY2VBaXJjcmFmdC5sZW5ndGh9IGFpcmNyYWZ0IGJ5ICR7c2VsZWN0ZWRNYW51ZmFjdHVyZXJ9YFxyXG4gICAgICApO1xyXG5cclxuICAgICAgLy8gRmlsdGVyIHRoZSBhaXJjcmFmdCBieSBtYW51ZmFjdHVyZXJcclxuICAgICAgbGV0IGZpbHRlcmVkQWlyY3JhZnQgPSBnZW9mZW5jZUFpcmNyYWZ0LmZpbHRlcihcclxuICAgICAgICAoYWlyY3JhZnQpID0+XHJcbiAgICAgICAgICBhaXJjcmFmdC5NQU5VRkFDVFVSRVI/LnRvTG93ZXJDYXNlKCkgPT09XHJcbiAgICAgICAgICBzZWxlY3RlZE1hbnVmYWN0dXJlci50b0xvd2VyQ2FzZSgpXHJcbiAgICAgICk7XHJcblxyXG4gICAgICAvLyBGdXJ0aGVyIGZpbHRlciBieSBtb2RlbCBpZiBzZWxlY3RlZFxyXG4gICAgICBpZiAoc2VsZWN0ZWRNb2RlbCkge1xyXG4gICAgICAgIGZpbHRlcmVkQWlyY3JhZnQgPSBmaWx0ZXJlZEFpcmNyYWZ0LmZpbHRlcihcclxuICAgICAgICAgIChhaXJjcmFmdCkgPT5cclxuICAgICAgICAgICAgYWlyY3JhZnQuTU9ERUw/LnRvTG93ZXJDYXNlKCkgPT09IHNlbGVjdGVkTW9kZWwudG9Mb3dlckNhc2UoKVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKGBGb3VuZCAke2ZpbHRlcmVkQWlyY3JhZnQubGVuZ3RofSBtYXRjaGluZyBhaXJjcmFmdGApO1xyXG5cclxuICAgICAgaWYgKGZpbHRlcmVkQWlyY3JhZnQubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgYWxlcnQoYE5vICR7c2VsZWN0ZWRNYW51ZmFjdHVyZXJ9IGFpcmNyYWZ0IGZvdW5kIGluIHRoaXMgYXJlYS5gKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENsZWFyIGRpc3BsYXkgZGF0YVxyXG4gICAgICBpZiAoY2xlYXJHZW9mZW5jZURhdGEpIHtcclxuICAgICAgICBjbGVhckdlb2ZlbmNlRGF0YSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBVcGRhdGUgdGhlIGRpc3BsYXlcclxuICAgICAgdXBkYXRlR2VvZmVuY2VBaXJjcmFmdChmaWx0ZXJlZEFpcmNyYWZ0KTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZpbHRlcmluZyBhaXJjcmFmdDonLCBlcnJvcik7XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICBzZXRMb2NhbExvYWRpbmcoZmFsc2UpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8vIFJlc2V0IGFsbCBmaWx0ZXJzXHJcbiAgY29uc3QgY2xlYXJBbGxGaWx0ZXJzID0gKCkgPT4ge1xyXG4gICAgY29uc29sZS5sb2coJ0NsZWFyaW5nIGFsbCBmaWx0ZXJzLi4uJyk7XHJcblxyXG4gICAgLy8gMS4gUmVzZXQgZmlsdGVyIG1vZGVcclxuICAgIHNldEZpbHRlck1vZGUoJ21hbnVmYWN0dXJlcicpO1xyXG5cclxuICAgIC8vIDIuIFVuYmxvY2sgQVBJIGNhbGxzIHRoYXQgbWlnaHQgaGF2ZSBiZWVuIGJsb2NrZWRcclxuICAgIG9wZW5Ta3lUcmFja2luZ1NlcnZpY2Uuc2V0QmxvY2tBbGxBcGlDYWxscyhmYWxzZSk7XHJcbiAgICBzZXRCbG9ja01hbnVmYWN0dXJlckFwaUNhbGxzKGZhbHNlKTtcclxuICAgIHNldElzTWFudWZhY3R1cmVyQXBpQmxvY2tlZChmYWxzZSk7XHJcblxyXG4gICAgLy8gMy4gQ2xlYXIgbWFudWZhY3R1cmVyIHNlbGVjdGlvblxyXG4gICAgc2VsZWN0TWFudWZhY3R1cmVyKG51bGwpO1xyXG4gICAgc2VsZWN0TW9kZWwobnVsbCk7XHJcblxyXG4gICAgLy8gNC4gQ2xlYXIgZ2VvZmVuY2VcclxuICAgIHNldEdlb2ZlbmNlTG9jYXRpb24oJycpO1xyXG4gICAgc2V0R2VvZmVuY2VDb29yZGluYXRlcyhudWxsKTtcclxuICAgIHNldEdlb2ZlbmNlQWlyY3JhZnQoW10pO1xyXG4gICAgc2V0R2VvZmVuY2VFbmFibGVkKGZhbHNlKTtcclxuICAgIHNldElzR2VvZmVuY2VBY3RpdmUoZmFsc2UpO1xyXG4gICAgaWYgKHR5cGVvZiBjbGVhckdlb2ZlbmNlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIGNsZWFyR2VvZmVuY2UoKTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgY2xlYXJHZW9mZW5jZURhdGEgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgY2xlYXJHZW9mZW5jZURhdGEoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyA1LiBSZXNldCBvd25lciBmaWx0ZXJzIHRvIHNlbGVjdCBhbGxcclxuICAgIHNldE93bmVyRmlsdGVycyhbLi4uYWxsT3duZXJUeXBlc10pO1xyXG5cclxuICAgIC8vIDYuIENsZWFyIHJlZ2lvbiBmaWx0ZXIgcHJvcGVybHlcclxuICAgIHNldEFjdGl2ZVJlZ2lvbihudWxsKTtcclxuICAgIHNldFNlbGVjdGVkUmVnaW9uKFJlZ2lvbkNvZGUuR0xPQkFMKTtcclxuXHJcbiAgICAvLyBDbGVhciByZWdpb24gb3V0bGluZSBmcm9tIG1hcFxyXG4gICAgaWYgKHJlZ2lvbk91dGxpbmUpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICAvLyBIYW5kbGUgZGlmZmVyZW50IHBvc3NpYmxlIG9iamVjdCBzdHJ1Y3R1cmVzXHJcbiAgICAgICAgaWYgKHR5cGVvZiByZWdpb25PdXRsaW5lLnJlbW92ZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgcmVnaW9uT3V0bGluZS5yZW1vdmUoKTtcclxuICAgICAgICB9IGVsc2UgaWYgKFxyXG4gICAgICAgICAgcmVnaW9uT3V0bGluZS5yZWN0YW5nbGUgJiZcclxuICAgICAgICAgIHR5cGVvZiByZWdpb25PdXRsaW5lLnJlY3RhbmdsZS5yZW1vdmUgPT09ICdmdW5jdGlvbidcclxuICAgICAgICApIHtcclxuICAgICAgICAgIHJlZ2lvbk91dGxpbmUucmVjdGFuZ2xlLnJlbW92ZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2xlYXIgYW55IGxhYmVscyBhc3NvY2lhdGVkIHdpdGggdGhlIHJlZ2lvblxyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgIHJlZ2lvbk91dGxpbmUubGFiZWwgJiZcclxuICAgICAgICAgIHR5cGVvZiByZWdpb25PdXRsaW5lLmxhYmVsLnJlbW92ZSA9PT0gJ2Z1bmN0aW9uJ1xyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgcmVnaW9uT3V0bGluZS5sYWJlbC5yZW1vdmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVtb3ZpbmcgcmVnaW9uIG91dGxpbmU6JywgZXJyb3IpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBBbHdheXMgcmVzZXQgdGhlIHJlZ2lvbiBvdXRsaW5lIHN0YXRlXHJcbiAgICAgIHNldFJlZ2lvbk91dGxpbmUobnVsbCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gNy4gUmVzZXQgbWFwIHZpZXcgdG8gZ2xvYmFsXHJcbiAgICBpZiAobWFwSW5zdGFuY2UpIHtcclxuICAgICAgLy8gVXNlIHRoZSBwcmVkZWZpbmVkIGNlbnRlciBhbmQgem9vbSBsZXZlbCBmcm9tIHlvdXIgbWFwIGNvbmZpZ1xyXG4gICAgICBtYXBJbnN0YW5jZS5zZXRWaWV3KE1BUF9DT05GSUcuQ0VOVEVSLCBNQVBfQ09ORklHLkRFRkFVTFRfWk9PTSk7XHJcbiAgICAgIG1hcEluc3RhbmNlLmludmFsaWRhdGVTaXplKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gOC4gUmVzZXQgdG8gaW5pdGlhbCBhaXJjcmFmdCBkYXRhXHJcbiAgICBpZiAodHlwZW9mIHJlc2V0ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHJlc2V0KCk7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBmdWxsUmVmcmVzaCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICBmdWxsUmVmcmVzaCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIDkuIENsb3NlIGFueSBvcGVuIGRyb3Bkb3duXHJcbiAgICBzZXRBY3RpdmVEcm9wZG93bihudWxsKTtcclxuXHJcbiAgICAvLyAxMC4gUmVzZXQgcmF0ZSBsaW1pdGluZyBzdGF0ZXNcclxuICAgIHNldElzUmF0ZUxpbWl0ZWQoZmFsc2UpO1xyXG4gICAgc2V0UmF0ZUxpbWl0VGltZXIobnVsbCk7XHJcblxyXG4gICAgLy8gMTEuIENsZWFyIGNvbWJpbmVkIG1vZGUgc3RhdGVcclxuICAgIHNldENvbWJpbmVkTW9kZVJlYWR5KGZhbHNlKTtcclxuXHJcbiAgICAvLyAxMi4gUmVzZXQgc2VhcmNoIHRlcm1zXHJcbiAgICBzZXRNYW51ZmFjdHVyZXJTZWFyY2hUZXJtKCcnKTtcclxuXHJcbiAgICAvLyAxMy4gRGlzcGF0Y2ggYSBjdXN0b20gZXZlbnQgdGhhdCBvdGhlciBjb21wb25lbnRzIGNhbiBsaXN0ZW4gZm9yXHJcbiAgICBjb25zdCBjbGVhckV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdyaWJib24tZmlsdGVycy1jbGVhcmVkJyk7XHJcbiAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KGNsZWFyRXZlbnQpO1xyXG5cclxuICAgIGNvbnNvbGUubG9nKCdBbGwgZmlsdGVycyBjbGVhcmVkIHN1Y2Nlc3NmdWxseScpO1xyXG4gIH07XHJcblxyXG4gIC8vIENhbGN1bGF0ZSBjb21iaW5lZCBsb2FkaW5nIHN0YXRlXHJcbiAgY29uc3QgY29tYmluZWRMb2FkaW5nID0gbG9jYWxMb2FkaW5nO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgLy8gU3RhdGVcclxuICAgIGZpbHRlck1vZGUsXHJcbiAgICBhY3RpdmVEcm9wZG93bixcclxuICAgIHNlbGVjdGVkTWFudWZhY3R1cmVyLFxyXG4gICAgc2VsZWN0ZWRNb2RlbCxcclxuICAgIGdlb2ZlbmNlTG9jYXRpb24sXHJcbiAgICBnZW9mZW5jZVJhZGl1cyxcclxuICAgIGlzR2VvZmVuY2VBY3RpdmUsXHJcbiAgICBnZW9mZW5jZUNvb3JkaW5hdGVzLFxyXG4gICAgYWN0aXZlUmVnaW9uLFxyXG4gICAgb3duZXJGaWx0ZXJzLFxyXG4gICAgYWxsT3duZXJUeXBlcyxcclxuICAgIG1hbnVmYWN0dXJlclNlYXJjaFRlcm0sXHJcbiAgICBjb21iaW5lZExvYWRpbmcsXHJcbiAgICBpc0dldHRpbmdMb2NhdGlvbixcclxuICAgIGRyb3Bkb3duUmVmcyxcclxuICAgIGxvY2FsTG9hZGluZyxcclxuICAgIGlzUmF0ZUxpbWl0ZWQsXHJcbiAgICBzZWxlY3RlZFJlZ2lvbixcclxuICAgIGlzUmVmcmVzaGluZyxcclxuICAgIGlzR2VvZmVuY2VQbGFjZW1lbnRNb2RlOiBmYWxzZSwgLy8gSW5pdGlhbGl6ZSB3aXRoIGEgZGVmYXVsdCB2YWx1ZVxyXG5cclxuICAgIC8vIE1ldGhvZHNcclxuICAgIHRvZ2dsZURyb3Bkb3duLFxyXG4gICAgdG9nZ2xlRmlsdGVyTW9kZSxcclxuICAgIHNlbGVjdE1hbnVmYWN0dXJlckFuZENsb3NlLFxyXG4gICAgaGFuZGxlTW9kZWxTZWxlY3QsXHJcbiAgICBnZXRVc2VyTG9jYXRpb24sXHJcbiAgICBwcm9jZXNzR2VvZmVuY2VTZWFyY2gsXHJcbiAgICBoYW5kbGVPd25lckZpbHRlckNoYW5nZSxcclxuICAgIGhhbmRsZVJlZ2lvblNlbGVjdCxcclxuICAgIHNldE1hbnVmYWN0dXJlclNlYXJjaFRlcm0sXHJcbiAgICBzZXRHZW9mZW5jZUxvY2F0aW9uLFxyXG4gICAgc2V0R2VvZmVuY2VSYWRpdXMsXHJcbiAgICB0b2dnbGVHZW9mZW5jZVN0YXRlLFxyXG4gICAgY2xlYXJBbGxGaWx0ZXJzLFxyXG4gICAgYXBwbHlDb21iaW5lZEZpbHRlcnMsXHJcbiAgICBnZXRBaXJjcmFmdE93bmVyVHlwZSxcclxuXHJcbiAgICByZWZyZXNoV2l0aEZpbHRlcnM6ICgpID0+IHtcclxuICAgICAgLy8gSW1wbGVtZW50IHJlZnJlc2ggbG9naWMgaGVyZVxyXG4gICAgICBpZiAodHlwZW9mIHJlZnJlc2hQb3NpdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICByZWZyZXNoUG9zaXRpb25zKCkuY2F0Y2goKGVycm9yKSA9PiB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZWZyZXNoaW5nIHBvc2l0aW9uczonLCBlcnJvcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBzZXRBY3RpdmVEcm9wZG93biwgLy8gQWRkIHRoaXMgbGluZSBpZiB5b3UgaGF2ZSB0aGlzIGZ1bmN0aW9uXHJcblxyXG4gICAgc2V0R2VvZmVuY2VDb29yZGluYXRlcyxcclxuICAgIHNldEdlb2ZlbmNlQ2VudGVyLFxyXG4gICAgdXBkYXRlR2VvZmVuY2VBaXJjcmFmdCxcclxuICB9O1xyXG59XHJcbiJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZVJlZiIsInVzZUVmZmVjdCIsIlJlYWN0IiwiUmVnaW9uQ29kZSIsInVzZUVuaGFuY2VkTWFwQ29udGV4dCIsIm9wZW5Ta3lUcmFja2luZ1NlcnZpY2UiLCJNYXBib3hTZXJ2aWNlIiwiYWRhcHRHZW9mZW5jZUFpcmNyYWZ0IiwiZW5yaWNoR2VvZmVuY2VBaXJjcmFmdCIsImdldEFpcmNyYWZ0TmVhckxvY2F0aW9uIiwiZ2V0QWlyY3JhZnROZWFyU2VhcmNoZWRMb2NhdGlvbiIsInVzZUdlb2xvY2F0aW9uIiwiTUFQX0NPTkZJRyIsImdldEJvdW5kc0J5UmVnaW9uIiwiZ2V0Wm9vbUxldmVsRm9yUmVnaW9uIiwidXNlRmlsdGVyTG9naWMiLCJzZWxlY3RlZE1hbnVmYWN0dXJlciIsInNlbGVjdGVkTW9kZWwiLCJ0b3RhbEFjdGl2ZSIsInNlbGVjdE1hbnVmYWN0dXJlciIsInNlbGVjdE1vZGVsIiwicmVzZXQiLCJmdWxsUmVmcmVzaCIsInJlZnJlc2hQb3NpdGlvbnMiLCJtYXBJbnN0YW5jZSIsInVwZGF0ZUFpcmNyYWZ0RGF0YSIsImNsZWFyR2VvZmVuY2VEYXRhIiwidXBkYXRlR2VvZmVuY2VBaXJjcmFmdCIsImJsb2NrTWFudWZhY3R1cmVyQXBpQ2FsbHMiLCJzZXRCbG9ja01hbnVmYWN0dXJlckFwaUNhbGxzIiwiaXNNYW51ZmFjdHVyZXJBcGlCbG9ja2VkIiwic2V0SXNNYW51ZmFjdHVyZXJBcGlCbG9ja2VkIiwiZ2VvZmVuY2VDZW50ZXIiLCJzZXRHZW9mZW5jZUNlbnRlciIsInRvZ2dsZUdlb2ZlbmNlIiwiY2xlYXJHZW9mZW5jZSIsImRpc3BsYXllZEFpcmNyYWZ0IiwiZ2V0Q3VycmVudFBvc2l0aW9uIiwibG9jYWxMb2FkaW5nIiwic2V0TG9jYWxMb2FkaW5nIiwiZmlsdGVyTW9kZSIsInNldEZpbHRlck1vZGUiLCJhY3RpdmVEcm9wZG93biIsInNldEFjdGl2ZURyb3Bkb3duIiwibWFudWZhY3R1cmVyU2VhcmNoVGVybSIsInNldE1hbnVmYWN0dXJlclNlYXJjaFRlcm0iLCJpc1JlZnJlc2hpbmciLCJzZXRJc1JlZnJlc2hpbmciLCJpc1JhdGVMaW1pdGVkIiwic2V0SXNSYXRlTGltaXRlZCIsInJhdGVMaW1pdFRpbWVyIiwic2V0UmF0ZUxpbWl0VGltZXIiLCJpc0dlb2ZlbmNlUGFuZWxPcGVuIiwic2V0SXNHZW9mZW5jZVBhbmVsT3BlbiIsImlzR2V0dGluZ0xvY2F0aW9uIiwic2V0SXNHZXR0aW5nTG9jYXRpb24iLCJnZW9mZW5jZUxvY2F0aW9uIiwic2V0R2VvZmVuY2VMb2NhdGlvbiIsImdlb2ZlbmNlUmFkaXVzIiwic2V0R2VvZmVuY2VSYWRpdXMiLCJnZW9mZW5jZUNvb3JkaW5hdGVzIiwic2V0R2VvZmVuY2VDb29yZGluYXRlcyIsImdlb2ZlbmNlQWlyY3JhZnQiLCJzZXRHZW9mZW5jZUFpcmNyYWZ0IiwiZ2VvZmVuY2VFbmFibGVkIiwic2V0R2VvZmVuY2VFbmFibGVkIiwiaXNHZW9mZW5jZUFjdGl2ZSIsInNldElzR2VvZmVuY2VBY3RpdmUiLCJpc1NlYXJjaFJlYWR5Iiwic2V0SXNTZWFyY2hSZWFkeSIsImFjdGl2ZVJlZ2lvbiIsInNldEFjdGl2ZVJlZ2lvbiIsInJlZ2lvbk91dGxpbmUiLCJzZXRSZWdpb25PdXRsaW5lIiwic2VsZWN0ZWRSZWdpb24iLCJzZXRTZWxlY3RlZFJlZ2lvbiIsIkdMT0JBTCIsImNvbWJpbmVkTW9kZVJlYWR5Iiwic2V0Q29tYmluZWRNb2RlUmVhZHkiLCJhbGxPd25lclR5cGVzIiwib3duZXJGaWx0ZXJzIiwic2V0T3duZXJGaWx0ZXJzIiwiZHJvcGRvd25SZWZzIiwiZmlsdGVyIiwibWFudWZhY3R1cmVyIiwibW9kZWwiLCJsb2NhdGlvbiIsInJlZ2lvbiIsIm93bmVyIiwiYWN0aW9ucyIsInRpbWVyIiwic2V0VGltZW91dCIsImNvbnNvbGUiLCJsb2ciLCJjbGVhclRpbWVvdXQiLCJoYW5kbGVDbGlja091dHNpZGUiLCJldmVudCIsImlzT3V0c2lkZUFsbCIsIk9iamVjdCIsInZhbHVlcyIsImV2ZXJ5IiwicmVmIiwiY3VycmVudCIsImNvbnRhaW5zIiwidGFyZ2V0IiwiZG9jdW1lbnQiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInJlbW92ZSIsImhhbmRsZU1hcEdlb2ZlbmNlQ2xpY2siLCJjdXN0b21FdmVudCIsImxhdCIsImxuZyIsImRldGFpbCIsInRvRml4ZWQiLCJsb2NhdGlvbk5hbWUiLCJnZXRMb2NhdGlvbk5hbWVGcm9tQ29vcmRpbmF0ZXMiLCJlcnJvciIsInRvZ2dsZURyb3Bkb3duIiwidHlwZSIsInN0b3BQcm9wYWdhdGlvbiIsInByZXZTdGF0ZSIsImhhbmRsZVJhdGVMaW1pdCIsInJldHJ5QWZ0ZXIiLCJzZXRCbG9ja0FsbEFwaUNhbGxzIiwiYWxlcnQiLCJ0b2dnbGVGaWx0ZXJNb2RlIiwibW9kZSIsImxlbmd0aCIsImZpbHRlckFpcmNyYWZ0QnlSZWdpb24iLCJ0b1N0cmluZyIsImFpcmNyYWZ0V2l0aFZhbGlkQ29vcmRzIiwicGxhbmUiLCJsYXRpdHVkZSIsImxvbmdpdHVkZSIsImlzTmFOIiwiZmlsdGVyZWRCeU93bmVyIiwiYWlyY3JhZnQiLCJpbmNsdWRlcyIsImdldEFpcmNyYWZ0T3duZXJUeXBlIiwiYXBwbHlDb21iaW5lZEZpbHRlcnMiLCJvd25lclR5cGUiLCJUWVBFX1JFR0lTVFJBTlQiLCJvd25lclR5cGVUb1N0cmluZyIsInR5cGVOdW0iLCJwYXJzZUludCIsIm93bmVyVHlwZU1hcCIsImFwcGx5T3duZXJUeXBlRmlsdGVyIiwiZmlsdGVycyIsImZpbHRlcmVkQWlyY3JhZnQiLCJoYW5kbGVPd25lckZpbHRlckNoYW5nZSIsInVwZGF0ZWRGaWx0ZXJzIiwicmVzZXRPd25lckZpbHRlcnMiLCJib3VuZHNFeHByZXNzaW9uIiwiQXJyYXkiLCJpc0FycmF5IiwibWluTGF0IiwibWluTG5nIiwibWF4TGF0IiwibWF4TG5nIiwiaGFuZGxlUmVnaW9uU2VsZWN0IiwiYm91bmRzIiwiem9vbUxldmVsIiwic2V0Wm9vbSIsIm9wdGlvbnMiLCJwYWRkaW5nIiwiUEFERElORyIsIkRFRkFVTFQiLCJmaXRCb3VuZHMiLCJpbnZhbGlkYXRlU2l6ZSIsImRyYXdSZWdpb25PdXRsaW5lIiwiY291bnRSZXNwb25zZSIsImZldGNoIiwib2siLCJjb3VudERhdGEiLCJqc29uIiwiY291bnQiLCJMIiwicmVxdWlyZSIsInJlY3RhbmdsZSIsImNvbG9yIiwid2VpZ2h0Iiwib3BhY2l0eSIsImZpbGwiLCJmaWxsQ29sb3IiLCJmaWxsT3BhY2l0eSIsImRhc2hBcnJheSIsImludGVyYWN0aXZlIiwiYWRkVG8iLCJnZXRVc2VyTG9jYXRpb24iLCJwb3NpdGlvbiIsImNvb3JkcyIsImZldGNoZWRBaXJjcmFmdCIsImFkYXB0ZWRBaXJjcmFmdCIsImVucmljaGVkQWlyY3JhZnQiLCJjdXJyZW50Wm9vbSIsImdldFpvb20iLCJ0YXJnZXRab29tIiwic2V0VmlldyIsIm1lc3NhZ2UiLCJzdGF0dXMiLCJwcm9jZXNzR2VvZmVuY2VTZWFyY2giLCJsb2NhdGlvbnMiLCJzZWFyY2hMb2NhdGlvbldpdGhNYXBib3giLCJjb29yZGluYXRlcyIsIm5hbWUiLCJFcnJvciIsIk1BTlVGQUNUVVJFUiIsInVuZGVmaW5lZCIsInRvZ2dsZUdlb2ZlbmNlU3RhdGUiLCJlbmFibGVkIiwid2FybiIsInNlbGVjdE1hbnVmYWN0dXJlckFuZENsb3NlIiwidmFsdWUiLCJmZXRjaEFpcmNyYWZ0QnlSZWdpb25BbmRNYW51ZmFjdHVyZXIiLCJmZXRjaE1hbnVmYWN0dXJlckRhdGEiLCJjYXRjaCIsInBhZ2UiLCJsaW1pdCIsInJlc3BvbnNlIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiZGF0YSIsImFpcmNyYWZ0RGF0YSIsInN0YXR1c1RleHQiLCJleHRlbmRlZEFpcmNyYWZ0IiwibWFwIiwiVFlQRV9BSVJDUkFGVCIsImlzR292ZXJubWVudCIsIk9QRVJBVE9SIiwidG9Mb3dlckNhc2UiLCJSRUdJT04iLCJoYW5kbGVNb2RlbFNlbGVjdCIsIk1PREVMIiwiY2xlYXJBbGxGaWx0ZXJzIiwibGFiZWwiLCJDRU5URVIiLCJERUZBVUxUX1pPT00iLCJjbGVhckV2ZW50IiwiQ3VzdG9tRXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwiY29tYmluZWRMb2FkaW5nIiwiaXNHZW9mZW5jZVBsYWNlbWVudE1vZGUiLCJyZWZyZXNoV2l0aEZpbHRlcnMiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/tracking/hooks/useFilterLogic.ts\n"));

/***/ })

});
"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_pages-dir-browser_components_tracking_map_AircraftTrackingMap_tsx",{

/***/ "(pages-dir-browser)/./components/tracking/hooks/useFilterLogic.ts":
/*!*****************************************************!*\
  !*** ./components/tracking/hooks/useFilterLogic.ts ***!
  \*****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useFilterLogic: () => (/* binding */ useFilterLogic)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _types_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/types/base */ \"(pages-dir-browser)/./types/base.ts\");\n/* harmony import */ var _context_EnhancedMapContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../context/EnhancedMapContext */ \"(pages-dir-browser)/./components/tracking/context/EnhancedMapContext.tsx\");\n/* harmony import */ var _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/services/openSkyTrackingService */ \"(pages-dir-browser)/./lib/services/openSkyTrackingService.ts\");\n/* harmony import */ var _lib_services_MapboxService__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../lib/services/MapboxService */ \"(pages-dir-browser)/./lib/services/MapboxService.ts\");\n/* harmony import */ var _lib_utils_geofenceAdapter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/lib/utils/geofenceAdapter */ \"(pages-dir-browser)/./lib/utils/geofenceAdapter.ts\");\n/* harmony import */ var _lib_utils_geofenceEnricher__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/lib/utils/geofenceEnricher */ \"(pages-dir-browser)/./lib/utils/geofenceEnricher.ts\");\n/* harmony import */ var _lib_services_geofencing__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../lib/services/geofencing */ \"(pages-dir-browser)/./lib/services/geofencing.ts\");\n/* harmony import */ var _hooks_useGeolocation__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../hooks/useGeolocation */ \"(pages-dir-browser)/./components/tracking/hooks/useGeolocation.ts\");\n/* harmony import */ var _config_map__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../config/map */ \"(pages-dir-browser)/./config/map.ts\");\n\n\n\n\n\n\n\n\n\n\n\nfunction useFilterLogic() {\n    // Get context state and functions\n    const { selectedManufacturer, selectedModel, totalActive, selectManufacturer, selectModel, reset, fullRefresh, refreshPositions, mapInstance, updateAircraftData, clearGeofenceData, updateGeofenceAircraft, blockManufacturerApiCalls, setBlockManufacturerApiCalls, isManufacturerApiBlocked, setIsManufacturerApiBlocked, geofenceCenter, setGeofenceCenter, toggleGeofence, clearGeofence, displayedAircraft } = (0,_context_EnhancedMapContext__WEBPACK_IMPORTED_MODULE_2__.useEnhancedMapContext)();\n    // Get geolocation hook\n    const { getCurrentPosition } = (0,_hooks_useGeolocation__WEBPACK_IMPORTED_MODULE_8__.useGeolocation)();\n    // Local state\n    const [localLoading, setLocalLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [filterMode, setFilterMode] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [activeDropdown, setActiveDropdown] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [manufacturerSearchTerm, setManufacturerSearchTerm] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)('');\n    const [isRefreshing, setIsRefreshing] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [isRateLimited, setIsRateLimited] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [rateLimitTimer, setRateLimitTimer] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [isGeofencePanelOpen, setIsGeofencePanelOpen] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    // Geofence state\n    const [isGettingLocation, setIsGettingLocation] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [geofenceLocation, setGeofenceLocation] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)('');\n    const [geofenceRadius, setGeofenceRadius] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(25);\n    const [geofenceCoordinates, setGeofenceCoordinates] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [geofenceAircraft, setGeofenceAircraft] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [geofenceEnabled, setGeofenceEnabled] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [isGeofenceActive, setIsGeofenceActive] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [isSearchReady, setIsSearchReady] = react__WEBPACK_IMPORTED_MODULE_0___default().useState(false);\n    // Region state\n    const [activeRegion, setActiveRegion] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [regionOutline, setRegionOutline] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [selectedRegion, setSelectedRegion] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(_types_base__WEBPACK_IMPORTED_MODULE_1__.RegionCode.GLOBAL);\n    // Combined mode state\n    const [combinedModeReady, setCombinedModeReady] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    // Owner filter state\n    const allOwnerTypes = [\n        'individual',\n        'partnership',\n        'corp-owner',\n        'co-owned',\n        'llc',\n        'non-citizen-corp',\n        'airline',\n        'freight',\n        'medical',\n        'media',\n        'historical',\n        'flying-club',\n        'emergency',\n        'local-govt',\n        'education',\n        'federal-govt',\n        'flight-school',\n        'leasing-corp',\n        'military',\n        'unknown'\n    ];\n    const [ownerFilters, setOwnerFilters] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([\n        ...allOwnerTypes\n    ]);\n    // Refs for dropdown handling\n    const dropdownRefs = {\n        filter: (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),\n        manufacturer: (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),\n        model: (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),\n        location: (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),\n        region: (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),\n        owner: (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),\n        actions: (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null)\n    };\n    // Effects\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect({\n        \"useFilterLogic.useEffect\": ()=>{\n            if (geofenceCoordinates) {\n                setIsSearchReady(true);\n            }\n        }\n    }[\"useFilterLogic.useEffect\"], [\n        geofenceCoordinates\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useFilterLogic.useEffect\": ()=>{\n            if (isRateLimited && rateLimitTimer) {\n                const timer = setTimeout({\n                    \"useFilterLogic.useEffect.timer\": ()=>{\n                        setIsRateLimited(false);\n                        setRateLimitTimer(null);\n                        console.log('Rate limit timer expired, resuming API calls');\n                    }\n                }[\"useFilterLogic.useEffect.timer\"], rateLimitTimer * 1000);\n                return ({\n                    \"useFilterLogic.useEffect\": ()=>clearTimeout(timer)\n                })[\"useFilterLogic.useEffect\"];\n            }\n        }\n    }[\"useFilterLogic.useEffect\"], [\n        isRateLimited,\n        rateLimitTimer\n    ]);\n    // Effect to sync geofence state\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useFilterLogic.useEffect\": ()=>{\n            // Update internal state when geofence is toggled externally\n            if (isGeofenceActive !== geofenceEnabled) {\n                setGeofenceEnabled(isGeofenceActive);\n            }\n        }\n    }[\"useFilterLogic.useEffect\"], [\n        isGeofenceActive\n    ]);\n    // Close dropdown when clicking outside\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useFilterLogic.useEffect\": ()=>{\n            const handleClickOutside = {\n                \"useFilterLogic.useEffect.handleClickOutside\": (event)=>{\n                    // Check if click is outside of all dropdowns\n                    const isOutsideAll = Object.values(dropdownRefs).every({\n                        \"useFilterLogic.useEffect.handleClickOutside.isOutsideAll\": (ref)=>!ref.current || !ref.current.contains(event.target)\n                    }[\"useFilterLogic.useEffect.handleClickOutside.isOutsideAll\"]);\n                    if (isOutsideAll) {\n                        setActiveDropdown(null);\n                    }\n                }\n            }[\"useFilterLogic.useEffect.handleClickOutside\"];\n            document.addEventListener('mousedown', handleClickOutside);\n            return ({\n                \"useFilterLogic.useEffect\": ()=>{\n                    document.removeEventListener('mousedown', handleClickOutside);\n                }\n            })[\"useFilterLogic.useEffect\"];\n        }\n    }[\"useFilterLogic.useEffect\"], []);\n    // Clean up region outline when component unmounts\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useFilterLogic.useEffect\": ()=>{\n            return ({\n                \"useFilterLogic.useEffect\": ()=>{\n                    if (regionOutline) {\n                        regionOutline.remove();\n                    }\n                }\n            })[\"useFilterLogic.useEffect\"];\n        }\n    }[\"useFilterLogic.useEffect\"], [\n        regionOutline\n    ]);\n    // Effect to handle map click for geofence\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useFilterLogic.useEffect\": ()=>{\n            const handleMapGeofenceClick = {\n                \"useFilterLogic.useEffect.handleMapGeofenceClick\": async (event)=>{\n                    try {\n                        // Cast the event to the proper type\n                        const customEvent = event;\n                        const { lat, lng } = customEvent.detail;\n                        // First update coordinates immediately\n                        setGeofenceCoordinates({\n                            lat,\n                            lng\n                        });\n                        // Then start an async operation to get the location name\n                        console.log(\"Getting location name for: \".concat(lat, \", \").concat(lng));\n                        // Temporarily show coordinates while fetching the name\n                        setGeofenceLocation(\"\".concat(lat.toFixed(6), \", \").concat(lng.toFixed(6)));\n                        // Get the friendly name asynchronously\n                        const locationName = await _lib_services_MapboxService__WEBPACK_IMPORTED_MODULE_4__.MapboxService.getLocationNameFromCoordinates(lat, lng);\n                        console.log(\"Got location name: \".concat(locationName));\n                        // Update with the friendly name once we have it\n                        if (locationName !== null) {\n                            setGeofenceLocation(locationName);\n                        }\n                        // Open the location dropdown if needed\n                        if (activeDropdown !== 'location') {\n                            setActiveDropdown('location');\n                        }\n                    } catch (error) {\n                        console.error('Error handling map click:', error);\n                    // Keep the coordinates display if there was an error\n                    }\n                }\n            }[\"useFilterLogic.useEffect.handleMapGeofenceClick\"];\n            // Add the event listener - use the standard event listener pattern\n            document.addEventListener('map-geofence-click', handleMapGeofenceClick);\n            // Clean up\n            return ({\n                \"useFilterLogic.useEffect\": ()=>{\n                    document.removeEventListener('map-geofence-click', handleMapGeofenceClick);\n                }\n            })[\"useFilterLogic.useEffect\"];\n        }\n    }[\"useFilterLogic.useEffect\"], [\n        setGeofenceLocation,\n        setGeofenceCoordinates,\n        setActiveDropdown,\n        activeDropdown\n    ]);\n    // Main methods\n    // Toggle dropdown function\n    const toggleDropdown = (type, event)=>{\n        event.stopPropagation();\n        setActiveDropdown((prevState)=>prevState === type ? null : type);\n        // If opening the geofence panel, close any active dropdown\n        if (type === 'geofence' && activeDropdown) {\n            setActiveDropdown(null);\n        }\n    };\n    const handleRateLimit = function() {\n        let retryAfter = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 30;\n        setIsRateLimited(true);\n        setRateLimitTimer(retryAfter);\n        console.log(\"Rate limited by API. Retry after \".concat(retryAfter, \"s\"));\n        // Block all API calls\n        _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].setBlockAllApiCalls(true);\n        setBlockManufacturerApiCalls(true);\n        // Show notification to user\n        if (retryAfter > 0) {\n            alert(\"Aircraft data refresh rate limited. Please wait \".concat(retryAfter, \" seconds before trying again.\"));\n        }\n    };\n    /**\r\n   * Toggle filter mode\r\n   */ const toggleFilterMode = (mode)=>{\n        setFilterMode(mode);\n        setActiveDropdown(null);\n        // Apply appropriate filters based on new mode\n        if (mode === 'region') {\n            // Block API calls in region mode\n            _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].setBlockAllApiCalls(true);\n            // Apply region filtering if we already have data\n            if (displayedAircraft && displayedAircraft.length > 0) {\n                filterAircraftByRegion(selectedRegion.toString());\n            }\n            // Clear manufacturer selection from the UI\n            selectManufacturer(null);\n            selectModel(null);\n            // If geofence is active, restore the full geofence data\n            if (geofenceCoordinates && geofenceAircraft.length > 0) {\n                updateGeofenceAircraft(geofenceAircraft);\n            }\n        } else if (mode === 'owner') {\n            // Filter displayed aircraft by owner type\n            if (displayedAircraft && displayedAircraft.length > 0) {\n                // First filter for valid coordinates\n                const aircraftWithValidCoords = displayedAircraft.filter((plane)=>typeof plane.latitude === 'number' && typeof plane.longitude === 'number' && !isNaN(plane.latitude) && !isNaN(plane.longitude));\n                // Apply owner type filter\n                let filteredByOwner = ownerFilters.length === 0 ? aircraftWithValidCoords : aircraftWithValidCoords.filter((aircraft)=>ownerFilters.includes(getAircraftOwnerType(aircraft)));\n                // Update display with filtered aircraft\n                if (clearGeofenceData) {\n                    clearGeofenceData();\n                }\n                updateGeofenceAircraft(filteredByOwner);\n            }\n        } else if (mode === 'both') {\n            // Both mode - BLOCK API CALLS\n            _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].setBlockAllApiCalls(true);\n            if (selectedManufacturer && isGeofenceActive && geofenceAircraft.length > 0) {\n                applyCombinedFilters();\n            } else {\n                // If one is missing, prompt the user\n                if (!selectedManufacturer && isGeofenceActive) {\n                    alert('Please select a manufacturer to use combined filter mode');\n                } else if (selectedManufacturer && !isGeofenceActive) {\n                    alert('Please set a location to use combined filter mode');\n                } else {\n                    alert('Please select both a manufacturer and location to use combined filter mode');\n                }\n            }\n        }\n    };\n    // Owner filter methods\n    const getAircraftOwnerType = (aircraft)=>{\n        const ownerType = aircraft.TYPE_REGISTRANT || 0;\n        return ownerTypeToString(ownerType);\n    };\n    const ownerTypeToString = (type)=>{\n        const typeNum = typeof type === 'string' ? parseInt(type, 10) : type;\n        const ownerTypeMap = {\n            1: 'individual',\n            2: 'partnership',\n            3: 'corp-owner',\n            4: 'co-owned',\n            7: 'llc',\n            8: 'non-citizen-corp',\n            9: 'airline',\n            10: 'freight',\n            11: 'medical',\n            12: 'media',\n            13: 'historical',\n            14: 'flying-club',\n            15: 'emergency',\n            16: 'local-govt',\n            17: 'education',\n            18: 'federal-govt',\n            19: 'flight-school',\n            20: 'leasing-corp',\n            21: 'military'\n        };\n        return ownerTypeMap[typeNum] || 'unknown';\n    };\n    const applyOwnerTypeFilter = (filters)=>{\n        // Skip filtering if all types are selected or none are selected\n        if (filters.length === 0 || filters.length === allOwnerTypes.length) {\n            return;\n        }\n        // Filter the aircraft based on selected owner types\n        if (displayedAircraft && displayedAircraft.length > 0) {\n            const filteredAircraft = displayedAircraft.filter((aircraft)=>{\n                const ownerType = getAircraftOwnerType(aircraft);\n                return filters.includes(ownerType);\n            });\n            // Update the displayed aircraft\n            if (clearGeofenceData) {\n                clearGeofenceData();\n            }\n            updateGeofenceAircraft(filteredAircraft);\n        }\n    };\n    const handleOwnerFilterChange = (updatedFilters)=>{\n        setOwnerFilters(updatedFilters);\n        // Apply the filter to your aircraft data\n        applyOwnerTypeFilter(updatedFilters);\n    };\n    const resetOwnerFilters = ()=>{\n        setOwnerFilters([\n            ...allOwnerTypes\n        ]);\n    };\n    // Region filter methods\n    const filterAircraftByRegion = (region)=>{\n        if (!displayedAircraft || displayedAircraft.length === 0) return;\n        setLocalLoading(true);\n        try {\n            // Get the bounds for the selected region\n            const boundsExpression = (0,_config_map__WEBPACK_IMPORTED_MODULE_9__.getBoundsByRegion)(region);\n            // Ensure bounds is in the correct format\n            if (!Array.isArray(boundsExpression) || boundsExpression.length !== 2) {\n                console.error(\"Invalid bounds format for region: \".concat(region), boundsExpression);\n                setLocalLoading(false);\n                return;\n            }\n            // Extract coordinates - Leaflet uses [lat, lng] format\n            const [[minLat, minLng], [maxLat, maxLng]] = boundsExpression;\n            console.log(\"Filtering by region: \".concat(region, \" with bounds:\"), {\n                minLat,\n                minLng,\n                maxLat,\n                maxLng\n            });\n            // Filter aircraft based on coordinates within the bounds\n            const filteredAircraft = displayedAircraft.filter((aircraft)=>{\n                // Check if aircraft has valid coordinates\n                if (typeof aircraft.latitude !== 'number' || typeof aircraft.longitude !== 'number' || isNaN(aircraft.latitude) || isNaN(aircraft.longitude)) {\n                    return false;\n                }\n                // Check if coordinates are within the bounds\n                return aircraft.latitude >= minLat && aircraft.latitude <= maxLat && aircraft.longitude >= minLng && aircraft.longitude <= maxLng;\n            });\n            // Update the display with filtered aircraft\n            if (clearGeofenceData) {\n                clearGeofenceData();\n            }\n            updateGeofenceAircraft(filteredAircraft);\n            console.log(\"Filtered to \".concat(filteredAircraft.length, \" aircraft in \").concat(region, \" region (out of \").concat(displayedAircraft.length, \" total)\"));\n        } catch (error) {\n            console.error('Error filtering aircraft by region:', error);\n        } finally{\n            setLocalLoading(false);\n        }\n    };\n    const handleRegionSelect = async (region)=>{\n        setActiveRegion(region);\n        setSelectedRegion(region);\n        setLocalLoading(true);\n        try {\n            // Set map bounds based on region\n            if (mapInstance) {\n                const bounds = (0,_config_map__WEBPACK_IMPORTED_MODULE_9__.getBoundsByRegion)(region);\n                // Get the appropriate zoom level for this region from your config\n                const zoomLevel = (0,_config_map__WEBPACK_IMPORTED_MODULE_9__.getZoomLevelForRegion)(region);\n                // First, set the appropriate zoom level\n                mapInstance.setZoom(zoomLevel);\n                // Then fit bounds with padding\n                const options = {\n                    padding: _config_map__WEBPACK_IMPORTED_MODULE_9__.MAP_CONFIG.PADDING.DEFAULT\n                };\n                mapInstance.fitBounds(bounds, options);\n                mapInstance.invalidateSize();\n                drawRegionOutline(region);\n            }\n            // Instead of immediately fetching aircraft data,\n            // just store the region selection for later use\n            console.log(\"Region selected. Waiting for manufacturer selection...\");\n            // Optionally, you could fetch just the count of aircraft in this region\n            // to give the user an idea of the data volume\n            const countResponse = await fetch(\"/api/tracking/region-count?region=\".concat(region));\n            if (countResponse.ok) {\n                const countData = await countResponse.json();\n                console.log(\"\".concat(countData.count, \" aircraft available in this region\"));\n            }\n            // Clear any previous aircraft data\n            if (clearGeofenceData) {\n                clearGeofenceData();\n            }\n        } catch (error) {\n            console.error('Error in region selection:', error);\n        } finally{\n            setLocalLoading(false);\n            setActiveDropdown(null);\n        }\n    };\n    const drawRegionOutline = (region)=>{\n        if (!mapInstance) return;\n        // Clear any existing outline\n        if (regionOutline) {\n            regionOutline.remove();\n        }\n        // Get the bounds for the selected region\n        const bounds = (0,_config_map__WEBPACK_IMPORTED_MODULE_9__.getBoundsByRegion)(region);\n        // Create a polygon from the bounds\n        const L = __webpack_require__(/*! leaflet */ \"(pages-dir-browser)/./node_modules/leaflet/dist/leaflet-src.js\");\n        const rectangle = L.rectangle(bounds, {\n            color: '#4f46e5',\n            weight: 3,\n            opacity: 0.7,\n            fill: true,\n            fillColor: '#4f46e5',\n            fillOpacity: 0.1,\n            dashArray: '5, 10',\n            interactive: false\n        });\n        // Add to map\n        rectangle.addTo(mapInstance);\n        // Update the state to include both the rectangle and the label\n        setRegionOutline({\n            remove: ()=>{\n                rectangle.remove();\n            }\n        });\n    };\n    // Geofence methods\n    // Fixed getUserLocation function\n    const getUserLocation = async ()=>{\n        if (isRateLimited) {\n            alert(\"Rate limited. Please wait \".concat(rateLimitTimer || 30, \" seconds before trying to get location.\"));\n            return;\n        }\n        setIsGettingLocation(true);\n        try {\n            const position = await getCurrentPosition();\n            if (position) {\n                const { latitude, longitude } = position.coords;\n                // Update state with coordinates\n                setGeofenceCoordinates({\n                    lat: latitude,\n                    lng: longitude\n                });\n                setGeofenceCenter({\n                    lat: latitude,\n                    lng: longitude\n                });\n                // Update the location display with coordinates\n                setGeofenceLocation(\"\".concat(latitude.toFixed(6), \", \").concat(longitude.toFixed(6)));\n                // Automatically trigger the geofence search\n                try {\n                    const fetchedAircraft = await (0,_lib_services_geofencing__WEBPACK_IMPORTED_MODULE_7__.getAircraftNearLocation)(latitude, longitude, geofenceRadius);\n                    if (fetchedAircraft.length === 0) {\n                        alert(\"No aircraft found near your current location. Try increasing the radius.\");\n                        setIsGettingLocation(false);\n                        return;\n                    }\n                    // Process the aircraft data\n                    const adaptedAircraft = (0,_lib_utils_geofenceAdapter__WEBPACK_IMPORTED_MODULE_5__.adaptGeofenceAircraft)(fetchedAircraft);\n                    const enrichedAircraft = await (0,_lib_utils_geofenceEnricher__WEBPACK_IMPORTED_MODULE_6__.enrichGeofenceAircraft)(adaptedAircraft);\n                    // Save to local state\n                    setGeofenceAircraft(enrichedAircraft);\n                    // Clear existing aircraft data\n                    if (clearGeofenceData) {\n                        clearGeofenceData();\n                    }\n                    // Update the map with new aircraft\n                    updateGeofenceAircraft(enrichedAircraft);\n                    setIsGeofenceActive(true);\n                    // Center the map on user's location - SIMPLIFIED ZOOM LOGIC\n                    if (mapInstance) {\n                        // Don't modify zoom if it's already at an appropriate level\n                        const currentZoom = mapInstance.getZoom();\n                        const targetZoom = currentZoom <= 7 ? 9 : currentZoom;\n                        // Set the view directly to the user's location\n                        mapInstance.setView([\n                            latitude,\n                            longitude\n                        ], targetZoom);\n                        // Make sure the map reflects changes\n                        mapInstance.invalidateSize();\n                    }\n                    // If in geofence mode, ensure the filter mode is set correctly\n                    if (filterMode !== 'geofence' && filterMode !== 'both') {\n                        setFilterMode('geofence');\n                    }\n                } catch (error) {\n                    var _error_message;\n                    if (((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes('rate limit')) || error.status === 429) {\n                        handleRateLimit(30);\n                        // Still update the location even if we couldn't get aircraft\n                        if (mapInstance) {\n                            mapInstance.setView([\n                                latitude,\n                                longitude\n                            ], 9);\n                            mapInstance.invalidateSize();\n                        }\n                    } else {\n                        throw error;\n                    }\n                }\n                // Close the dropdown after selection\n                setActiveDropdown(null);\n            }\n        } catch (error) {\n            console.error('Error getting user location:', error);\n            alert('Unable to access your location. Please make sure location services are enabled in your browser.');\n        } finally{\n            setIsGettingLocation(false);\n        }\n    };\n    const processGeofenceSearch = async ()=>{\n        if (!geofenceLocation) return;\n        // Check if rate limited\n        if (isRateLimited) {\n            alert(\"Rate limited. Please wait \".concat(rateLimitTimer || 30, \" seconds before searching again.\"));\n            return;\n        }\n        // Block API calls while doing geofence search in combined mode\n        if (filterMode === 'both') {\n            _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].setBlockAllApiCalls(true);\n            setBlockManufacturerApiCalls(true);\n        }\n        // Set loading state\n        setLocalLoading(true);\n        try {\n            console.log('Searching for aircraft near location: \"'.concat(geofenceLocation, '\"'));\n            // This will handle Postal codes, place names, addresses, POIs, etc.\n            let fetchedAircraft;\n            try {\n                fetchedAircraft = await (0,_lib_services_geofencing__WEBPACK_IMPORTED_MODULE_7__.getAircraftNearSearchedLocation)(geofenceLocation, geofenceRadius);\n            } catch (error) {\n                var _error_message;\n                if (((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes('rate limit')) || error.status === 429) {\n                    const retryAfter = 30; // Default to 30 seconds if not specified\n                    handleRateLimit(retryAfter);\n                    setLocalLoading(false);\n                    return;\n                }\n                throw error;\n            }\n            // Get coordinates for the map\n            let locations;\n            try {\n                locations = await _lib_services_MapboxService__WEBPACK_IMPORTED_MODULE_4__.MapboxService.searchLocationWithMapbox(geofenceLocation, 1);\n            } catch (error) {\n                console.error('Error searching location with Mapbox:', error);\n                // Continue with aircraft data if available\n                locations = [];\n            }\n            let coordinates = null;\n            if (locations.length > 0) {\n                coordinates = {\n                    lat: locations[0].lat,\n                    lng: locations[0].lng\n                };\n                // Save the formatted location name\n                setGeofenceLocation(locations[0].name);\n            } else if (fetchedAircraft.length > 0 && fetchedAircraft[0].latitude && fetchedAircraft[0].longitude) {\n                // Fallback to first aircraft position\n                coordinates = {\n                    lat: fetchedAircraft[0].latitude,\n                    lng: fetchedAircraft[0].longitude\n                };\n            }\n            if (fetchedAircraft.length === 0) {\n                alert(\"No aircraft found near \".concat(geofenceLocation, \". Try increasing the radius or searching in a different area.\"));\n                setLocalLoading(false);\n                return;\n            }\n            // Update state with the coordinates\n            if (coordinates) {\n                setGeofenceCoordinates(coordinates);\n                setGeofenceCenter(coordinates);\n                setGeofenceRadius(geofenceRadius);\n            }\n            if (!isGeofenceActive) {\n                toggleGeofence();\n            } else if (!coordinates) {\n                throw new Error('Could not determine coordinates for the location');\n            }\n            console.log(\"Found \".concat(fetchedAircraft.length, \" aircraft in the area, preparing for display...\"));\n            // Ensure the data is in the right format\n            const adaptedAircraft = fetchedAircraft[0].MANUFACTURER !== undefined ? fetchedAircraft // Already in the right format\n             : (0,_lib_utils_geofenceAdapter__WEBPACK_IMPORTED_MODULE_5__.adaptGeofenceAircraft)(fetchedAircraft); // Needs adaptation\n            // Enrich with static data\n            console.log('Enriching geofence aircraft with static data...');\n            const enrichedAircraft = await (0,_lib_utils_geofenceEnricher__WEBPACK_IMPORTED_MODULE_6__.enrichGeofenceAircraft)(adaptedAircraft);\n            // Save the FULL set to local state\n            setGeofenceAircraft(enrichedAircraft);\n            setIsGeofenceActive(true);\n            // Clear existing aircraft data\n            if (clearGeofenceData) {\n                clearGeofenceData();\n            }\n            // If we're in combined mode and have a manufacturer, apply the combined filter\n            if (filterMode === 'both' && selectedManufacturer) {\n                // Make sure API calls remain blocked\n                _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].setBlockAllApiCalls(true);\n                setBlockManufacturerApiCalls(true);\n                setTimeout(()=>{\n                    applyCombinedFilters();\n                }, 100);\n            } else {\n                // Just show all aircraft in the geofence\n                updateGeofenceAircraft(enrichedAircraft);\n                // Center the map - SIMPLIFIED ZOOM LOGIC\n                if (mapInstance && coordinates) {\n                    // Get current zoom level\n                    const currentZoom = mapInstance.getZoom();\n                    // Use appropriate zoom level based on current view\n                    const targetZoom = currentZoom <= 7 ? 9 : currentZoom;\n                    // Set view to the coordinates\n                    mapInstance.setView([\n                        coordinates.lat,\n                        coordinates.lng\n                    ], targetZoom);\n                    // Ensure map is updated\n                    mapInstance.invalidateSize();\n                }\n            }\n            // Close dropdown after search\n            setActiveDropdown(null);\n        } catch (error) {\n            var _error_message1;\n            console.error('Error in geofence search:', error);\n            if (((_error_message1 = error.message) === null || _error_message1 === void 0 ? void 0 : _error_message1.includes('rate limit')) || error.status === 429) {\n                handleRateLimit(30);\n            } else {\n                alert(\"Error: \".concat(error instanceof Error ? error.message : 'Unknown error occurred'));\n            }\n        } finally{\n            setLocalLoading(false);\n        }\n    };\n    /**\r\n   * STEP 3: Fix toggleGeofenceState to better handle manually clicking the button\r\n   */ const toggleGeofenceState = (enabled)=>{\n        console.log('toggleGeofenceState called with:', enabled);\n        console.log('Current geofenceCoordinates:', geofenceCoordinates);\n        if (enabled) {\n            // Check if we have valid coordinates\n            if (geofenceCoordinates && typeof geofenceCoordinates.lat === 'number' && typeof geofenceCoordinates.lng === 'number' && !isNaN(geofenceCoordinates.lat) && !isNaN(geofenceCoordinates.lng)) {\n                console.log('Valid coordinates found, enabling geofence');\n                // Set flags first\n                setGeofenceEnabled(true);\n                setIsGeofenceActive(true);\n                // Call context toggle function if available\n                if (typeof toggleGeofence === 'function') {\n                    toggleGeofence();\n                }\n                // Display aircraft if we have them\n                if (geofenceAircraft && geofenceAircraft.length > 0) {\n                    console.log(\"Showing \".concat(geofenceAircraft.length, \" aircraft in geofence\"));\n                    updateGeofenceAircraft(geofenceAircraft);\n                } else {\n                    // No aircraft data yet, trigger a search\n                    console.log('No aircraft data yet, triggering search');\n                    setTimeout(()=>{\n                        processGeofenceSearch();\n                    }, 100);\n                }\n            } else {\n                // No valid coordinates\n                console.warn('No valid coordinates, showing alert');\n                alert('Please set a location before enabling geofence.\\n\\nClick anywhere on the map to set a location.');\n                setGeofenceEnabled(false);\n                setIsGeofenceActive(false);\n            }\n        } else {\n            // Disabling geofence\n            console.log('Disabling geofence');\n            setGeofenceEnabled(false);\n            setIsGeofenceActive(false);\n            // Clear geofence data if function available\n            if (typeof clearGeofenceData === 'function') {\n                clearGeofenceData();\n            }\n        }\n    };\n    // Manufacturer filter methods\n    const selectManufacturerAndClose = (value)=>{\n        // Close dropdown\n        setActiveDropdown(null);\n        setManufacturerSearchTerm('');\n        // If clearing the selection\n        if (value === '') {\n            selectManufacturer(null);\n            return;\n        }\n        // Set the manufacturer selection\n        selectManufacturer(value);\n        // If region is already selected, fetch filtered data\n        if (activeRegion !== null) {\n            fetchAircraftByRegionAndManufacturer(activeRegion, value);\n        } else {\n            // Otherwise, just proceed with manufacturer-only filtering as before\n            fetchManufacturerData(value);\n        }\n    };\n    const fetchManufacturerData = (manufacturer)=>{\n        if (isRateLimited) {\n            console.log(\"Skipping data fetch - rate limited for \".concat(rateLimitTimer, \"s\"));\n            return;\n        }\n        console.log(\"Fetching data for manufacturer: \".concat(manufacturer));\n        try {\n            // If you have a context function for this, call it after a slight delay\n            if (typeof refreshPositions === 'function') {\n                // Apply a small delay to prevent overwhelming the API\n                setTimeout(()=>{\n                    refreshPositions().catch((error)=>{\n                        var _error_message;\n                        if (((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes('rate limit')) || error.status === 429) {\n                            handleRateLimit(30);\n                        } else {\n                            console.error('Error fetching manufacturer data:', error);\n                        }\n                    });\n                }, 200);\n            }\n        } catch (error) {\n            var _error_message;\n            if (((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes('rate limit')) || error.status === 429) {\n                handleRateLimit(30);\n            } else {\n                console.error('Error scheduling manufacturer data fetch:', error);\n            }\n        }\n    };\n    const fetchAircraftByRegionAndManufacturer = async function(region, manufacturer) {\n        let page = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, limit = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 500;\n        if (!region || !manufacturer) {\n            console.log('Both region and manufacturer must be selected');\n            return;\n        }\n        setLocalLoading(true);\n        try {\n            const response = await fetch(\"/api/tracking/filtered-aircraft?region=\".concat(region, \"&manufacturer=\").concat(encodeURIComponent(manufacturer), \"&page=\").concat(page, \"&limit=\").concat(limit));\n            const data = await response.json();\n            const aircraftData = data.aircraft || [];\n            if (!response.ok) {\n                throw new Error(\"API error: \".concat(response.statusText));\n            }\n            // Process the filtered aircraft data\n            if (aircraftData.length > 0) {\n                const extendedAircraft = aircraftData.map((aircraft)=>{\n                    var _aircraft_OPERATOR;\n                    var _aircraft_OPERATOR_toLowerCase_includes;\n                    return {\n                        ...aircraft,\n                        type: aircraft.TYPE_AIRCRAFT || 'Unknown',\n                        isGovernment: (_aircraft_OPERATOR_toLowerCase_includes = (_aircraft_OPERATOR = aircraft.OPERATOR) === null || _aircraft_OPERATOR === void 0 ? void 0 : _aircraft_OPERATOR.toLowerCase().includes('government')) !== null && _aircraft_OPERATOR_toLowerCase_includes !== void 0 ? _aircraft_OPERATOR_toLowerCase_includes : false,\n                        REGION: aircraft.REGION,\n                        zoomLevel: undefined\n                    };\n                });\n                // Update the map\n                updateGeofenceAircraft(extendedAircraft);\n            } else {\n                console.log(\"No aircraft found for manufacturer \".concat(manufacturer, \" in region \").concat(region));\n            }\n        } catch (error) {\n            console.error('Error fetching filtered aircraft:', error);\n        } finally{\n            setLocalLoading(false);\n        }\n    };\n    // Model selection methods\n    const handleModelSelect = (value)=>{\n        selectModel(value === '' ? null : value);\n        setActiveDropdown(null);\n        // If in combined mode, reapply the filter\n        if (filterMode === 'both' && isGeofenceActive && selectedManufacturer) {\n            setTimeout(()=>{\n                applyCombinedFilters();\n            }, 100);\n        }\n    };\n    // Combined filter methods\n    const applyCombinedFilters = ()=>{\n        if (!selectedManufacturer || !isGeofenceActive || geofenceAircraft.length === 0) {\n            return;\n        }\n        setLocalLoading(true);\n        try {\n            console.log(\"Filtering \".concat(geofenceAircraft.length, \" aircraft by \").concat(selectedManufacturer));\n            // Filter the aircraft by manufacturer\n            let filteredAircraft = geofenceAircraft.filter((aircraft)=>{\n                var _aircraft_MANUFACTURER;\n                return ((_aircraft_MANUFACTURER = aircraft.MANUFACTURER) === null || _aircraft_MANUFACTURER === void 0 ? void 0 : _aircraft_MANUFACTURER.toLowerCase()) === selectedManufacturer.toLowerCase();\n            });\n            // Further filter by model if selected\n            if (selectedModel) {\n                filteredAircraft = filteredAircraft.filter((aircraft)=>{\n                    var _aircraft_MODEL;\n                    return ((_aircraft_MODEL = aircraft.MODEL) === null || _aircraft_MODEL === void 0 ? void 0 : _aircraft_MODEL.toLowerCase()) === selectedModel.toLowerCase();\n                });\n            }\n            console.log(\"Found \".concat(filteredAircraft.length, \" matching aircraft\"));\n            if (filteredAircraft.length === 0) {\n                alert(\"No \".concat(selectedManufacturer, \" aircraft found in this area.\"));\n                return;\n            }\n            // Clear display data\n            if (clearGeofenceData) {\n                clearGeofenceData();\n            }\n            // Update the display\n            updateGeofenceAircraft(filteredAircraft);\n        } catch (error) {\n            console.error('Error filtering aircraft:', error);\n        } finally{\n            setLocalLoading(false);\n        }\n    };\n    // Reset all filters\n    const clearAllFilters = ()=>{\n        console.log('Clearing all filters...');\n        // 1. Reset filter mode\n        setFilterMode('manufacturer');\n        // 2. Unblock API calls that might have been blocked\n        _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].setBlockAllApiCalls(false);\n        setBlockManufacturerApiCalls(false);\n        setIsManufacturerApiBlocked(false);\n        // 3. Clear manufacturer selection\n        selectManufacturer(null);\n        selectModel(null);\n        // 4. Clear geofence\n        setGeofenceLocation('');\n        setGeofenceCoordinates(null);\n        setGeofenceAircraft([]);\n        setGeofenceEnabled(false);\n        setIsGeofenceActive(false);\n        if (typeof clearGeofence === 'function') {\n            clearGeofence();\n        }\n        if (typeof clearGeofenceData === 'function') {\n            clearGeofenceData();\n        }\n        // 5. Reset owner filters to select all\n        setOwnerFilters([\n            ...allOwnerTypes\n        ]);\n        // 6. Clear region filter properly\n        setActiveRegion(null);\n        setSelectedRegion(_types_base__WEBPACK_IMPORTED_MODULE_1__.RegionCode.GLOBAL);\n        // Clear region outline from map\n        if (regionOutline) {\n            try {\n                // Handle different possible object structures\n                if (typeof regionOutline.remove === 'function') {\n                    regionOutline.remove();\n                } else if (regionOutline.rectangle && typeof regionOutline.rectangle.remove === 'function') {\n                    regionOutline.rectangle.remove();\n                }\n                // Clear any labels associated with the region\n                if (regionOutline.label && typeof regionOutline.label.remove === 'function') {\n                    regionOutline.label.remove();\n                }\n            } catch (error) {\n                console.error('Error removing region outline:', error);\n            }\n            // Always reset the region outline state\n            setRegionOutline(null);\n        }\n        // 7. Reset map view to global\n        if (mapInstance) {\n            // Use the predefined center and zoom level from your map config\n            mapInstance.setView(_config_map__WEBPACK_IMPORTED_MODULE_9__.MAP_CONFIG.CENTER, _config_map__WEBPACK_IMPORTED_MODULE_9__.MAP_CONFIG.DEFAULT_ZOOM);\n            mapInstance.invalidateSize();\n        }\n        // 8. Reset to initial aircraft data\n        if (typeof reset === 'function') {\n            reset();\n        } else if (typeof fullRefresh === 'function') {\n            fullRefresh();\n        }\n        // 9. Close any open dropdown\n        setActiveDropdown(null);\n        // 10. Reset rate limiting states\n        setIsRateLimited(false);\n        setRateLimitTimer(null);\n        // 11. Clear combined mode state\n        setCombinedModeReady(false);\n        // 12. Reset search terms\n        setManufacturerSearchTerm('');\n        // 13. Dispatch a custom event that other components can listen for\n        const clearEvent = new CustomEvent('ribbon-filters-cleared');\n        document.dispatchEvent(clearEvent);\n        console.log('All filters cleared successfully');\n    };\n    // Calculate combined loading state\n    const combinedLoading = localLoading;\n    return {\n        // State\n        filterMode,\n        activeDropdown,\n        selectedManufacturer,\n        selectedModel,\n        geofenceLocation,\n        geofenceRadius,\n        isGeofenceActive,\n        geofenceCoordinates,\n        activeRegion,\n        ownerFilters,\n        allOwnerTypes,\n        manufacturerSearchTerm,\n        combinedLoading,\n        isGettingLocation,\n        dropdownRefs,\n        localLoading,\n        isRateLimited,\n        selectedRegion,\n        isRefreshing,\n        isGeofencePlacementMode: false,\n        // Methods\n        toggleDropdown,\n        toggleFilterMode,\n        selectManufacturerAndClose,\n        handleModelSelect,\n        getUserLocation,\n        processGeofenceSearch,\n        handleOwnerFilterChange,\n        handleRegionSelect,\n        setManufacturerSearchTerm,\n        setGeofenceLocation,\n        setGeofenceRadius,\n        toggleGeofenceState,\n        clearAllFilters,\n        applyCombinedFilters,\n        getAircraftOwnerType,\n        refreshWithFilters: ()=>{\n            // Implement refresh logic here\n            if (typeof refreshPositions === 'function') {\n                refreshPositions().catch((error)=>{\n                    console.error('Error refreshing positions:', error);\n                });\n            }\n        },\n        setActiveDropdown,\n        setGeofenceCoordinates,\n        setGeofenceCenter,\n        updateGeofenceAircraft\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvdHJhY2tpbmcvaG9va3MvdXNlRmlsdGVyTG9naWMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQW9EO0FBQzFCO0FBQ2dCO0FBRTRCO0FBQ0s7QUFDUDtBQUNBO0FBQ0U7QUFJNUI7QUFDZTtBQUs1QjtBQVd0QixTQUFTZ0I7SUFDZCxrQ0FBa0M7SUFDbEMsTUFBTSxFQUNKQyxvQkFBb0IsRUFDcEJDLGFBQWEsRUFDYkMsV0FBVyxFQUNYQyxrQkFBa0IsRUFDbEJDLFdBQVcsRUFDWEMsS0FBSyxFQUNMQyxXQUFXLEVBQ1hDLGdCQUFnQixFQUNoQkMsV0FBVyxFQUNYQyxrQkFBa0IsRUFDbEJDLGlCQUFpQixFQUNqQkMsc0JBQXNCLEVBQ3RCQyx5QkFBeUIsRUFDekJDLDRCQUE0QixFQUM1QkMsd0JBQXdCLEVBQ3hCQywyQkFBMkIsRUFDM0JDLGNBQWMsRUFDZEMsaUJBQWlCLEVBQ2pCQyxjQUFjLEVBQ2RDLGFBQWEsRUFDYkMsaUJBQWlCLEVBQ2xCLEdBQUdoQyxrRkFBcUJBO0lBRXpCLHVCQUF1QjtJQUN2QixNQUFNLEVBQUVpQyxrQkFBa0IsRUFBRSxHQUFHMUIscUVBQWNBO0lBRTdDLGNBQWM7SUFDZCxNQUFNLENBQUMyQixjQUFjQyxnQkFBZ0IsR0FBR3hDLCtDQUFRQSxDQUFDO0lBQ2pELE1BQU0sQ0FBQ3lDLFlBQVlDLGNBQWMsR0FBRzFDLCtDQUFRQSxDQUFvQjtJQUNoRSxNQUFNLENBQUMyQyxnQkFBZ0JDLGtCQUFrQixHQUFHNUMsK0NBQVFBLENBQWdCO0lBQ3BFLE1BQU0sQ0FBQzZDLHdCQUF3QkMsMEJBQTBCLEdBQUc5QywrQ0FBUUEsQ0FBQztJQUNyRSxNQUFNLENBQUMrQyxjQUFjQyxnQkFBZ0IsR0FBR2hELCtDQUFRQSxDQUFDO0lBQ2pELE1BQU0sQ0FBQ2lELGVBQWVDLGlCQUFpQixHQUFHbEQsK0NBQVFBLENBQUM7SUFDbkQsTUFBTSxDQUFDbUQsZ0JBQWdCQyxrQkFB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QUNBbU0seUJBQXlCO1FBRXpCLFVBQVU7UUFDVjNIO1FBQ0FRO1FBQ0FzRjtRQUNBbUI7UUFDQTFDO1FBQ0FZO1FBQ0FuRDtRQUNBVTtRQUNBbkg7UUFDQVk7UUFDQUU7UUFDQXNKO1FBQ0F3QjtRQUNBN0Y7UUFDQUQ7UUFFQXVHLG9CQUFvQjtZQUNsQiwrQkFBK0I7WUFDL0IsSUFBSSxPQUFPM04scUJBQXFCLFlBQVk7Z0JBQzFDQSxtQkFBbUJpTSxLQUFLLENBQUMsQ0FBQ25HO29CQUN4QnpCLFFBQVF5QixLQUFLLENBQUMsK0JBQStCQTtnQkFDL0M7WUFDRjtRQUNGO1FBQ0ExRTtRQUVBa0I7UUFDQTVCO1FBQ0FOO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxzYXRob1xcRG9jdW1lbnRzXFxQcm9qZWN0c1xcYWlyY3JhZnQtdHJhY2tpbmdcXGNvbXBvbmVudHNcXHRyYWNraW5nXFxob29rc1xcdXNlRmlsdGVyTG9naWMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlU3RhdGUsIHVzZVJlZiwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyBSZWdpb25Db2RlIH0gZnJvbSAnQC90eXBlcy9iYXNlJztcclxuaW1wb3J0IHR5cGUgeyBFeHRlbmRlZEFpcmNyYWZ0IH0gZnJvbSAnQC90eXBlcy9iYXNlJztcclxuaW1wb3J0IHsgdXNlRW5oYW5jZWRNYXBDb250ZXh0IH0gZnJvbSAnLi4vY29udGV4dC9FbmhhbmNlZE1hcENvbnRleHQnO1xyXG5pbXBvcnQgb3BlblNreVRyYWNraW5nU2VydmljZSBmcm9tICdAL2xpYi9zZXJ2aWNlcy9vcGVuU2t5VHJhY2tpbmdTZXJ2aWNlJztcclxuaW1wb3J0IHsgTWFwYm94U2VydmljZSB9IGZyb20gJy4uLy4uLy4uL2xpYi9zZXJ2aWNlcy9NYXBib3hTZXJ2aWNlJztcclxuaW1wb3J0IHsgYWRhcHRHZW9mZW5jZUFpcmNyYWZ0IH0gZnJvbSAnQC9saWIvdXRpbHMvZ2VvZmVuY2VBZGFwdGVyJztcclxuaW1wb3J0IHsgZW5yaWNoR2VvZmVuY2VBaXJjcmFmdCB9IGZyb20gJ0AvbGliL3V0aWxzL2dlb2ZlbmNlRW5yaWNoZXInO1xyXG5pbXBvcnQge1xyXG4gIGdldEFpcmNyYWZ0TmVhckxvY2F0aW9uLFxyXG4gIGdldEFpcmNyYWZ0TmVhclNlYXJjaGVkTG9jYXRpb24sXHJcbn0gZnJvbSAnLi4vLi4vLi4vbGliL3NlcnZpY2VzL2dlb2ZlbmNpbmcnO1xyXG5pbXBvcnQgeyB1c2VHZW9sb2NhdGlvbiB9IGZyb20gJy4uL2hvb2tzL3VzZUdlb2xvY2F0aW9uJztcclxuaW1wb3J0IHtcclxuICBNQVBfQ09ORklHLFxyXG4gIGdldEJvdW5kc0J5UmVnaW9uLFxyXG4gIGdldFpvb21MZXZlbEZvclJlZ2lvbixcclxufSBmcm9tICcuLi8uLi8uLi9jb25maWcvbWFwJztcclxuXHJcbnR5cGUgTWFwR2VvZmVuY2VDbGlja0V2ZW50ID0gQ3VzdG9tRXZlbnQ8eyBsYXQ6IG51bWJlcjsgbG5nOiBudW1iZXIgfT47XHJcblxyXG5leHBvcnQgdHlwZSBGaWx0ZXJNb2RlID1cclxuICB8ICdtYW51ZmFjdHVyZXInXHJcbiAgfCAnZ2VvZmVuY2UnXHJcbiAgfCAnYm90aCdcclxuICB8ICdvd25lcidcclxuICB8ICdyZWdpb24nO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUZpbHRlckxvZ2ljKCkge1xyXG4gIC8vIEdldCBjb250ZXh0IHN0YXRlIGFuZCBmdW5jdGlvbnNcclxuICBjb25zdCB7XHJcbiAgICBzZWxlY3RlZE1hbnVmYWN0dXJlcixcclxuICAgIHNlbGVjdGVkTW9kZWwsXHJcbiAgICB0b3RhbEFjdGl2ZSxcclxuICAgIHNlbGVjdE1hbnVmYWN0dXJlcixcclxuICAgIHNlbGVjdE1vZGVsLFxyXG4gICAgcmVzZXQsXHJcbiAgICBmdWxsUmVmcmVzaCxcclxuICAgIHJlZnJlc2hQb3NpdGlvbnMsXHJcbiAgICBtYXBJbnN0YW5jZSxcclxuICAgIHVwZGF0ZUFpcmNyYWZ0RGF0YSxcclxuICAgIGNsZWFyR2VvZmVuY2VEYXRhLFxyXG4gICAgdXBkYXRlR2VvZmVuY2VBaXJjcmFmdCxcclxuICAgIGJsb2NrTWFudWZhY3R1cmVyQXBpQ2FsbHMsXHJcbiAgICBzZXRCbG9ja01hbnVmYWN0dXJlckFwaUNhbGxzLFxyXG4gICAgaXNNYW51ZmFjdHVyZXJBcGlCbG9ja2VkLFxyXG4gICAgc2V0SXNNYW51ZmFjdHVyZXJBcGlCbG9ja2VkLFxyXG4gICAgZ2VvZmVuY2VDZW50ZXIsXHJcbiAgICBzZXRHZW9mZW5jZUNlbnRlcixcclxuICAgIHRvZ2dsZUdlb2ZlbmNlLFxyXG4gICAgY2xlYXJHZW9mZW5jZSxcclxuICAgIGRpc3BsYXllZEFpcmNyYWZ0LFxyXG4gIH0gPSB1c2VFbmhhbmNlZE1hcENvbnRleHQoKTtcclxuXHJcbiAgLy8gR2V0IGdlb2xvY2F0aW9uIGhvb2tcclxuICBjb25zdCB7IGdldEN1cnJlbnRQb3NpdGlvbiB9ID0gdXNlR2VvbG9jYXRpb24oKTtcclxuXHJcbiAgLy8gTG9jYWwgc3RhdGVcclxuICBjb25zdCBbbG9jYWxMb2FkaW5nLCBzZXRMb2NhbExvYWRpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gIGNvbnN0IFtmaWx0ZXJNb2RlLCBzZXRGaWx0ZXJNb2RlXSA9IHVzZVN0YXRlPEZpbHRlck1vZGUgfCBudWxsPihudWxsKTtcclxuICBjb25zdCBbYWN0aXZlRHJvcGRvd24sIHNldEFjdGl2ZURyb3Bkb3duXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xyXG4gIGNvbnN0IFttYW51ZmFjdHVyZXJTZWFyY2hUZXJtLCBzZXRNYW51ZmFjdHVyZXJTZWFyY2hUZXJtXSA9IHVzZVN0YXRlKCcnKTtcclxuICBjb25zdCBbaXNSZWZyZXNoaW5nLCBzZXRJc1JlZnJlc2hpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gIGNvbnN0IFtpc1JhdGVMaW1pdGVkLCBzZXRJc1JhdGVMaW1pdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICBjb25zdCBbcmF0ZUxpbWl0VGltZXIsIHNldFJhdGVMaW1pdFRpbWVyXSA9IHVzZVN0YXRlPG51bWJlciB8IG51bGw+KG51bGwpO1xyXG4gIGNvbnN0IFtpc0dlb2ZlbmNlUGFuZWxPcGVuLCBzZXRJc0dlb2ZlbmNlUGFuZWxPcGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuXHJcbiAgLy8gR2VvZmVuY2Ugc3RhdGVcclxuICBjb25zdCBbaXNHZXR0aW5nTG9jYXRpb24sIHNldElzR2V0dGluZ0xvY2F0aW9uXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICBjb25zdCBbZ2VvZmVuY2VMb2NhdGlvbiwgc2V0R2VvZmVuY2VMb2NhdGlvbl0gPSB1c2VTdGF0ZTxzdHJpbmc+KCcnKTtcclxuICBjb25zdCBbZ2VvZmVuY2VSYWRpdXMsIHNldEdlb2ZlbmNlUmFkaXVzXSA9IHVzZVN0YXRlPG51bWJlcj4oMjUpO1xyXG4gIGNvbnN0IFtnZW9mZW5jZUNvb3JkaW5hdGVzLCBzZXRHZW9mZW5jZUNvb3JkaW5hdGVzXSA9IHVzZVN0YXRlPHtcclxuICAgIGxhdDogbnVtYmVyO1xyXG4gICAgbG5nOiBudW1iZXI7XHJcbiAgfSB8IG51bGw+KG51bGwpO1xyXG4gIGNvbnN0IFtnZW9mZW5jZUFpcmNyYWZ0LCBzZXRHZW9mZW5jZUFpcmNyYWZ0XSA9IHVzZVN0YXRlPEV4dGVuZGVkQWlyY3JhZnRbXT4oXHJcbiAgICBbXVxyXG4gICk7XHJcbiAgY29uc3QgW2dlb2ZlbmNlRW5hYmxlZCwgc2V0R2VvZmVuY2VFbmFibGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICBjb25zdCBbaXNHZW9mZW5jZUFjdGl2ZSwgc2V0SXNHZW9mZW5jZUFjdGl2ZV0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgY29uc3QgW2lzU2VhcmNoUmVhZHksIHNldElzU2VhcmNoUmVhZHldID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xyXG5cclxuICAvLyBSZWdpb24gc3RhdGVcclxuICBjb25zdCBbYWN0aXZlUmVnaW9uLCBzZXRBY3RpdmVSZWdpb25dID0gdXNlU3RhdGU8UmVnaW9uQ29kZSB8IHN0cmluZyB8IG51bGw+KFxyXG4gICAgbnVsbFxyXG4gICk7XHJcbiAgY29uc3QgW3JlZ2lvbk91dGxpbmUsIHNldFJlZ2lvbk91dGxpbmVdID0gdXNlU3RhdGU8YW55PihudWxsKTtcclxuICBjb25zdCBbc2VsZWN0ZWRSZWdpb24sIHNldFNlbGVjdGVkUmVnaW9uXSA9IHVzZVN0YXRlPG51bWJlcj4oXHJcbiAgICBSZWdpb25Db2RlLkdMT0JBTFxyXG4gICk7XHJcblxyXG4gIC8vIENvbWJpbmVkIG1vZGUgc3RhdGVcclxuICBjb25zdCBbY29tYmluZWRNb2RlUmVhZHksIHNldENvbWJpbmVkTW9kZVJlYWR5XSA9IHVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKTtcclxuXHJcbiAgLy8gT3duZXIgZmlsdGVyIHN0YXRlXHJcbiAgY29uc3QgYWxsT3duZXJUeXBlcyA9IFtcclxuICAgICdpbmRpdmlkdWFsJyxcclxuICAgICdwYXJ0bmVyc2hpcCcsXHJcbiAgICAnY29ycC1vd25lcicsXHJcbiAgICAnY28tb3duZWQnLFxyXG4gICAgJ2xsYycsXHJcbiAgICAnbm9uLWNpdGl6ZW4tY29ycCcsXHJcbiAgICAnYWlybGluZScsXHJcbiAgICAnZnJlaWdodCcsXHJcbiAgICAnbWVkaWNhbCcsXHJcbiAgICAnbWVkaWEnLFxyXG4gICAgJ2hpc3RvcmljYWwnLFxyXG4gICAgJ2ZseWluZy1jbHViJyxcclxuICAgICdlbWVyZ2VuY3knLFxyXG4gICAgJ2xvY2FsLWdvdnQnLFxyXG4gICAgJ2VkdWNhdGlvbicsXHJcbiAgICAnZmVkZXJhbC1nb3Z0JyxcclxuICAgICdmbGlnaHQtc2Nob29sJyxcclxuICAgICdsZWFzaW5nLWNvcnAnLFxyXG4gICAgJ21pbGl0YXJ5JyxcclxuICAgICd1bmtub3duJyxcclxuICBdO1xyXG5cclxuICBjb25zdCBbb3duZXJGaWx0ZXJzLCBzZXRPd25lckZpbHRlcnNdID0gdXNlU3RhdGU8c3RyaW5nW10+KFtcclxuICAgIC4uLmFsbE93bmVyVHlwZXMsXHJcbiAgXSk7XHJcblxyXG4gIC8vIFJlZnMgZm9yIGRyb3Bkb3duIGhhbmRsaW5nXHJcbiAgY29uc3QgZHJvcGRvd25SZWZzID0ge1xyXG4gICAgZmlsdGVyOiB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpLFxyXG4gICAgbWFudWZhY3R1cmVyOiB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpLFxyXG4gICAgbW9kZWw6IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCksXHJcbiAgICBsb2NhdGlvbjogdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKSxcclxuICAgIHJlZ2lvbjogdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKSxcclxuICAgIG93bmVyOiB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpLFxyXG4gICAgYWN0aW9uczogdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKSxcclxuICB9O1xyXG5cclxuICAvLyBFZmZlY3RzXHJcblxyXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAoZ2VvZmVuY2VDb29yZGluYXRlcykge1xyXG4gICAgICBzZXRJc1NlYXJjaFJlYWR5KHRydWUpO1xyXG4gICAgfVxyXG4gIH0sIFtnZW9mZW5jZUNvb3JkaW5hdGVzXSk7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAoaXNSYXRlTGltaXRlZCAmJiByYXRlTGltaXRUaW1lcikge1xyXG4gICAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgIHNldElzUmF0ZUxpbWl0ZWQoZmFsc2UpO1xyXG4gICAgICAgIHNldFJhdGVMaW1pdFRpbWVyKG51bGwpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdSYXRlIGxpbWl0IHRpbWVyIGV4cGlyZWQsIHJlc3VtaW5nIEFQSSBjYWxscycpO1xyXG4gICAgICB9LCByYXRlTGltaXRUaW1lciAqIDEwMDApO1xyXG5cclxuICAgICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dCh0aW1lcik7XHJcbiAgICB9XHJcbiAgfSwgW2lzUmF0ZUxpbWl0ZWQsIHJhdGVMaW1pdFRpbWVyXSk7XHJcblxyXG4gIC8vIEVmZmVjdCB0byBzeW5jIGdlb2ZlbmNlIHN0YXRlXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIC8vIFVwZGF0ZSBpbnRlcm5hbCBzdGF0ZSB3aGVuIGdlb2ZlbmNlIGlzIHRvZ2dsZWQgZXh0ZXJuYWxseVxyXG4gICAgaWYgKGlzR2VvZmVuY2VBY3RpdmUgIT09IGdlb2ZlbmNlRW5hYmxlZCkge1xyXG4gICAgICBzZXRHZW9mZW5jZUVuYWJsZWQoaXNHZW9mZW5jZUFjdGl2ZSk7XHJcbiAgICB9XHJcbiAgfSwgW2lzR2VvZmVuY2VBY3RpdmVdKTtcclxuXHJcbiAgLy8gQ2xvc2UgZHJvcGRvd24gd2hlbiBjbGlja2luZyBvdXRzaWRlXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGNvbnN0IGhhbmRsZUNsaWNrT3V0c2lkZSA9IChldmVudDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAvLyBDaGVjayBpZiBjbGljayBpcyBvdXRzaWRlIG9mIGFsbCBkcm9wZG93bnNcclxuICAgICAgY29uc3QgaXNPdXRzaWRlQWxsID0gT2JqZWN0LnZhbHVlcyhkcm9wZG93blJlZnMpLmV2ZXJ5KFxyXG4gICAgICAgIChyZWYpID0+ICFyZWYuY3VycmVudCB8fCAhcmVmLmN1cnJlbnQuY29udGFpbnMoZXZlbnQudGFyZ2V0IGFzIE5vZGUpXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBpZiAoaXNPdXRzaWRlQWxsKSB7XHJcbiAgICAgICAgc2V0QWN0aXZlRHJvcGRvd24obnVsbCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgaGFuZGxlQ2xpY2tPdXRzaWRlKTtcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGhhbmRsZUNsaWNrT3V0c2lkZSk7XHJcbiAgICB9O1xyXG4gIH0sIFtdKTtcclxuXHJcbiAgLy8gQ2xlYW4gdXAgcmVnaW9uIG91dGxpbmUgd2hlbiBjb21wb25lbnQgdW5tb3VudHNcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgaWYgKHJlZ2lvbk91dGxpbmUpIHtcclxuICAgICAgICByZWdpb25PdXRsaW5lLnJlbW92ZSgpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH0sIFtyZWdpb25PdXRsaW5lXSk7XHJcblxyXG4gIC8vIEVmZmVjdCB0byBoYW5kbGUgbWFwIGNsaWNrIGZvciBnZW9mZW5jZVxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBjb25zdCBoYW5kbGVNYXBHZW9mZW5jZUNsaWNrID0gYXN5bmMgKGV2ZW50OiBFdmVudCkgPT4ge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIC8vIENhc3QgdGhlIGV2ZW50IHRvIHRoZSBwcm9wZXIgdHlwZVxyXG4gICAgICAgIGNvbnN0IGN1c3RvbUV2ZW50ID0gZXZlbnQgYXMgQ3VzdG9tRXZlbnQ8eyBsYXQ6IG51bWJlcjsgbG5nOiBudW1iZXIgfT47XHJcbiAgICAgICAgY29uc3QgeyBsYXQsIGxuZyB9ID0gY3VzdG9tRXZlbnQuZGV0YWlsO1xyXG5cclxuICAgICAgICAvLyBGaXJzdCB1cGRhdGUgY29vcmRpbmF0ZXMgaW1tZWRpYXRlbHlcclxuICAgICAgICBzZXRHZW9mZW5jZUNvb3JkaW5hdGVzKHsgbGF0LCBsbmcgfSk7XHJcblxyXG4gICAgICAgIC8vIFRoZW4gc3RhcnQgYW4gYXN5bmMgb3BlcmF0aW9uIHRvIGdldCB0aGUgbG9jYXRpb24gbmFtZVxyXG4gICAgICAgIGNvbnNvbGUubG9nKGBHZXR0aW5nIGxvY2F0aW9uIG5hbWUgZm9yOiAke2xhdH0sICR7bG5nfWApO1xyXG5cclxuICAgICAgICAvLyBUZW1wb3JhcmlseSBzaG93IGNvb3JkaW5hdGVzIHdoaWxlIGZldGNoaW5nIHRoZSBuYW1lXHJcbiAgICAgICAgc2V0R2VvZmVuY2VMb2NhdGlvbihgJHtsYXQudG9GaXhlZCg2KX0sICR7bG5nLnRvRml4ZWQoNil9YCk7XHJcblxyXG4gICAgICAgIC8vIEdldCB0aGUgZnJpZW5kbHkgbmFtZSBhc3luY2hyb25vdXNseVxyXG4gICAgICAgIGNvbnN0IGxvY2F0aW9uTmFtZSA9IGF3YWl0IE1hcGJveFNlcnZpY2UuZ2V0TG9jYXRpb25OYW1lRnJvbUNvb3JkaW5hdGVzKFxyXG4gICAgICAgICAgbGF0LFxyXG4gICAgICAgICAgbG5nXHJcbiAgICAgICAgKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhgR290IGxvY2F0aW9uIG5hbWU6ICR7bG9jYXRpb25OYW1lfWApO1xyXG5cclxuICAgICAgICAvLyBVcGRhdGUgd2l0aCB0aGUgZnJpZW5kbHkgbmFtZSBvbmNlIHdlIGhhdmUgaXRcclxuICAgICAgICBpZiAobG9jYXRpb25OYW1lICE9PSBudWxsKSB7XHJcbiAgICAgICAgICBzZXRHZW9mZW5jZUxvY2F0aW9uKGxvY2F0aW9uTmFtZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBPcGVuIHRoZSBsb2NhdGlvbiBkcm9wZG93biBpZiBuZWVkZWRcclxuICAgICAgICBpZiAoYWN0aXZlRHJvcGRvd24gIT09ICdsb2NhdGlvbicpIHtcclxuICAgICAgICAgIHNldEFjdGl2ZURyb3Bkb3duKCdsb2NhdGlvbicpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBoYW5kbGluZyBtYXAgY2xpY2s6JywgZXJyb3IpO1xyXG4gICAgICAgIC8vIEtlZXAgdGhlIGNvb3JkaW5hdGVzIGRpc3BsYXkgaWYgdGhlcmUgd2FzIGFuIGVycm9yXHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8gQWRkIHRoZSBldmVudCBsaXN0ZW5lciAtIHVzZSB0aGUgc3RhbmRhcmQgZXZlbnQgbGlzdGVuZXIgcGF0dGVyblxyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcclxuICAgICAgJ21hcC1nZW9mZW5jZS1jbGljaycsXHJcbiAgICAgIGhhbmRsZU1hcEdlb2ZlbmNlQ2xpY2sgYXMgRXZlbnRMaXN0ZW5lclxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBDbGVhbiB1cFxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcclxuICAgICAgICAnbWFwLWdlb2ZlbmNlLWNsaWNrJyxcclxuICAgICAgICBoYW5kbGVNYXBHZW9mZW5jZUNsaWNrIGFzIEV2ZW50TGlzdGVuZXJcclxuICAgICAgKTtcclxuICAgIH07XHJcbiAgfSwgW1xyXG4gICAgc2V0R2VvZmVuY2VMb2NhdGlvbixcclxuICAgIHNldEdlb2ZlbmNlQ29vcmRpbmF0ZXMsXHJcbiAgICBzZXRBY3RpdmVEcm9wZG93bixcclxuICAgIGFjdGl2ZURyb3Bkb3duLFxyXG4gIF0pO1xyXG5cclxuICAvLyBNYWluIG1ldGhvZHNcclxuICAvLyBUb2dnbGUgZHJvcGRvd24gZnVuY3Rpb25cclxuICBjb25zdCB0b2dnbGVEcm9wZG93biA9ICh0eXBlLCBldmVudCkgPT4ge1xyXG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICBzZXRBY3RpdmVEcm9wZG93bigocHJldlN0YXRlKSA9PiAocHJldlN0YXRlID09PSB0eXBlID8gbnVsbCA6IHR5cGUpKTtcclxuXHJcbiAgICAvLyBJZiBvcGVuaW5nIHRoZSBnZW9mZW5jZSBwYW5lbCwgY2xvc2UgYW55IGFjdGl2ZSBkcm9wZG93blxyXG4gICAgaWYgKHR5cGUgPT09ICdnZW9mZW5jZScgJiYgYWN0aXZlRHJvcGRvd24pIHtcclxuICAgICAgc2V0QWN0aXZlRHJvcGRvd24obnVsbCk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgaGFuZGxlUmF0ZUxpbWl0ID0gKHJldHJ5QWZ0ZXI6IG51bWJlciA9IDMwKSA9PiB7XHJcbiAgICBzZXRJc1JhdGVMaW1pdGVkKHRydWUpO1xyXG4gICAgc2V0UmF0ZUxpbWl0VGltZXIocmV0cnlBZnRlcik7XHJcbiAgICBjb25zb2xlLmxvZyhgUmF0ZSBsaW1pdGVkIGJ5IEFQSS4gUmV0cnkgYWZ0ZXIgJHtyZXRyeUFmdGVyfXNgKTtcclxuXHJcbiAgICAvLyBCbG9jayBhbGwgQVBJIGNhbGxzXHJcbiAgICBvcGVuU2t5VHJhY2tpbmdTZXJ2aWNlLnNldEJsb2NrQWxsQXBpQ2FsbHModHJ1ZSk7XHJcbiAgICBzZXRCbG9ja01hbnVmYWN0dXJlckFwaUNhbGxzKHRydWUpO1xyXG5cclxuICAgIC8vIFNob3cgbm90aWZpY2F0aW9uIHRvIHVzZXJcclxuICAgIGlmIChyZXRyeUFmdGVyID4gMCkge1xyXG4gICAgICBhbGVydChcclxuICAgICAgICBgQWlyY3JhZnQgZGF0YSByZWZyZXNoIHJhdGUgbGltaXRlZC4gUGxlYXNlIHdhaXQgJHtyZXRyeUFmdGVyfSBzZWNvbmRzIGJlZm9yZSB0cnlpbmcgYWdhaW4uYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFRvZ2dsZSBmaWx0ZXIgbW9kZVxyXG4gICAqL1xyXG4gIGNvbnN0IHRvZ2dsZUZpbHRlck1vZGUgPSAobW9kZTogRmlsdGVyTW9kZSkgPT4ge1xyXG4gICAgc2V0RmlsdGVyTW9kZShtb2RlKTtcclxuICAgIHNldEFjdGl2ZURyb3Bkb3duKG51bGwpO1xyXG5cclxuICAgIC8vIEFwcGx5IGFwcHJvcHJpYXRlIGZpbHRlcnMgYmFzZWQgb24gbmV3IG1vZGVcclxuICAgIGlmIChtb2RlID09PSAncmVnaW9uJykge1xyXG4gICAgICAvLyBCbG9jayBBUEkgY2FsbHMgaW4gcmVnaW9uIG1vZGVcclxuICAgICAgb3BlblNreVRyYWNraW5nU2VydmljZS5zZXRCbG9ja0FsbEFwaUNhbGxzKHRydWUpO1xyXG5cclxuICAgICAgLy8gQXBwbHkgcmVnaW9uIGZpbHRlcmluZyBpZiB3ZSBhbHJlYWR5IGhhdmUgZGF0YVxyXG4gICAgICBpZiAoZGlzcGxheWVkQWlyY3JhZnQgJiYgZGlzcGxheWVkQWlyY3JhZnQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGZpbHRlckFpcmNyYWZ0QnlSZWdpb24oc2VsZWN0ZWRSZWdpb24udG9TdHJpbmcoKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENsZWFyIG1hbnVmYWN0dXJlciBzZWxlY3Rpb24gZnJvbSB0aGUgVUlcclxuICAgICAgc2VsZWN0TWFudWZhY3R1cmVyKG51bGwpO1xyXG4gICAgICBzZWxlY3RNb2RlbChudWxsKTtcclxuXHJcbiAgICAgIC8vIElmIGdlb2ZlbmNlIGlzIGFjdGl2ZSwgcmVzdG9yZSB0aGUgZnVsbCBnZW9mZW5jZSBkYXRhXHJcbiAgICAgIGlmIChnZW9mZW5jZUNvb3JkaW5hdGVzICYmIGdlb2ZlbmNlQWlyY3JhZnQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHVwZGF0ZUdlb2ZlbmNlQWlyY3JhZnQoZ2VvZmVuY2VBaXJjcmFmdCk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gJ293bmVyJykge1xyXG4gICAgICAvLyBGaWx0ZXIgZGlzcGxheWVkIGFpcmNyYWZ0IGJ5IG93bmVyIHR5cGVcclxuICAgICAgaWYgKGRpc3BsYXllZEFpcmNyYWZ0ICYmIGRpc3BsYXllZEFpcmNyYWZ0Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAvLyBGaXJzdCBmaWx0ZXIgZm9yIHZhbGlkIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgY29uc3QgYWlyY3JhZnRXaXRoVmFsaWRDb29yZHMgPSBkaXNwbGF5ZWRBaXJjcmFmdC5maWx0ZXIoXHJcbiAgICAgICAgICAocGxhbmUpID0+XHJcbiAgICAgICAgICAgIHR5cGVvZiBwbGFuZS5sYXRpdHVkZSA9PT0gJ251bWJlcicgJiZcclxuICAgICAgICAgICAgdHlwZW9mIHBsYW5lLmxvbmdpdHVkZSA9PT0gJ251bWJlcicgJiZcclxuICAgICAgICAgICAgIWlzTmFOKHBsYW5lLmxhdGl0dWRlKSAmJlxyXG4gICAgICAgICAgICAhaXNOYU4ocGxhbmUubG9uZ2l0dWRlKVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIC8vIEFwcGx5IG93bmVyIHR5cGUgZmlsdGVyXHJcbiAgICAgICAgbGV0IGZpbHRlcmVkQnlPd25lciA9XHJcbiAgICAgICAgICBvd25lckZpbHRlcnMubGVuZ3RoID09PSAwXHJcbiAgICAgICAgICAgID8gYWlyY3JhZnRXaXRoVmFsaWRDb29yZHNcclxuICAgICAgICAgICAgOiBhaXJjcmFmdFdpdGhWYWxpZENvb3Jkcy5maWx0ZXIoKGFpcmNyYWZ0KSA9PlxyXG4gICAgICAgICAgICAgICAgb3duZXJGaWx0ZXJzLmluY2x1ZGVzKGdldEFpcmNyYWZ0T3duZXJUeXBlKGFpcmNyYWZ0KSlcclxuICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyBVcGRhdGUgZGlzcGxheSB3aXRoIGZpbHRlcmVkIGFpcmNyYWZ0XHJcbiAgICAgICAgaWYgKGNsZWFyR2VvZmVuY2VEYXRhKSB7XHJcbiAgICAgICAgICBjbGVhckdlb2ZlbmNlRGF0YSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB1cGRhdGVHZW9mZW5jZUFpcmNyYWZ0KGZpbHRlcmVkQnlPd25lcik7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gJ2JvdGgnKSB7XHJcbiAgICAgIC8vIEJvdGggbW9kZSAtIEJMT0NLIEFQSSBDQUxMU1xyXG4gICAgICBvcGVuU2t5VHJhY2tpbmdTZXJ2aWNlLnNldEJsb2NrQWxsQXBpQ2FsbHModHJ1ZSk7XHJcblxyXG4gICAgICBpZiAoXHJcbiAgICAgICAgc2VsZWN0ZWRNYW51ZmFjdHVyZXIgJiZcclxuICAgICAgICBpc0dlb2ZlbmNlQWN0aXZlICYmXHJcbiAgICAgICAgZ2VvZmVuY2VBaXJjcmFmdC5sZW5ndGggPiAwXHJcbiAgICAgICkge1xyXG4gICAgICAgIGFwcGx5Q29tYmluZWRGaWx0ZXJzKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gSWYgb25lIGlzIG1pc3NpbmcsIHByb21wdCB0aGUgdXNlclxyXG4gICAgICAgIGlmICghc2VsZWN0ZWRNYW51ZmFjdHVyZXIgJiYgaXNHZW9mZW5jZUFjdGl2ZSkge1xyXG4gICAgICAgICAgYWxlcnQoJ1BsZWFzZSBzZWxlY3QgYSBtYW51ZmFjdHVyZXIgdG8gdXNlIGNvbWJpbmVkIGZpbHRlciBtb2RlJyk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChzZWxlY3RlZE1hbnVmYWN0dXJlciAmJiAhaXNHZW9mZW5jZUFjdGl2ZSkge1xyXG4gICAgICAgICAgYWxlcnQoJ1BsZWFzZSBzZXQgYSBsb2NhdGlvbiB0byB1c2UgY29tYmluZWQgZmlsdGVyIG1vZGUnKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgYWxlcnQoXHJcbiAgICAgICAgICAgICdQbGVhc2Ugc2VsZWN0IGJvdGggYSBtYW51ZmFjdHVyZXIgYW5kIGxvY2F0aW9uIHRvIHVzZSBjb21iaW5lZCBmaWx0ZXIgbW9kZSdcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLy8gT3duZXIgZmlsdGVyIG1ldGhvZHNcclxuICBjb25zdCBnZXRBaXJjcmFmdE93bmVyVHlwZSA9IChhaXJjcmFmdDogRXh0ZW5kZWRBaXJjcmFmdCk6IHN0cmluZyA9PiB7XHJcbiAgICBjb25zdCBvd25lclR5cGUgPSBhaXJjcmFmdC5UWVBFX1JFR0lTVFJBTlQgfHwgMDtcclxuICAgIHJldHVybiBvd25lclR5cGVUb1N0cmluZyhvd25lclR5cGUpO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IG93bmVyVHlwZVRvU3RyaW5nID0gKHR5cGU6IG51bWJlciB8IHN0cmluZyk6IHN0cmluZyA9PiB7XHJcbiAgICBjb25zdCB0eXBlTnVtID0gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnID8gcGFyc2VJbnQodHlwZSwgMTApIDogdHlwZTtcclxuXHJcbiAgICBjb25zdCBvd25lclR5cGVNYXA6IFJlY29yZDxudW1iZXIsIHN0cmluZz4gPSB7XHJcbiAgICAgIDE6ICdpbmRpdmlkdWFsJyxcclxuICAgICAgMjogJ3BhcnRuZXJzaGlwJyxcclxuICAgICAgMzogJ2NvcnAtb3duZXInLFxyXG4gICAgICA0OiAnY28tb3duZWQnLFxyXG4gICAgICA3OiAnbGxjJyxcclxuICAgICAgODogJ25vbi1jaXRpemVuLWNvcnAnLFxyXG4gICAgICA5OiAnYWlybGluZScsXHJcbiAgICAgIDEwOiAnZnJlaWdodCcsXHJcbiAgICAgIDExOiAnbWVkaWNhbCcsXHJcbiAgICAgIDEyOiAnbWVkaWEnLFxyXG4gICAgICAxMzogJ2hpc3RvcmljYWwnLFxyXG4gICAgICAxNDogJ2ZseWluZy1jbHViJyxcclxuICAgICAgMTU6ICdlbWVyZ2VuY3knLFxyXG4gICAgICAxNjogJ2xvY2FsLWdvdnQnLFxyXG4gICAgICAxNzogJ2VkdWNhdGlvbicsXHJcbiAgICAgIDE4OiAnZmVkZXJhbC1nb3Z0JyxcclxuICAgICAgMTk6ICdmbGlnaHQtc2Nob29sJyxcclxuICAgICAgMjA6ICdsZWFzaW5nLWNvcnAnLFxyXG4gICAgICAyMTogJ21pbGl0YXJ5JyxcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIG93bmVyVHlwZU1hcFt0eXBlTnVtXSB8fCAndW5rbm93bic7XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgYXBwbHlPd25lclR5cGVGaWx0ZXIgPSAoZmlsdGVyczogc3RyaW5nW10pID0+IHtcclxuICAgIC8vIFNraXAgZmlsdGVyaW5nIGlmIGFsbCB0eXBlcyBhcmUgc2VsZWN0ZWQgb3Igbm9uZSBhcmUgc2VsZWN0ZWRcclxuICAgIGlmIChmaWx0ZXJzLmxlbmd0aCA9PT0gMCB8fCBmaWx0ZXJzLmxlbmd0aCA9PT0gYWxsT3duZXJUeXBlcy5sZW5ndGgpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEZpbHRlciB0aGUgYWlyY3JhZnQgYmFzZWQgb24gc2VsZWN0ZWQgb3duZXIgdHlwZXNcclxuICAgIGlmIChkaXNwbGF5ZWRBaXJjcmFmdCAmJiBkaXNwbGF5ZWRBaXJjcmFmdC5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGNvbnN0IGZpbHRlcmVkQWlyY3JhZnQgPSBkaXNwbGF5ZWRBaXJjcmFmdC5maWx0ZXIoKGFpcmNyYWZ0KSA9PiB7XHJcbiAgICAgICAgY29uc3Qgb3duZXJUeXBlID0gZ2V0QWlyY3JhZnRPd25lclR5cGUoYWlyY3JhZnQpO1xyXG4gICAgICAgIHJldHVybiBmaWx0ZXJzLmluY2x1ZGVzKG93bmVyVHlwZSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gVXBkYXRlIHRoZSBkaXNwbGF5ZWQgYWlyY3JhZnRcclxuICAgICAgaWYgKGNsZWFyR2VvZmVuY2VEYXRhKSB7XHJcbiAgICAgICAgY2xlYXJHZW9mZW5jZURhdGEoKTtcclxuICAgICAgfVxyXG4gICAgICB1cGRhdGVHZW9mZW5jZUFpcmNyYWZ0KGZpbHRlcmVkQWlyY3JhZnQpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGNvbnN0IGhhbmRsZU93bmVyRmlsdGVyQ2hhbmdlID0gKHVwZGF0ZWRGaWx0ZXJzOiBzdHJpbmdbXSkgPT4ge1xyXG4gICAgc2V0T3duZXJGaWx0ZXJzKHVwZGF0ZWRGaWx0ZXJzKTtcclxuICAgIC8vIEFwcGx5IHRoZSBmaWx0ZXIgdG8geW91ciBhaXJjcmFmdCBkYXRhXHJcbiAgICBhcHBseU93bmVyVHlwZUZpbHRlcih1cGRhdGVkRmlsdGVycyk7XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgcmVzZXRPd25lckZpbHRlcnMgPSAoKSA9PiB7XHJcbiAgICBzZXRPd25lckZpbHRlcnMoWy4uLmFsbE93bmVyVHlwZXNdKTtcclxuICB9O1xyXG5cclxuICAvLyBSZWdpb24gZmlsdGVyIG1ldGhvZHNcclxuICBjb25zdCBmaWx0ZXJBaXJjcmFmdEJ5UmVnaW9uID0gKHJlZ2lvbjogc3RyaW5nKSA9PiB7XHJcbiAgICBpZiAoIWRpc3BsYXllZEFpcmNyYWZ0IHx8IGRpc3BsYXllZEFpcmNyYWZ0Lmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xyXG4gICAgc2V0TG9jYWxMb2FkaW5nKHRydWUpO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIEdldCB0aGUgYm91bmRzIGZvciB0aGUgc2VsZWN0ZWQgcmVnaW9uXHJcbiAgICAgIGNvbnN0IGJvdW5kc0V4cHJlc3Npb24gPSBnZXRCb3VuZHNCeVJlZ2lvbihyZWdpb24pO1xyXG5cclxuICAgICAgLy8gRW5zdXJlIGJvdW5kcyBpcyBpbiB0aGUgY29ycmVjdCBmb3JtYXRcclxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGJvdW5kc0V4cHJlc3Npb24pIHx8IGJvdW5kc0V4cHJlc3Npb24ubGVuZ3RoICE9PSAyKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihcclxuICAgICAgICAgIGBJbnZhbGlkIGJvdW5kcyBmb3JtYXQgZm9yIHJlZ2lvbjogJHtyZWdpb259YCxcclxuICAgICAgICAgIGJvdW5kc0V4cHJlc3Npb25cclxuICAgICAgICApO1xyXG4gICAgICAgIHNldExvY2FsTG9hZGluZyhmYWxzZSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBFeHRyYWN0IGNvb3JkaW5hdGVzIC0gTGVhZmxldCB1c2VzIFtsYXQsIGxuZ10gZm9ybWF0XHJcbiAgICAgIGNvbnN0IFtbbWluTGF0LCBtaW5MbmddLCBbbWF4TGF0LCBtYXhMbmddXSA9IGJvdW5kc0V4cHJlc3Npb247XHJcblxyXG4gICAgICBjb25zb2xlLmxvZyhgRmlsdGVyaW5nIGJ5IHJlZ2lvbjogJHtyZWdpb259IHdpdGggYm91bmRzOmAsIHtcclxuICAgICAgICBtaW5MYXQsXHJcbiAgICAgICAgbWluTG5nLFxyXG4gICAgICAgIG1heExhdCxcclxuICAgICAgICBtYXhMbmcsXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gRmlsdGVyIGFpcmNyYWZ0IGJhc2VkIG9uIGNvb3JkaW5hdGVzIHdpdGhpbiB0aGUgYm91bmRzXHJcbiAgICAgIGNvbnN0IGZpbHRlcmVkQWlyY3JhZnQgPSBkaXNwbGF5ZWRBaXJjcmFmdC5maWx0ZXIoKGFpcmNyYWZ0KSA9PiB7XHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgYWlyY3JhZnQgaGFzIHZhbGlkIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgdHlwZW9mIGFpcmNyYWZ0LmxhdGl0dWRlICE9PSAnbnVtYmVyJyB8fFxyXG4gICAgICAgICAgdHlwZW9mIGFpcmNyYWZ0LmxvbmdpdHVkZSAhPT0gJ251bWJlcicgfHxcclxuICAgICAgICAgIGlzTmFOKGFpcmNyYWZ0LmxhdGl0dWRlKSB8fFxyXG4gICAgICAgICAgaXNOYU4oYWlyY3JhZnQubG9uZ2l0dWRlKVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgY29vcmRpbmF0ZXMgYXJlIHdpdGhpbiB0aGUgYm91bmRzXHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgIGFpcmNyYWZ0LmxhdGl0dWRlID49IG1pbkxhdCAmJlxyXG4gICAgICAgICAgYWlyY3JhZnQubGF0aXR1ZGUgPD0gbWF4TGF0ICYmXHJcbiAgICAgICAgICBhaXJjcmFmdC5sb25naXR1ZGUgPj0gbWluTG5nICYmXHJcbiAgICAgICAgICBhaXJjcmFmdC5sb25naXR1ZGUgPD0gbWF4TG5nXHJcbiAgICAgICAgKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBVcGRhdGUgdGhlIGRpc3BsYXkgd2l0aCBmaWx0ZXJlZCBhaXJjcmFmdFxyXG4gICAgICBpZiAoY2xlYXJHZW9mZW5jZURhdGEpIHtcclxuICAgICAgICBjbGVhckdlb2ZlbmNlRGF0YSgpO1xyXG4gICAgICB9XHJcbiAgICAgIHVwZGF0ZUdlb2ZlbmNlQWlyY3JhZnQoZmlsdGVyZWRBaXJjcmFmdCk7XHJcbiAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgIGBGaWx0ZXJlZCB0byAke2ZpbHRlcmVkQWlyY3JhZnQubGVuZ3RofSBhaXJjcmFmdCBpbiAke3JlZ2lvbn0gcmVnaW9uIChvdXQgb2YgJHtkaXNwbGF5ZWRBaXJjcmFmdC5sZW5ndGh9IHRvdGFsKWBcclxuICAgICAgKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZpbHRlcmluZyBhaXJjcmFmdCBieSByZWdpb246JywgZXJyb3IpO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgc2V0TG9jYWxMb2FkaW5nKGZhbHNlKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBjb25zdCBoYW5kbGVSZWdpb25TZWxlY3QgPSBhc3luYyAocmVnaW9uOiBSZWdpb25Db2RlKSA9PiB7XHJcbiAgICBzZXRBY3RpdmVSZWdpb24ocmVnaW9uKTtcclxuICAgIHNldFNlbGVjdGVkUmVnaW9uKHJlZ2lvbik7XHJcbiAgICBzZXRMb2NhbExvYWRpbmcodHJ1ZSk7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gU2V0IG1hcCBib3VuZHMgYmFzZWQgb24gcmVnaW9uXHJcbiAgICAgIGlmIChtYXBJbnN0YW5jZSkge1xyXG4gICAgICAgIGNvbnN0IGJvdW5kcyA9IGdldEJvdW5kc0J5UmVnaW9uKHJlZ2lvbik7XHJcblxyXG4gICAgICAgIC8vIEdldCB0aGUgYXBwcm9wcmlhdGUgem9vbSBsZXZlbCBmb3IgdGhpcyByZWdpb24gZnJvbSB5b3VyIGNvbmZpZ1xyXG4gICAgICAgIGNvbnN0IHpvb21MZXZlbCA9IGdldFpvb21MZXZlbEZvclJlZ2lvbihyZWdpb24pO1xyXG5cclxuICAgICAgICAvLyBGaXJzdCwgc2V0IHRoZSBhcHByb3ByaWF0ZSB6b29tIGxldmVsXHJcbiAgICAgICAgbWFwSW5zdGFuY2Uuc2V0Wm9vbSh6b29tTGV2ZWwpO1xyXG5cclxuICAgICAgICAvLyBUaGVuIGZpdCBib3VuZHMgd2l0aCBwYWRkaW5nXHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcclxuICAgICAgICAgIHBhZGRpbmc6IE1BUF9DT05GSUcuUEFERElORy5ERUZBVUxULFxyXG4gICAgICAgICAgLy8gRG9uJ3Qgc2V0IG1heFpvb20gaGVyZSBhcyB3ZSB3YW50IHRoZSByZWdpb24gdG8gYmUgcHJvcGVybHkgZGlzcGxheWVkXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgbWFwSW5zdGFuY2UuZml0Qm91bmRzKGJvdW5kcyBhcyBhbnksIG9wdGlvbnMpO1xyXG4gICAgICAgIG1hcEluc3RhbmNlLmludmFsaWRhdGVTaXplKCk7XHJcbiAgICAgICAgZHJhd1JlZ2lvbk91dGxpbmUocmVnaW9uKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSW5zdGVhZCBvZiBpbW1lZGlhdGVseSBmZXRjaGluZyBhaXJjcmFmdCBkYXRhLFxyXG4gICAgICAvLyBqdXN0IHN0b3JlIHRoZSByZWdpb24gc2VsZWN0aW9uIGZvciBsYXRlciB1c2VcclxuICAgICAgY29uc29sZS5sb2coYFJlZ2lvbiBzZWxlY3RlZC4gV2FpdGluZyBmb3IgbWFudWZhY3R1cmVyIHNlbGVjdGlvbi4uLmApO1xyXG5cclxuICAgICAgLy8gT3B0aW9uYWxseSwgeW91IGNvdWxkIGZldGNoIGp1c3QgdGhlIGNvdW50IG9mIGFpcmNyYWZ0IGluIHRoaXMgcmVnaW9uXHJcbiAgICAgIC8vIHRvIGdpdmUgdGhlIHVzZXIgYW4gaWRlYSBvZiB0aGUgZGF0YSB2b2x1bWVcclxuICAgICAgY29uc3QgY291bnRSZXNwb25zZSA9IGF3YWl0IGZldGNoKFxyXG4gICAgICAgIGAvYXBpL3RyYWNraW5nL3JlZ2lvbi1jb3VudD9yZWdpb249JHtyZWdpb259YFxyXG4gICAgICApO1xyXG4gICAgICBpZiAoY291bnRSZXNwb25zZS5vaykge1xyXG4gICAgICAgIGNvbnN0IGNvdW50RGF0YSA9IGF3YWl0IGNvdW50UmVzcG9uc2UuanNvbigpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGAke2NvdW50RGF0YS5jb3VudH0gYWlyY3JhZnQgYXZhaWxhYmxlIGluIHRoaXMgcmVnaW9uYCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENsZWFyIGFueSBwcmV2aW91cyBhaXJjcmFmdCBkYXRhXHJcbiAgICAgIGlmIChjbGVhckdlb2ZlbmNlRGF0YSkge1xyXG4gICAgICAgIGNsZWFyR2VvZmVuY2VEYXRhKCk7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIHJlZ2lvbiBzZWxlY3Rpb246JywgZXJyb3IpO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgc2V0TG9jYWxMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgc2V0QWN0aXZlRHJvcGRvd24obnVsbCk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgZHJhd1JlZ2lvbk91dGxpbmUgPSAocmVnaW9uOiBSZWdpb25Db2RlKSA9PiB7XHJcbiAgICBpZiAoIW1hcEluc3RhbmNlKSByZXR1cm47XHJcblxyXG4gICAgLy8gQ2xlYXIgYW55IGV4aXN0aW5nIG91dGxpbmVcclxuICAgIGlmIChyZWdpb25PdXRsaW5lKSB7XHJcbiAgICAgIHJlZ2lvbk91dGxpbmUucmVtb3ZlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gR2V0IHRoZSBib3VuZHMgZm9yIHRoZSBzZWxlY3RlZCByZWdpb25cclxuICAgIGNvbnN0IGJvdW5kcyA9IGdldEJvdW5kc0J5UmVnaW9uKHJlZ2lvbikgYXMgW1xyXG4gICAgICBbbnVtYmVyLCBudW1iZXJdLFxyXG4gICAgICBbbnVtYmVyLCBudW1iZXJdLFxyXG4gICAgXTtcclxuXHJcbiAgICAvLyBDcmVhdGUgYSBwb2x5Z29uIGZyb20gdGhlIGJvdW5kc1xyXG4gICAgY29uc3QgTCA9IHJlcXVpcmUoJ2xlYWZsZXQnKTtcclxuICAgIGNvbnN0IHJlY3RhbmdsZSA9IEwucmVjdGFuZ2xlKGJvdW5kcywge1xyXG4gICAgICBjb2xvcjogJyM0ZjQ2ZTUnLCAvLyBJbmRpZ28gY29sb3IgbWF0Y2hpbmcgeW91ciBVSVxyXG4gICAgICB3ZWlnaHQ6IDMsXHJcbiAgICAgIG9wYWNpdHk6IDAuNyxcclxuICAgICAgZmlsbDogdHJ1ZSxcclxuICAgICAgZmlsbENvbG9yOiAnIzRmNDZlNScsXHJcbiAgICAgIGZpbGxPcGFjaXR5OiAwLjEsXHJcbiAgICAgIGRhc2hBcnJheTogJzUsIDEwJywgLy8gT3B0aW9uYWw6IGNyZWF0ZXMgYSBkYXNoZWQgbGluZVxyXG4gICAgICBpbnRlcmFjdGl2ZTogZmFsc2UsIC8vIFByZXZlbnRzIHRoZSByZWN0YW5nbGUgZnJvbSBjYXB0dXJpbmcgbW91c2UgZXZlbnRzXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBBZGQgdG8gbWFwXHJcbiAgICByZWN0YW5nbGUuYWRkVG8obWFwSW5zdGFuY2UpO1xyXG5cclxuICAgIC8vIFVwZGF0ZSB0aGUgc3RhdGUgdG8gaW5jbHVkZSBib3RoIHRoZSByZWN0YW5nbGUgYW5kIHRoZSBsYWJlbFxyXG4gICAgc2V0UmVnaW9uT3V0bGluZSh7XHJcbiAgICAgIHJlbW92ZTogKCkgPT4ge1xyXG4gICAgICAgIHJlY3RhbmdsZS5yZW1vdmUoKTtcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIC8vIEdlb2ZlbmNlIG1ldGhvZHNcclxuICAvLyBGaXhlZCBnZXRVc2VyTG9jYXRpb24gZnVuY3Rpb25cclxuICBjb25zdCBnZXRVc2VyTG9jYXRpb24gPSBhc3luYyAoKSA9PiB7XHJcbiAgICBpZiAoaXNSYXRlTGltaXRlZCkge1xyXG4gICAgICBhbGVydChcclxuICAgICAgICBgUmF0ZSBsaW1pdGVkLiBQbGVhc2Ugd2FpdCAke3JhdGVMaW1pdFRpbWVyIHx8IDMwfSBzZWNvbmRzIGJlZm9yZSB0cnlpbmcgdG8gZ2V0IGxvY2F0aW9uLmBcclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHNldElzR2V0dGluZ0xvY2F0aW9uKHRydWUpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcG9zaXRpb24gPSBhd2FpdCBnZXRDdXJyZW50UG9zaXRpb24oKTtcclxuXHJcbiAgICAgIGlmIChwb3NpdGlvbikge1xyXG4gICAgICAgIGNvbnN0IHsgbGF0aXR1ZGUsIGxvbmdpdHVkZSB9ID0gcG9zaXRpb24uY29vcmRzO1xyXG5cclxuICAgICAgICAvLyBVcGRhdGUgc3RhdGUgd2l0aCBjb29yZGluYXRlc1xyXG4gICAgICAgIHNldEdlb2ZlbmNlQ29vcmRpbmF0ZXMoeyBsYXQ6IGxhdGl0dWRlLCBsbmc6IGxvbmdpdHVkZSB9KTtcclxuICAgICAgICBzZXRHZW9mZW5jZUNlbnRlcih7IGxhdDogbGF0aXR1ZGUsIGxuZzogbG9uZ2l0dWRlIH0pO1xyXG5cclxuICAgICAgICAvLyBVcGRhdGUgdGhlIGxvY2F0aW9uIGRpc3BsYXkgd2l0aCBjb29yZGluYXRlc1xyXG4gICAgICAgIHNldEdlb2ZlbmNlTG9jYXRpb24oYCR7bGF0aXR1ZGUudG9GaXhlZCg2KX0sICR7bG9uZ2l0dWRlLnRvRml4ZWQoNil9YCk7XHJcblxyXG4gICAgICAgIC8vIEF1dG9tYXRpY2FsbHkgdHJpZ2dlciB0aGUgZ2VvZmVuY2Ugc2VhcmNoXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnN0IGZldGNoZWRBaXJjcmFmdCA9IGF3YWl0IGdldEFpcmNyYWZ0TmVhckxvY2F0aW9uKFxyXG4gICAgICAgICAgICBsYXRpdHVkZSxcclxuICAgICAgICAgICAgbG9uZ2l0dWRlLFxyXG4gICAgICAgICAgICBnZW9mZW5jZVJhZGl1c1xyXG4gICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICBpZiAoZmV0Y2hlZEFpcmNyYWZ0Lmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBhbGVydChcclxuICAgICAgICAgICAgICBgTm8gYWlyY3JhZnQgZm91bmQgbmVhciB5b3VyIGN1cnJlbnQgbG9jYXRpb24uIFRyeSBpbmNyZWFzaW5nIHRoZSByYWRpdXMuYFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBzZXRJc0dldHRpbmdMb2NhdGlvbihmYWxzZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBQcm9jZXNzIHRoZSBhaXJjcmFmdCBkYXRhXHJcbiAgICAgICAgICBjb25zdCBhZGFwdGVkQWlyY3JhZnQgPSBhZGFwdEdlb2ZlbmNlQWlyY3JhZnQoZmV0Y2hlZEFpcmNyYWZ0KTtcclxuICAgICAgICAgIGNvbnN0IGVucmljaGVkQWlyY3JhZnQgPVxyXG4gICAgICAgICAgICBhd2FpdCBlbnJpY2hHZW9mZW5jZUFpcmNyYWZ0KGFkYXB0ZWRBaXJjcmFmdCk7XHJcblxyXG4gICAgICAgICAgLy8gU2F2ZSB0byBsb2NhbCBzdGF0ZVxyXG4gICAgICAgICAgc2V0R2VvZmVuY2VBaXJjcmFmdChlbnJpY2hlZEFpcmNyYWZ0KTtcclxuXHJcbiAgICAgICAgICAvLyBDbGVhciBleGlzdGluZyBhaXJjcmFmdCBkYXRhXHJcbiAgICAgICAgICBpZiAoY2xlYXJHZW9mZW5jZURhdGEpIHtcclxuICAgICAgICAgICAgY2xlYXJHZW9mZW5jZURhdGEoKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIG1hcCB3aXRoIG5ldyBhaXJjcmFmdFxyXG4gICAgICAgICAgdXBkYXRlR2VvZmVuY2VBaXJjcmFmdChlbnJpY2hlZEFpcmNyYWZ0KTtcclxuICAgICAgICAgIHNldElzR2VvZmVuY2VBY3RpdmUodHJ1ZSk7XHJcblxyXG4gICAgICAgICAgLy8gQ2VudGVyIHRoZSBtYXAgb24gdXNlcidzIGxvY2F0aW9uIC0gU0lNUExJRklFRCBaT09NIExPR0lDXHJcbiAgICAgICAgICBpZiAobWFwSW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgLy8gRG9uJ3QgbW9kaWZ5IHpvb20gaWYgaXQncyBhbHJlYWR5IGF0IGFuIGFwcHJvcHJpYXRlIGxldmVsXHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRab29tID0gbWFwSW5zdGFuY2UuZ2V0Wm9vbSgpO1xyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXRab29tID0gY3VycmVudFpvb20gPD0gNyA/IDkgOiBjdXJyZW50Wm9vbTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNldCB0aGUgdmlldyBkaXJlY3RseSB0byB0aGUgdXNlcidzIGxvY2F0aW9uXHJcbiAgICAgICAgICAgIG1hcEluc3RhbmNlLnNldFZpZXcoW2xhdGl0dWRlLCBsb25naXR1ZGVdLCB0YXJnZXRab29tKTtcclxuXHJcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgbWFwIHJlZmxlY3RzIGNoYW5nZXNcclxuICAgICAgICAgICAgbWFwSW5zdGFuY2UuaW52YWxpZGF0ZVNpemUoKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBJZiBpbiBnZW9mZW5jZSBtb2RlLCBlbnN1cmUgdGhlIGZpbHRlciBtb2RlIGlzIHNldCBjb3JyZWN0bHlcclxuICAgICAgICAgIGlmIChmaWx0ZXJNb2RlICE9PSAnZ2VvZmVuY2UnICYmIGZpbHRlck1vZGUgIT09ICdib3RoJykge1xyXG4gICAgICAgICAgICBzZXRGaWx0ZXJNb2RlKCdnZW9mZW5jZScpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygncmF0ZSBsaW1pdCcpIHx8IGVycm9yLnN0YXR1cyA9PT0gNDI5KSB7XHJcbiAgICAgICAgICAgIGhhbmRsZVJhdGVMaW1pdCgzMCk7XHJcbiAgICAgICAgICAgIC8vIFN0aWxsIHVwZGF0ZSB0aGUgbG9jYXRpb24gZXZlbiBpZiB3ZSBjb3VsZG4ndCBnZXQgYWlyY3JhZnRcclxuICAgICAgICAgICAgaWYgKG1hcEluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgbWFwSW5zdGFuY2Uuc2V0VmlldyhbbGF0aXR1ZGUsIGxvbmdpdHVkZV0sIDkpO1xyXG4gICAgICAgICAgICAgIG1hcEluc3RhbmNlLmludmFsaWRhdGVTaXplKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2xvc2UgdGhlIGRyb3Bkb3duIGFmdGVyIHNlbGVjdGlvblxyXG4gICAgICAgIHNldEFjdGl2ZURyb3Bkb3duKG51bGwpO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHVzZXIgbG9jYXRpb246JywgZXJyb3IpO1xyXG4gICAgICBhbGVydChcclxuICAgICAgICAnVW5hYmxlIHRvIGFjY2VzcyB5b3VyIGxvY2F0aW9uLiBQbGVhc2UgbWFrZSBzdXJlIGxvY2F0aW9uIHNlcnZpY2VzIGFyZSBlbmFibGVkIGluIHlvdXIgYnJvd3Nlci4nXHJcbiAgICAgICk7XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICBzZXRJc0dldHRpbmdMb2NhdGlvbihmYWxzZSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgcHJvY2Vzc0dlb2ZlbmNlU2VhcmNoID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgaWYgKCFnZW9mZW5jZUxvY2F0aW9uKSByZXR1cm47XHJcblxyXG4gICAgLy8gQ2hlY2sgaWYgcmF0ZSBsaW1pdGVkXHJcbiAgICBpZiAoaXNSYXRlTGltaXRlZCkge1xyXG4gICAgICBhbGVydChcclxuICAgICAgICBgUmF0ZSBsaW1pdGVkLiBQbGVhc2Ugd2FpdCAke3JhdGVMaW1pdFRpbWVyIHx8IDMwfSBzZWNvbmRzIGJlZm9yZSBzZWFyY2hpbmcgYWdhaW4uYFxyXG4gICAgICApO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQmxvY2sgQVBJIGNhbGxzIHdoaWxlIGRvaW5nIGdlb2ZlbmNlIHNlYXJjaCBpbiBjb21iaW5lZCBtb2RlXHJcbiAgICBpZiAoZmlsdGVyTW9kZSA9PT0gJ2JvdGgnKSB7XHJcbiAgICAgIG9wZW5Ta3lUcmFja2luZ1NlcnZpY2Uuc2V0QmxvY2tBbGxBcGlDYWxscyh0cnVlKTtcclxuICAgICAgc2V0QmxvY2tNYW51ZmFjdHVyZXJBcGlDYWxscyh0cnVlKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTZXQgbG9hZGluZyBzdGF0ZVxyXG4gICAgc2V0TG9jYWxMb2FkaW5nKHRydWUpO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgIGBTZWFyY2hpbmcgZm9yIGFpcmNyYWZ0IG5lYXIgbG9jYXRpb246IFwiJHtnZW9mZW5jZUxvY2F0aW9ufVwiYFxyXG4gICAgICApO1xyXG5cclxuICAgICAgLy8gVGhpcyB3aWxsIGhhbmRsZSBQb3N0YWwgY29kZXMsIHBsYWNlIG5hbWVzLCBhZGRyZXNzZXMsIFBPSXMsIGV0Yy5cclxuICAgICAgbGV0IGZldGNoZWRBaXJjcmFmdDtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBmZXRjaGVkQWlyY3JhZnQgPSBhd2FpdCBnZXRBaXJjcmFmdE5lYXJTZWFyY2hlZExvY2F0aW9uKFxyXG4gICAgICAgICAgZ2VvZmVuY2VMb2NhdGlvbixcclxuICAgICAgICAgIGdlb2ZlbmNlUmFkaXVzXHJcbiAgICAgICAgKTtcclxuICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgICAgIGlmIChlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygncmF0ZSBsaW1pdCcpIHx8IGVycm9yLnN0YXR1cyA9PT0gNDI5KSB7XHJcbiAgICAgICAgICBjb25zdCByZXRyeUFmdGVyID0gMzA7IC8vIERlZmF1bHQgdG8gMzAgc2Vjb25kcyBpZiBub3Qgc3BlY2lmaWVkXHJcbiAgICAgICAgICBoYW5kbGVSYXRlTGltaXQocmV0cnlBZnRlcik7XHJcbiAgICAgICAgICBzZXRMb2NhbExvYWRpbmcoZmFsc2UpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gR2V0IGNvb3JkaW5hdGVzIGZvciB0aGUgbWFwXHJcbiAgICAgIGxldCBsb2NhdGlvbnM6IHsgbGF0OiBudW1iZXI7IGxuZzogbnVtYmVyOyBuYW1lOiBzdHJpbmcgfVtdO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGxvY2F0aW9ucyA9IGF3YWl0IE1hcGJveFNlcnZpY2Uuc2VhcmNoTG9jYXRpb25XaXRoTWFwYm94KFxyXG4gICAgICAgICAgZ2VvZmVuY2VMb2NhdGlvbixcclxuICAgICAgICAgIDFcclxuICAgICAgICApO1xyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHNlYXJjaGluZyBsb2NhdGlvbiB3aXRoIE1hcGJveDonLCBlcnJvcik7XHJcbiAgICAgICAgLy8gQ29udGludWUgd2l0aCBhaXJjcmFmdCBkYXRhIGlmIGF2YWlsYWJsZVxyXG4gICAgICAgIGxvY2F0aW9ucyA9IFtdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBsZXQgY29vcmRpbmF0ZXM6IHsgbGF0OiBudW1iZXI7IGxuZzogbnVtYmVyIH0gfCBudWxsID0gbnVsbDtcclxuXHJcbiAgICAgIGlmIChsb2NhdGlvbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGNvb3JkaW5hdGVzID0ge1xyXG4gICAgICAgICAgbGF0OiBsb2NhdGlvbnNbMF0ubGF0LFxyXG4gICAgICAgICAgbG5nOiBsb2NhdGlvbnNbMF0ubG5nLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gU2F2ZSB0aGUgZm9ybWF0dGVkIGxvY2F0aW9uIG5hbWVcclxuICAgICAgICBzZXRHZW9mZW5jZUxvY2F0aW9uKGxvY2F0aW9uc1swXS5uYW1lKTtcclxuICAgICAgfSBlbHNlIGlmIChcclxuICAgICAgICBmZXRjaGVkQWlyY3JhZnQubGVuZ3RoID4gMCAmJlxyXG4gICAgICAgIGZldGNoZWRBaXJjcmFmdFswXS5sYXRpdHVkZSAmJlxyXG4gICAgICAgIGZldGNoZWRBaXJjcmFmdFswXS5sb25naXR1ZGVcclxuICAgICAgKSB7XHJcbiAgICAgICAgLy8gRmFsbGJhY2sgdG8gZmlyc3QgYWlyY3JhZnQgcG9zaXRpb25cclxuICAgICAgICBjb29yZGluYXRlcyA9IHtcclxuICAgICAgICAgIGxhdDogZmV0Y2hlZEFpcmNyYWZ0WzBdLmxhdGl0dWRlLFxyXG4gICAgICAgICAgbG5nOiBmZXRjaGVkQWlyY3JhZnRbMF0ubG9uZ2l0dWRlLFxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChmZXRjaGVkQWlyY3JhZnQubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgYWxlcnQoXHJcbiAgICAgICAgICBgTm8gYWlyY3JhZnQgZm91bmQgbmVhciAke2dlb2ZlbmNlTG9jYXRpb259LiBUcnkgaW5jcmVhc2luZyB0aGUgcmFkaXVzIG9yIHNlYXJjaGluZyBpbiBhIGRpZmZlcmVudCBhcmVhLmBcclxuICAgICAgICApO1xyXG4gICAgICAgIHNldExvY2FsTG9hZGluZyhmYWxzZSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBVcGRhdGUgc3RhdGUgd2l0aCB0aGUgY29vcmRpbmF0ZXNcclxuICAgICAgaWYgKGNvb3JkaW5hdGVzKSB7XHJcbiAgICAgICAgc2V0R2VvZmVuY2VDb29yZGluYXRlcyhjb29yZGluYXRlcyk7XHJcbiAgICAgICAgc2V0R2VvZmVuY2VDZW50ZXIoY29vcmRpbmF0ZXMpO1xyXG4gICAgICAgIHNldEdlb2ZlbmNlUmFkaXVzKGdlb2ZlbmNlUmFkaXVzKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIWlzR2VvZmVuY2VBY3RpdmUpIHtcclxuICAgICAgICB0b2dnbGVHZW9mZW5jZSgpO1xyXG4gICAgICB9IGVsc2UgaWYgKCFjb29yZGluYXRlcykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGRldGVybWluZSBjb29yZGluYXRlcyBmb3IgdGhlIGxvY2F0aW9uJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgIGBGb3VuZCAke2ZldGNoZWRBaXJjcmFmdC5sZW5ndGh9IGFpcmNyYWZ0IGluIHRoZSBhcmVhLCBwcmVwYXJpbmcgZm9yIGRpc3BsYXkuLi5gXHJcbiAgICAgICk7XHJcblxyXG4gICAgICAvLyBFbnN1cmUgdGhlIGRhdGEgaXMgaW4gdGhlIHJpZ2h0IGZvcm1hdFxyXG4gICAgICBjb25zdCBhZGFwdGVkQWlyY3JhZnQgPVxyXG4gICAgICAgIGZldGNoZWRBaXJjcmFmdFswXS5NQU5VRkFDVFVSRVIgIT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgPyBmZXRjaGVkQWlyY3JhZnQgLy8gQWxyZWFkeSBpbiB0aGUgcmlnaHQgZm9ybWF0XHJcbiAgICAgICAgICA6IGFkYXB0R2VvZmVuY2VBaXJjcmFmdChmZXRjaGVkQWlyY3JhZnQpOyAvLyBOZWVkcyBhZGFwdGF0aW9uXHJcblxyXG4gICAgICAvLyBFbnJpY2ggd2l0aCBzdGF0aWMgZGF0YVxyXG4gICAgICBjb25zb2xlLmxvZygnRW5yaWNoaW5nIGdlb2ZlbmNlIGFpcmNyYWZ0IHdpdGggc3RhdGljIGRhdGEuLi4nKTtcclxuICAgICAgY29uc3QgZW5yaWNoZWRBaXJjcmFmdCA9IGF3YWl0IGVucmljaEdlb2ZlbmNlQWlyY3JhZnQoYWRhcHRlZEFpcmNyYWZ0KTtcclxuXHJcbiAgICAgIC8vIFNhdmUgdGhlIEZVTEwgc2V0IHRvIGxvY2FsIHN0YXRlXHJcbiAgICAgIHNldEdlb2ZlbmNlQWlyY3JhZnQoZW5yaWNoZWRBaXJjcmFmdCk7XHJcbiAgICAgIHNldElzR2VvZmVuY2VBY3RpdmUodHJ1ZSk7XHJcblxyXG4gICAgICAvLyBDbGVhciBleGlzdGluZyBhaXJjcmFmdCBkYXRhXHJcbiAgICAgIGlmIChjbGVhckdlb2ZlbmNlRGF0YSkge1xyXG4gICAgICAgIGNsZWFyR2VvZmVuY2VEYXRhKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIElmIHdlJ3JlIGluIGNvbWJpbmVkIG1vZGUgYW5kIGhhdmUgYSBtYW51ZmFjdHVyZXIsIGFwcGx5IHRoZSBjb21iaW5lZCBmaWx0ZXJcclxuICAgICAgaWYgKGZpbHRlck1vZGUgPT09ICdib3RoJyAmJiBzZWxlY3RlZE1hbnVmYWN0dXJlcikge1xyXG4gICAgICAgIC8vIE1ha2Ugc3VyZSBBUEkgY2FsbHMgcmVtYWluIGJsb2NrZWRcclxuICAgICAgICBvcGVuU2t5VHJhY2tpbmdTZXJ2aWNlLnNldEJsb2NrQWxsQXBpQ2FsbHModHJ1ZSk7XHJcbiAgICAgICAgc2V0QmxvY2tNYW51ZmFjdHVyZXJBcGlDYWxscyh0cnVlKTtcclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgIGFwcGx5Q29tYmluZWRGaWx0ZXJzKCk7XHJcbiAgICAgICAgfSwgMTAwKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBKdXN0IHNob3cgYWxsIGFpcmNyYWZ0IGluIHRoZSBnZW9mZW5jZVxyXG4gICAgICAgIHVwZGF0ZUdlb2ZlbmNlQWlyY3JhZnQoZW5yaWNoZWRBaXJjcmFmdCk7XHJcblxyXG4gICAgICAgIC8vIENlbnRlciB0aGUgbWFwIC0gU0lNUExJRklFRCBaT09NIExPR0lDXHJcbiAgICAgICAgaWYgKG1hcEluc3RhbmNlICYmIGNvb3JkaW5hdGVzKSB7XHJcbiAgICAgICAgICAvLyBHZXQgY3VycmVudCB6b29tIGxldmVsXHJcbiAgICAgICAgICBjb25zdCBjdXJyZW50Wm9vbSA9IG1hcEluc3RhbmNlLmdldFpvb20oKTtcclxuICAgICAgICAgIC8vIFVzZSBhcHByb3ByaWF0ZSB6b29tIGxldmVsIGJhc2VkIG9uIGN1cnJlbnQgdmlld1xyXG4gICAgICAgICAgY29uc3QgdGFyZ2V0Wm9vbSA9IGN1cnJlbnRab29tIDw9IDcgPyA5IDogY3VycmVudFpvb207XHJcblxyXG4gICAgICAgICAgLy8gU2V0IHZpZXcgdG8gdGhlIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICBtYXBJbnN0YW5jZS5zZXRWaWV3KFtjb29yZGluYXRlcy5sYXQsIGNvb3JkaW5hdGVzLmxuZ10sIHRhcmdldFpvb20pO1xyXG5cclxuICAgICAgICAgIC8vIEVuc3VyZSBtYXAgaXMgdXBkYXRlZFxyXG4gICAgICAgICAgbWFwSW5zdGFuY2UuaW52YWxpZGF0ZVNpemUoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENsb3NlIGRyb3Bkb3duIGFmdGVyIHNlYXJjaFxyXG4gICAgICBzZXRBY3RpdmVEcm9wZG93bihudWxsKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gZ2VvZmVuY2Ugc2VhcmNoOicsIGVycm9yKTtcclxuICAgICAgaWYgKGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCdyYXRlIGxpbWl0JykgfHwgZXJyb3Iuc3RhdHVzID09PSA0MjkpIHtcclxuICAgICAgICBoYW5kbGVSYXRlTGltaXQoMzApO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGFsZXJ0KFxyXG4gICAgICAgICAgYEVycm9yOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3Igb2NjdXJyZWQnfWBcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICBzZXRMb2NhbExvYWRpbmcoZmFsc2UpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFNURVAgMzogRml4IHRvZ2dsZUdlb2ZlbmNlU3RhdGUgdG8gYmV0dGVyIGhhbmRsZSBtYW51YWxseSBjbGlja2luZyB0aGUgYnV0dG9uXHJcbiAgICovXHJcbiAgY29uc3QgdG9nZ2xlR2VvZmVuY2VTdGF0ZSA9IChlbmFibGVkOiBib29sZWFuKSA9PiB7XHJcbiAgICBjb25zb2xlLmxvZygndG9nZ2xlR2VvZmVuY2VTdGF0ZSBjYWxsZWQgd2l0aDonLCBlbmFibGVkKTtcclxuICAgIGNvbnNvbGUubG9nKCdDdXJyZW50IGdlb2ZlbmNlQ29vcmRpbmF0ZXM6JywgZ2VvZmVuY2VDb29yZGluYXRlcyk7XHJcblxyXG4gICAgaWYgKGVuYWJsZWQpIHtcclxuICAgICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSB2YWxpZCBjb29yZGluYXRlc1xyXG4gICAgICBpZiAoXHJcbiAgICAgICAgZ2VvZmVuY2VDb29yZGluYXRlcyAmJlxyXG4gICAgICAgIHR5cGVvZiBnZW9mZW5jZUNvb3JkaW5hdGVzLmxhdCA9PT0gJ251bWJlcicgJiZcclxuICAgICAgICB0eXBlb2YgZ2VvZmVuY2VDb29yZGluYXRlcy5sbmcgPT09ICdudW1iZXInICYmXHJcbiAgICAgICAgIWlzTmFOKGdlb2ZlbmNlQ29vcmRpbmF0ZXMubGF0KSAmJlxyXG4gICAgICAgICFpc05hTihnZW9mZW5jZUNvb3JkaW5hdGVzLmxuZylcclxuICAgICAgKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1ZhbGlkIGNvb3JkaW5hdGVzIGZvdW5kLCBlbmFibGluZyBnZW9mZW5jZScpO1xyXG5cclxuICAgICAgICAvLyBTZXQgZmxhZ3MgZmlyc3RcclxuICAgICAgICBzZXRHZW9mZW5jZUVuYWJsZWQodHJ1ZSk7XHJcbiAgICAgICAgc2V0SXNHZW9mZW5jZUFjdGl2ZSh0cnVlKTtcclxuXHJcbiAgICAgICAgLy8gQ2FsbCBjb250ZXh0IHRvZ2dsZSBmdW5jdGlvbiBpZiBhdmFpbGFibGVcclxuICAgICAgICBpZiAodHlwZW9mIHRvZ2dsZUdlb2ZlbmNlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICB0b2dnbGVHZW9mZW5jZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRGlzcGxheSBhaXJjcmFmdCBpZiB3ZSBoYXZlIHRoZW1cclxuICAgICAgICBpZiAoZ2VvZmVuY2VBaXJjcmFmdCAmJiBnZW9mZW5jZUFpcmNyYWZ0Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgICBgU2hvd2luZyAke2dlb2ZlbmNlQWlyY3JhZnQubGVuZ3RofSBhaXJjcmFmdCBpbiBnZW9mZW5jZWBcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICB1cGRhdGVHZW9mZW5jZUFpcmNyYWZ0KGdlb2ZlbmNlQWlyY3JhZnQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBObyBhaXJjcmFmdCBkYXRhIHlldCwgdHJpZ2dlciBhIHNlYXJjaFxyXG4gICAgICAgICAgY29uc29sZS5sb2coJ05vIGFpcmNyYWZ0IGRhdGEgeWV0LCB0cmlnZ2VyaW5nIHNlYXJjaCcpO1xyXG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHByb2Nlc3NHZW9mZW5jZVNlYXJjaCgpO1xyXG4gICAgICAgICAgfSwgMTAwKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gTm8gdmFsaWQgY29vcmRpbmF0ZXNcclxuICAgICAgICBjb25zb2xlLndhcm4oJ05vIHZhbGlkIGNvb3JkaW5hdGVzLCBzaG93aW5nIGFsZXJ0Jyk7XHJcbiAgICAgICAgYWxlcnQoXHJcbiAgICAgICAgICAnUGxlYXNlIHNldCBhIGxvY2F0aW9uIGJlZm9yZSBlbmFibGluZyBnZW9mZW5jZS5cXG5cXG5DbGljayBhbnl3aGVyZSBvbiB0aGUgbWFwIHRvIHNldCBhIGxvY2F0aW9uLidcclxuICAgICAgICApO1xyXG4gICAgICAgIHNldEdlb2ZlbmNlRW5hYmxlZChmYWxzZSk7XHJcbiAgICAgICAgc2V0SXNHZW9mZW5jZUFjdGl2ZShmYWxzZSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIERpc2FibGluZyBnZW9mZW5jZVxyXG4gICAgICBjb25zb2xlLmxvZygnRGlzYWJsaW5nIGdlb2ZlbmNlJyk7XHJcbiAgICAgIHNldEdlb2ZlbmNlRW5hYmxlZChmYWxzZSk7XHJcbiAgICAgIHNldElzR2VvZmVuY2VBY3RpdmUoZmFsc2UpO1xyXG5cclxuICAgICAgLy8gQ2xlYXIgZ2VvZmVuY2UgZGF0YSBpZiBmdW5jdGlvbiBhdmFpbGFibGVcclxuICAgICAgaWYgKHR5cGVvZiBjbGVhckdlb2ZlbmNlRGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIGNsZWFyR2VvZmVuY2VEYXRhKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvLyBNYW51ZmFjdHVyZXIgZmlsdGVyIG1ldGhvZHNcclxuICBjb25zdCBzZWxlY3RNYW51ZmFjdHVyZXJBbmRDbG9zZSA9ICh2YWx1ZTogc3RyaW5nKSA9PiB7XHJcbiAgICAvLyBDbG9zZSBkcm9wZG93blxyXG4gICAgc2V0QWN0aXZlRHJvcGRvd24obnVsbCk7XHJcbiAgICBzZXRNYW51ZmFjdHVyZXJTZWFyY2hUZXJtKCcnKTtcclxuXHJcbiAgICAvLyBJZiBjbGVhcmluZyB0aGUgc2VsZWN0aW9uXHJcbiAgICBpZiAodmFsdWUgPT09ICcnKSB7XHJcbiAgICAgIHNlbGVjdE1hbnVmYWN0dXJlcihudWxsKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNldCB0aGUgbWFudWZhY3R1cmVyIHNlbGVjdGlvblxyXG4gICAgc2VsZWN0TWFudWZhY3R1cmVyKHZhbHVlKTtcclxuXHJcbiAgICAvLyBJZiByZWdpb24gaXMgYWxyZWFkeSBzZWxlY3RlZCwgZmV0Y2ggZmlsdGVyZWQgZGF0YVxyXG4gICAgaWYgKGFjdGl2ZVJlZ2lvbiAhPT0gbnVsbCkge1xyXG4gICAgICBmZXRjaEFpcmNyYWZ0QnlSZWdpb25BbmRNYW51ZmFjdHVyZXIoYWN0aXZlUmVnaW9uIGFzIFJlZ2lvbkNvZGUsIHZhbHVlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIE90aGVyd2lzZSwganVzdCBwcm9jZWVkIHdpdGggbWFudWZhY3R1cmVyLW9ubHkgZmlsdGVyaW5nIGFzIGJlZm9yZVxyXG4gICAgICBmZXRjaE1hbnVmYWN0dXJlckRhdGEodmFsdWUpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGNvbnN0IGZldGNoTWFudWZhY3R1cmVyRGF0YSA9IChtYW51ZmFjdHVyZXI6IHN0cmluZykgPT4ge1xyXG4gICAgaWYgKGlzUmF0ZUxpbWl0ZWQpIHtcclxuICAgICAgY29uc29sZS5sb2coYFNraXBwaW5nIGRhdGEgZmV0Y2ggLSByYXRlIGxpbWl0ZWQgZm9yICR7cmF0ZUxpbWl0VGltZXJ9c2ApO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc29sZS5sb2coYEZldGNoaW5nIGRhdGEgZm9yIG1hbnVmYWN0dXJlcjogJHttYW51ZmFjdHVyZXJ9YCk7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gSWYgeW91IGhhdmUgYSBjb250ZXh0IGZ1bmN0aW9uIGZvciB0aGlzLCBjYWxsIGl0IGFmdGVyIGEgc2xpZ2h0IGRlbGF5XHJcbiAgICAgIGlmICh0eXBlb2YgcmVmcmVzaFBvc2l0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIC8vIEFwcGx5IGEgc21hbGwgZGVsYXkgdG8gcHJldmVudCBvdmVyd2hlbG1pbmcgdGhlIEFQSVxyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgcmVmcmVzaFBvc2l0aW9ucygpLmNhdGNoKChlcnJvcjogYW55KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygncmF0ZSBsaW1pdCcpIHx8IGVycm9yLnN0YXR1cyA9PT0gNDI5KSB7XHJcbiAgICAgICAgICAgICAgaGFuZGxlUmF0ZUxpbWl0KDMwKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBtYW51ZmFjdHVyZXIgZGF0YTonLCBlcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sIDIwMCk7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgICAgaWYgKGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCdyYXRlIGxpbWl0JykgfHwgZXJyb3Iuc3RhdHVzID09PSA0MjkpIHtcclxuICAgICAgICBoYW5kbGVSYXRlTGltaXQoMzApO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHNjaGVkdWxpbmcgbWFudWZhY3R1cmVyIGRhdGEgZmV0Y2g6JywgZXJyb3IpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgZmV0Y2hBaXJjcmFmdEJ5UmVnaW9uQW5kTWFudWZhY3R1cmVyID0gYXN5bmMgKFxyXG4gICAgcmVnaW9uOiBSZWdpb25Db2RlLFxyXG4gICAgbWFudWZhY3R1cmVyOiBzdHJpbmcsXHJcbiAgICBwYWdlOiBudW1iZXIgPSAxLFxyXG4gICAgbGltaXQ6IG51bWJlciA9IDUwMFxyXG4gICkgPT4ge1xyXG4gICAgaWYgKCFyZWdpb24gfHwgIW1hbnVmYWN0dXJlcikge1xyXG4gICAgICBjb25zb2xlLmxvZygnQm90aCByZWdpb24gYW5kIG1hbnVmYWN0dXJlciBtdXN0IGJlIHNlbGVjdGVkJyk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBzZXRMb2NhbExvYWRpbmcodHJ1ZSk7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcclxuICAgICAgICBgL2FwaS90cmFja2luZy9maWx0ZXJlZC1haXJjcmFmdD9yZWdpb249JHtyZWdpb259Jm1hbnVmYWN0dXJlcj0ke2VuY29kZVVSSUNvbXBvbmVudChtYW51ZmFjdHVyZXIpfSZwYWdlPSR7cGFnZX0mbGltaXQ9JHtsaW1pdH1gXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICBjb25zdCBhaXJjcmFmdERhdGEgPSBkYXRhLmFpcmNyYWZ0IHx8IFtdO1xyXG5cclxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQVBJIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFByb2Nlc3MgdGhlIGZpbHRlcmVkIGFpcmNyYWZ0IGRhdGFcclxuICAgICAgaWYgKGFpcmNyYWZ0RGF0YS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgLy8gVHJhbnNmb3JtIHRvIEV4dGVuZGVkQWlyY3JhZnRcclxuICAgICAgICBpbnRlcmZhY2UgQWlyY3JhZnREYXRhIHtcclxuICAgICAgICAgIFRZUEVfQUlSQ1JBRlQ/OiBzdHJpbmc7XHJcbiAgICAgICAgICBPUEVSQVRPUj86IHN0cmluZztcclxuICAgICAgICAgIFJFR0lPTjogbnVtYmVyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgZXh0ZW5kZWRBaXJjcmFmdDogRXh0ZW5kZWRBaXJjcmFmdFtdID0gYWlyY3JhZnREYXRhLm1hcChcclxuICAgICAgICAgIChhaXJjcmFmdDogQWlyY3JhZnREYXRhKSA9PiAoe1xyXG4gICAgICAgICAgICAuLi5haXJjcmFmdCxcclxuICAgICAgICAgICAgdHlwZTogYWlyY3JhZnQuVFlQRV9BSVJDUkFGVCB8fCAnVW5rbm93bicsXHJcbiAgICAgICAgICAgIGlzR292ZXJubWVudDpcclxuICAgICAgICAgICAgICBhaXJjcmFmdC5PUEVSQVRPUj8udG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnZ292ZXJubWVudCcpID8/IGZhbHNlLFxyXG4gICAgICAgICAgICBSRUdJT046IGFpcmNyYWZ0LlJFR0lPTixcclxuICAgICAgICAgICAgem9vbUxldmVsOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgbWFwXHJcbiAgICAgICAgdXBkYXRlR2VvZmVuY2VBaXJjcmFmdChleHRlbmRlZEFpcmNyYWZ0KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgIGBObyBhaXJjcmFmdCBmb3VuZCBmb3IgbWFudWZhY3R1cmVyICR7bWFudWZhY3R1cmVyfSBpbiByZWdpb24gJHtyZWdpb259YFxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGZpbHRlcmVkIGFpcmNyYWZ0OicsIGVycm9yKTtcclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgIHNldExvY2FsTG9hZGluZyhmYWxzZSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLy8gTW9kZWwgc2VsZWN0aW9uIG1ldGhvZHNcclxuICBjb25zdCBoYW5kbGVNb2RlbFNlbGVjdCA9ICh2YWx1ZTogc3RyaW5nKSA9PiB7XHJcbiAgICBzZWxlY3RNb2RlbCh2YWx1ZSA9PT0gJycgPyBudWxsIDogdmFsdWUpO1xyXG4gICAgc2V0QWN0aXZlRHJvcGRvd24obnVsbCk7XHJcblxyXG4gICAgLy8gSWYgaW4gY29tYmluZWQgbW9kZSwgcmVhcHBseSB0aGUgZmlsdGVyXHJcbiAgICBpZiAoZmlsdGVyTW9kZSA9PT0gJ2JvdGgnICYmIGlzR2VvZmVuY2VBY3RpdmUgJiYgc2VsZWN0ZWRNYW51ZmFjdHVyZXIpIHtcclxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgYXBwbHlDb21iaW5lZEZpbHRlcnMoKTtcclxuICAgICAgfSwgMTAwKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvLyBDb21iaW5lZCBmaWx0ZXIgbWV0aG9kc1xyXG4gIGNvbnN0IGFwcGx5Q29tYmluZWRGaWx0ZXJzID0gKCkgPT4ge1xyXG4gICAgaWYgKFxyXG4gICAgICAhc2VsZWN0ZWRNYW51ZmFjdHVyZXIgfHxcclxuICAgICAgIWlzR2VvZmVuY2VBY3RpdmUgfHxcclxuICAgICAgZ2VvZmVuY2VBaXJjcmFmdC5sZW5ndGggPT09IDBcclxuICAgICkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgc2V0TG9jYWxMb2FkaW5nKHRydWUpO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgIGBGaWx0ZXJpbmcgJHtnZW9mZW5jZUFpcmNyYWZ0Lmxlbmd0aH0gYWlyY3JhZnQgYnkgJHtzZWxlY3RlZE1hbnVmYWN0dXJlcn1gXHJcbiAgICAgICk7XHJcblxyXG4gICAgICAvLyBGaWx0ZXIgdGhlIGFpcmNyYWZ0IGJ5IG1hbnVmYWN0dXJlclxyXG4gICAgICBsZXQgZmlsdGVyZWRBaXJjcmFmdCA9IGdlb2ZlbmNlQWlyY3JhZnQuZmlsdGVyKFxyXG4gICAgICAgIChhaXJjcmFmdCkgPT5cclxuICAgICAgICAgIGFpcmNyYWZ0Lk1BTlVGQUNUVVJFUj8udG9Mb3dlckNhc2UoKSA9PT1cclxuICAgICAgICAgIHNlbGVjdGVkTWFudWZhY3R1cmVyLnRvTG93ZXJDYXNlKClcclxuICAgICAgKTtcclxuXHJcbiAgICAgIC8vIEZ1cnRoZXIgZmlsdGVyIGJ5IG1vZGVsIGlmIHNlbGVjdGVkXHJcbiAgICAgIGlmIChzZWxlY3RlZE1vZGVsKSB7XHJcbiAgICAgICAgZmlsdGVyZWRBaXJjcmFmdCA9IGZpbHRlcmVkQWlyY3JhZnQuZmlsdGVyKFxyXG4gICAgICAgICAgKGFpcmNyYWZ0KSA9PlxyXG4gICAgICAgICAgICBhaXJjcmFmdC5NT0RFTD8udG9Mb3dlckNhc2UoKSA9PT0gc2VsZWN0ZWRNb2RlbC50b0xvd2VyQ2FzZSgpXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc29sZS5sb2coYEZvdW5kICR7ZmlsdGVyZWRBaXJjcmFmdC5sZW5ndGh9IG1hdGNoaW5nIGFpcmNyYWZ0YCk7XHJcblxyXG4gICAgICBpZiAoZmlsdGVyZWRBaXJjcmFmdC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICBhbGVydChgTm8gJHtzZWxlY3RlZE1hbnVmYWN0dXJlcn0gYWlyY3JhZnQgZm91bmQgaW4gdGhpcyBhcmVhLmApO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2xlYXIgZGlzcGxheSBkYXRhXHJcbiAgICAgIGlmIChjbGVhckdlb2ZlbmNlRGF0YSkge1xyXG4gICAgICAgIGNsZWFyR2VvZmVuY2VEYXRhKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFVwZGF0ZSB0aGUgZGlzcGxheVxyXG4gICAgICB1cGRhdGVHZW9mZW5jZUFpcmNyYWZ0KGZpbHRlcmVkQWlyY3JhZnQpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmlsdGVyaW5nIGFpcmNyYWZ0OicsIGVycm9yKTtcclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgIHNldExvY2FsTG9hZGluZyhmYWxzZSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLy8gUmVzZXQgYWxsIGZpbHRlcnNcclxuICBjb25zdCBjbGVhckFsbEZpbHRlcnMgPSAoKSA9PiB7XHJcbiAgICBjb25zb2xlLmxvZygnQ2xlYXJpbmcgYWxsIGZpbHRlcnMuLi4nKTtcclxuXHJcbiAgICAvLyAxLiBSZXNldCBmaWx0ZXIgbW9kZVxyXG4gICAgc2V0RmlsdGVyTW9kZSgnbWFudWZhY3R1cmVyJyk7XHJcblxyXG4gICAgLy8gMi4gVW5ibG9jayBBUEkgY2FsbHMgdGhhdCBtaWdodCBoYXZlIGJlZW4gYmxvY2tlZFxyXG4gICAgb3BlblNreVRyYWNraW5nU2VydmljZS5zZXRCbG9ja0FsbEFwaUNhbGxzKGZhbHNlKTtcclxuICAgIHNldEJsb2NrTWFudWZhY3R1cmVyQXBpQ2FsbHMoZmFsc2UpO1xyXG4gICAgc2V0SXNNYW51ZmFjdHVyZXJBcGlCbG9ja2VkKGZhbHNlKTtcclxuXHJcbiAgICAvLyAzLiBDbGVhciBtYW51ZmFjdHVyZXIgc2VsZWN0aW9uXHJcbiAgICBzZWxlY3RNYW51ZmFjdHVyZXIobnVsbCk7XHJcbiAgICBzZWxlY3RNb2RlbChudWxsKTtcclxuXHJcbiAgICAvLyA0LiBDbGVhciBnZW9mZW5jZVxyXG4gICAgc2V0R2VvZmVuY2VMb2NhdGlvbignJyk7XHJcbiAgICBzZXRHZW9mZW5jZUNvb3JkaW5hdGVzKG51bGwpO1xyXG4gICAgc2V0R2VvZmVuY2VBaXJjcmFmdChbXSk7XHJcbiAgICBzZXRHZW9mZW5jZUVuYWJsZWQoZmFsc2UpO1xyXG4gICAgc2V0SXNHZW9mZW5jZUFjdGl2ZShmYWxzZSk7XHJcbiAgICBpZiAodHlwZW9mIGNsZWFyR2VvZmVuY2UgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgY2xlYXJHZW9mZW5jZSgpO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBjbGVhckdlb2ZlbmNlRGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICBjbGVhckdlb2ZlbmNlRGF0YSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIDUuIFJlc2V0IG93bmVyIGZpbHRlcnMgdG8gc2VsZWN0IGFsbFxyXG4gICAgc2V0T3duZXJGaWx0ZXJzKFsuLi5hbGxPd25lclR5cGVzXSk7XHJcblxyXG4gICAgLy8gNi4gQ2xlYXIgcmVnaW9uIGZpbHRlciBwcm9wZXJseVxyXG4gICAgc2V0QWN0aXZlUmVnaW9uKG51bGwpO1xyXG4gICAgc2V0U2VsZWN0ZWRSZWdpb24oUmVnaW9uQ29kZS5HTE9CQUwpO1xyXG5cclxuICAgIC8vIENsZWFyIHJlZ2lvbiBvdXRsaW5lIGZyb20gbWFwXHJcbiAgICBpZiAocmVnaW9uT3V0bGluZSkge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIC8vIEhhbmRsZSBkaWZmZXJlbnQgcG9zc2libGUgb2JqZWN0IHN0cnVjdHVyZXNcclxuICAgICAgICBpZiAodHlwZW9mIHJlZ2lvbk91dGxpbmUucmVtb3ZlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICByZWdpb25PdXRsaW5lLnJlbW92ZSgpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgICAgICByZWdpb25PdXRsaW5lLnJlY3RhbmdsZSAmJlxyXG4gICAgICAgICAgdHlwZW9mIHJlZ2lvbk91dGxpbmUucmVjdGFuZ2xlLnJlbW92ZSA9PT0gJ2Z1bmN0aW9uJ1xyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgcmVnaW9uT3V0bGluZS5yZWN0YW5nbGUucmVtb3ZlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDbGVhciBhbnkgbGFiZWxzIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVnaW9uXHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgcmVnaW9uT3V0bGluZS5sYWJlbCAmJlxyXG4gICAgICAgICAgdHlwZW9mIHJlZ2lvbk91dGxpbmUubGFiZWwucmVtb3ZlID09PSAnZnVuY3Rpb24nXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICByZWdpb25PdXRsaW5lLmxhYmVsLnJlbW92ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZW1vdmluZyByZWdpb24gb3V0bGluZTonLCBlcnJvcik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEFsd2F5cyByZXNldCB0aGUgcmVnaW9uIG91dGxpbmUgc3RhdGVcclxuICAgICAgc2V0UmVnaW9uT3V0bGluZShudWxsKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyA3LiBSZXNldCBtYXAgdmlldyB0byBnbG9iYWxcclxuICAgIGlmIChtYXBJbnN0YW5jZSkge1xyXG4gICAgICAvLyBVc2UgdGhlIHByZWRlZmluZWQgY2VudGVyIGFuZCB6b29tIGxldmVsIGZyb20geW91ciBtYXAgY29uZmlnXHJcbiAgICAgIG1hcEluc3RhbmNlLnNldFZpZXcoTUFQX0NPTkZJRy5DRU5URVIsIE1BUF9DT05GSUcuREVGQVVMVF9aT09NKTtcclxuICAgICAgbWFwSW5zdGFuY2UuaW52YWxpZGF0ZVNpemUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyA4LiBSZXNldCB0byBpbml0aWFsIGFpcmNyYWZ0IGRhdGFcclxuICAgIGlmICh0eXBlb2YgcmVzZXQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgcmVzZXQoKTtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGZ1bGxSZWZyZXNoID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIGZ1bGxSZWZyZXNoKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gOS4gQ2xvc2UgYW55IG9wZW4gZHJvcGRvd25cclxuICAgIHNldEFjdGl2ZURyb3Bkb3duKG51bGwpO1xyXG5cclxuICAgIC8vIDEwLiBSZXNldCByYXRlIGxpbWl0aW5nIHN0YXRlc1xyXG4gICAgc2V0SXNSYXRlTGltaXRlZChmYWxzZSk7XHJcbiAgICBzZXRSYXRlTGltaXRUaW1lcihudWxsKTtcclxuXHJcbiAgICAvLyAxMS4gQ2xlYXIgY29tYmluZWQgbW9kZSBzdGF0ZVxyXG4gICAgc2V0Q29tYmluZWRNb2RlUmVhZHkoZmFsc2UpO1xyXG5cclxuICAgIC8vIDEyLiBSZXNldCBzZWFyY2ggdGVybXNcclxuICAgIHNldE1hbnVmYWN0dXJlclNlYXJjaFRlcm0oJycpO1xyXG5cclxuICAgIC8vIDEzLiBEaXNwYXRjaCBhIGN1c3RvbSBldmVudCB0aGF0IG90aGVyIGNvbXBvbmVudHMgY2FuIGxpc3RlbiBmb3JcclxuICAgIGNvbnN0IGNsZWFyRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ3JpYmJvbi1maWx0ZXJzLWNsZWFyZWQnKTtcclxuICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoY2xlYXJFdmVudCk7XHJcblxyXG4gICAgY29uc29sZS5sb2coJ0FsbCBmaWx0ZXJzIGNsZWFyZWQgc3VjY2Vzc2Z1bGx5Jyk7XHJcbiAgfTtcclxuXHJcbiAgLy8gQ2FsY3VsYXRlIGNvbWJpbmVkIGxvYWRpbmcgc3RhdGVcclxuICBjb25zdCBjb21iaW5lZExvYWRpbmcgPSBsb2NhbExvYWRpbmc7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICAvLyBTdGF0ZVxyXG4gICAgZmlsdGVyTW9kZSxcclxuICAgIGFjdGl2ZURyb3Bkb3duLFxyXG4gICAgc2VsZWN0ZWRNYW51ZmFjdHVyZXIsXHJcbiAgICBzZWxlY3RlZE1vZGVsLFxyXG4gICAgZ2VvZmVuY2VMb2NhdGlvbixcclxuICAgIGdlb2ZlbmNlUmFkaXVzLFxyXG4gICAgaXNHZW9mZW5jZUFjdGl2ZSxcclxuICAgIGdlb2ZlbmNlQ29vcmRpbmF0ZXMsXHJcbiAgICBhY3RpdmVSZWdpb24sXHJcbiAgICBvd25lckZpbHRlcnMsXHJcbiAgICBhbGxPd25lclR5cGVzLFxyXG4gICAgbWFudWZhY3R1cmVyU2VhcmNoVGVybSxcclxuICAgIGNvbWJpbmVkTG9hZGluZyxcclxuICAgIGlzR2V0dGluZ0xvY2F0aW9uLFxyXG4gICAgZHJvcGRvd25SZWZzLFxyXG4gICAgbG9jYWxMb2FkaW5nLFxyXG4gICAgaXNSYXRlTGltaXRlZCxcclxuICAgIHNlbGVjdGVkUmVnaW9uLFxyXG4gICAgaXNSZWZyZXNoaW5nLFxyXG4gICAgaXNHZW9mZW5jZVBsYWNlbWVudE1vZGU6IGZhbHNlLCAvLyBJbml0aWFsaXplIHdpdGggYSBkZWZhdWx0IHZhbHVlXHJcblxyXG4gICAgLy8gTWV0aG9kc1xyXG4gICAgdG9nZ2xlRHJvcGRvd24sXHJcbiAgICB0b2dnbGVGaWx0ZXJNb2RlLFxyXG4gICAgc2VsZWN0TWFudWZhY3R1cmVyQW5kQ2xvc2UsXHJcbiAgICBoYW5kbGVNb2RlbFNlbGVjdCxcclxuICAgIGdldFVzZXJMb2NhdGlvbixcclxuICAgIHByb2Nlc3NHZW9mZW5jZVNlYXJjaCxcclxuICAgIGhhbmRsZU93bmVyRmlsdGVyQ2hhbmdlLFxyXG4gICAgaGFuZGxlUmVnaW9uU2VsZWN0LFxyXG4gICAgc2V0TWFudWZhY3R1cmVyU2VhcmNoVGVybSxcclxuICAgIHNldEdlb2ZlbmNlTG9jYXRpb24sXHJcbiAgICBzZXRHZW9mZW5jZVJhZGl1cyxcclxuICAgIHRvZ2dsZUdlb2ZlbmNlU3RhdGUsXHJcbiAgICBjbGVhckFsbEZpbHRlcnMsXHJcbiAgICBhcHBseUNvbWJpbmVkRmlsdGVycyxcclxuICAgIGdldEFpcmNyYWZ0T3duZXJUeXBlLFxyXG5cclxuICAgIHJlZnJlc2hXaXRoRmlsdGVyczogKCkgPT4ge1xyXG4gICAgICAvLyBJbXBsZW1lbnQgcmVmcmVzaCBsb2dpYyBoZXJlXHJcbiAgICAgIGlmICh0eXBlb2YgcmVmcmVzaFBvc2l0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHJlZnJlc2hQb3NpdGlvbnMoKS5jYXRjaCgoZXJyb3IpID0+IHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlZnJlc2hpbmcgcG9zaXRpb25zOicsIGVycm9yKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIHNldEFjdGl2ZURyb3Bkb3duLCAvLyBBZGQgdGhpcyBsaW5lIGlmIHlvdSBoYXZlIHRoaXMgZnVuY3Rpb25cclxuXHJcbiAgICBzZXRHZW9mZW5jZUNvb3JkaW5hdGVzLFxyXG4gICAgc2V0R2VvZmVuY2VDZW50ZXIsXHJcbiAgICB1cGRhdGVHZW9mZW5jZUFpcmNyYWZ0LFxyXG4gIH07XHJcbn1cclxuIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlUmVmIiwidXNlRWZmZWN0IiwiUmVhY3QiLCJSZWdpb25Db2RlIiwidXNlRW5oYW5jZWRNYXBDb250ZXh0Iiwib3BlblNreVRyYWNraW5nU2VydmljZSIsIk1hcGJveFNlcnZpY2UiLCJhZGFwdEdlb2ZlbmNlQWlyY3JhZnQiLCJlbnJpY2hHZW9mZW5jZUFpcmNyYWZ0IiwiZ2V0QWlyY3JhZnROZWFyTG9jYXRpb24iLCJnZXRBaXJjcmFmdE5lYXJTZWFyY2hlZExvY2F0aW9uIiwidXNlR2VvbG9jYXRpb24iLCJNQVBfQ09ORklHIiwiZ2V0Qm91bmRzQnlSZWdpb24iLCJnZXRab29tTGV2ZWxGb3JSZWdpb24iLCJ1c2VGaWx0ZXJMb2dpYyIsInNlbGVjdGVkTWFudWZhY3R1cmVyIiwic2VsZWN0ZWRNb2RlbCIsInRvdGFsQWN0aXZlIiwic2VsZWN0TWFudWZhY3R1cmVyIiwic2VsZWN0TW9kZWwiLCJyZXNldCIsImZ1bGxSZWZyZXNoIiwicmVmcmVzaFBvc2l0aW9ucyIsIm1hcEluc3RhbmNlIiwidXBkYXRlQWlyY3JhZnREYXRhIiwiY2xlYXJHZW9mZW5jZURhdGEiLCJ1cGRhdGVHZW9mZW5jZUFpcmNyYWZ0IiwiYmxvY2tNYW51ZmFjdHVyZXJBcGlDYWxscyIsInNldEJsb2NrTWFudWZhY3R1cmVyQXBpQ2FsbHMiLCJpc01hbnVmYWN0dXJlckFwaUJsb2NrZWQiLCJzZXRJc01hbnVmYWN0dXJlckFwaUJsb2NrZWQiLCJnZW9mZW5jZUNlbnRlciIsInNldEdlb2ZlbmNlQ2VudGVyIiwidG9nZ2xlR2VvZmVuY2UiLCJjbGVhckdlb2ZlbmNlIiwiZGlzcGxheWVkQWlyY3JhZnQiLCJnZXRDdXJyZW50UG9zaXRpb24iLCJsb2NhbExvYWRpbmciLCJzZXRMb2NhbExvYWRpbmciLCJmaWx0ZXJNb2RlIiwic2V0RmlsdGVyTW9kZSIsImFjdGl2ZURyb3Bkb3duIiwic2V0QWN0aXZlRHJvcGRvd24iLCJtYW51ZmFjdHVyZXJTZWFyY2hUZXJtIiwic2V0TWFudWZhY3R1cmVyU2VhcmNoVGVybSIsImlzUmVmcmVzaGluZyIsInNldElzUmVmcmVzaGluZyIsImlzUmF0ZUxpbWl0ZWQiLCJzZXRJc1JhdGVMaW1pdGVkIiwicmF0ZUxpbWl0VGltZXIiLCJzZXRSYXRlTGltaXRUaW1lciIsImlzR2VvZmVuY2VQYW5lbE9wZW4iLCJzZXRJc0dlb2ZlbmNlUGFuZWxPcGVuIiwiaXNHZXR0aW5nTG9jYXRpb24iLCJzZXRJc0dldHRpbmdMb2NhdGlvbiIsImdlb2ZlbmNlTG9jYXRpb24iLCJzZXRHZW9mZW5jZUxvY2F0aW9uIiwiZ2VvZmVuY2VSYWRpdXMiLCJzZXRHZW9mZW5jZVJhZGl1cyIsImdlb2ZlbmNlQ29vcmRpbmF0ZXMiLCJzZXRHZW9mZW5jZUNvb3JkaW5hdGVzIiwiZ2VvZmVuY2VBaXJjcmFmdCIsInNldEdlb2ZlbmNlQWlyY3JhZnQiLCJnZW9mZW5jZUVuYWJsZWQiLCJzZXRHZW9mZW5jZUVuYWJsZWQiLCJpc0dlb2ZlbmNlQWN0aXZlIiwic2V0SXNHZW9mZW5jZUFjdGl2ZSIsImlzU2VhcmNoUmVhZHkiLCJzZXRJc1NlYXJjaFJlYWR5IiwiYWN0aXZlUmVnaW9uIiwic2V0QWN0aXZlUmVnaW9uIiwicmVnaW9uT3V0bGluZSIsInNldFJlZ2lvbk91dGxpbmUiLCJzZWxlY3RlZFJlZ2lvbiIsInNldFNlbGVjdGVkUmVnaW9uIiwiR0xPQkFMIiwiY29tYmluZWRNb2RlUmVhZHkiLCJzZXRDb21iaW5lZE1vZGVSZWFkeSIsImFsbE93bmVyVHlwZXMiLCJvd25lckZpbHRlcnMiLCJzZXRPd25lckZpbHRlcnMiLCJkcm9wZG93blJlZnMiLCJmaWx0ZXIiLCJtYW51ZmFjdHVyZXIiLCJtb2RlbCIsImxvY2F0aW9uIiwicmVnaW9uIiwib3duZXIiLCJhY3Rpb25zIiwidGltZXIiLCJzZXRUaW1lb3V0IiwiY29uc29sZSIsImxvZyIsImNsZWFyVGltZW91dCIsImhhbmRsZUNsaWNrT3V0c2lkZSIsImV2ZW50IiwiaXNPdXRzaWRlQWxsIiwiT2JqZWN0IiwidmFsdWVzIiwiZXZlcnkiLCJyZWYiLCJjdXJyZW50IiwiY29udGFpbnMiLCJ0YXJnZXQiLCJkb2N1bWVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicmVtb3ZlIiwiaGFuZGxlTWFwR2VvZmVuY2VDbGljayIsImN1c3RvbUV2ZW50IiwibGF0IiwibG5nIiwiZGV0YWlsIiwidG9GaXhlZCIsImxvY2F0aW9uTmFtZSIsImdldExvY2F0aW9uTmFtZUZyb21Db29yZGluYXRlcyIsImVycm9yIiwidG9nZ2xlRHJvcGRvd24iLCJ0eXBlIiwic3RvcFByb3BhZ2F0aW9uIiwicHJldlN0YXRlIiwiaGFuZGxlUmF0ZUxpbWl0IiwicmV0cnlBZnRlciIsInNldEJsb2NrQWxsQXBpQ2FsbHMiLCJhbGVydCIsInRvZ2dsZUZpbHRlck1vZGUiLCJtb2RlIiwibGVuZ3RoIiwiZmlsdGVyQWlyY3JhZnRCeVJlZ2lvbiIsInRvU3RyaW5nIiwiYWlyY3JhZnRXaXRoVmFsaWRDb29yZHMiLCJwbGFuZSIsImxhdGl0dWRlIiwibG9uZ2l0dWRlIiwiaXNOYU4iLCJmaWx0ZXJlZEJ5T3duZXIiLCJhaXJjcmFmdCIsImluY2x1ZGVzIiwiZ2V0QWlyY3JhZnRPd25lclR5cGUiLCJhcHBseUNvbWJpbmVkRmlsdGVycyIsIm93bmVyVHlwZSIsIlRZUEVfUkVHSVNUUkFOVCIsIm93bmVyVHlwZVRvU3RyaW5nIiwidHlwZU51bSIsInBhcnNlSW50Iiwib3duZXJUeXBlTWFwIiwiYXBwbHlPd25lclR5cGVGaWx0ZXIiLCJmaWx0ZXJzIiwiZmlsdGVyZWRBaXJjcmFmdCIsImhhbmRsZU93bmVyRmlsdGVyQ2hhbmdlIiwidXBkYXRlZEZpbHRlcnMiLCJyZXNldE93bmVyRmlsdGVycyIsImJvdW5kc0V4cHJlc3Npb24iLCJBcnJheSIsImlzQXJyYXkiLCJtaW5MYXQiLCJtaW5MbmciLCJtYXhMYXQiLCJtYXhMbmciLCJoYW5kbGVSZWdpb25TZWxlY3QiLCJib3VuZHMiLCJ6b29tTGV2ZWwiLCJzZXRab29tIiwib3B0aW9ucyIsInBhZGRpbmciLCJQQURESU5HIiwiREVGQVVMVCIsImZpdEJvdW5kcyIsImludmFsaWRhdGVTaXplIiwiZHJhd1JlZ2lvbk91dGxpbmUiLCJjb3VudFJlc3BvbnNlIiwiZmV0Y2giLCJvayIsImNvdW50RGF0YSIsImpzb24iLCJjb3VudCIsIkwiLCJyZXF1aXJlIiwicmVjdGFuZ2xlIiwiY29sb3IiLCJ3ZWlnaHQiLCJvcGFjaXR5IiwiZmlsbCIsImZpbGxDb2xvciIsImZpbGxPcGFjaXR5IiwiZGFzaEFycmF5IiwiaW50ZXJhY3RpdmUiLCJhZGRUbyIsImdldFVzZXJMb2NhdGlvbiIsInBvc2l0aW9uIiwiY29vcmRzIiwiZmV0Y2hlZEFpcmNyYWZ0IiwiYWRhcHRlZEFpcmNyYWZ0IiwiZW5yaWNoZWRBaXJjcmFmdCIsImN1cnJlbnRab29tIiwiZ2V0Wm9vbSIsInRhcmdldFpvb20iLCJzZXRWaWV3IiwibWVzc2FnZSIsInN0YXR1cyIsInByb2Nlc3NHZW9mZW5jZVNlYXJjaCIsImxvY2F0aW9ucyIsInNlYXJjaExvY2F0aW9uV2l0aE1hcGJveCIsImNvb3JkaW5hdGVzIiwibmFtZSIsIkVycm9yIiwiTUFOVUZBQ1RVUkVSIiwidW5kZWZpbmVkIiwidG9nZ2xlR2VvZmVuY2VTdGF0ZSIsImVuYWJsZWQiLCJ3YXJuIiwic2VsZWN0TWFudWZhY3R1cmVyQW5kQ2xvc2UiLCJ2YWx1ZSIsImZldGNoQWlyY3JhZnRCeVJlZ2lvbkFuZE1hbnVmYWN0dXJlciIsImZldGNoTWFudWZhY3R1cmVyRGF0YSIsImNhdGNoIiwicGFnZSIsImxpbWl0IiwicmVzcG9uc2UiLCJlbmNvZGVVUklDb21wb25lbnQiLCJkYXRhIiwiYWlyY3JhZnREYXRhIiwic3RhdHVzVGV4dCIsImV4dGVuZGVkQWlyY3JhZnQiLCJtYXAiLCJUWVBFX0FJUkNSQUZUIiwiaXNHb3Zlcm5tZW50IiwiT1BFUkFUT1IiLCJ0b0xvd2VyQ2FzZSIsIlJFR0lPTiIsImhhbmRsZU1vZGVsU2VsZWN0IiwiTU9ERUwiLCJjbGVhckFsbEZpbHRlcnMiLCJsYWJlbCIsIkNFTlRFUiIsIkRFRkFVTFRfWk9PTSIsImNsZWFyRXZlbnQiLCJDdXN0b21FdmVudCIsImRpc3BhdGNoRXZlbnQiLCJjb21iaW5lZExvYWRpbmciLCJpc0dlb2ZlbmNlUGxhY2VtZW50TW9kZSIsInJlZnJlc2hXaXRoRmlsdGVycyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/tracking/hooks/useFilterLogic.ts\n"));

/***/ })

});
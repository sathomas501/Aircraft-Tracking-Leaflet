"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_pages-dir-browser_components_tracking_map_AircraftTrackingMap_tsx",{

/***/ "(pages-dir-browser)/./components/tracking/hooks/useFilterLogic.ts":
/*!*****************************************************!*\
  !*** ./components/tracking/hooks/useFilterLogic.ts ***!
  \*****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useFilterLogic: () => (/* binding */ useFilterLogic)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _types_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/types/base */ \"(pages-dir-browser)/./types/base.ts\");\n/* harmony import */ var _context_EnhancedMapContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../context/EnhancedMapContext */ \"(pages-dir-browser)/./components/tracking/context/EnhancedMapContext.tsx\");\n/* harmony import */ var _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/services/openSkyTrackingService */ \"(pages-dir-browser)/./lib/services/openSkyTrackingService.ts\");\n/* harmony import */ var _lib_services_MapboxService__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../lib/services/MapboxService */ \"(pages-dir-browser)/./lib/services/MapboxService.ts\");\n/* harmony import */ var _lib_utils_geofenceAdapter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/lib/utils/geofenceAdapter */ \"(pages-dir-browser)/./lib/utils/geofenceAdapter.ts\");\n/* harmony import */ var _lib_utils_geofenceEnricher__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/lib/utils/geofenceEnricher */ \"(pages-dir-browser)/./lib/utils/geofenceEnricher.ts\");\n/* harmony import */ var _hooks_useGeolocationServices__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../hooks/useGeolocationServices */ \"(pages-dir-browser)/./components/tracking/hooks/useGeolocationServices.ts\");\n/* harmony import */ var _lib_services_geofencing__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../lib/services/geofencing */ \"(pages-dir-browser)/./lib/services/geofencing.ts\");\n/* harmony import */ var _hooks_useGeolocation__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../hooks/useGeolocation */ \"(pages-dir-browser)/./components/tracking/hooks/useGeolocation.ts\");\n/* harmony import */ var _config_map__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../config/map */ \"(pages-dir-browser)/./config/map.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\nfunction useFilterLogic() {\n    // Get context state and functions\n    const { selectedManufacturer, selectedModel, totalActive, selectManufacturer, selectModel, reset, fullRefresh, refreshPositions, mapInstance, updateAircraftData, clearGeofenceData, updateGeofenceAircraft, blockManufacturerApiCalls, setBlockManufacturerApiCalls, isManufacturerApiBlocked, setIsManufacturerApiBlocked, geofenceCenter, setGeofenceCenter, toggleGeofence, clearGeofence, displayedAircraft } = (0,_context_EnhancedMapContext__WEBPACK_IMPORTED_MODULE_2__.useEnhancedMapContext)();\n    // Use our combined geolocation services hook\n    const geolocationServices = (0,_hooks_useGeolocationServices__WEBPACK_IMPORTED_MODULE_7__.useGeolocationServices)();\n    // Local state\n    const [localLoading, setLocalLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [filterMode, setFilterMode] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [activeDropdown, setActiveDropdown] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [manufacturerSearchTerm, setManufacturerSearchTerm] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)('');\n    const [isRefreshing, setIsRefreshing] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [isRateLimited, setIsRateLimited] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [rateLimitTimer, setRateLimitTimer] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    // Geofence state\n    const [isGettingLocation, setIsGettingLocation] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [geofenceLocation, setGeofenceLocation] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)('');\n    const [geofenceRadius, setGeofenceRadius] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(25);\n    const [geofenceCoordinates, setGeofenceCoordinates] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [geofenceAircraft, setGeofenceAircraft] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [geofenceEnabled, setGeofenceEnabled] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [isGeofenceActive, setIsGeofenceActive] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [isSearchReady, setIsSearchReady] = react__WEBPACK_IMPORTED_MODULE_0___default().useState(false);\n    // Region state\n    const [activeRegion, setActiveRegion] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [regionOutline, setRegionOutline] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [selectedRegion, setSelectedRegion] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(_types_base__WEBPACK_IMPORTED_MODULE_1__.RegionCode.GLOBAL);\n    // Combined mode state\n    const [combinedModeReady, setCombinedModeReady] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    // Owner filter state\n    const allOwnerTypes = [\n        'individual',\n        'partnership',\n        'corp-owner',\n        'co-owned',\n        'llc',\n        'non-citizen-corp',\n        'airline',\n        'freight',\n        'medical',\n        'media',\n        'historical',\n        'flying-club',\n        'emergency',\n        'local-govt',\n        'education',\n        'federal-govt',\n        'flight-school',\n        'leasing-corp',\n        'military',\n        'unknown'\n    ];\n    const [ownerFilters, setOwnerFilters] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([\n        ...allOwnerTypes\n    ]);\n    // Refs for dropdown handling\n    const dropdownRefs = {\n        filter: (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),\n        manufacturer: (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),\n        model: (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),\n        location: (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),\n        region: (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),\n        owner: (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),\n        actions: (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null)\n    };\n    // Get geolocation hook - use the entire hook instance\n    const geolocation = (0,_hooks_useGeolocation__WEBPACK_IMPORTED_MODULE_9__.useGeolocation)(null);\n    // Effects\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect({\n        \"useFilterLogic.useEffect\": ()=>{\n            if (geofenceCoordinates) {\n                setIsSearchReady(true);\n            }\n        }\n    }[\"useFilterLogic.useEffect\"], [\n        geofenceCoordinates\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useFilterLogic.useEffect\": ()=>{\n            if (isRateLimited && rateLimitTimer) {\n                const timer = setTimeout({\n                    \"useFilterLogic.useEffect.timer\": ()=>{\n                        setIsRateLimited(false);\n                        setRateLimitTimer(null);\n                        console.log('Rate limit timer expired, resuming API calls');\n                    }\n                }[\"useFilterLogic.useEffect.timer\"], rateLimitTimer * 1000);\n                return ({\n                    \"useFilterLogic.useEffect\": ()=>clearTimeout(timer)\n                })[\"useFilterLogic.useEffect\"];\n            }\n        }\n    }[\"useFilterLogic.useEffect\"], [\n        isRateLimited,\n        rateLimitTimer\n    ]);\n    // Effect to sync geofence state\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useFilterLogic.useEffect\": ()=>{\n            // Update internal state when geofence is toggled externally\n            if (isGeofenceActive !== geofenceEnabled) {\n                setGeofenceEnabled(isGeofenceActive);\n            }\n        }\n    }[\"useFilterLogic.useEffect\"], [\n        isGeofenceActive\n    ]);\n    // Close dropdown when clicking outside\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useFilterLogic.useEffect\": ()=>{\n            const handleClickOutside = {\n                \"useFilterLogic.useEffect.handleClickOutside\": (event)=>{\n                    // Check if click is outside of all dropdowns\n                    const isOutsideAll = Object.values(dropdownRefs).every({\n                        \"useFilterLogic.useEffect.handleClickOutside.isOutsideAll\": (ref)=>!ref.current || !ref.current.contains(event.target)\n                    }[\"useFilterLogic.useEffect.handleClickOutside.isOutsideAll\"]);\n                    if (isOutsideAll) {\n                        setActiveDropdown(null);\n                    }\n                }\n            }[\"useFilterLogic.useEffect.handleClickOutside\"];\n            document.addEventListener('mousedown', handleClickOutside);\n            return ({\n                \"useFilterLogic.useEffect\": ()=>{\n                    document.removeEventListener('mousedown', handleClickOutside);\n                }\n            })[\"useFilterLogic.useEffect\"];\n        }\n    }[\"useFilterLogic.useEffect\"], []);\n    // Clean up region outline when component unmounts\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useFilterLogic.useEffect\": ()=>{\n            return ({\n                \"useFilterLogic.useEffect\": ()=>{\n                    if (regionOutline) {\n                        regionOutline.remove();\n                    }\n                }\n            })[\"useFilterLogic.useEffect\"];\n        }\n    }[\"useFilterLogic.useEffect\"], [\n        regionOutline\n    ]);\n    // Effect to handle map click for geofence\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useFilterLogic.useEffect\": ()=>{\n            const handleMapGeofenceClick = {\n                \"useFilterLogic.useEffect.handleMapGeofenceClick\": async (event)=>{\n                    try {\n                        // Cast the event to the proper type\n                        const customEvent = event;\n                        const { lat, lng } = customEvent.detail;\n                        // First update coordinates immediately\n                        setGeofenceCoordinates({\n                            lat,\n                            lng\n                        });\n                        // Then start an async operation to get the location name\n                        console.log(\"Getting location name for: \".concat(lat, \", \").concat(lng));\n                        // Temporarily show coordinates while fetching the name\n                        setGeofenceLocation(\"\".concat(lat.toFixed(6), \", \").concat(lng.toFixed(6)));\n                        // Get the friendly name asynchronously\n                        const locationName = await _lib_services_MapboxService__WEBPACK_IMPORTED_MODULE_4__.MapboxService.getLocationNameFromCoordinates(lat, lng);\n                        console.log(\"Got location name: \".concat(locationName));\n                        // Update with the friendly name once we have it\n                        if (locationName !== null) {\n                            setGeofenceLocation(locationName);\n                        }\n                        // Open the location dropdown if needed\n                        if (activeDropdown !== 'location') {\n                            setActiveDropdown('location');\n                        }\n                    } catch (error) {\n                        console.error('Error handling map click:', error);\n                    // Keep the coordinates display if there was an error\n                    }\n                }\n            }[\"useFilterLogic.useEffect.handleMapGeofenceClick\"];\n            // Add the event listener - use the standard event listener pattern\n            document.addEventListener('map-geofence-click', handleMapGeofenceClick);\n            // Clean up\n            return ({\n                \"useFilterLogic.useEffect\": ()=>{\n                    document.removeEventListener('map-geofence-click', handleMapGeofenceClick);\n                }\n            })[\"useFilterLogic.useEffect\"];\n        }\n    }[\"useFilterLogic.useEffect\"], [\n        setGeofenceLocation,\n        setGeofenceCoordinates,\n        setActiveDropdown,\n        activeDropdown\n    ]);\n    // Main methods\n    const toggleDropdown = (dropdown, event)=>{\n        if (activeDropdown === dropdown) {\n            setActiveDropdown(null);\n        } else {\n            setActiveDropdown(dropdown);\n        }\n        // Prevent events from bubbling up\n        event.stopPropagation();\n    };\n    const handleRateLimit = function() {\n        let retryAfter = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 30;\n        setIsRateLimited(true);\n        setRateLimitTimer(retryAfter);\n        console.log(\"Rate limited by API. Retry after \".concat(retryAfter, \"s\"));\n        // Block all API calls\n        _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].setBlockAllApiCalls(true);\n        setBlockManufacturerApiCalls(true);\n        // Show notification to user\n        if (retryAfter > 0) {\n            alert(\"Aircraft data refresh rate limited. Please wait \".concat(retryAfter, \" seconds before trying again.\"));\n        }\n    };\n    /**\r\n   * Toggle filter mode\r\n   */ const toggleFilterMode = (mode)=>{\n        setFilterMode(mode);\n        setActiveDropdown(null);\n        // Apply appropriate filters based on new mode\n        if (mode === 'region') {\n            // Block API calls in region mode\n            _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].setBlockAllApiCalls(true);\n            // Apply region filtering if we already have data\n            if (displayedAircraft && displayedAircraft.length > 0) {\n                filterAircraftByRegion(selectedRegion.toString());\n            }\n            // Clear manufacturer selection from the UI\n            selectManufacturer(null);\n            selectModel(null);\n            // If geofence is active, restore the full geofence data\n            if (geofenceCoordinates && geofenceAircraft.length > 0) {\n                updateGeofenceAircraft(geofenceAircraft);\n            }\n        } else if (mode === 'owner') {\n            // Filter displayed aircraft by owner type\n            if (displayedAircraft && displayedAircraft.length > 0) {\n                // First filter for valid coordinates\n                const aircraftWithValidCoords = displayedAircraft.filter((plane)=>typeof plane.latitude === 'number' && typeof plane.longitude === 'number' && !isNaN(plane.latitude) && !isNaN(plane.longitude));\n                // Apply owner type filter\n                let filteredByOwner = ownerFilters.length === 0 ? aircraftWithValidCoords : aircraftWithValidCoords.filter((aircraft)=>ownerFilters.includes(getAircraftOwnerType(aircraft)));\n                // Update display with filtered aircraft\n                if (clearGeofenceData) {\n                    clearGeofenceData();\n                }\n                updateGeofenceAircraft(filteredByOwner);\n            }\n        } else if (mode === 'both') {\n            // Both mode - BLOCK API CALLS\n            _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].setBlockAllApiCalls(true);\n            if (selectedManufacturer && isGeofenceActive && geofenceAircraft.length > 0) {\n                applyCombinedFilters();\n            } else {\n                // If one is missing, prompt the user\n                if (!selectedManufacturer && isGeofenceActive) {\n                    alert('Please select a manufacturer to use combined filter mode');\n                } else if (selectedManufacturer && !isGeofenceActive) {\n                    alert('Please set a location to use combined filter mode');\n                } else {\n                    alert('Please select both a manufacturer and location to use combined filter mode');\n                }\n            }\n        }\n    };\n    // Owner filter methods\n    const getAircraftOwnerType = (aircraft)=>{\n        const ownerType = aircraft.TYPE_REGISTRANT || 0;\n        return ownerTypeToString(ownerType);\n    };\n    const ownerTypeToString = (type)=>{\n        const typeNum = typeof type === 'string' ? parseInt(type, 10) : type;\n        const ownerTypeMap = {\n            1: 'individual',\n            2: 'partnership',\n            3: 'corp-owner',\n            4: 'co-owned',\n            7: 'llc',\n            8: 'non-citizen-corp',\n            9: 'airline',\n            10: 'freight',\n            11: 'medical',\n            12: 'media',\n            13: 'historical',\n            14: 'flying-club',\n            15: 'emergency',\n            16: 'local-govt',\n            17: 'education',\n            18: 'federal-govt',\n            19: 'flight-school',\n            20: 'leasing-corp',\n            21: 'military'\n        };\n        return ownerTypeMap[typeNum] || 'unknown';\n    };\n    const applyOwnerTypeFilter = (filters)=>{\n        // Skip filtering if all types are selected or none are selected\n        if (filters.length === 0 || filters.length === allOwnerTypes.length) {\n            return;\n        }\n        // Filter the aircraft based on selected owner types\n        if (displayedAircraft && displayedAircraft.length > 0) {\n            const filteredAircraft = displayedAircraft.filter((aircraft)=>{\n                const ownerType = getAircraftOwnerType(aircraft);\n                return filters.includes(ownerType);\n            });\n            // Update the displayed aircraft\n            if (clearGeofenceData) {\n                clearGeofenceData();\n            }\n            updateGeofenceAircraft(filteredAircraft);\n        }\n    };\n    const handleOwnerFilterChange = (updatedFilters)=>{\n        setOwnerFilters(updatedFilters);\n        // Apply the filter to your aircraft data\n        applyOwnerTypeFilter(updatedFilters);\n    };\n    const resetOwnerFilters = ()=>{\n        setOwnerFilters([\n            ...allOwnerTypes\n        ]);\n    };\n    // Region filter methods\n    const filterAircraftByRegion = (region)=>{\n        if (!displayedAircraft || displayedAircraft.length === 0) return;\n        setLocalLoading(true);\n        try {\n            // Get the bounds for the selected region\n            const boundsExpression = (0,_config_map__WEBPACK_IMPORTED_MODULE_10__.getBoundsByRegion)(region);\n            // Ensure bounds is in the correct format\n            if (!Array.isArray(boundsExpression) || boundsExpression.length !== 2) {\n                console.error(\"Invalid bounds format for region: \".concat(region), boundsExpression);\n                setLocalLoading(false);\n                return;\n            }\n            // Extract coordinates - Leaflet uses [lat, lng] format\n            const [[minLat, minLng], [maxLat, maxLng]] = boundsExpression;\n            console.log(\"Filtering by region: \".concat(region, \" with bounds:\"), {\n                minLat,\n                minLng,\n                maxLat,\n                maxLng\n            });\n            // Filter aircraft based on coordinates within the bounds\n            const filteredAircraft = displayedAircraft.filter((aircraft)=>{\n                // Check if aircraft has valid coordinates\n                if (typeof aircraft.latitude !== 'number' || typeof aircraft.longitude !== 'number' || isNaN(aircraft.latitude) || isNaN(aircraft.longitude)) {\n                    return false;\n                }\n                // Check if coordinates are within the bounds\n                return aircraft.latitude >= minLat && aircraft.latitude <= maxLat && aircraft.longitude >= minLng && aircraft.longitude <= maxLng;\n            });\n            // Update the display with filtered aircraft\n            if (clearGeofenceData) {\n                clearGeofenceData();\n            }\n            updateGeofenceAircraft(filteredAircraft);\n            console.log(\"Filtered to \".concat(filteredAircraft.length, \" aircraft in \").concat(region, \" region (out of \").concat(displayedAircraft.length, \" total)\"));\n        } catch (error) {\n            console.error('Error filtering aircraft by region:', error);\n        } finally{\n            setLocalLoading(false);\n        }\n    };\n    const handleRegionSelect = async (region)=>{\n        setActiveRegion(region);\n        setSelectedRegion(region);\n        setLocalLoading(true);\n        try {\n            // Set map bounds based on region\n            if (mapInstance) {\n                const bounds = (0,_config_map__WEBPACK_IMPORTED_MODULE_10__.getBoundsByRegion)(region);\n                // Get the appropriate zoom level for this region from your config\n                const zoomLevel = (0,_config_map__WEBPACK_IMPORTED_MODULE_10__.getZoomLevelForRegion)(region);\n                // First, set the appropriate zoom level\n                mapInstance.setZoom(zoomLevel);\n                // Then fit bounds with padding\n                const options = {\n                    padding: _config_map__WEBPACK_IMPORTED_MODULE_10__.MAP_CONFIG.PADDING.DEFAULT\n                };\n                mapInstance.fitBounds(bounds, options);\n                mapInstance.invalidateSize();\n                drawRegionOutline(region);\n            }\n            // Instead of immediately fetching aircraft data,\n            // just store the region selection for later use\n            console.log(\"Region selected. Waiting for manufacturer selection...\");\n            // Optionally, you could fetch just the count of aircraft in this region\n            // to give the user an idea of the data volume\n            const countResponse = await fetch(\"/api/tracking/region-count?region=\".concat(region));\n            if (countResponse.ok) {\n                const countData = await countResponse.json();\n                console.log(\"\".concat(countData.count, \" aircraft available in this region\"));\n            }\n            // Clear any previous aircraft data\n            if (clearGeofenceData) {\n                clearGeofenceData();\n            }\n        } catch (error) {\n            console.error('Error in region selection:', error);\n        } finally{\n            setLocalLoading(false);\n            setActiveDropdown(null);\n        }\n    };\n    const drawRegionOutline = (region)=>{\n        if (!mapInstance) return;\n        // Clear any existing outline\n        if (regionOutline) {\n            regionOutline.remove();\n        }\n        // Get the bounds for the selected region\n        const bounds = (0,_config_map__WEBPACK_IMPORTED_MODULE_10__.getBoundsByRegion)(region);\n        // Create a polygon from the bounds\n        const L = __webpack_require__(/*! leaflet */ \"(pages-dir-browser)/./node_modules/leaflet/dist/leaflet-src.js\");\n        const rectangle = L.rectangle(bounds, {\n            color: '#4f46e5',\n            weight: 3,\n            opacity: 0.7,\n            fill: true,\n            fillColor: '#4f46e5',\n            fillOpacity: 0.1,\n            dashArray: '5, 10',\n            interactive: false\n        });\n        // Add to map\n        rectangle.addTo(mapInstance);\n        // Update the state to include both the rectangle and the label\n        setRegionOutline({\n            remove: ()=>{\n                rectangle.remove();\n            }\n        });\n    };\n    // Geofence methods\n    // Fixed getUserLocation function\n    const getUserLocation = async ()=>{\n        if (isRateLimited) {\n            alert(\"Rate limited. Please wait \".concat(rateLimitTimer || 30, \" seconds before trying to get location.\"));\n            return;\n        }\n        const getUserLocation = async ()=>{\n            if (isRateLimited) {\n                alert(\"Rate limited. Please wait \".concat(rateLimitTimer || 30, \" seconds before trying to get location.\"));\n                return;\n            }\n            setIsGettingLocation(true);\n            try {\n                // Use the getCurrentPosition from our combined hook\n                const position = await geolocationServices.getCurrentPosition();\n                if (position) {\n                    const { latitude, longitude } = position.coords;\n                    // Update state with coordinates\n                    setGeofenceCoordinates({\n                        lat: latitude,\n                        lng: longitude\n                    });\n                    setGeofenceCenter({\n                        lat: latitude,\n                        lng: longitude\n                    });\n                    // Update the location display with coordinates\n                    setGeofenceLocation(\"\".concat(latitude.toFixed(6), \", \").concat(longitude.toFixed(6)));\n                    // Automatically trigger the geofence search\n                    try {\n                        const fetchedAircraft = await (0,_lib_services_geofencing__WEBPACK_IMPORTED_MODULE_8__.getAircraftNearLocation)(latitude, longitude, geofenceRadius);\n                        if (fetchedAircraft.length === 0) {\n                            alert(\"No aircraft found near your current location. Try increasing the radius.\");\n                            setIsGettingLocation(false);\n                            return;\n                        }\n                        // Process the aircraft data\n                        const adaptedAircraft = (0,_lib_utils_geofenceAdapter__WEBPACK_IMPORTED_MODULE_5__.adaptGeofenceAircraft)(fetchedAircraft);\n                        const enrichedAircraft = await (0,_lib_utils_geofenceEnricher__WEBPACK_IMPORTED_MODULE_6__.enrichGeofenceAircraft)(adaptedAircraft);\n                        // Save to local state\n                        setGeofenceAircraft(enrichedAircraft);\n                        // Clear existing aircraft data\n                        if (clearGeofenceData) {\n                            clearGeofenceData();\n                        }\n                        // Update the map with new aircraft\n                        updateGeofenceAircraft(enrichedAircraft);\n                        setIsGeofenceActive(true);\n                        // Center the map on user's location - SIMPLIFIED ZOOM LOGIC\n                        if (mapInstance) {\n                            // Don't modify zoom if it's already at an appropriate level\n                            const currentZoom = mapInstance.getZoom();\n                            const targetZoom = currentZoom <= 7 ? 9 : currentZoom;\n                            // Set the view directly to the user's location\n                            mapInstance.setView([\n                                latitude,\n                                longitude\n                            ], targetZoom);\n                            // Make sure the map reflects changes\n                            mapInstance.invalidateSize();\n                        }\n                        // If in geofence mode, ensure the filter mode is set correctly\n                        if (filterMode !== 'geofence' && filterMode !== 'both') {\n                            setFilterMode('geofence');\n                        }\n                    } catch (error) {\n                        var _error_message;\n                        if (((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes('rate limit')) || error.status === 429) {\n                            handleRateLimit(30);\n                            // Still update the location even if we couldn't get aircraft\n                            if (mapInstance) {\n                                mapInstance.setView([\n                                    latitude,\n                                    longitude\n                                ], 9);\n                                mapInstance.invalidateSize();\n                            }\n                        } else {\n                            throw error;\n                        }\n                    }\n                    // Close the dropdown after selection\n                    setActiveDropdown(null);\n                }\n            } catch (error) {\n                console.error('Error getting user location:', error);\n                alert('Unable to access your location. Please make sure location services are enabled in your browser.');\n            } finally{\n                setIsGettingLocation(false);\n            }\n        };\n        const processGeofenceSearch = async ()=>{\n            if (!geofenceLocation) return;\n            // Check if rate limited\n            if (isRateLimited) {\n                alert(\"Rate limited. Please wait \".concat(rateLimitTimer || 30, \" seconds before searching again.\"));\n                return;\n            }\n            // Block API calls while doing geofence search in combined mode\n            if (filterMode === 'both') {\n                _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].setBlockAllApiCalls(true);\n                setBlockManufacturerApiCalls(true);\n            }\n            // Set loading state\n            setLocalLoading(true);\n            try {\n                console.log('Searching for aircraft near location: \"'.concat(geofenceLocation, '\"'));\n                // This will handle Postal codes, place names, addresses, POIs, etc.\n                let fetchedAircraft;\n                try {\n                    fetchedAircraft = await (0,_lib_services_geofencing__WEBPACK_IMPORTED_MODULE_8__.getAircraftNearSearchedLocation)(geofenceLocation, geofenceRadius);\n                } catch (error) {\n                    var _error_message;\n                    if (((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes('rate limit')) || error.status === 429) {\n                        const retryAfter = 30; // Default to 30 seconds if not specified\n                        handleRateLimit(retryAfter);\n                        setLocalLoading(false);\n                        return;\n                    }\n                    throw error;\n                }\n                // Get coordinates for the map\n                let locations;\n                try {\n                    locations = await _lib_services_MapboxService__WEBPACK_IMPORTED_MODULE_4__.MapboxService.searchLocationWithMapbox(geofenceLocation, 1);\n                } catch (error) {\n                    console.error('Error searching location with Mapbox:', error);\n                    // Continue with aircraft data if available\n                    locations = [];\n                }\n                let coordinates = null;\n                if (locations.length > 0) {\n                    coordinates = {\n                        lat: locations[0].lat,\n                        lng: locations[0].lng\n                    };\n                    // Save the formatted location name\n                    setGeofenceLocation(locations[0].name);\n                } else if (fetchedAircraft.length > 0 && fetchedAircraft[0].latitude && fetchedAircraft[0].longitude) {\n                    // Fallback to first aircraft position\n                    coordinates = {\n                        lat: fetchedAircraft[0].latitude,\n                        lng: fetchedAircraft[0].longitude\n                    };\n                }\n                if (fetchedAircraft.length === 0) {\n                    alert(\"No aircraft found near \".concat(geofenceLocation, \". Try increasing the radius or searching in a different area.\"));\n                    setLocalLoading(false);\n                    return;\n                }\n                // Update state with the coordinates\n                if (coordinates) {\n                    setGeofenceCoordinates(coordinates);\n                    setGeofenceCenter(coordinates);\n                    setGeofenceRadius(geofenceRadius);\n                }\n                if (!isGeofenceActive) {\n                    toggleGeofence();\n                } else if (!coordinates) {\n                    throw new Error('Could not determine coordinates for the location');\n                }\n                console.log(\"Found \".concat(fetchedAircraft.length, \" aircraft in the area, preparing for display...\"));\n                // Ensure the data is in the right format\n                const adaptedAircraft = fetchedAircraft[0].MANUFACTURER !== undefined ? fetchedAircraft // Already in the right format\n                 : (0,_lib_utils_geofenceAdapter__WEBPACK_IMPORTED_MODULE_5__.adaptGeofenceAircraft)(fetchedAircraft); // Needs adaptation\n                // Enrich with static data\n                console.log('Enriching geofence aircraft with static data...');\n                const enrichedAircraft = await (0,_lib_utils_geofenceEnricher__WEBPACK_IMPORTED_MODULE_6__.enrichGeofenceAircraft)(adaptedAircraft);\n                // Save the FULL set to local state\n                setGeofenceAircraft(enrichedAircraft);\n                setIsGeofenceActive(true);\n                // Clear existing aircraft data\n                if (clearGeofenceData) {\n                    clearGeofenceData();\n                }\n                // If we're in combined mode and have a manufacturer, apply the combined filter\n                if (filterMode === 'both' && selectedManufacturer) {\n                    // Make sure API calls remain blocked\n                    _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].setBlockAllApiCalls(true);\n                    setBlockManufacturerApiCalls(true);\n                    setTimeout(()=>{\n                        applyCombinedFilters();\n                    }, 100);\n                } else {\n                    // Just show all aircraft in the geofence\n                    updateGeofenceAircraft(enrichedAircraft);\n                    // Center the map - SIMPLIFIED ZOOM LOGIC\n                    if (mapInstance && coordinates) {\n                        // Get current zoom level\n                        const currentZoom = mapInstance.getZoom();\n                        // Use appropriate zoom level based on current view\n                        const targetZoom = currentZoom <= 7 ? 9 : currentZoom;\n                        // Set view to the coordinates\n                        mapInstance.setView([\n                            coordinates.lat,\n                            coordinates.lng\n                        ], targetZoom);\n                        // Ensure map is updated\n                        mapInstance.invalidateSize();\n                    }\n                }\n                // Close dropdown after search\n                setActiveDropdown(null);\n            } catch (error) {\n                var _error_message1;\n                console.error('Error in geofence search:', error);\n                if (((_error_message1 = error.message) === null || _error_message1 === void 0 ? void 0 : _error_message1.includes('rate limit')) || error.status === 429) {\n                    handleRateLimit(30);\n                } else {\n                    alert(\"Error: \".concat(error instanceof Error ? error.message : 'Unknown error occurred'));\n                }\n            } finally{\n                setLocalLoading(false);\n            }\n        };\n        /**\r\n     * STEP 3: Fix toggleGeofenceState to better handle manually clicking the button\r\n     */ const toggleGeofenceState = (enabled)=>{\n            console.log('toggleGeofenceState called with:', enabled);\n            console.log('Current geofenceCoordinates:', geofenceCoordinates);\n            if (enabled) {\n                // Check if we have valid coordinates\n                if (geofenceCoordinates && typeof geofenceCoordinates.lat === 'number' && typeof geofenceCoordinates.lng === 'number' && !isNaN(geofenceCoordinates.lat) && !isNaN(geofenceCoordinates.lng)) {\n                    console.log('Valid coordinates found, enabling geofence');\n                    // Set flags first\n                    setGeofenceEnabled(true);\n                    setIsGeofenceActive(true);\n                    // Call context toggle function if available\n                    if (typeof toggleGeofence === 'function') {\n                        toggleGeofence();\n                    }\n                    // Display aircraft if we have them\n                    if (geofenceAircraft && geofenceAircraft.length > 0) {\n                        console.log(\"Showing \".concat(geofenceAircraft.length, \" aircraft in geofence\"));\n                        updateGeofenceAircraft(geofenceAircraft);\n                    } else {\n                        // No aircraft data yet, trigger a search\n                        console.log('No aircraft data yet, triggering search');\n                        setTimeout(()=>{\n                            processGeofenceSearch();\n                        }, 100);\n                    }\n                } else {\n                    // No valid coordinates\n                    console.warn('No valid coordinates, showing alert');\n                    alert('Please set a location before enabling geofence.\\n\\nClick anywhere on the map to set a location.');\n                    setGeofenceEnabled(false);\n                    setIsGeofenceActive(false);\n                }\n            } else {\n                // Disabling geofence\n                console.log('Disabling geofence');\n                setGeofenceEnabled(false);\n                setIsGeofenceActive(false);\n                // Clear geofence data if function available\n                if (typeof clearGeofenceData === 'function') {\n                    clearGeofenceData();\n                }\n            }\n        };\n        // Manufacturer filter methods\n        const selectManufacturerAndClose = (value)=>{\n            // Close dropdown\n            setActiveDropdown(null);\n            setManufacturerSearchTerm('');\n            // If clearing the selection\n            if (value === '') {\n                selectManufacturer(null);\n                return;\n            }\n            // Set the manufacturer selection\n            selectManufacturer(value);\n            // If region is already selected, fetch filtered data\n            if (activeRegion !== null) {\n                fetchAircraftByRegionAndManufacturer(activeRegion, value);\n            } else {\n                // Otherwise, just proceed with manufacturer-only filtering as before\n                fetchManufacturerData(value);\n            }\n        };\n        const fetchManufacturerData = (manufacturer)=>{\n            if (isRateLimited) {\n                console.log(\"Skipping data fetch - rate limited for \".concat(rateLimitTimer, \"s\"));\n                return;\n            }\n            console.log(\"Fetching data for manufacturer: \".concat(manufacturer));\n            try {\n                // If you have a context function for this, call it after a slight delay\n                if (typeof refreshPositions === 'function') {\n                    // Apply a small delay to prevent overwhelming the API\n                    setTimeout(()=>{\n                        refreshPositions().catch((error)=>{\n                            var _error_message;\n                            if (((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes('rate limit')) || error.status === 429) {\n                                handleRateLimit(30);\n                            } else {\n                                console.error('Error fetching manufacturer data:', error);\n                            }\n                        });\n                    }, 200);\n                }\n            } catch (error) {\n                var _error_message;\n                if (((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes('rate limit')) || error.status === 429) {\n                    handleRateLimit(30);\n                } else {\n                    console.error('Error scheduling manufacturer data fetch:', error);\n                }\n            }\n        };\n        const fetchAircraftByRegionAndManufacturer = async function(region, manufacturer) {\n            let page = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, limit = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 500;\n            if (!region || !manufacturer) {\n                console.log('Both region and manufacturer must be selected');\n                return;\n            }\n            setLocalLoading(true);\n            try {\n                const response = await fetch(\"/api/tracking/filtered-aircraft?region=\".concat(region, \"&manufacturer=\").concat(encodeURIComponent(manufacturer), \"&page=\").concat(page, \"&limit=\").concat(limit));\n                const data = await response.json();\n                const aircraftData = data.aircraft || [];\n                if (!response.ok) {\n                    throw new Error(\"API error: \".concat(response.statusText));\n                }\n                // Process the filtered aircraft data\n                if (aircraftData.length > 0) {\n                    const extendedAircraft = aircraftData.map((aircraft)=>{\n                        var _aircraft_OPERATOR;\n                        var _aircraft_OPERATOR_toLowerCase_includes;\n                        return {\n                            ...aircraft,\n                            type: aircraft.TYPE_AIRCRAFT || 'Unknown',\n                            isGovernment: (_aircraft_OPERATOR_toLowerCase_includes = (_aircraft_OPERATOR = aircraft.OPERATOR) === null || _aircraft_OPERATOR === void 0 ? void 0 : _aircraft_OPERATOR.toLowerCase().includes('government')) !== null && _aircraft_OPERATOR_toLowerCase_includes !== void 0 ? _aircraft_OPERATOR_toLowerCase_includes : false,\n                            REGION: aircraft.REGION,\n                            zoomLevel: undefined\n                        };\n                    });\n                    // Update the map\n                    updateGeofenceAircraft(extendedAircraft);\n                } else {\n                    console.log(\"No aircraft found for manufacturer \".concat(manufacturer, \" in region \").concat(region));\n                }\n            } catch (error) {\n                console.error('Error fetching filtered aircraft:', error);\n            } finally{\n                setLocalLoading(false);\n            }\n        };\n        // Model selection methods\n        const handleModelSelect = (value)=>{\n            selectModel(value === '' ? null : value);\n            setActiveDropdown(null);\n            // If in combined mode, reapply the filter\n            if (filterMode === 'both' && isGeofenceActive && selectedManufacturer) {\n                setTimeout(()=>{\n                    applyCombinedFilters();\n                }, 100);\n            }\n        };\n        // Combined filter methods\n        const applyCombinedFilters = ()=>{\n            if (!selectedManufacturer || !isGeofenceActive || geofenceAircraft.length === 0) {\n                return;\n            }\n            setLocalLoading(true);\n            try {\n                console.log(\"Filtering \".concat(geofenceAircraft.length, \" aircraft by \").concat(selectedManufacturer));\n                // Filter the aircraft by manufacturer\n                let filteredAircraft = geofenceAircraft.filter((aircraft)=>{\n                    var _aircraft_MANUFACTURER;\n                    return ((_aircraft_MANUFACTURER = aircraft.MANUFACTURER) === null || _aircraft_MANUFACTURER === void 0 ? void 0 : _aircraft_MANUFACTURER.toLowerCase()) === selectedManufacturer.toLowerCase();\n                });\n                // Further filter by model if selected\n                if (selectedModel) {\n                    filteredAircraft = filteredAircraft.filter((aircraft)=>{\n                        var _aircraft_MODEL;\n                        return ((_aircraft_MODEL = aircraft.MODEL) === null || _aircraft_MODEL === void 0 ? void 0 : _aircraft_MODEL.toLowerCase()) === selectedModel.toLowerCase();\n                    });\n                }\n                console.log(\"Found \".concat(filteredAircraft.length, \" matching aircraft\"));\n                if (filteredAircraft.length === 0) {\n                    alert(\"No \".concat(selectedManufacturer, \" aircraft found in this area.\"));\n                    return;\n                }\n                // Clear display data\n                if (clearGeofenceData) {\n                    clearGeofenceData();\n                }\n                // Update the display\n                updateGeofenceAircraft(filteredAircraft);\n            } catch (error) {\n                console.error('Error filtering aircraft:', error);\n            } finally{\n                setLocalLoading(false);\n            }\n        };\n        // Reset all filters\n        const clearAllFilters = ()=>{\n            console.log('Clearing all filters...');\n            // 1. Reset filter mode\n            setFilterMode('manufacturer');\n            // 2. Unblock API calls that might have been blocked\n            _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].setBlockAllApiCalls(false);\n            setBlockManufacturerApiCalls(false);\n            setIsManufacturerApiBlocked(false);\n            // 3. Clear manufacturer selection\n            selectManufacturer(null);\n            selectModel(null);\n            // 4. Clear geofence\n            setGeofenceLocation('');\n            setGeofenceCoordinates(null);\n            setGeofenceAircraft([]);\n            setGeofenceEnabled(false);\n            setIsGeofenceActive(false);\n            if (typeof clearGeofence === 'function') {\n                clearGeofence();\n            }\n            if (typeof clearGeofenceData === 'function') {\n                clearGeofenceData();\n            }\n            // 5. Reset owner filters to select all\n            setOwnerFilters([\n                ...allOwnerTypes\n            ]);\n            // 6. Clear region filter properly\n            setActiveRegion(null);\n            setSelectedRegion(_types_base__WEBPACK_IMPORTED_MODULE_1__.RegionCode.GLOBAL);\n            // Clear region outline from map\n            if (regionOutline) {\n                try {\n                    // Handle different possible object structures\n                    if (typeof regionOutline.remove === 'function') {\n                        regionOutline.remove();\n                    } else if (regionOutline.rectangle && typeof regionOutline.rectangle.remove === 'function') {\n                        regionOutline.rectangle.remove();\n                    }\n                    // Clear any labels associated with the region\n                    if (regionOutline.label && typeof regionOutline.label.remove === 'function') {\n                        regionOutline.label.remove();\n                    }\n                } catch (error) {\n                    console.error('Error removing region outline:', error);\n                }\n                // Always reset the region outline state\n                setRegionOutline(null);\n            }\n            // 7. Reset map view to global\n            if (mapInstance) {\n                // Use the predefined center and zoom level from your map config\n                mapInstance.setView(_config_map__WEBPACK_IMPORTED_MODULE_10__.MAP_CONFIG.CENTER, _config_map__WEBPACK_IMPORTED_MODULE_10__.MAP_CONFIG.DEFAULT_ZOOM);\n                mapInstance.invalidateSize();\n            }\n            // 8. Reset to initial aircraft data\n            if (typeof reset === 'function') {\n                reset();\n            } else if (typeof fullRefresh === 'function') {\n                fullRefresh();\n            }\n            // 9. Close any open dropdown\n            setActiveDropdown(null);\n            // 10. Reset rate limiting states\n            setIsRateLimited(false);\n            setRateLimitTimer(null);\n            // 11. Clear combined mode state\n            setCombinedModeReady(false);\n            // 12. Reset search terms\n            setManufacturerSearchTerm('');\n            // 13. Dispatch a custom event that other components can listen for\n            const clearEvent = new CustomEvent('ribbon-filters-cleared');\n            document.dispatchEvent(clearEvent);\n            console.log('All filters cleared successfully');\n        };\n        // Calculate combined loading state\n        const combinedLoading = localLoading;\n        return {\n            // State\n            filterMode,\n            activeDropdown,\n            selectedManufacturer,\n            selectedModel,\n            geofenceLocation,\n            geofenceRadius,\n            isGeofenceActive,\n            geofenceCoordinates,\n            getUserLocation,\n            activeRegion,\n            ownerFilters,\n            allOwnerTypes,\n            manufacturerSearchTerm,\n            combinedLoading,\n            isGettingLocation,\n            dropdownRefs,\n            localLoading,\n            isRateLimited,\n            selectedRegion,\n            isRefreshing,\n            isGeofencePlacementMode: false,\n            // Methods\n            toggleDropdown,\n            toggleFilterMode,\n            selectManufacturerAndClose,\n            handleModelSelect,\n            processGeofenceSearch,\n            handleOwnerFilterChange,\n            handleRegionSelect,\n            setManufacturerSearchTerm,\n            setGeofenceLocation,\n            setGeofenceRadius,\n            toggleGeofenceState,\n            clearAllFilters,\n            applyCombinedFilters,\n            getAircraftOwnerType,\n            setGeofenceCoordinates,\n            setGeofenceCenter,\n            updateGeofenceAircraft,\n            refreshWithFilters: ()=>{\n                // Implement refresh logic here\n                if (typeof refreshPositions === 'function') {\n                    refreshPositions().catch((error)=>{\n                        console.error('Error refreshing positions:', error);\n                    });\n                }\n            },\n            setActiveDropdown\n        };\n    };\n}\nfunction applyCombinedFilters() {\n    throw new Error('Function not implemented.');\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvdHJhY2tpbmcvaG9va3MvdXNlRmlsdGVyTG9naWMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFvRDtBQUMxQjtBQUNnQjtBQUU0QjtBQUNLO0FBQ1A7QUFDQTtBQUNFO0FBQ0c7QUFJL0I7QUFDZTtBQUs1QjtBQVd0QixTQUFTaUI7SUFDZCxrQ0FBa0M7SUFDbEMsTUFBTSxFQUNKQyxvQkFBb0IsRUFDcEJDLGFBQWEsRUFDYkMsV0FBVyxFQUNYQyxrQkFBa0IsRUFDbEJDLFdBQVcsRUFDWEMsS0FBSyxFQUNMQyxXQUFXLEVBQ1hDLGdCQUFnQixFQUNoQkMsV0FBVyxFQUNYQyxrQkFBa0IsRUFDbEJDLGlCQUFpQixFQUNqQkMsc0JBQXNCLEVBQ3RCQyx5QkFBeUIsRUFDekJDLDRCQUE0QixFQUM1QkMsd0JBQXdCLEVBQ3hCQywyQkFBMkIsRUFDM0JDLGNBQWMsRUFDZEMsaUJBQWlCLEVBQ2pCQyxjQUFjLEVBQ2RDLGFBQWEsRUFDYkMsaUJBQWlCLEVBQ2xCLEdBQUdqQyxrRkFBcUJBO0lBRXpCLDZDQUE2QztJQUM3QyxNQUFNa0Msc0JBQXNCN0IscUZBQXNCQTtJQUVsRCxjQUFjO0lBQ2QsTUFBTSxDQUFDOEIsY0FBY0MsZ0JBQWdCLEdBQUd6QywrQ0FBUUEsQ0FBQztJQUNqRCxNQUFNLENBQUMwQyxZQUFZQyxjQUFjLEdBQUczQywrQ0FBUUEsQ0FBb0I7SUFDaEUsTUFBTSxDQUFDNEMsZ0JBQWdCQyxrQkFBa0IsR0FBRzdDLCtDQUFRQSxDQUFnQjtJQUNwRSxNQUFNLENBQUM4Qyx3QkFBd0JDLDBCQUEwQixHQUFHL0MsK0NBQVFBLENBQUM7SUFDckUsTUFBTSxDQUFDZ0QsY0FBY0MsZ0JBQWdCLEdBQUdqRCwrQ0FBUUEsQ0FBQztJQUNqRCxNQUFNLENBQUNrRCxlQUFlQyxpQkFBaUIsR0FBR25ELCtDQUFRQSxDQUFDO0lBQ25ELE1BQU0sQ0FBQ29ELGdCQUFnQkMsa0JBQWtCLEdBQUdy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O1FBQ2Q7UUFFQSxtQ0FBbUM7UUFDbkMsTUFBTW9KLGtCQUFrQjFNO1FBRXhCLE9BQU87WUFDTCxRQUFRO1lBQ1JFO1lBQ0FFO1lBQ0ExQjtZQUNBQztZQUNBcUM7WUFDQUU7WUFDQVE7WUFDQU47WUFDQWtJO1lBQ0F4SDtZQUNBVTtZQUNBRDtZQUNBakM7WUFDQW9NO1lBQ0E1TDtZQUNBNEI7WUFDQTFDO1lBQ0FVO1lBQ0F3QjtZQUNBMUI7WUFDQW1NLHlCQUF5QjtZQUV6QixVQUFVO1lBQ1Y1SDtZQUNBTztZQUNBd0Y7WUFDQW1CO1lBQ0E5QjtZQUNBcEQ7WUFDQVU7WUFDQWxIO1lBQ0FVO1lBQ0FFO1lBQ0F3SjtZQUNBd0I7WUFDQS9GO1lBQ0FEO1lBQ0E5RTtZQUNBMUI7WUFDQU47WUFFQXVOLG9CQUFvQjtnQkFDbEIsK0JBQStCO2dCQUMvQixJQUFJLE9BQU8zTixxQkFBcUIsWUFBWTtvQkFDMUNBLG1CQUFtQmlNLEtBQUssQ0FBQyxDQUFDcEc7d0JBQ3hCekIsUUFBUXlCLEtBQUssQ0FBQywrQkFBK0JBO29CQUMvQztnQkFDRjtZQUNGO1lBQ0F6RTtRQUNGO0lBQ0Y7QUFDRjtBQUNBLFNBQVMrRjtJQUNQLE1BQU0sSUFBSW9FLE1BQU07QUFDbEIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcc2F0aG9cXERvY3VtZW50c1xcUHJvamVjdHNcXGFpcmNyYWZ0LXRyYWNraW5nXFxjb21wb25lbnRzXFx0cmFja2luZ1xcaG9va3NcXHVzZUZpbHRlckxvZ2ljLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVN0YXRlLCB1c2VSZWYsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgUmVnaW9uQ29kZSB9IGZyb20gJ0AvdHlwZXMvYmFzZSc7XHJcbmltcG9ydCB0eXBlIHsgRXh0ZW5kZWRBaXJjcmFmdCB9IGZyb20gJ0AvdHlwZXMvYmFzZSc7XHJcbmltcG9ydCB7IHVzZUVuaGFuY2VkTWFwQ29udGV4dCB9IGZyb20gJy4uL2NvbnRleHQvRW5oYW5jZWRNYXBDb250ZXh0JztcclxuaW1wb3J0IG9wZW5Ta3lUcmFja2luZ1NlcnZpY2UgZnJvbSAnQC9saWIvc2VydmljZXMvb3BlblNreVRyYWNraW5nU2VydmljZSc7XHJcbmltcG9ydCB7IE1hcGJveFNlcnZpY2UgfSBmcm9tICcuLi8uLi8uLi9saWIvc2VydmljZXMvTWFwYm94U2VydmljZSc7XHJcbmltcG9ydCB7IGFkYXB0R2VvZmVuY2VBaXJjcmFmdCB9IGZyb20gJ0AvbGliL3V0aWxzL2dlb2ZlbmNlQWRhcHRlcic7XHJcbmltcG9ydCB7IGVucmljaEdlb2ZlbmNlQWlyY3JhZnQgfSBmcm9tICdAL2xpYi91dGlscy9nZW9mZW5jZUVucmljaGVyJztcclxuaW1wb3J0IHsgdXNlR2VvbG9jYXRpb25TZXJ2aWNlcyB9IGZyb20gJy4uL2hvb2tzL3VzZUdlb2xvY2F0aW9uU2VydmljZXMnO1xyXG5pbXBvcnQge1xyXG4gIGdldEFpcmNyYWZ0TmVhckxvY2F0aW9uLFxyXG4gIGdldEFpcmNyYWZ0TmVhclNlYXJjaGVkTG9jYXRpb24sXHJcbn0gZnJvbSAnLi4vLi4vLi4vbGliL3NlcnZpY2VzL2dlb2ZlbmNpbmcnO1xyXG5pbXBvcnQgeyB1c2VHZW9sb2NhdGlvbiB9IGZyb20gJy4uL2hvb2tzL3VzZUdlb2xvY2F0aW9uJztcclxuaW1wb3J0IHtcclxuICBNQVBfQ09ORklHLFxyXG4gIGdldEJvdW5kc0J5UmVnaW9uLFxyXG4gIGdldFpvb21MZXZlbEZvclJlZ2lvbixcclxufSBmcm9tICcuLi8uLi8uLi9jb25maWcvbWFwJztcclxuXHJcbnR5cGUgTWFwR2VvZmVuY2VDbGlja0V2ZW50ID0gQ3VzdG9tRXZlbnQ8eyBsYXQ6IG51bWJlcjsgbG5nOiBudW1iZXIgfT47XHJcblxyXG5leHBvcnQgdHlwZSBGaWx0ZXJNb2RlID1cclxuICB8ICdtYW51ZmFjdHVyZXInXHJcbiAgfCAnZ2VvZmVuY2UnXHJcbiAgfCAnYm90aCdcclxuICB8ICdvd25lcidcclxuICB8ICdyZWdpb24nO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUZpbHRlckxvZ2ljKCkge1xyXG4gIC8vIEdldCBjb250ZXh0IHN0YXRlIGFuZCBmdW5jdGlvbnNcclxuICBjb25zdCB7XHJcbiAgICBzZWxlY3RlZE1hbnVmYWN0dXJlcixcclxuICAgIHNlbGVjdGVkTW9kZWwsXHJcbiAgICB0b3RhbEFjdGl2ZSxcclxuICAgIHNlbGVjdE1hbnVmYWN0dXJlcixcclxuICAgIHNlbGVjdE1vZGVsLFxyXG4gICAgcmVzZXQsXHJcbiAgICBmdWxsUmVmcmVzaCxcclxuICAgIHJlZnJlc2hQb3NpdGlvbnMsXHJcbiAgICBtYXBJbnN0YW5jZSxcclxuICAgIHVwZGF0ZUFpcmNyYWZ0RGF0YSxcclxuICAgIGNsZWFyR2VvZmVuY2VEYXRhLFxyXG4gICAgdXBkYXRlR2VvZmVuY2VBaXJjcmFmdCxcclxuICAgIGJsb2NrTWFudWZhY3R1cmVyQXBpQ2FsbHMsXHJcbiAgICBzZXRCbG9ja01hbnVmYWN0dXJlckFwaUNhbGxzLFxyXG4gICAgaXNNYW51ZmFjdHVyZXJBcGlCbG9ja2VkLFxyXG4gICAgc2V0SXNNYW51ZmFjdHVyZXJBcGlCbG9ja2VkLFxyXG4gICAgZ2VvZmVuY2VDZW50ZXIsXHJcbiAgICBzZXRHZW9mZW5jZUNlbnRlcixcclxuICAgIHRvZ2dsZUdlb2ZlbmNlLFxyXG4gICAgY2xlYXJHZW9mZW5jZSxcclxuICAgIGRpc3BsYXllZEFpcmNyYWZ0LFxyXG4gIH0gPSB1c2VFbmhhbmNlZE1hcENvbnRleHQoKTtcclxuXHJcbiAgLy8gVXNlIG91ciBjb21iaW5lZCBnZW9sb2NhdGlvbiBzZXJ2aWNlcyBob29rXHJcbiAgY29uc3QgZ2VvbG9jYXRpb25TZXJ2aWNlcyA9IHVzZUdlb2xvY2F0aW9uU2VydmljZXMoKTtcclxuXHJcbiAgLy8gTG9jYWwgc3RhdGVcclxuICBjb25zdCBbbG9jYWxMb2FkaW5nLCBzZXRMb2NhbExvYWRpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gIGNvbnN0IFtmaWx0ZXJNb2RlLCBzZXRGaWx0ZXJNb2RlXSA9IHVzZVN0YXRlPEZpbHRlck1vZGUgfCBudWxsPihudWxsKTtcclxuICBjb25zdCBbYWN0aXZlRHJvcGRvd24sIHNldEFjdGl2ZURyb3Bkb3duXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xyXG4gIGNvbnN0IFttYW51ZmFjdHVyZXJTZWFyY2hUZXJtLCBzZXRNYW51ZmFjdHVyZXJTZWFyY2hUZXJtXSA9IHVzZVN0YXRlKCcnKTtcclxuICBjb25zdCBbaXNSZWZyZXNoaW5nLCBzZXRJc1JlZnJlc2hpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gIGNvbnN0IFtpc1JhdGVMaW1pdGVkLCBzZXRJc1JhdGVMaW1pdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICBjb25zdCBbcmF0ZUxpbWl0VGltZXIsIHNldFJhdGVMaW1pdFRpbWVyXSA9IHVzZVN0YXRlPG51bWJlciB8IG51bGw+KG51bGwpO1xyXG5cclxuICAvLyBHZW9mZW5jZSBzdGF0ZVxyXG4gIGNvbnN0IFtpc0dldHRpbmdMb2NhdGlvbiwgc2V0SXNHZXR0aW5nTG9jYXRpb25dID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gIGNvbnN0IFtnZW9mZW5jZUxvY2F0aW9uLCBzZXRHZW9mZW5jZUxvY2F0aW9uXSA9IHVzZVN0YXRlPHN0cmluZz4oJycpO1xyXG4gIGNvbnN0IFtnZW9mZW5jZVJhZGl1cywgc2V0R2VvZmVuY2VSYWRpdXNdID0gdXNlU3RhdGU8bnVtYmVyPigyNSk7XHJcbiAgY29uc3QgW2dlb2ZlbmNlQ29vcmRpbmF0ZXMsIHNldEdlb2ZlbmNlQ29vcmRpbmF0ZXNdID0gdXNlU3RhdGU8e1xyXG4gICAgbGF0OiBudW1iZXI7XHJcbiAgICBsbmc6IG51bWJlcjtcclxuICB9IHwgbnVsbD4obnVsbCk7XHJcbiAgY29uc3QgW2dlb2ZlbmNlQWlyY3JhZnQsIHNldEdlb2ZlbmNlQWlyY3JhZnRdID0gdXNlU3RhdGU8RXh0ZW5kZWRBaXJjcmFmdFtdPihcclxuICAgIFtdXHJcbiAgKTtcclxuICBjb25zdCBbZ2VvZmVuY2VFbmFibGVkLCBzZXRHZW9mZW5jZUVuYWJsZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gIGNvbnN0IFtpc0dlb2ZlbmNlQWN0aXZlLCBzZXRJc0dlb2ZlbmNlQWN0aXZlXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICBjb25zdCBbaXNTZWFyY2hSZWFkeSwgc2V0SXNTZWFyY2hSZWFkeV0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XHJcblxyXG4gIC8vIFJlZ2lvbiBzdGF0ZVxyXG4gIGNvbnN0IFthY3RpdmVSZWdpb24sIHNldEFjdGl2ZVJlZ2lvbl0gPSB1c2VTdGF0ZTxSZWdpb25Db2RlIHwgc3RyaW5nIHwgbnVsbD4oXHJcbiAgICBudWxsXHJcbiAgKTtcclxuICBjb25zdCBbcmVnaW9uT3V0bGluZSwgc2V0UmVnaW9uT3V0bGluZV0gPSB1c2VTdGF0ZTxhbnk+KG51bGwpO1xyXG4gIGNvbnN0IFtzZWxlY3RlZFJlZ2lvbiwgc2V0U2VsZWN0ZWRSZWdpb25dID0gdXNlU3RhdGU8bnVtYmVyPihcclxuICAgIFJlZ2lvbkNvZGUuR0xPQkFMXHJcbiAgKTtcclxuXHJcbiAgLy8gQ29tYmluZWQgbW9kZSBzdGF0ZVxyXG4gIGNvbnN0IFtjb21iaW5lZE1vZGVSZWFkeSwgc2V0Q29tYmluZWRNb2RlUmVhZHldID0gdXNlU3RhdGU8Ym9vbGVhbj4oZmFsc2UpO1xyXG5cclxuICAvLyBPd25lciBmaWx0ZXIgc3RhdGVcclxuICBjb25zdCBhbGxPd25lclR5cGVzID0gW1xyXG4gICAgJ2luZGl2aWR1YWwnLFxyXG4gICAgJ3BhcnRuZXJzaGlwJyxcclxuICAgICdjb3JwLW93bmVyJyxcclxuICAgICdjby1vd25lZCcsXHJcbiAgICAnbGxjJyxcclxuICAgICdub24tY2l0aXplbi1jb3JwJyxcclxuICAgICdhaXJsaW5lJyxcclxuICAgICdmcmVpZ2h0JyxcclxuICAgICdtZWRpY2FsJyxcclxuICAgICdtZWRpYScsXHJcbiAgICAnaGlzdG9yaWNhbCcsXHJcbiAgICAnZmx5aW5nLWNsdWInLFxyXG4gICAgJ2VtZXJnZW5jeScsXHJcbiAgICAnbG9jYWwtZ292dCcsXHJcbiAgICAnZWR1Y2F0aW9uJyxcclxuICAgICdmZWRlcmFsLWdvdnQnLFxyXG4gICAgJ2ZsaWdodC1zY2hvb2wnLFxyXG4gICAgJ2xlYXNpbmctY29ycCcsXHJcbiAgICAnbWlsaXRhcnknLFxyXG4gICAgJ3Vua25vd24nLFxyXG4gIF07XHJcblxyXG4gIGNvbnN0IFtvd25lckZpbHRlcnMsIHNldE93bmVyRmlsdGVyc10gPSB1c2VTdGF0ZTxzdHJpbmdbXT4oW1xyXG4gICAgLi4uYWxsT3duZXJUeXBlcyxcclxuICBdKTtcclxuXHJcbiAgLy8gUmVmcyBmb3IgZHJvcGRvd24gaGFuZGxpbmdcclxuICBjb25zdCBkcm9wZG93blJlZnMgPSB7XHJcbiAgICBmaWx0ZXI6IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCksXHJcbiAgICBtYW51ZmFjdHVyZXI6IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCksXHJcbiAgICBtb2RlbDogdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKSxcclxuICAgIGxvY2F0aW9uOiB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpLFxyXG4gICAgcmVnaW9uOiB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpLFxyXG4gICAgb3duZXI6IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCksXHJcbiAgICBhY3Rpb25zOiB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpLFxyXG4gIH07XHJcblxyXG4gIC8vIEdldCBnZW9sb2NhdGlvbiBob29rIC0gdXNlIHRoZSBlbnRpcmUgaG9vayBpbnN0YW5jZVxyXG4gIGNvbnN0IGdlb2xvY2F0aW9uID0gdXNlR2VvbG9jYXRpb24obnVsbCk7XHJcbiAgLy8gRWZmZWN0c1xyXG5cclxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKGdlb2ZlbmNlQ29vcmRpbmF0ZXMpIHtcclxuICAgICAgc2V0SXNTZWFyY2hSZWFkeSh0cnVlKTtcclxuICAgIH1cclxuICB9LCBbZ2VvZmVuY2VDb29yZGluYXRlc10pO1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKGlzUmF0ZUxpbWl0ZWQgJiYgcmF0ZUxpbWl0VGltZXIpIHtcclxuICAgICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICBzZXRJc1JhdGVMaW1pdGVkKGZhbHNlKTtcclxuICAgICAgICBzZXRSYXRlTGltaXRUaW1lcihudWxsKTtcclxuICAgICAgICBjb25zb2xlLmxvZygnUmF0ZSBsaW1pdCB0aW1lciBleHBpcmVkLCByZXN1bWluZyBBUEkgY2FsbHMnKTtcclxuICAgICAgfSwgcmF0ZUxpbWl0VGltZXIgKiAxMDAwKTtcclxuXHJcbiAgICAgIHJldHVybiAoKSA9PiBjbGVhclRpbWVvdXQodGltZXIpO1xyXG4gICAgfVxyXG4gIH0sIFtpc1JhdGVMaW1pdGVkLCByYXRlTGltaXRUaW1lcl0pO1xyXG5cclxuICAvLyBFZmZlY3QgdG8gc3luYyBnZW9mZW5jZSBzdGF0ZVxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAvLyBVcGRhdGUgaW50ZXJuYWwgc3RhdGUgd2hlbiBnZW9mZW5jZSBpcyB0b2dnbGVkIGV4dGVybmFsbHlcclxuICAgIGlmIChpc0dlb2ZlbmNlQWN0aXZlICE9PSBnZW9mZW5jZUVuYWJsZWQpIHtcclxuICAgICAgc2V0R2VvZmVuY2VFbmFibGVkKGlzR2VvZmVuY2VBY3RpdmUpO1xyXG4gICAgfVxyXG4gIH0sIFtpc0dlb2ZlbmNlQWN0aXZlXSk7XHJcblxyXG4gIC8vIENsb3NlIGRyb3Bkb3duIHdoZW4gY2xpY2tpbmcgb3V0c2lkZVxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBjb25zdCBoYW5kbGVDbGlja091dHNpZGUgPSAoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgLy8gQ2hlY2sgaWYgY2xpY2sgaXMgb3V0c2lkZSBvZiBhbGwgZHJvcGRvd25zXHJcbiAgICAgIGNvbnN0IGlzT3V0c2lkZUFsbCA9IE9iamVjdC52YWx1ZXMoZHJvcGRvd25SZWZzKS5ldmVyeShcclxuICAgICAgICAocmVmKSA9PiAhcmVmLmN1cnJlbnQgfHwgIXJlZi5jdXJyZW50LmNvbnRhaW5zKGV2ZW50LnRhcmdldCBhcyBOb2RlKVxyXG4gICAgICApO1xyXG5cclxuICAgICAgaWYgKGlzT3V0c2lkZUFsbCkge1xyXG4gICAgICAgIHNldEFjdGl2ZURyb3Bkb3duKG51bGwpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGhhbmRsZUNsaWNrT3V0c2lkZSk7XHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBoYW5kbGVDbGlja091dHNpZGUpO1xyXG4gICAgfTtcclxuICB9LCBbXSk7XHJcblxyXG4gIC8vIENsZWFuIHVwIHJlZ2lvbiBvdXRsaW5lIHdoZW4gY29tcG9uZW50IHVubW91bnRzXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIGlmIChyZWdpb25PdXRsaW5lKSB7XHJcbiAgICAgICAgcmVnaW9uT3V0bGluZS5yZW1vdmUoKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9LCBbcmVnaW9uT3V0bGluZV0pO1xyXG5cclxuICAvLyBFZmZlY3QgdG8gaGFuZGxlIG1hcCBjbGljayBmb3IgZ2VvZmVuY2VcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgY29uc3QgaGFuZGxlTWFwR2VvZmVuY2VDbGljayA9IGFzeW5jIChldmVudDogRXZlbnQpID0+IHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICAvLyBDYXN0IHRoZSBldmVudCB0byB0aGUgcHJvcGVyIHR5cGVcclxuICAgICAgICBjb25zdCBjdXN0b21FdmVudCA9IGV2ZW50IGFzIEN1c3RvbUV2ZW50PHsgbGF0OiBudW1iZXI7IGxuZzogbnVtYmVyIH0+O1xyXG4gICAgICAgIGNvbnN0IHsgbGF0LCBsbmcgfSA9IGN1c3RvbUV2ZW50LmRldGFpbDtcclxuXHJcbiAgICAgICAgLy8gRmlyc3QgdXBkYXRlIGNvb3JkaW5hdGVzIGltbWVkaWF0ZWx5XHJcbiAgICAgICAgc2V0R2VvZmVuY2VDb29yZGluYXRlcyh7IGxhdCwgbG5nIH0pO1xyXG5cclxuICAgICAgICAvLyBUaGVuIHN0YXJ0IGFuIGFzeW5jIG9wZXJhdGlvbiB0byBnZXQgdGhlIGxvY2F0aW9uIG5hbWVcclxuICAgICAgICBjb25zb2xlLmxvZyhgR2V0dGluZyBsb2NhdGlvbiBuYW1lIGZvcjogJHtsYXR9LCAke2xuZ31gKTtcclxuXHJcbiAgICAgICAgLy8gVGVtcG9yYXJpbHkgc2hvdyBjb29yZGluYXRlcyB3aGlsZSBmZXRjaGluZyB0aGUgbmFtZVxyXG4gICAgICAgIHNldEdlb2ZlbmNlTG9jYXRpb24oYCR7bGF0LnRvRml4ZWQoNil9LCAke2xuZy50b0ZpeGVkKDYpfWApO1xyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIGZyaWVuZGx5IG5hbWUgYXN5bmNocm9ub3VzbHlcclxuICAgICAgICBjb25zdCBsb2NhdGlvbk5hbWUgPSBhd2FpdCBNYXBib3hTZXJ2aWNlLmdldExvY2F0aW9uTmFtZUZyb21Db29yZGluYXRlcyhcclxuICAgICAgICAgIGxhdCxcclxuICAgICAgICAgIGxuZ1xyXG4gICAgICAgICk7XHJcbiAgICAgICAgY29uc29sZS5sb2coYEdvdCBsb2NhdGlvbiBuYW1lOiAke2xvY2F0aW9uTmFtZX1gKTtcclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIHdpdGggdGhlIGZyaWVuZGx5IG5hbWUgb25jZSB3ZSBoYXZlIGl0XHJcbiAgICAgICAgaWYgKGxvY2F0aW9uTmFtZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgc2V0R2VvZmVuY2VMb2NhdGlvbihsb2NhdGlvbk5hbWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gT3BlbiB0aGUgbG9jYXRpb24gZHJvcGRvd24gaWYgbmVlZGVkXHJcbiAgICAgICAgaWYgKGFjdGl2ZURyb3Bkb3duICE9PSAnbG9jYXRpb24nKSB7XHJcbiAgICAgICAgICBzZXRBY3RpdmVEcm9wZG93bignbG9jYXRpb24nKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaGFuZGxpbmcgbWFwIGNsaWNrOicsIGVycm9yKTtcclxuICAgICAgICAvLyBLZWVwIHRoZSBjb29yZGluYXRlcyBkaXNwbGF5IGlmIHRoZXJlIHdhcyBhbiBlcnJvclxyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEFkZCB0aGUgZXZlbnQgbGlzdGVuZXIgLSB1c2UgdGhlIHN0YW5kYXJkIGV2ZW50IGxpc3RlbmVyIHBhdHRlcm5cclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXHJcbiAgICAgICdtYXAtZ2VvZmVuY2UtY2xpY2snLFxyXG4gICAgICBoYW5kbGVNYXBHZW9mZW5jZUNsaWNrIGFzIEV2ZW50TGlzdGVuZXJcclxuICAgICk7XHJcblxyXG4gICAgLy8gQ2xlYW4gdXBcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXHJcbiAgICAgICAgJ21hcC1nZW9mZW5jZS1jbGljaycsXHJcbiAgICAgICAgaGFuZGxlTWFwR2VvZmVuY2VDbGljayBhcyBFdmVudExpc3RlbmVyXHJcbiAgICAgICk7XHJcbiAgICB9O1xyXG4gIH0sIFtcclxuICAgIHNldEdlb2ZlbmNlTG9jYXRpb24sXHJcbiAgICBzZXRHZW9mZW5jZUNvb3JkaW5hdGVzLFxyXG4gICAgc2V0QWN0aXZlRHJvcGRvd24sXHJcbiAgICBhY3RpdmVEcm9wZG93bixcclxuICBdKTtcclxuXHJcbiAgLy8gTWFpbiBtZXRob2RzXHJcbiAgY29uc3QgdG9nZ2xlRHJvcGRvd24gPSAoZHJvcGRvd246IHN0cmluZywgZXZlbnQ6IFJlYWN0Lk1vdXNlRXZlbnQpID0+IHtcclxuICAgIGlmIChhY3RpdmVEcm9wZG93biA9PT0gZHJvcGRvd24pIHtcclxuICAgICAgc2V0QWN0aXZlRHJvcGRvd24obnVsbCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzZXRBY3RpdmVEcm9wZG93bihkcm9wZG93bik7XHJcbiAgICB9XHJcbiAgICAvLyBQcmV2ZW50IGV2ZW50cyBmcm9tIGJ1YmJsaW5nIHVwXHJcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICB9O1xyXG5cclxuICBjb25zdCBoYW5kbGVSYXRlTGltaXQgPSAocmV0cnlBZnRlcjogbnVtYmVyID0gMzApID0+IHtcclxuICAgIHNldElzUmF0ZUxpbWl0ZWQodHJ1ZSk7XHJcbiAgICBzZXRSYXRlTGltaXRUaW1lcihyZXRyeUFmdGVyKTtcclxuICAgIGNvbnNvbGUubG9nKGBSYXRlIGxpbWl0ZWQgYnkgQVBJLiBSZXRyeSBhZnRlciAke3JldHJ5QWZ0ZXJ9c2ApO1xyXG5cclxuICAgIC8vIEJsb2NrIGFsbCBBUEkgY2FsbHNcclxuICAgIG9wZW5Ta3lUcmFja2luZ1NlcnZpY2Uuc2V0QmxvY2tBbGxBcGlDYWxscyh0cnVlKTtcclxuICAgIHNldEJsb2NrTWFudWZhY3R1cmVyQXBpQ2FsbHModHJ1ZSk7XHJcblxyXG4gICAgLy8gU2hvdyBub3RpZmljYXRpb24gdG8gdXNlclxyXG4gICAgaWYgKHJldHJ5QWZ0ZXIgPiAwKSB7XHJcbiAgICAgIGFsZXJ0KFxyXG4gICAgICAgIGBBaXJjcmFmdCBkYXRhIHJlZnJlc2ggcmF0ZSBsaW1pdGVkLiBQbGVhc2Ugd2FpdCAke3JldHJ5QWZ0ZXJ9IHNlY29uZHMgYmVmb3JlIHRyeWluZyBhZ2Fpbi5gXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogVG9nZ2xlIGZpbHRlciBtb2RlXHJcbiAgICovXHJcbiAgY29uc3QgdG9nZ2xlRmlsdGVyTW9kZSA9IChtb2RlOiBGaWx0ZXJNb2RlKSA9PiB7XHJcbiAgICBzZXRGaWx0ZXJNb2RlKG1vZGUpO1xyXG4gICAgc2V0QWN0aXZlRHJvcGRvd24obnVsbCk7XHJcblxyXG4gICAgLy8gQXBwbHkgYXBwcm9wcmlhdGUgZmlsdGVycyBiYXNlZCBvbiBuZXcgbW9kZVxyXG4gICAgaWYgKG1vZGUgPT09ICdyZWdpb24nKSB7XHJcbiAgICAgIC8vIEJsb2NrIEFQSSBjYWxscyBpbiByZWdpb24gbW9kZVxyXG4gICAgICBvcGVuU2t5VHJhY2tpbmdTZXJ2aWNlLnNldEJsb2NrQWxsQXBpQ2FsbHModHJ1ZSk7XHJcblxyXG4gICAgICAvLyBBcHBseSByZWdpb24gZmlsdGVyaW5nIGlmIHdlIGFscmVhZHkgaGF2ZSBkYXRhXHJcbiAgICAgIGlmIChkaXNwbGF5ZWRBaXJjcmFmdCAmJiBkaXNwbGF5ZWRBaXJjcmFmdC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgZmlsdGVyQWlyY3JhZnRCeVJlZ2lvbihzZWxlY3RlZFJlZ2lvbi50b1N0cmluZygpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2xlYXIgbWFudWZhY3R1cmVyIHNlbGVjdGlvbiBmcm9tIHRoZSBVSVxyXG4gICAgICBzZWxlY3RNYW51ZmFjdHVyZXIobnVsbCk7XHJcbiAgICAgIHNlbGVjdE1vZGVsKG51bGwpO1xyXG5cclxuICAgICAgLy8gSWYgZ2VvZmVuY2UgaXMgYWN0aXZlLCByZXN0b3JlIHRoZSBmdWxsIGdlb2ZlbmNlIGRhdGFcclxuICAgICAgaWYgKGdlb2ZlbmNlQ29vcmRpbmF0ZXMgJiYgZ2VvZmVuY2VBaXJjcmFmdC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgdXBkYXRlR2VvZmVuY2VBaXJjcmFmdChnZW9mZW5jZUFpcmNyYWZ0KTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChtb2RlID09PSAnb3duZXInKSB7XHJcbiAgICAgIC8vIEZpbHRlciBkaXNwbGF5ZWQgYWlyY3JhZnQgYnkgb3duZXIgdHlwZVxyXG4gICAgICBpZiAoZGlzcGxheWVkQWlyY3JhZnQgJiYgZGlzcGxheWVkQWlyY3JhZnQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIC8vIEZpcnN0IGZpbHRlciBmb3IgdmFsaWQgY29vcmRpbmF0ZXNcclxuICAgICAgICBjb25zdCBhaXJjcmFmdFdpdGhWYWxpZENvb3JkcyA9IGRpc3BsYXllZEFpcmNyYWZ0LmZpbHRlcihcclxuICAgICAgICAgIChwbGFuZSkgPT5cclxuICAgICAgICAgICAgdHlwZW9mIHBsYW5lLmxhdGl0dWRlID09PSAnbnVtYmVyJyAmJlxyXG4gICAgICAgICAgICB0eXBlb2YgcGxhbmUubG9uZ2l0dWRlID09PSAnbnVtYmVyJyAmJlxyXG4gICAgICAgICAgICAhaXNOYU4ocGxhbmUubGF0aXR1ZGUpICYmXHJcbiAgICAgICAgICAgICFpc05hTihwbGFuZS5sb25naXR1ZGUpXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gQXBwbHkgb3duZXIgdHlwZSBmaWx0ZXJcclxuICAgICAgICBsZXQgZmlsdGVyZWRCeU93bmVyID1cclxuICAgICAgICAgIG93bmVyRmlsdGVycy5sZW5ndGggPT09IDBcclxuICAgICAgICAgICAgPyBhaXJjcmFmdFdpdGhWYWxpZENvb3Jkc1xyXG4gICAgICAgICAgICA6IGFpcmNyYWZ0V2l0aFZhbGlkQ29vcmRzLmZpbHRlcigoYWlyY3JhZnQpID0+XHJcbiAgICAgICAgICAgICAgICBvd25lckZpbHRlcnMuaW5jbHVkZXMoZ2V0QWlyY3JhZnRPd25lclR5cGUoYWlyY3JhZnQpKVxyXG4gICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSBkaXNwbGF5IHdpdGggZmlsdGVyZWQgYWlyY3JhZnRcclxuICAgICAgICBpZiAoY2xlYXJHZW9mZW5jZURhdGEpIHtcclxuICAgICAgICAgIGNsZWFyR2VvZmVuY2VEYXRhKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHVwZGF0ZUdlb2ZlbmNlQWlyY3JhZnQoZmlsdGVyZWRCeU93bmVyKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChtb2RlID09PSAnYm90aCcpIHtcclxuICAgICAgLy8gQm90aCBtb2RlIC0gQkxPQ0sgQVBJIENBTExTXHJcbiAgICAgIG9wZW5Ta3lUcmFja2luZ1NlcnZpY2Uuc2V0QmxvY2tBbGxBcGlDYWxscyh0cnVlKTtcclxuXHJcbiAgICAgIGlmIChcclxuICAgICAgICBzZWxlY3RlZE1hbnVmYWN0dXJlciAmJlxyXG4gICAgICAgIGlzR2VvZmVuY2VBY3RpdmUgJiZcclxuICAgICAgICBnZW9mZW5jZUFpcmNyYWZ0Lmxlbmd0aCA+IDBcclxuICAgICAgKSB7XHJcbiAgICAgICAgYXBwbHlDb21iaW5lZEZpbHRlcnMoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBJZiBvbmUgaXMgbWlzc2luZywgcHJvbXB0IHRoZSB1c2VyXHJcbiAgICAgICAgaWYgKCFzZWxlY3RlZE1hbnVmYWN0dXJlciAmJiBpc0dlb2ZlbmNlQWN0aXZlKSB7XHJcbiAgICAgICAgICBhbGVydCgnUGxlYXNlIHNlbGVjdCBhIG1hbnVmYWN0dXJlciB0byB1c2UgY29tYmluZWQgZmlsdGVyIG1vZGUnKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHNlbGVjdGVkTWFudWZhY3R1cmVyICYmICFpc0dlb2ZlbmNlQWN0aXZlKSB7XHJcbiAgICAgICAgICBhbGVydCgnUGxlYXNlIHNldCBhIGxvY2F0aW9uIHRvIHVzZSBjb21iaW5lZCBmaWx0ZXIgbW9kZScpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBhbGVydChcclxuICAgICAgICAgICAgJ1BsZWFzZSBzZWxlY3QgYm90aCBhIG1hbnVmYWN0dXJlciBhbmQgbG9jYXRpb24gdG8gdXNlIGNvbWJpbmVkIGZpbHRlciBtb2RlJ1xyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvLyBPd25lciBmaWx0ZXIgbWV0aG9kc1xyXG4gIGNvbnN0IGdldEFpcmNyYWZ0T3duZXJUeXBlID0gKGFpcmNyYWZ0OiBFeHRlbmRlZEFpcmNyYWZ0KTogc3RyaW5nID0+IHtcclxuICAgIGNvbnN0IG93bmVyVHlwZSA9IGFpcmNyYWZ0LlRZUEVfUkVHSVNUUkFOVCB8fCAwO1xyXG4gICAgcmV0dXJuIG93bmVyVHlwZVRvU3RyaW5nKG93bmVyVHlwZSk7XHJcbiAgfTtcclxuXHJcbiAgY29uc3Qgb3duZXJUeXBlVG9TdHJpbmcgPSAodHlwZTogbnVtYmVyIHwgc3RyaW5nKTogc3RyaW5nID0+IHtcclxuICAgIGNvbnN0IHR5cGVOdW0gPSB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgPyBwYXJzZUludCh0eXBlLCAxMCkgOiB0eXBlO1xyXG5cclxuICAgIGNvbnN0IG93bmVyVHlwZU1hcDogUmVjb3JkPG51bWJlciwgc3RyaW5nPiA9IHtcclxuICAgICAgMTogJ2luZGl2aWR1YWwnLFxyXG4gICAgICAyOiAncGFydG5lcnNoaXAnLFxyXG4gICAgICAzOiAnY29ycC1vd25lcicsXHJcbiAgICAgIDQ6ICdjby1vd25lZCcsXHJcbiAgICAgIDc6ICdsbGMnLFxyXG4gICAgICA4OiAnbm9uLWNpdGl6ZW4tY29ycCcsXHJcbiAgICAgIDk6ICdhaXJsaW5lJyxcclxuICAgICAgMTA6ICdmcmVpZ2h0JyxcclxuICAgICAgMTE6ICdtZWRpY2FsJyxcclxuICAgICAgMTI6ICdtZWRpYScsXHJcbiAgICAgIDEzOiAnaGlzdG9yaWNhbCcsXHJcbiAgICAgIDE0OiAnZmx5aW5nLWNsdWInLFxyXG4gICAgICAxNTogJ2VtZXJnZW5jeScsXHJcbiAgICAgIDE2OiAnbG9jYWwtZ292dCcsXHJcbiAgICAgIDE3OiAnZWR1Y2F0aW9uJyxcclxuICAgICAgMTg6ICdmZWRlcmFsLWdvdnQnLFxyXG4gICAgICAxOTogJ2ZsaWdodC1zY2hvb2wnLFxyXG4gICAgICAyMDogJ2xlYXNpbmctY29ycCcsXHJcbiAgICAgIDIxOiAnbWlsaXRhcnknLFxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gb3duZXJUeXBlTWFwW3R5cGVOdW1dIHx8ICd1bmtub3duJztcclxuICB9O1xyXG5cclxuICBjb25zdCBhcHBseU93bmVyVHlwZUZpbHRlciA9IChmaWx0ZXJzOiBzdHJpbmdbXSkgPT4ge1xyXG4gICAgLy8gU2tpcCBmaWx0ZXJpbmcgaWYgYWxsIHR5cGVzIGFyZSBzZWxlY3RlZCBvciBub25lIGFyZSBzZWxlY3RlZFxyXG4gICAgaWYgKGZpbHRlcnMubGVuZ3RoID09PSAwIHx8IGZpbHRlcnMubGVuZ3RoID09PSBhbGxPd25lclR5cGVzLmxlbmd0aCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRmlsdGVyIHRoZSBhaXJjcmFmdCBiYXNlZCBvbiBzZWxlY3RlZCBvd25lciB0eXBlc1xyXG4gICAgaWYgKGRpc3BsYXllZEFpcmNyYWZ0ICYmIGRpc3BsYXllZEFpcmNyYWZ0Lmxlbmd0aCA+IDApIHtcclxuICAgICAgY29uc3QgZmlsdGVyZWRBaXJjcmFmdCA9IGRpc3BsYXllZEFpcmNyYWZ0LmZpbHRlcigoYWlyY3JhZnQpID0+IHtcclxuICAgICAgICBjb25zdCBvd25lclR5cGUgPSBnZXRBaXJjcmFmdE93bmVyVHlwZShhaXJjcmFmdCk7XHJcbiAgICAgICAgcmV0dXJuIGZpbHRlcnMuaW5jbHVkZXMob3duZXJUeXBlKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBVcGRhdGUgdGhlIGRpc3BsYXllZCBhaXJjcmFmdFxyXG4gICAgICBpZiAoY2xlYXJHZW9mZW5jZURhdGEpIHtcclxuICAgICAgICBjbGVhckdlb2ZlbmNlRGF0YSgpO1xyXG4gICAgICB9XHJcbiAgICAgIHVwZGF0ZUdlb2ZlbmNlQWlyY3JhZnQoZmlsdGVyZWRBaXJjcmFmdCk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgaGFuZGxlT3duZXJGaWx0ZXJDaGFuZ2UgPSAodXBkYXRlZEZpbHRlcnM6IHN0cmluZ1tdKSA9PiB7XHJcbiAgICBzZXRPd25lckZpbHRlcnModXBkYXRlZEZpbHRlcnMpO1xyXG4gICAgLy8gQXBwbHkgdGhlIGZpbHRlciB0byB5b3VyIGFpcmNyYWZ0IGRhdGFcclxuICAgIGFwcGx5T3duZXJUeXBlRmlsdGVyKHVwZGF0ZWRGaWx0ZXJzKTtcclxuICB9O1xyXG5cclxuICBjb25zdCByZXNldE93bmVyRmlsdGVycyA9ICgpID0+IHtcclxuICAgIHNldE93bmVyRmlsdGVycyhbLi4uYWxsT3duZXJUeXBlc10pO1xyXG4gIH07XHJcblxyXG4gIC8vIFJlZ2lvbiBmaWx0ZXIgbWV0aG9kc1xyXG4gIGNvbnN0IGZpbHRlckFpcmNyYWZ0QnlSZWdpb24gPSAocmVnaW9uOiBzdHJpbmcpID0+IHtcclxuICAgIGlmICghZGlzcGxheWVkQWlyY3JhZnQgfHwgZGlzcGxheWVkQWlyY3JhZnQubGVuZ3RoID09PSAwKSByZXR1cm47XHJcbiAgICBzZXRMb2NhbExvYWRpbmcodHJ1ZSk7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gR2V0IHRoZSBib3VuZHMgZm9yIHRoZSBzZWxlY3RlZCByZWdpb25cclxuICAgICAgY29uc3QgYm91bmRzRXhwcmVzc2lvbiA9IGdldEJvdW5kc0J5UmVnaW9uKHJlZ2lvbik7XHJcblxyXG4gICAgICAvLyBFbnN1cmUgYm91bmRzIGlzIGluIHRoZSBjb3JyZWN0IGZvcm1hdFxyXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYm91bmRzRXhwcmVzc2lvbikgfHwgYm91bmRzRXhwcmVzc2lvbi5sZW5ndGggIT09IDIpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKFxyXG4gICAgICAgICAgYEludmFsaWQgYm91bmRzIGZvcm1hdCBmb3IgcmVnaW9uOiAke3JlZ2lvbn1gLFxyXG4gICAgICAgICAgYm91bmRzRXhwcmVzc2lvblxyXG4gICAgICAgICk7XHJcbiAgICAgICAgc2V0TG9jYWxMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEV4dHJhY3QgY29vcmRpbmF0ZXMgLSBMZWFmbGV0IHVzZXMgW2xhdCwgbG5nXSBmb3JtYXRcclxuICAgICAgY29uc3QgW1ttaW5MYXQsIG1pbkxuZ10sIFttYXhMYXQsIG1heExuZ11dID0gYm91bmRzRXhwcmVzc2lvbjtcclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKGBGaWx0ZXJpbmcgYnkgcmVnaW9uOiAke3JlZ2lvbn0gd2l0aCBib3VuZHM6YCwge1xyXG4gICAgICAgIG1pbkxhdCxcclxuICAgICAgICBtaW5MbmcsXHJcbiAgICAgICAgbWF4TGF0LFxyXG4gICAgICAgIG1heExuZyxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBGaWx0ZXIgYWlyY3JhZnQgYmFzZWQgb24gY29vcmRpbmF0ZXMgd2l0aGluIHRoZSBib3VuZHNcclxuICAgICAgY29uc3QgZmlsdGVyZWRBaXJjcmFmdCA9IGRpc3BsYXllZEFpcmNyYWZ0LmZpbHRlcigoYWlyY3JhZnQpID0+IHtcclxuICAgICAgICAvLyBDaGVjayBpZiBhaXJjcmFmdCBoYXMgdmFsaWQgY29vcmRpbmF0ZXNcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICB0eXBlb2YgYWlyY3JhZnQubGF0aXR1ZGUgIT09ICdudW1iZXInIHx8XHJcbiAgICAgICAgICB0eXBlb2YgYWlyY3JhZnQubG9uZ2l0dWRlICE9PSAnbnVtYmVyJyB8fFxyXG4gICAgICAgICAgaXNOYU4oYWlyY3JhZnQubGF0aXR1ZGUpIHx8XHJcbiAgICAgICAgICBpc05hTihhaXJjcmFmdC5sb25naXR1ZGUpXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDaGVjayBpZiBjb29yZGluYXRlcyBhcmUgd2l0aGluIHRoZSBib3VuZHNcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgYWlyY3JhZnQubGF0aXR1ZGUgPj0gbWluTGF0ICYmXHJcbiAgICAgICAgICBhaXJjcmFmdC5sYXRpdHVkZSA8PSBtYXhMYXQgJiZcclxuICAgICAgICAgIGFpcmNyYWZ0LmxvbmdpdHVkZSA+PSBtaW5MbmcgJiZcclxuICAgICAgICAgIGFpcmNyYWZ0LmxvbmdpdHVkZSA8PSBtYXhMbmdcclxuICAgICAgICApO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIFVwZGF0ZSB0aGUgZGlzcGxheSB3aXRoIGZpbHRlcmVkIGFpcmNyYWZ0XHJcbiAgICAgIGlmIChjbGVhckdlb2ZlbmNlRGF0YSkge1xyXG4gICAgICAgIGNsZWFyR2VvZmVuY2VEYXRhKCk7XHJcbiAgICAgIH1cclxuICAgICAgdXBkYXRlR2VvZmVuY2VBaXJjcmFmdChmaWx0ZXJlZEFpcmNyYWZ0KTtcclxuICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgYEZpbHRlcmVkIHRvICR7ZmlsdGVyZWRBaXJjcmFmdC5sZW5ndGh9IGFpcmNyYWZ0IGluICR7cmVnaW9ufSByZWdpb24gKG91dCBvZiAke2Rpc3BsYXllZEFpcmNyYWZ0Lmxlbmd0aH0gdG90YWwpYFxyXG4gICAgICApO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmlsdGVyaW5nIGFpcmNyYWZ0IGJ5IHJlZ2lvbjonLCBlcnJvcik7XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICBzZXRMb2NhbExvYWRpbmcoZmFsc2UpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGNvbnN0IGhhbmRsZVJlZ2lvblNlbGVjdCA9IGFzeW5jIChyZWdpb246IFJlZ2lvbkNvZGUpID0+IHtcclxuICAgIHNldEFjdGl2ZVJlZ2lvbihyZWdpb24pO1xyXG4gICAgc2V0U2VsZWN0ZWRSZWdpb24ocmVnaW9uKTtcclxuICAgIHNldExvY2FsTG9hZGluZyh0cnVlKTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBTZXQgbWFwIGJvdW5kcyBiYXNlZCBvbiByZWdpb25cclxuICAgICAgaWYgKG1hcEluc3RhbmNlKSB7XHJcbiAgICAgICAgY29uc3QgYm91bmRzID0gZ2V0Qm91bmRzQnlSZWdpb24ocmVnaW9uKTtcclxuXHJcbiAgICAgICAgLy8gR2V0IHRoZSBhcHByb3ByaWF0ZSB6b29tIGxldmVsIGZvciB0aGlzIHJlZ2lvbiBmcm9tIHlvdXIgY29uZmlnXHJcbiAgICAgICAgY29uc3Qgem9vbUxldmVsID0gZ2V0Wm9vbUxldmVsRm9yUmVnaW9uKHJlZ2lvbik7XHJcblxyXG4gICAgICAgIC8vIEZpcnN0LCBzZXQgdGhlIGFwcHJvcHJpYXRlIHpvb20gbGV2ZWxcclxuICAgICAgICBtYXBJbnN0YW5jZS5zZXRab29tKHpvb21MZXZlbCk7XHJcblxyXG4gICAgICAgIC8vIFRoZW4gZml0IGJvdW5kcyB3aXRoIHBhZGRpbmdcclxuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xyXG4gICAgICAgICAgcGFkZGluZzogTUFQX0NPTkZJRy5QQURESU5HLkRFRkFVTFQsXHJcbiAgICAgICAgICAvLyBEb24ndCBzZXQgbWF4Wm9vbSBoZXJlIGFzIHdlIHdhbnQgdGhlIHJlZ2lvbiB0byBiZSBwcm9wZXJseSBkaXNwbGF5ZWRcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBtYXBJbnN0YW5jZS5maXRCb3VuZHMoYm91bmRzIGFzIGFueSwgb3B0aW9ucyk7XHJcbiAgICAgICAgbWFwSW5zdGFuY2UuaW52YWxpZGF0ZVNpemUoKTtcclxuICAgICAgICBkcmF3UmVnaW9uT3V0bGluZShyZWdpb24pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBJbnN0ZWFkIG9mIGltbWVkaWF0ZWx5IGZldGNoaW5nIGFpcmNyYWZ0IGRhdGEsXHJcbiAgICAgIC8vIGp1c3Qgc3RvcmUgdGhlIHJlZ2lvbiBzZWxlY3Rpb24gZm9yIGxhdGVyIHVzZVxyXG4gICAgICBjb25zb2xlLmxvZyhgUmVnaW9uIHNlbGVjdGVkLiBXYWl0aW5nIGZvciBtYW51ZmFjdHVyZXIgc2VsZWN0aW9uLi4uYCk7XHJcblxyXG4gICAgICAvLyBPcHRpb25hbGx5LCB5b3UgY291bGQgZmV0Y2gganVzdCB0aGUgY291bnQgb2YgYWlyY3JhZnQgaW4gdGhpcyByZWdpb25cclxuICAgICAgLy8gdG8gZ2l2ZSB0aGUgdXNlciBhbiBpZGVhIG9mIHRoZSBkYXRhIHZvbHVtZVxyXG4gICAgICBjb25zdCBjb3VudFJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXHJcbiAgICAgICAgYC9hcGkvdHJhY2tpbmcvcmVnaW9uLWNvdW50P3JlZ2lvbj0ke3JlZ2lvbn1gXHJcbiAgICAgICk7XHJcbiAgICAgIGlmIChjb3VudFJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgY29uc3QgY291bnREYXRhID0gYXdhaXQgY291bnRSZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgY29uc29sZS5sb2coYCR7Y291bnREYXRhLmNvdW50fSBhaXJjcmFmdCBhdmFpbGFibGUgaW4gdGhpcyByZWdpb25gKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2xlYXIgYW55IHByZXZpb3VzIGFpcmNyYWZ0IGRhdGFcclxuICAgICAgaWYgKGNsZWFyR2VvZmVuY2VEYXRhKSB7XHJcbiAgICAgICAgY2xlYXJHZW9mZW5jZURhdGEoKTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gcmVnaW9uIHNlbGVjdGlvbjonLCBlcnJvcik7XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICBzZXRMb2NhbExvYWRpbmcoZmFsc2UpO1xyXG4gICAgICBzZXRBY3RpdmVEcm9wZG93bihudWxsKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBjb25zdCBkcmF3UmVnaW9uT3V0bGluZSA9IChyZWdpb246IFJlZ2lvbkNvZGUpID0+IHtcclxuICAgIGlmICghbWFwSW5zdGFuY2UpIHJldHVybjtcclxuXHJcbiAgICAvLyBDbGVhciBhbnkgZXhpc3Rpbmcgb3V0bGluZVxyXG4gICAgaWYgKHJlZ2lvbk91dGxpbmUpIHtcclxuICAgICAgcmVnaW9uT3V0bGluZS5yZW1vdmUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBHZXQgdGhlIGJvdW5kcyBmb3IgdGhlIHNlbGVjdGVkIHJlZ2lvblxyXG4gICAgY29uc3QgYm91bmRzID0gZ2V0Qm91bmRzQnlSZWdpb24ocmVnaW9uKSBhcyBbXHJcbiAgICAgIFtudW1iZXIsIG51bWJlcl0sXHJcbiAgICAgIFtudW1iZXIsIG51bWJlcl0sXHJcbiAgICBdO1xyXG5cclxuICAgIC8vIENyZWF0ZSBhIHBvbHlnb24gZnJvbSB0aGUgYm91bmRzXHJcbiAgICBjb25zdCBMID0gcmVxdWlyZSgnbGVhZmxldCcpO1xyXG4gICAgY29uc3QgcmVjdGFuZ2xlID0gTC5yZWN0YW5nbGUoYm91bmRzLCB7XHJcbiAgICAgIGNvbG9yOiAnIzRmNDZlNScsIC8vIEluZGlnbyBjb2xvciBtYXRjaGluZyB5b3VyIFVJXHJcbiAgICAgIHdlaWdodDogMyxcclxuICAgICAgb3BhY2l0eTogMC43LFxyXG4gICAgICBmaWxsOiB0cnVlLFxyXG4gICAgICBmaWxsQ29sb3I6ICcjNGY0NmU1JyxcclxuICAgICAgZmlsbE9wYWNpdHk6IDAuMSxcclxuICAgICAgZGFzaEFycmF5OiAnNSwgMTAnLCAvLyBPcHRpb25hbDogY3JlYXRlcyBhIGRhc2hlZCBsaW5lXHJcbiAgICAgIGludGVyYWN0aXZlOiBmYWxzZSwgLy8gUHJldmVudHMgdGhlIHJlY3RhbmdsZSBmcm9tIGNhcHR1cmluZyBtb3VzZSBldmVudHNcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEFkZCB0byBtYXBcclxuICAgIHJlY3RhbmdsZS5hZGRUbyhtYXBJbnN0YW5jZSk7XHJcblxyXG4gICAgLy8gVXBkYXRlIHRoZSBzdGF0ZSB0byBpbmNsdWRlIGJvdGggdGhlIHJlY3RhbmdsZSBhbmQgdGhlIGxhYmVsXHJcbiAgICBzZXRSZWdpb25PdXRsaW5lKHtcclxuICAgICAgcmVtb3ZlOiAoKSA9PiB7XHJcbiAgICAgICAgcmVjdGFuZ2xlLnJlbW92ZSgpO1xyXG4gICAgICB9LFxyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgLy8gR2VvZmVuY2UgbWV0aG9kc1xyXG4gIC8vIEZpeGVkIGdldFVzZXJMb2NhdGlvbiBmdW5jdGlvblxyXG4gIGNvbnN0IGdldFVzZXJMb2NhdGlvbiA9IGFzeW5jICgpID0+IHtcclxuICAgIGlmIChpc1JhdGVMaW1pdGVkKSB7XHJcbiAgICAgIGFsZXJ0KFxyXG4gICAgICAgIGBSYXRlIGxpbWl0ZWQuIFBsZWFzZSB3YWl0ICR7cmF0ZUxpbWl0VGltZXIgfHwgMzB9IHNlY29uZHMgYmVmb3JlIHRyeWluZyB0byBnZXQgbG9jYXRpb24uYFxyXG4gICAgICApO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZ2V0VXNlckxvY2F0aW9uID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICBpZiAoaXNSYXRlTGltaXRlZCkge1xyXG4gICAgICAgIGFsZXJ0KFxyXG4gICAgICAgICAgYFJhdGUgbGltaXRlZC4gUGxlYXNlIHdhaXQgJHtyYXRlTGltaXRUaW1lciB8fCAzMH0gc2Vjb25kcyBiZWZvcmUgdHJ5aW5nIHRvIGdldCBsb2NhdGlvbi5gXHJcbiAgICAgICAgKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHNldElzR2V0dGluZ0xvY2F0aW9uKHRydWUpO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIC8vIFVzZSB0aGUgZ2V0Q3VycmVudFBvc2l0aW9uIGZyb20gb3VyIGNvbWJpbmVkIGhvb2tcclxuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IGF3YWl0IGdlb2xvY2F0aW9uU2VydmljZXMuZ2V0Q3VycmVudFBvc2l0aW9uKCk7XHJcblxyXG4gICAgICAgIGlmIChwb3NpdGlvbikge1xyXG4gICAgICAgICAgY29uc3QgeyBsYXRpdHVkZSwgbG9uZ2l0dWRlIH0gPSBwb3NpdGlvbi5jb29yZHM7XHJcblxyXG4gICAgICAgICAgLy8gVXBkYXRlIHN0YXRlIHdpdGggY29vcmRpbmF0ZXNcclxuICAgICAgICAgIHNldEdlb2ZlbmNlQ29vcmRpbmF0ZXMoeyBsYXQ6IGxhdGl0dWRlLCBsbmc6IGxvbmdpdHVkZSB9KTtcclxuICAgICAgICAgIHNldEdlb2ZlbmNlQ2VudGVyKHsgbGF0OiBsYXRpdHVkZSwgbG5nOiBsb25naXR1ZGUgfSk7XHJcblxyXG4gICAgICAgICAgLy8gVXBkYXRlIHRoZSBsb2NhdGlvbiBkaXNwbGF5IHdpdGggY29vcmRpbmF0ZXNcclxuICAgICAgICAgIHNldEdlb2ZlbmNlTG9jYXRpb24oXHJcbiAgICAgICAgICAgIGAke2xhdGl0dWRlLnRvRml4ZWQoNil9LCAke2xvbmdpdHVkZS50b0ZpeGVkKDYpfWBcclxuICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgLy8gQXV0b21hdGljYWxseSB0cmlnZ2VyIHRoZSBnZW9mZW5jZSBzZWFyY2hcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZldGNoZWRBaXJjcmFmdCA9IGF3YWl0IGdldEFpcmNyYWZ0TmVhckxvY2F0aW9uKFxyXG4gICAgICAgICAgICAgIGxhdGl0dWRlLFxyXG4gICAgICAgICAgICAgIGxvbmdpdHVkZSxcclxuICAgICAgICAgICAgICBnZW9mZW5jZVJhZGl1c1xyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgaWYgKGZldGNoZWRBaXJjcmFmdC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICBhbGVydChcclxuICAgICAgICAgICAgICAgIGBObyBhaXJjcmFmdCBmb3VuZCBuZWFyIHlvdXIgY3VycmVudCBsb2NhdGlvbi4gVHJ5IGluY3JlYXNpbmcgdGhlIHJhZGl1cy5gXHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICBzZXRJc0dldHRpbmdMb2NhdGlvbihmYWxzZSk7XHJcbiAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBQcm9jZXNzIHRoZSBhaXJjcmFmdCBkYXRhXHJcbiAgICAgICAgICAgIGNvbnN0IGFkYXB0ZWRBaXJjcmFmdCA9IGFkYXB0R2VvZmVuY2VBaXJjcmFmdChmZXRjaGVkQWlyY3JhZnQpO1xyXG4gICAgICAgICAgICBjb25zdCBlbnJpY2hlZEFpcmNyYWZ0ID1cclxuICAgICAgICAgICAgICBhd2FpdCBlbnJpY2hHZW9mZW5jZUFpcmNyYWZ0KGFkYXB0ZWRBaXJjcmFmdCk7XHJcblxyXG4gICAgICAgICAgICAvLyBTYXZlIHRvIGxvY2FsIHN0YXRlXHJcbiAgICAgICAgICAgIHNldEdlb2ZlbmNlQWlyY3JhZnQoZW5yaWNoZWRBaXJjcmFmdCk7XHJcblxyXG4gICAgICAgICAgICAvLyBDbGVhciBleGlzdGluZyBhaXJjcmFmdCBkYXRhXHJcbiAgICAgICAgICAgIGlmIChjbGVhckdlb2ZlbmNlRGF0YSkge1xyXG4gICAgICAgICAgICAgIGNsZWFyR2VvZmVuY2VEYXRhKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgbWFwIHdpdGggbmV3IGFpcmNyYWZ0XHJcbiAgICAgICAgICAgIHVwZGF0ZUdlb2ZlbmNlQWlyY3JhZnQoZW5yaWNoZWRBaXJjcmFmdCk7XHJcbiAgICAgICAgICAgIHNldElzR2VvZmVuY2VBY3RpdmUodHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBDZW50ZXIgdGhlIG1hcCBvbiB1c2VyJ3MgbG9jYXRpb24gLSBTSU1QTElGSUVEIFpPT00gTE9HSUNcclxuICAgICAgICAgICAgaWYgKG1hcEluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgLy8gRG9uJ3QgbW9kaWZ5IHpvb20gaWYgaXQncyBhbHJlYWR5IGF0IGFuIGFwcHJvcHJpYXRlIGxldmVsXHJcbiAgICAgICAgICAgICAgY29uc3QgY3VycmVudFpvb20gPSBtYXBJbnN0YW5jZS5nZXRab29tKCk7XHJcbiAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0Wm9vbSA9IGN1cnJlbnRab29tIDw9IDcgPyA5IDogY3VycmVudFpvb207XHJcblxyXG4gICAgICAgICAgICAgIC8vIFNldCB0aGUgdmlldyBkaXJlY3RseSB0byB0aGUgdXNlcidzIGxvY2F0aW9uXHJcbiAgICAgICAgICAgICAgbWFwSW5zdGFuY2Uuc2V0VmlldyhbbGF0aXR1ZGUsIGxvbmdpdHVkZV0sIHRhcmdldFpvb20pO1xyXG5cclxuICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIG1hcCByZWZsZWN0cyBjaGFuZ2VzXHJcbiAgICAgICAgICAgICAgbWFwSW5zdGFuY2UuaW52YWxpZGF0ZVNpemUoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSWYgaW4gZ2VvZmVuY2UgbW9kZSwgZW5zdXJlIHRoZSBmaWx0ZXIgbW9kZSBpcyBzZXQgY29ycmVjdGx5XHJcbiAgICAgICAgICAgIGlmIChmaWx0ZXJNb2RlICE9PSAnZ2VvZmVuY2UnICYmIGZpbHRlck1vZGUgIT09ICdib3RoJykge1xyXG4gICAgICAgICAgICAgIHNldEZpbHRlck1vZGUoJ2dlb2ZlbmNlJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCdyYXRlIGxpbWl0JykgfHwgZXJyb3Iuc3RhdHVzID09PSA0MjkpIHtcclxuICAgICAgICAgICAgICBoYW5kbGVSYXRlTGltaXQoMzApO1xyXG4gICAgICAgICAgICAgIC8vIFN0aWxsIHVwZGF0ZSB0aGUgbG9jYXRpb24gZXZlbiBpZiB3ZSBjb3VsZG4ndCBnZXQgYWlyY3JhZnRcclxuICAgICAgICAgICAgICBpZiAobWFwSW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgIG1hcEluc3RhbmNlLnNldFZpZXcoW2xhdGl0dWRlLCBsb25naXR1ZGVdLCA5KTtcclxuICAgICAgICAgICAgICAgIG1hcEluc3RhbmNlLmludmFsaWRhdGVTaXplKCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gQ2xvc2UgdGhlIGRyb3Bkb3duIGFmdGVyIHNlbGVjdGlvblxyXG4gICAgICAgICAgc2V0QWN0aXZlRHJvcGRvd24obnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgdXNlciBsb2NhdGlvbjonLCBlcnJvcik7XHJcbiAgICAgICAgYWxlcnQoXHJcbiAgICAgICAgICAnVW5hYmxlIHRvIGFjY2VzcyB5b3VyIGxvY2F0aW9uLiBQbGVhc2UgbWFrZSBzdXJlIGxvY2F0aW9uIHNlcnZpY2VzIGFyZSBlbmFibGVkIGluIHlvdXIgYnJvd3Nlci4nXHJcbiAgICAgICAgKTtcclxuICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICBzZXRJc0dldHRpbmdMb2NhdGlvbihmYWxzZSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgcHJvY2Vzc0dlb2ZlbmNlU2VhcmNoID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICBpZiAoIWdlb2ZlbmNlTG9jYXRpb24pIHJldHVybjtcclxuXHJcbiAgICAgIC8vIENoZWNrIGlmIHJhdGUgbGltaXRlZFxyXG4gICAgICBpZiAoaXNSYXRlTGltaXRlZCkge1xyXG4gICAgICAgIGFsZXJ0KFxyXG4gICAgICAgICAgYFJhdGUgbGltaXRlZC4gUGxlYXNlIHdhaXQgJHtyYXRlTGltaXRUaW1lciB8fCAzMH0gc2Vjb25kcyBiZWZvcmUgc2VhcmNoaW5nIGFnYWluLmBcclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQmxvY2sgQVBJIGNhbGxzIHdoaWxlIGRvaW5nIGdlb2ZlbmNlIHNlYXJjaCBpbiBjb21iaW5lZCBtb2RlXHJcbiAgICAgIGlmIChmaWx0ZXJNb2RlID09PSAnYm90aCcpIHtcclxuICAgICAgICBvcGVuU2t5VHJhY2tpbmdTZXJ2aWNlLnNldEJsb2NrQWxsQXBpQ2FsbHModHJ1ZSk7XHJcbiAgICAgICAgc2V0QmxvY2tNYW51ZmFjdHVyZXJBcGlDYWxscyh0cnVlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gU2V0IGxvYWRpbmcgc3RhdGVcclxuICAgICAgc2V0TG9jYWxMb2FkaW5nKHRydWUpO1xyXG5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgIGBTZWFyY2hpbmcgZm9yIGFpcmNyYWZ0IG5lYXIgbG9jYXRpb246IFwiJHtnZW9mZW5jZUxvY2F0aW9ufVwiYFxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIC8vIFRoaXMgd2lsbCBoYW5kbGUgUG9zdGFsIGNvZGVzLCBwbGFjZSBuYW1lcywgYWRkcmVzc2VzLCBQT0lzLCBldGMuXHJcbiAgICAgICAgbGV0IGZldGNoZWRBaXJjcmFmdDtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgZmV0Y2hlZEFpcmNyYWZ0ID0gYXdhaXQgZ2V0QWlyY3JhZnROZWFyU2VhcmNoZWRMb2NhdGlvbihcclxuICAgICAgICAgICAgZ2VvZmVuY2VMb2NhdGlvbixcclxuICAgICAgICAgICAgZ2VvZmVuY2VSYWRpdXNcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCdyYXRlIGxpbWl0JykgfHwgZXJyb3Iuc3RhdHVzID09PSA0MjkpIHtcclxuICAgICAgICAgICAgY29uc3QgcmV0cnlBZnRlciA9IDMwOyAvLyBEZWZhdWx0IHRvIDMwIHNlY29uZHMgaWYgbm90IHNwZWNpZmllZFxyXG4gICAgICAgICAgICBoYW5kbGVSYXRlTGltaXQocmV0cnlBZnRlcik7XHJcbiAgICAgICAgICAgIHNldExvY2FsTG9hZGluZyhmYWxzZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gR2V0IGNvb3JkaW5hdGVzIGZvciB0aGUgbWFwXHJcbiAgICAgICAgbGV0IGxvY2F0aW9uczogeyBsYXQ6IG51bWJlcjsgbG5nOiBudW1iZXI7IG5hbWU6IHN0cmluZyB9W107XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGxvY2F0aW9ucyA9IGF3YWl0IE1hcGJveFNlcnZpY2Uuc2VhcmNoTG9jYXRpb25XaXRoTWFwYm94KFxyXG4gICAgICAgICAgICBnZW9mZW5jZUxvY2F0aW9uLFxyXG4gICAgICAgICAgICAxXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzZWFyY2hpbmcgbG9jYXRpb24gd2l0aCBNYXBib3g6JywgZXJyb3IpO1xyXG4gICAgICAgICAgLy8gQ29udGludWUgd2l0aCBhaXJjcmFmdCBkYXRhIGlmIGF2YWlsYWJsZVxyXG4gICAgICAgICAgbG9jYXRpb25zID0gW107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgY29vcmRpbmF0ZXM6IHsgbGF0OiBudW1iZXI7IGxuZzogbnVtYmVyIH0gfCBudWxsID0gbnVsbDtcclxuXHJcbiAgICAgICAgaWYgKGxvY2F0aW9ucy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICBjb29yZGluYXRlcyA9IHtcclxuICAgICAgICAgICAgbGF0OiBsb2NhdGlvbnNbMF0ubGF0LFxyXG4gICAgICAgICAgICBsbmc6IGxvY2F0aW9uc1swXS5sbmcsXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgLy8gU2F2ZSB0aGUgZm9ybWF0dGVkIGxvY2F0aW9uIG5hbWVcclxuICAgICAgICAgIHNldEdlb2ZlbmNlTG9jYXRpb24obG9jYXRpb25zWzBdLm5hbWUpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgICAgICBmZXRjaGVkQWlyY3JhZnQubGVuZ3RoID4gMCAmJlxyXG4gICAgICAgICAgZmV0Y2hlZEFpcmNyYWZ0WzBdLmxhdGl0dWRlICYmXHJcbiAgICAgICAgICBmZXRjaGVkQWlyY3JhZnRbMF0ubG9uZ2l0dWRlXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAvLyBGYWxsYmFjayB0byBmaXJzdCBhaXJjcmFmdCBwb3NpdGlvblxyXG4gICAgICAgICAgY29vcmRpbmF0ZXMgPSB7XHJcbiAgICAgICAgICAgIGxhdDogZmV0Y2hlZEFpcmNyYWZ0WzBdLmxhdGl0dWRlLFxyXG4gICAgICAgICAgICBsbmc6IGZldGNoZWRBaXJjcmFmdFswXS5sb25naXR1ZGUsXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGZldGNoZWRBaXJjcmFmdC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgIGFsZXJ0KFxyXG4gICAgICAgICAgICBgTm8gYWlyY3JhZnQgZm91bmQgbmVhciAke2dlb2ZlbmNlTG9jYXRpb259LiBUcnkgaW5jcmVhc2luZyB0aGUgcmFkaXVzIG9yIHNlYXJjaGluZyBpbiBhIGRpZmZlcmVudCBhcmVhLmBcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICBzZXRMb2NhbExvYWRpbmcoZmFsc2UpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIHN0YXRlIHdpdGggdGhlIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgaWYgKGNvb3JkaW5hdGVzKSB7XHJcbiAgICAgICAgICBzZXRHZW9mZW5jZUNvb3JkaW5hdGVzKGNvb3JkaW5hdGVzKTtcclxuICAgICAgICAgIHNldEdlb2ZlbmNlQ2VudGVyKGNvb3JkaW5hdGVzKTtcclxuICAgICAgICAgIHNldEdlb2ZlbmNlUmFkaXVzKGdlb2ZlbmNlUmFkaXVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpc0dlb2ZlbmNlQWN0aXZlKSB7XHJcbiAgICAgICAgICB0b2dnbGVHZW9mZW5jZSgpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIWNvb3JkaW5hdGVzKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBkZXRlcm1pbmUgY29vcmRpbmF0ZXMgZm9yIHRoZSBsb2NhdGlvbicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICBgRm91bmQgJHtmZXRjaGVkQWlyY3JhZnQubGVuZ3RofSBhaXJjcmFmdCBpbiB0aGUgYXJlYSwgcHJlcGFyaW5nIGZvciBkaXNwbGF5Li4uYFxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIC8vIEVuc3VyZSB0aGUgZGF0YSBpcyBpbiB0aGUgcmlnaHQgZm9ybWF0XHJcbiAgICAgICAgY29uc3QgYWRhcHRlZEFpcmNyYWZ0ID1cclxuICAgICAgICAgIGZldGNoZWRBaXJjcmFmdFswXS5NQU5VRkFDVFVSRVIgIT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICA/IGZldGNoZWRBaXJjcmFmdCAvLyBBbHJlYWR5IGluIHRoZSByaWdodCBmb3JtYXRcclxuICAgICAgICAgICAgOiBhZGFwdEdlb2ZlbmNlQWlyY3JhZnQoZmV0Y2hlZEFpcmNyYWZ0KTsgLy8gTmVlZHMgYWRhcHRhdGlvblxyXG5cclxuICAgICAgICAvLyBFbnJpY2ggd2l0aCBzdGF0aWMgZGF0YVxyXG4gICAgICAgIGNvbnNvbGUubG9nKCdFbnJpY2hpbmcgZ2VvZmVuY2UgYWlyY3JhZnQgd2l0aCBzdGF0aWMgZGF0YS4uLicpO1xyXG4gICAgICAgIGNvbnN0IGVucmljaGVkQWlyY3JhZnQgPSBhd2FpdCBlbnJpY2hHZW9mZW5jZUFpcmNyYWZ0KGFkYXB0ZWRBaXJjcmFmdCk7XHJcblxyXG4gICAgICAgIC8vIFNhdmUgdGhlIEZVTEwgc2V0IHRvIGxvY2FsIHN0YXRlXHJcbiAgICAgICAgc2V0R2VvZmVuY2VBaXJjcmFmdChlbnJpY2hlZEFpcmNyYWZ0KTtcclxuICAgICAgICBzZXRJc0dlb2ZlbmNlQWN0aXZlKHRydWUpO1xyXG5cclxuICAgICAgICAvLyBDbGVhciBleGlzdGluZyBhaXJjcmFmdCBkYXRhXHJcbiAgICAgICAgaWYgKGNsZWFyR2VvZmVuY2VEYXRhKSB7XHJcbiAgICAgICAgICBjbGVhckdlb2ZlbmNlRGF0YSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSWYgd2UncmUgaW4gY29tYmluZWQgbW9kZSBhbmQgaGF2ZSBhIG1hbnVmYWN0dXJlciwgYXBwbHkgdGhlIGNvbWJpbmVkIGZpbHRlclxyXG4gICAgICAgIGlmIChmaWx0ZXJNb2RlID09PSAnYm90aCcgJiYgc2VsZWN0ZWRNYW51ZmFjdHVyZXIpIHtcclxuICAgICAgICAgIC8vIE1ha2Ugc3VyZSBBUEkgY2FsbHMgcmVtYWluIGJsb2NrZWRcclxuICAgICAgICAgIG9wZW5Ta3lUcmFja2luZ1NlcnZpY2Uuc2V0QmxvY2tBbGxBcGlDYWxscyh0cnVlKTtcclxuICAgICAgICAgIHNldEJsb2NrTWFudWZhY3R1cmVyQXBpQ2FsbHModHJ1ZSk7XHJcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgYXBwbHlDb21iaW5lZEZpbHRlcnMoKTtcclxuICAgICAgICAgIH0sIDEwMCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIEp1c3Qgc2hvdyBhbGwgYWlyY3JhZnQgaW4gdGhlIGdlb2ZlbmNlXHJcbiAgICAgICAgICB1cGRhdGVHZW9mZW5jZUFpcmNyYWZ0KGVucmljaGVkQWlyY3JhZnQpO1xyXG5cclxuICAgICAgICAgIC8vIENlbnRlciB0aGUgbWFwIC0gU0lNUExJRklFRCBaT09NIExPR0lDXHJcbiAgICAgICAgICBpZiAobWFwSW5zdGFuY2UgJiYgY29vcmRpbmF0ZXMpIHtcclxuICAgICAgICAgICAgLy8gR2V0IGN1cnJlbnQgem9vbSBsZXZlbFxyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50Wm9vbSA9IG1hcEluc3RhbmNlLmdldFpvb20oKTtcclxuICAgICAgICAgICAgLy8gVXNlIGFwcHJvcHJpYXRlIHpvb20gbGV2ZWwgYmFzZWQgb24gY3VycmVudCB2aWV3XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldFpvb20gPSBjdXJyZW50Wm9vbSA8PSA3ID8gOSA6IGN1cnJlbnRab29tO1xyXG5cclxuICAgICAgICAgICAgLy8gU2V0IHZpZXcgdG8gdGhlIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICAgIG1hcEluc3RhbmNlLnNldFZpZXcoW2Nvb3JkaW5hdGVzLmxhdCwgY29vcmRpbmF0ZXMubG5nXSwgdGFyZ2V0Wm9vbSk7XHJcblxyXG4gICAgICAgICAgICAvLyBFbnN1cmUgbWFwIGlzIHVwZGF0ZWRcclxuICAgICAgICAgICAgbWFwSW5zdGFuY2UuaW52YWxpZGF0ZVNpemUoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENsb3NlIGRyb3Bkb3duIGFmdGVyIHNlYXJjaFxyXG4gICAgICAgIHNldEFjdGl2ZURyb3Bkb3duKG51bGwpO1xyXG4gICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gZ2VvZmVuY2Ugc2VhcmNoOicsIGVycm9yKTtcclxuICAgICAgICBpZiAoZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ3JhdGUgbGltaXQnKSB8fCBlcnJvci5zdGF0dXMgPT09IDQyOSkge1xyXG4gICAgICAgICAgaGFuZGxlUmF0ZUxpbWl0KDMwKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgYWxlcnQoXHJcbiAgICAgICAgICAgIGBFcnJvcjogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yIG9jY3VycmVkJ31gXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICBzZXRMb2NhbExvYWRpbmcoZmFsc2UpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU1RFUCAzOiBGaXggdG9nZ2xlR2VvZmVuY2VTdGF0ZSB0byBiZXR0ZXIgaGFuZGxlIG1hbnVhbGx5IGNsaWNraW5nIHRoZSBidXR0b25cclxuICAgICAqL1xyXG4gICAgY29uc3QgdG9nZ2xlR2VvZmVuY2VTdGF0ZSA9IChlbmFibGVkOiBib29sZWFuKSA9PiB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCd0b2dnbGVHZW9mZW5jZVN0YXRlIGNhbGxlZCB3aXRoOicsIGVuYWJsZWQpO1xyXG4gICAgICBjb25zb2xlLmxvZygnQ3VycmVudCBnZW9mZW5jZUNvb3JkaW5hdGVzOicsIGdlb2ZlbmNlQ29vcmRpbmF0ZXMpO1xyXG5cclxuICAgICAgaWYgKGVuYWJsZWQpIHtcclxuICAgICAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIHZhbGlkIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgZ2VvZmVuY2VDb29yZGluYXRlcyAmJlxyXG4gICAgICAgICAgdHlwZW9mIGdlb2ZlbmNlQ29vcmRpbmF0ZXMubGF0ID09PSAnbnVtYmVyJyAmJlxyXG4gICAgICAgICAgdHlwZW9mIGdlb2ZlbmNlQ29vcmRpbmF0ZXMubG5nID09PSAnbnVtYmVyJyAmJlxyXG4gICAgICAgICAgIWlzTmFOKGdlb2ZlbmNlQ29vcmRpbmF0ZXMubGF0KSAmJlxyXG4gICAgICAgICAgIWlzTmFOKGdlb2ZlbmNlQ29vcmRpbmF0ZXMubG5nKVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coJ1ZhbGlkIGNvb3JkaW5hdGVzIGZvdW5kLCBlbmFibGluZyBnZW9mZW5jZScpO1xyXG5cclxuICAgICAgICAgIC8vIFNldCBmbGFncyBmaXJzdFxyXG4gICAgICAgICAgc2V0R2VvZmVuY2VFbmFibGVkKHRydWUpO1xyXG4gICAgICAgICAgc2V0SXNHZW9mZW5jZUFjdGl2ZSh0cnVlKTtcclxuXHJcbiAgICAgICAgICAvLyBDYWxsIGNvbnRleHQgdG9nZ2xlIGZ1bmN0aW9uIGlmIGF2YWlsYWJsZVxyXG4gICAgICAgICAgaWYgKHR5cGVvZiB0b2dnbGVHZW9mZW5jZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB0b2dnbGVHZW9mZW5jZSgpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIERpc3BsYXkgYWlyY3JhZnQgaWYgd2UgaGF2ZSB0aGVtXHJcbiAgICAgICAgICBpZiAoZ2VvZmVuY2VBaXJjcmFmdCAmJiBnZW9mZW5jZUFpcmNyYWZ0Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICAgICAgYFNob3dpbmcgJHtnZW9mZW5jZUFpcmNyYWZ0Lmxlbmd0aH0gYWlyY3JhZnQgaW4gZ2VvZmVuY2VgXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHVwZGF0ZUdlb2ZlbmNlQWlyY3JhZnQoZ2VvZmVuY2VBaXJjcmFmdCk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBObyBhaXJjcmFmdCBkYXRhIHlldCwgdHJpZ2dlciBhIHNlYXJjaFxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnTm8gYWlyY3JhZnQgZGF0YSB5ZXQsIHRyaWdnZXJpbmcgc2VhcmNoJyk7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgIHByb2Nlc3NHZW9mZW5jZVNlYXJjaCgpO1xyXG4gICAgICAgICAgICB9LCAxMDApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBObyB2YWxpZCBjb29yZGluYXRlc1xyXG4gICAgICAgICAgY29uc29sZS53YXJuKCdObyB2YWxpZCBjb29yZGluYXRlcywgc2hvd2luZyBhbGVydCcpO1xyXG4gICAgICAgICAgYWxlcnQoXHJcbiAgICAgICAgICAgICdQbGVhc2Ugc2V0IGEgbG9jYXRpb24gYmVmb3JlIGVuYWJsaW5nIGdlb2ZlbmNlLlxcblxcbkNsaWNrIGFueXdoZXJlIG9uIHRoZSBtYXAgdG8gc2V0IGEgbG9jYXRpb24uJ1xyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIHNldEdlb2ZlbmNlRW5hYmxlZChmYWxzZSk7XHJcbiAgICAgICAgICBzZXRJc0dlb2ZlbmNlQWN0aXZlKGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gRGlzYWJsaW5nIGdlb2ZlbmNlXHJcbiAgICAgICAgY29uc29sZS5sb2coJ0Rpc2FibGluZyBnZW9mZW5jZScpO1xyXG4gICAgICAgIHNldEdlb2ZlbmNlRW5hYmxlZChmYWxzZSk7XHJcbiAgICAgICAgc2V0SXNHZW9mZW5jZUFjdGl2ZShmYWxzZSk7XHJcblxyXG4gICAgICAgIC8vIENsZWFyIGdlb2ZlbmNlIGRhdGEgaWYgZnVuY3Rpb24gYXZhaWxhYmxlXHJcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhckdlb2ZlbmNlRGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgY2xlYXJHZW9mZW5jZURhdGEoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8gTWFudWZhY3R1cmVyIGZpbHRlciBtZXRob2RzXHJcbiAgICBjb25zdCBzZWxlY3RNYW51ZmFjdHVyZXJBbmRDbG9zZSA9ICh2YWx1ZTogc3RyaW5nKSA9PiB7XHJcbiAgICAgIC8vIENsb3NlIGRyb3Bkb3duXHJcbiAgICAgIHNldEFjdGl2ZURyb3Bkb3duKG51bGwpO1xyXG4gICAgICBzZXRNYW51ZmFjdHVyZXJTZWFyY2hUZXJtKCcnKTtcclxuXHJcbiAgICAgIC8vIElmIGNsZWFyaW5nIHRoZSBzZWxlY3Rpb25cclxuICAgICAgaWYgKHZhbHVlID09PSAnJykge1xyXG4gICAgICAgIHNlbGVjdE1hbnVmYWN0dXJlcihudWxsKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFNldCB0aGUgbWFudWZhY3R1cmVyIHNlbGVjdGlvblxyXG4gICAgICBzZWxlY3RNYW51ZmFjdHVyZXIodmFsdWUpO1xyXG5cclxuICAgICAgLy8gSWYgcmVnaW9uIGlzIGFscmVhZHkgc2VsZWN0ZWQsIGZldGNoIGZpbHRlcmVkIGRhdGFcclxuICAgICAgaWYgKGFjdGl2ZVJlZ2lvbiAhPT0gbnVsbCkge1xyXG4gICAgICAgIGZldGNoQWlyY3JhZnRCeVJlZ2lvbkFuZE1hbnVmYWN0dXJlcihhY3RpdmVSZWdpb24gYXMgUmVnaW9uQ29kZSwgdmFsdWUpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIE90aGVyd2lzZSwganVzdCBwcm9jZWVkIHdpdGggbWFudWZhY3R1cmVyLW9ubHkgZmlsdGVyaW5nIGFzIGJlZm9yZVxyXG4gICAgICAgIGZldGNoTWFudWZhY3R1cmVyRGF0YSh2YWx1ZSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgZmV0Y2hNYW51ZmFjdHVyZXJEYXRhID0gKG1hbnVmYWN0dXJlcjogc3RyaW5nKSA9PiB7XHJcbiAgICAgIGlmIChpc1JhdGVMaW1pdGVkKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICBgU2tpcHBpbmcgZGF0YSBmZXRjaCAtIHJhdGUgbGltaXRlZCBmb3IgJHtyYXRlTGltaXRUaW1lcn1zYFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zb2xlLmxvZyhgRmV0Y2hpbmcgZGF0YSBmb3IgbWFudWZhY3R1cmVyOiAke21hbnVmYWN0dXJlcn1gKTtcclxuXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgLy8gSWYgeW91IGhhdmUgYSBjb250ZXh0IGZ1bmN0aW9uIGZvciB0aGlzLCBjYWxsIGl0IGFmdGVyIGEgc2xpZ2h0IGRlbGF5XHJcbiAgICAgICAgaWYgKHR5cGVvZiByZWZyZXNoUG9zaXRpb25zID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAvLyBBcHBseSBhIHNtYWxsIGRlbGF5IHRvIHByZXZlbnQgb3ZlcndoZWxtaW5nIHRoZSBBUElcclxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICByZWZyZXNoUG9zaXRpb25zKCkuY2F0Y2goKGVycm9yOiBhbnkpID0+IHtcclxuICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygncmF0ZSBsaW1pdCcpIHx8XHJcbiAgICAgICAgICAgICAgICBlcnJvci5zdGF0dXMgPT09IDQyOVxyXG4gICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlUmF0ZUxpbWl0KDMwKTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgbWFudWZhY3R1cmVyIGRhdGE6JywgZXJyb3IpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9LCAyMDApO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgICAgIGlmIChlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygncmF0ZSBsaW1pdCcpIHx8IGVycm9yLnN0YXR1cyA9PT0gNDI5KSB7XHJcbiAgICAgICAgICBoYW5kbGVSYXRlTGltaXQoMzApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzY2hlZHVsaW5nIG1hbnVmYWN0dXJlciBkYXRhIGZldGNoOicsIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgZmV0Y2hBaXJjcmFmdEJ5UmVnaW9uQW5kTWFudWZhY3R1cmVyID0gYXN5bmMgKFxyXG4gICAgICByZWdpb246IFJlZ2lvbkNvZGUsXHJcbiAgICAgIG1hbnVmYWN0dXJlcjogc3RyaW5nLFxyXG4gICAgICBwYWdlOiBudW1iZXIgPSAxLFxyXG4gICAgICBsaW1pdDogbnVtYmVyID0gNTAwXHJcbiAgICApID0+IHtcclxuICAgICAgaWYgKCFyZWdpb24gfHwgIW1hbnVmYWN0dXJlcikge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdCb3RoIHJlZ2lvbiBhbmQgbWFudWZhY3R1cmVyIG11c3QgYmUgc2VsZWN0ZWQnKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHNldExvY2FsTG9hZGluZyh0cnVlKTtcclxuXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcclxuICAgICAgICAgIGAvYXBpL3RyYWNraW5nL2ZpbHRlcmVkLWFpcmNyYWZ0P3JlZ2lvbj0ke3JlZ2lvbn0mbWFudWZhY3R1cmVyPSR7ZW5jb2RlVVJJQ29tcG9uZW50KG1hbnVmYWN0dXJlcil9JnBhZ2U9JHtwYWdlfSZsaW1pdD0ke2xpbWl0fWBcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICAgIGNvbnN0IGFpcmNyYWZ0RGF0YSA9IGRhdGEuYWlyY3JhZnQgfHwgW107XHJcblxyXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQVBJIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBQcm9jZXNzIHRoZSBmaWx0ZXJlZCBhaXJjcmFmdCBkYXRhXHJcbiAgICAgICAgaWYgKGFpcmNyYWZ0RGF0YS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAvLyBUcmFuc2Zvcm0gdG8gRXh0ZW5kZWRBaXJjcmFmdFxyXG4gICAgICAgICAgaW50ZXJmYWNlIEFpcmNyYWZ0RGF0YSB7XHJcbiAgICAgICAgICAgIFRZUEVfQUlSQ1JBRlQ/OiBzdHJpbmc7XHJcbiAgICAgICAgICAgIE9QRVJBVE9SPzogc3RyaW5nO1xyXG4gICAgICAgICAgICBSRUdJT046IG51bWJlcjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBjb25zdCBleHRlbmRlZEFpcmNyYWZ0OiBFeHRlbmRlZEFpcmNyYWZ0W10gPSBhaXJjcmFmdERhdGEubWFwKFxyXG4gICAgICAgICAgICAoYWlyY3JhZnQ6IEFpcmNyYWZ0RGF0YSkgPT4gKHtcclxuICAgICAgICAgICAgICAuLi5haXJjcmFmdCxcclxuICAgICAgICAgICAgICB0eXBlOiBhaXJjcmFmdC5UWVBFX0FJUkNSQUZUIHx8ICdVbmtub3duJyxcclxuICAgICAgICAgICAgICBpc0dvdmVybm1lbnQ6XHJcbiAgICAgICAgICAgICAgICBhaXJjcmFmdC5PUEVSQVRPUj8udG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnZ292ZXJubWVudCcpID8/XHJcbiAgICAgICAgICAgICAgICBmYWxzZSxcclxuICAgICAgICAgICAgICBSRUdJT046IGFpcmNyYWZ0LlJFR0lPTixcclxuICAgICAgICAgICAgICB6b29tTGV2ZWw6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgLy8gVXBkYXRlIHRoZSBtYXBcclxuICAgICAgICAgIHVwZGF0ZUdlb2ZlbmNlQWlyY3JhZnQoZXh0ZW5kZWRBaXJjcmFmdCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgICBgTm8gYWlyY3JhZnQgZm91bmQgZm9yIG1hbnVmYWN0dXJlciAke21hbnVmYWN0dXJlcn0gaW4gcmVnaW9uICR7cmVnaW9ufWBcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGZpbHRlcmVkIGFpcmNyYWZ0OicsIGVycm9yKTtcclxuICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICBzZXRMb2NhbExvYWRpbmcoZmFsc2UpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIE1vZGVsIHNlbGVjdGlvbiBtZXRob2RzXHJcbiAgICBjb25zdCBoYW5kbGVNb2RlbFNlbGVjdCA9ICh2YWx1ZTogc3RyaW5nKSA9PiB7XHJcbiAgICAgIHNlbGVjdE1vZGVsKHZhbHVlID09PSAnJyA/IG51bGwgOiB2YWx1ZSk7XHJcbiAgICAgIHNldEFjdGl2ZURyb3Bkb3duKG51bGwpO1xyXG5cclxuICAgICAgLy8gSWYgaW4gY29tYmluZWQgbW9kZSwgcmVhcHBseSB0aGUgZmlsdGVyXHJcbiAgICAgIGlmIChmaWx0ZXJNb2RlID09PSAnYm90aCcgJiYgaXNHZW9mZW5jZUFjdGl2ZSAmJiBzZWxlY3RlZE1hbnVmYWN0dXJlcikge1xyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgYXBwbHlDb21iaW5lZEZpbHRlcnMoKTtcclxuICAgICAgICB9LCAxMDApO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIENvbWJpbmVkIGZpbHRlciBtZXRob2RzXHJcbiAgICBjb25zdCBhcHBseUNvbWJpbmVkRmlsdGVycyA9ICgpID0+IHtcclxuICAgICAgaWYgKFxyXG4gICAgICAgICFzZWxlY3RlZE1hbnVmYWN0dXJlciB8fFxyXG4gICAgICAgICFpc0dlb2ZlbmNlQWN0aXZlIHx8XHJcbiAgICAgICAgZ2VvZmVuY2VBaXJjcmFmdC5sZW5ndGggPT09IDBcclxuICAgICAgKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzZXRMb2NhbExvYWRpbmcodHJ1ZSk7XHJcblxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgYEZpbHRlcmluZyAke2dlb2ZlbmNlQWlyY3JhZnQubGVuZ3RofSBhaXJjcmFmdCBieSAke3NlbGVjdGVkTWFudWZhY3R1cmVyfWBcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyBGaWx0ZXIgdGhlIGFpcmNyYWZ0IGJ5IG1hbnVmYWN0dXJlclxyXG4gICAgICAgIGxldCBmaWx0ZXJlZEFpcmNyYWZ0ID0gZ2VvZmVuY2VBaXJjcmFmdC5maWx0ZXIoXHJcbiAgICAgICAgICAoYWlyY3JhZnQpID0+XHJcbiAgICAgICAgICAgIGFpcmNyYWZ0Lk1BTlVGQUNUVVJFUj8udG9Mb3dlckNhc2UoKSA9PT1cclxuICAgICAgICAgICAgc2VsZWN0ZWRNYW51ZmFjdHVyZXIudG9Mb3dlckNhc2UoKVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIC8vIEZ1cnRoZXIgZmlsdGVyIGJ5IG1vZGVsIGlmIHNlbGVjdGVkXHJcbiAgICAgICAgaWYgKHNlbGVjdGVkTW9kZWwpIHtcclxuICAgICAgICAgIGZpbHRlcmVkQWlyY3JhZnQgPSBmaWx0ZXJlZEFpcmNyYWZ0LmZpbHRlcihcclxuICAgICAgICAgICAgKGFpcmNyYWZ0KSA9PlxyXG4gICAgICAgICAgICAgIGFpcmNyYWZ0Lk1PREVMPy50b0xvd2VyQ2FzZSgpID09PSBzZWxlY3RlZE1vZGVsLnRvTG93ZXJDYXNlKClcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhgRm91bmQgJHtmaWx0ZXJlZEFpcmNyYWZ0Lmxlbmd0aH0gbWF0Y2hpbmcgYWlyY3JhZnRgKTtcclxuXHJcbiAgICAgICAgaWYgKGZpbHRlcmVkQWlyY3JhZnQubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICBhbGVydChgTm8gJHtzZWxlY3RlZE1hbnVmYWN0dXJlcn0gYWlyY3JhZnQgZm91bmQgaW4gdGhpcyBhcmVhLmApO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2xlYXIgZGlzcGxheSBkYXRhXHJcbiAgICAgICAgaWYgKGNsZWFyR2VvZmVuY2VEYXRhKSB7XHJcbiAgICAgICAgICBjbGVhckdlb2ZlbmNlRGF0YSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBkaXNwbGF5XHJcbiAgICAgICAgdXBkYXRlR2VvZmVuY2VBaXJjcmFmdChmaWx0ZXJlZEFpcmNyYWZ0KTtcclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmaWx0ZXJpbmcgYWlyY3JhZnQ6JywgZXJyb3IpO1xyXG4gICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHNldExvY2FsTG9hZGluZyhmYWxzZSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8gUmVzZXQgYWxsIGZpbHRlcnNcclxuICAgIGNvbnN0IGNsZWFyQWxsRmlsdGVycyA9ICgpID0+IHtcclxuICAgICAgY29uc29sZS5sb2coJ0NsZWFyaW5nIGFsbCBmaWx0ZXJzLi4uJyk7XHJcblxyXG4gICAgICAvLyAxLiBSZXNldCBmaWx0ZXIgbW9kZVxyXG4gICAgICBzZXRGaWx0ZXJNb2RlKCdtYW51ZmFjdHVyZXInKTtcclxuXHJcbiAgICAgIC8vIDIuIFVuYmxvY2sgQVBJIGNhbGxzIHRoYXQgbWlnaHQgaGF2ZSBiZWVuIGJsb2NrZWRcclxuICAgICAgb3BlblNreVRyYWNraW5nU2VydmljZS5zZXRCbG9ja0FsbEFwaUNhbGxzKGZhbHNlKTtcclxuICAgICAgc2V0QmxvY2tNYW51ZmFjdHVyZXJBcGlDYWxscyhmYWxzZSk7XHJcbiAgICAgIHNldElzTWFudWZhY3R1cmVyQXBpQmxvY2tlZChmYWxzZSk7XHJcblxyXG4gICAgICAvLyAzLiBDbGVhciBtYW51ZmFjdHVyZXIgc2VsZWN0aW9uXHJcbiAgICAgIHNlbGVjdE1hbnVmYWN0dXJlcihudWxsKTtcclxuICAgICAgc2VsZWN0TW9kZWwobnVsbCk7XHJcblxyXG4gICAgICAvLyA0LiBDbGVhciBnZW9mZW5jZVxyXG4gICAgICBzZXRHZW9mZW5jZUxvY2F0aW9uKCcnKTtcclxuICAgICAgc2V0R2VvZmVuY2VDb29yZGluYXRlcyhudWxsKTtcclxuICAgICAgc2V0R2VvZmVuY2VBaXJjcmFmdChbXSk7XHJcbiAgICAgIHNldEdlb2ZlbmNlRW5hYmxlZChmYWxzZSk7XHJcbiAgICAgIHNldElzR2VvZmVuY2VBY3RpdmUoZmFsc2UpO1xyXG4gICAgICBpZiAodHlwZW9mIGNsZWFyR2VvZmVuY2UgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICBjbGVhckdlb2ZlbmNlKCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHR5cGVvZiBjbGVhckdlb2ZlbmNlRGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIGNsZWFyR2VvZmVuY2VEYXRhKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIDUuIFJlc2V0IG93bmVyIGZpbHRlcnMgdG8gc2VsZWN0IGFsbFxyXG4gICAgICBzZXRPd25lckZpbHRlcnMoWy4uLmFsbE93bmVyVHlwZXNdKTtcclxuXHJcbiAgICAgIC8vIDYuIENsZWFyIHJlZ2lvbiBmaWx0ZXIgcHJvcGVybHlcclxuICAgICAgc2V0QWN0aXZlUmVnaW9uKG51bGwpO1xyXG4gICAgICBzZXRTZWxlY3RlZFJlZ2lvbihSZWdpb25Db2RlLkdMT0JBTCk7XHJcblxyXG4gICAgICAvLyBDbGVhciByZWdpb24gb3V0bGluZSBmcm9tIG1hcFxyXG4gICAgICBpZiAocmVnaW9uT3V0bGluZSkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAvLyBIYW5kbGUgZGlmZmVyZW50IHBvc3NpYmxlIG9iamVjdCBzdHJ1Y3R1cmVzXHJcbiAgICAgICAgICBpZiAodHlwZW9mIHJlZ2lvbk91dGxpbmUucmVtb3ZlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHJlZ2lvbk91dGxpbmUucmVtb3ZlKCk7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKFxyXG4gICAgICAgICAgICByZWdpb25PdXRsaW5lLnJlY3RhbmdsZSAmJlxyXG4gICAgICAgICAgICB0eXBlb2YgcmVnaW9uT3V0bGluZS5yZWN0YW5nbGUucmVtb3ZlID09PSAnZnVuY3Rpb24nXHJcbiAgICAgICAgICApIHtcclxuICAgICAgICAgICAgcmVnaW9uT3V0bGluZS5yZWN0YW5nbGUucmVtb3ZlKCk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gQ2xlYXIgYW55IGxhYmVscyBhc3NvY2lhdGVkIHdpdGggdGhlIHJlZ2lvblxyXG4gICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICByZWdpb25PdXRsaW5lLmxhYmVsICYmXHJcbiAgICAgICAgICAgIHR5cGVvZiByZWdpb25PdXRsaW5lLmxhYmVsLnJlbW92ZSA9PT0gJ2Z1bmN0aW9uJ1xyXG4gICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIHJlZ2lvbk91dGxpbmUubGFiZWwucmVtb3ZlKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlbW92aW5nIHJlZ2lvbiBvdXRsaW5lOicsIGVycm9yKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEFsd2F5cyByZXNldCB0aGUgcmVnaW9uIG91dGxpbmUgc3RhdGVcclxuICAgICAgICBzZXRSZWdpb25PdXRsaW5lKG51bGwpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyA3LiBSZXNldCBtYXAgdmlldyB0byBnbG9iYWxcclxuICAgICAgaWYgKG1hcEluc3RhbmNlKSB7XHJcbiAgICAgICAgLy8gVXNlIHRoZSBwcmVkZWZpbmVkIGNlbnRlciBhbmQgem9vbSBsZXZlbCBmcm9tIHlvdXIgbWFwIGNvbmZpZ1xyXG4gICAgICAgIG1hcEluc3RhbmNlLnNldFZpZXcoTUFQX0NPTkZJRy5DRU5URVIsIE1BUF9DT05GSUcuREVGQVVMVF9aT09NKTtcclxuICAgICAgICBtYXBJbnN0YW5jZS5pbnZhbGlkYXRlU2l6ZSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyA4LiBSZXNldCB0byBpbml0aWFsIGFpcmNyYWZ0IGRhdGFcclxuICAgICAgaWYgKHR5cGVvZiByZXNldCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHJlc2V0KCk7XHJcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZ1bGxSZWZyZXNoID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgZnVsbFJlZnJlc2goKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gOS4gQ2xvc2UgYW55IG9wZW4gZHJvcGRvd25cclxuICAgICAgc2V0QWN0aXZlRHJvcGRvd24obnVsbCk7XHJcblxyXG4gICAgICAvLyAxMC4gUmVzZXQgcmF0ZSBsaW1pdGluZyBzdGF0ZXNcclxuICAgICAgc2V0SXNSYXRlTGltaXRlZChmYWxzZSk7XHJcbiAgICAgIHNldFJhdGVMaW1pdFRpbWVyKG51bGwpO1xyXG5cclxuICAgICAgLy8gMTEuIENsZWFyIGNvbWJpbmVkIG1vZGUgc3RhdGVcclxuICAgICAgc2V0Q29tYmluZWRNb2RlUmVhZHkoZmFsc2UpO1xyXG5cclxuICAgICAgLy8gMTIuIFJlc2V0IHNlYXJjaCB0ZXJtc1xyXG4gICAgICBzZXRNYW51ZmFjdHVyZXJTZWFyY2hUZXJtKCcnKTtcclxuXHJcbiAgICAgIC8vIDEzLiBEaXNwYXRjaCBhIGN1c3RvbSBldmVudCB0aGF0IG90aGVyIGNvbXBvbmVudHMgY2FuIGxpc3RlbiBmb3JcclxuICAgICAgY29uc3QgY2xlYXJFdmVudCA9IG5ldyBDdXN0b21FdmVudCgncmliYm9uLWZpbHRlcnMtY2xlYXJlZCcpO1xyXG4gICAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KGNsZWFyRXZlbnQpO1xyXG5cclxuICAgICAgY29uc29sZS5sb2coJ0FsbCBmaWx0ZXJzIGNsZWFyZWQgc3VjY2Vzc2Z1bGx5Jyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIENhbGN1bGF0ZSBjb21iaW5lZCBsb2FkaW5nIHN0YXRlXHJcbiAgICBjb25zdCBjb21iaW5lZExvYWRpbmcgPSBsb2NhbExvYWRpbmc7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgLy8gU3RhdGVcclxuICAgICAgZmlsdGVyTW9kZSxcclxuICAgICAgYWN0aXZlRHJvcGRvd24sXHJcbiAgICAgIHNlbGVjdGVkTWFudWZhY3R1cmVyLFxyXG4gICAgICBzZWxlY3RlZE1vZGVsLFxyXG4gICAgICBnZW9mZW5jZUxvY2F0aW9uLFxyXG4gICAgICBnZW9mZW5jZVJhZGl1cyxcclxuICAgICAgaXNHZW9mZW5jZUFjdGl2ZSxcclxuICAgICAgZ2VvZmVuY2VDb29yZGluYXRlcyxcclxuICAgICAgZ2V0VXNlckxvY2F0aW9uLFxyXG4gICAgICBhY3RpdmVSZWdpb24sXHJcbiAgICAgIG93bmVyRmlsdGVycyxcclxuICAgICAgYWxsT3duZXJUeXBlcyxcclxuICAgICAgbWFudWZhY3R1cmVyU2VhcmNoVGVybSxcclxuICAgICAgY29tYmluZWRMb2FkaW5nLFxyXG4gICAgICBpc0dldHRpbmdMb2NhdGlvbixcclxuICAgICAgZHJvcGRvd25SZWZzLFxyXG4gICAgICBsb2NhbExvYWRpbmcsXHJcbiAgICAgIGlzUmF0ZUxpbWl0ZWQsXHJcbiAgICAgIHNlbGVjdGVkUmVnaW9uLFxyXG4gICAgICBpc1JlZnJlc2hpbmcsXHJcbiAgICAgIGlzR2VvZmVuY2VQbGFjZW1lbnRNb2RlOiBmYWxzZSwgLy8gSW5pdGlhbGl6ZSB3aXRoIGEgZGVmYXVsdCB2YWx1ZVxyXG5cclxuICAgICAgLy8gTWV0aG9kc1xyXG4gICAgICB0b2dnbGVEcm9wZG93bixcclxuICAgICAgdG9nZ2xlRmlsdGVyTW9kZSxcclxuICAgICAgc2VsZWN0TWFudWZhY3R1cmVyQW5kQ2xvc2UsXHJcbiAgICAgIGhhbmRsZU1vZGVsU2VsZWN0LFxyXG4gICAgICBwcm9jZXNzR2VvZmVuY2VTZWFyY2gsXHJcbiAgICAgIGhhbmRsZU93bmVyRmlsdGVyQ2hhbmdlLFxyXG4gICAgICBoYW5kbGVSZWdpb25TZWxlY3QsXHJcbiAgICAgIHNldE1hbnVmYWN0dXJlclNlYXJjaFRlcm0sXHJcbiAgICAgIHNldEdlb2ZlbmNlTG9jYXRpb24sXHJcbiAgICAgIHNldEdlb2ZlbmNlUmFkaXVzLFxyXG4gICAgICB0b2dnbGVHZW9mZW5jZVN0YXRlLFxyXG4gICAgICBjbGVhckFsbEZpbHRlcnMsXHJcbiAgICAgIGFwcGx5Q29tYmluZWRGaWx0ZXJzLFxyXG4gICAgICBnZXRBaXJjcmFmdE93bmVyVHlwZSxcclxuICAgICAgc2V0R2VvZmVuY2VDb29yZGluYXRlcyxcclxuICAgICAgc2V0R2VvZmVuY2VDZW50ZXIsXHJcbiAgICAgIHVwZGF0ZUdlb2ZlbmNlQWlyY3JhZnQsXHJcblxyXG4gICAgICByZWZyZXNoV2l0aEZpbHRlcnM6ICgpID0+IHtcclxuICAgICAgICAvLyBJbXBsZW1lbnQgcmVmcmVzaCBsb2dpYyBoZXJlXHJcbiAgICAgICAgaWYgKHR5cGVvZiByZWZyZXNoUG9zaXRpb25zID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICByZWZyZXNoUG9zaXRpb25zKCkuY2F0Y2goKGVycm9yKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlZnJlc2hpbmcgcG9zaXRpb25zOicsIGVycm9yKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgc2V0QWN0aXZlRHJvcGRvd24sIC8vIEFkZCB0aGlzIGxpbmUgaWYgeW91IGhhdmUgdGhpcyBmdW5jdGlvblxyXG4gICAgfTtcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIGFwcGx5Q29tYmluZWRGaWx0ZXJzKCkge1xyXG4gIHRocm93IG5ldyBFcnJvcignRnVuY3Rpb24gbm90IGltcGxlbWVudGVkLicpO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZVJlZiIsInVzZUVmZmVjdCIsIlJlYWN0IiwiUmVnaW9uQ29kZSIsInVzZUVuaGFuY2VkTWFwQ29udGV4dCIsIm9wZW5Ta3lUcmFja2luZ1NlcnZpY2UiLCJNYXBib3hTZXJ2aWNlIiwiYWRhcHRHZW9mZW5jZUFpcmNyYWZ0IiwiZW5yaWNoR2VvZmVuY2VBaXJjcmFmdCIsInVzZUdlb2xvY2F0aW9uU2VydmljZXMiLCJnZXRBaXJjcmFmdE5lYXJMb2NhdGlvbiIsImdldEFpcmNyYWZ0TmVhclNlYXJjaGVkTG9jYXRpb24iLCJ1c2VHZW9sb2NhdGlvbiIsIk1BUF9DT05GSUciLCJnZXRCb3VuZHNCeVJlZ2lvbiIsImdldFpvb21MZXZlbEZvclJlZ2lvbiIsInVzZUZpbHRlckxvZ2ljIiwic2VsZWN0ZWRNYW51ZmFjdHVyZXIiLCJzZWxlY3RlZE1vZGVsIiwidG90YWxBY3RpdmUiLCJzZWxlY3RNYW51ZmFjdHVyZXIiLCJzZWxlY3RNb2RlbCIsInJlc2V0IiwiZnVsbFJlZnJlc2giLCJyZWZyZXNoUG9zaXRpb25zIiwibWFwSW5zdGFuY2UiLCJ1cGRhdGVBaXJjcmFmdERhdGEiLCJjbGVhckdlb2ZlbmNlRGF0YSIsInVwZGF0ZUdlb2ZlbmNlQWlyY3JhZnQiLCJibG9ja01hbnVmYWN0dXJlckFwaUNhbGxzIiwic2V0QmxvY2tNYW51ZmFjdHVyZXJBcGlDYWxscyIsImlzTWFudWZhY3R1cmVyQXBpQmxvY2tlZCIsInNldElzTWFudWZhY3R1cmVyQXBpQmxvY2tlZCIsImdlb2ZlbmNlQ2VudGVyIiwic2V0R2VvZmVuY2VDZW50ZXIiLCJ0b2dnbGVHZW9mZW5jZSIsImNsZWFyR2VvZmVuY2UiLCJkaXNwbGF5ZWRBaXJjcmFmdCIsImdlb2xvY2F0aW9uU2VydmljZXMiLCJsb2NhbExvYWRpbmciLCJzZXRMb2NhbExvYWRpbmciLCJmaWx0ZXJNb2RlIiwic2V0RmlsdGVyTW9kZSIsImFjdGl2ZURyb3Bkb3duIiwic2V0QWN0aXZlRHJvcGRvd24iLCJtYW51ZmFjdHVyZXJTZWFyY2hUZXJtIiwic2V0TWFudWZhY3R1cmVyU2VhcmNoVGVybSIsImlzUmVmcmVzaGluZyIsInNldElzUmVmcmVzaGluZyIsImlzUmF0ZUxpbWl0ZWQiLCJzZXRJc1JhdGVMaW1pdGVkIiwicmF0ZUxpbWl0VGltZXIiLCJzZXRSYXRlTGltaXRUaW1lciIsImlzR2V0dGluZ0xvY2F0aW9uIiwic2V0SXNHZXR0aW5nTG9jYXRpb24iLCJnZW9mZW5jZUxvY2F0aW9uIiwic2V0R2VvZmVuY2VMb2NhdGlvbiIsImdlb2ZlbmNlUmFkaXVzIiwic2V0R2VvZmVuY2VSYWRpdXMiLCJnZW9mZW5jZUNvb3JkaW5hdGVzIiwic2V0R2VvZmVuY2VDb29yZGluYXRlcyIsImdlb2ZlbmNlQWlyY3JhZnQiLCJzZXRHZW9mZW5jZUFpcmNyYWZ0IiwiZ2VvZmVuY2VFbmFibGVkIiwic2V0R2VvZmVuY2VFbmFibGVkIiwiaXNHZW9mZW5jZUFjdGl2ZSIsInNldElzR2VvZmVuY2VBY3RpdmUiLCJpc1NlYXJjaFJlYWR5Iiwic2V0SXNTZWFyY2hSZWFkeSIsImFjdGl2ZVJlZ2lvbiIsInNldEFjdGl2ZVJlZ2lvbiIsInJlZ2lvbk91dGxpbmUiLCJzZXRSZWdpb25PdXRsaW5lIiwic2VsZWN0ZWRSZWdpb24iLCJzZXRTZWxlY3RlZFJlZ2lvbiIsIkdMT0JBTCIsImNvbWJpbmVkTW9kZVJlYWR5Iiwic2V0Q29tYmluZWRNb2RlUmVhZHkiLCJhbGxPd25lclR5cGVzIiwib3duZXJGaWx0ZXJzIiwic2V0T3duZXJGaWx0ZXJzIiwiZHJvcGRvd25SZWZzIiwiZmlsdGVyIiwibWFudWZhY3R1cmVyIiwibW9kZWwiLCJsb2NhdGlvbiIsInJlZ2lvbiIsIm93bmVyIiwiYWN0aW9ucyIsImdlb2xvY2F0aW9uIiwidGltZXIiLCJzZXRUaW1lb3V0IiwiY29uc29sZSIsImxvZyIsImNsZWFyVGltZW91dCIsImhhbmRsZUNsaWNrT3V0c2lkZSIsImV2ZW50IiwiaXNPdXRzaWRlQWxsIiwiT2JqZWN0IiwidmFsdWVzIiwiZXZlcnkiLCJyZWYiLCJjdXJyZW50IiwiY29udGFpbnMiLCJ0YXJnZXQiLCJkb2N1bWVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicmVtb3ZlIiwiaGFuZGxlTWFwR2VvZmVuY2VDbGljayIsImN1c3RvbUV2ZW50IiwibGF0IiwibG5nIiwiZGV0YWlsIiwidG9GaXhlZCIsImxvY2F0aW9uTmFtZSIsImdldExvY2F0aW9uTmFtZUZyb21Db29yZGluYXRlcyIsImVycm9yIiwidG9nZ2xlRHJvcGRvd24iLCJkcm9wZG93biIsInN0b3BQcm9wYWdhdGlvbiIsImhhbmRsZVJhdGVMaW1pdCIsInJldHJ5QWZ0ZXIiLCJzZXRCbG9ja0FsbEFwaUNhbGxzIiwiYWxlcnQiLCJ0b2dnbGVGaWx0ZXJNb2RlIiwibW9kZSIsImxlbmd0aCIsImZpbHRlckFpcmNyYWZ0QnlSZWdpb24iLCJ0b1N0cmluZyIsImFpcmNyYWZ0V2l0aFZhbGlkQ29vcmRzIiwicGxhbmUiLCJsYXRpdHVkZSIsImxvbmdpdHVkZSIsImlzTmFOIiwiZmlsdGVyZWRCeU93bmVyIiwiYWlyY3JhZnQiLCJpbmNsdWRlcyIsImdldEFpcmNyYWZ0T3duZXJUeXBlIiwiYXBwbHlDb21iaW5lZEZpbHRlcnMiLCJvd25lclR5cGUiLCJUWVBFX1JFR0lTVFJBTlQiLCJvd25lclR5cGVUb1N0cmluZyIsInR5cGUiLCJ0eXBlTnVtIiwicGFyc2VJbnQiLCJvd25lclR5cGVNYXAiLCJhcHBseU93bmVyVHlwZUZpbHRlciIsImZpbHRlcnMiLCJmaWx0ZXJlZEFpcmNyYWZ0IiwiaGFuZGxlT3duZXJGaWx0ZXJDaGFuZ2UiLCJ1cGRhdGVkRmlsdGVycyIsInJlc2V0T3duZXJGaWx0ZXJzIiwiYm91bmRzRXhwcmVzc2lvbiIsIkFycmF5IiwiaXNBcnJheSIsIm1pbkxhdCIsIm1pbkxuZyIsIm1heExhdCIsIm1heExuZyIsImhhbmRsZVJlZ2lvblNlbGVjdCIsImJvdW5kcyIsInpvb21MZXZlbCIsInNldFpvb20iLCJvcHRpb25zIiwicGFkZGluZyIsIlBBRERJTkciLCJERUZBVUxUIiwiZml0Qm91bmRzIiwiaW52YWxpZGF0ZVNpemUiLCJkcmF3UmVnaW9uT3V0bGluZSIsImNvdW50UmVzcG9uc2UiLCJmZXRjaCIsIm9rIiwiY291bnREYXRhIiwianNvbiIsImNvdW50IiwiTCIsInJlcXVpcmUiLCJyZWN0YW5nbGUiLCJjb2xvciIsIndlaWdodCIsIm9wYWNpdHkiLCJmaWxsIiwiZmlsbENvbG9yIiwiZmlsbE9wYWNpdHkiLCJkYXNoQXJyYXkiLCJpbnRlcmFjdGl2ZSIsImFkZFRvIiwiZ2V0VXNlckxvY2F0aW9uIiwicG9zaXRpb24iLCJnZXRDdXJyZW50UG9zaXRpb24iLCJjb29yZHMiLCJmZXRjaGVkQWlyY3JhZnQiLCJhZGFwdGVkQWlyY3JhZnQiLCJlbnJpY2hlZEFpcmNyYWZ0IiwiY3VycmVudFpvb20iLCJnZXRab29tIiwidGFyZ2V0Wm9vbSIsInNldFZpZXciLCJtZXNzYWdlIiwic3RhdHVzIiwicHJvY2Vzc0dlb2ZlbmNlU2VhcmNoIiwibG9jYXRpb25zIiwic2VhcmNoTG9jYXRpb25XaXRoTWFwYm94IiwiY29vcmRpbmF0ZXMiLCJuYW1lIiwiRXJyb3IiLCJNQU5VRkFDVFVSRVIiLCJ1bmRlZmluZWQiLCJ0b2dnbGVHZW9mZW5jZVN0YXRlIiwiZW5hYmxlZCIsIndhcm4iLCJzZWxlY3RNYW51ZmFjdHVyZXJBbmRDbG9zZSIsInZhbHVlIiwiZmV0Y2hBaXJjcmFmdEJ5UmVnaW9uQW5kTWFudWZhY3R1cmVyIiwiZmV0Y2hNYW51ZmFjdHVyZXJEYXRhIiwiY2F0Y2giLCJwYWdlIiwibGltaXQiLCJyZXNwb25zZSIsImVuY29kZVVSSUNvbXBvbmVudCIsImRhdGEiLCJhaXJjcmFmdERhdGEiLCJzdGF0dXNUZXh0IiwiZXh0ZW5kZWRBaXJjcmFmdCIsIm1hcCIsIlRZUEVfQUlSQ1JBRlQiLCJpc0dvdmVybm1lbnQiLCJPUEVSQVRPUiIsInRvTG93ZXJDYXNlIiwiUkVHSU9OIiwiaGFuZGxlTW9kZWxTZWxlY3QiLCJNT0RFTCIsImNsZWFyQWxsRmlsdGVycyIsImxhYmVsIiwiQ0VOVEVSIiwiREVGQVVMVF9aT09NIiwiY2xlYXJFdmVudCIsIkN1c3RvbUV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsImNvbWJpbmVkTG9hZGluZyIsImlzR2VvZmVuY2VQbGFjZW1lbnRNb2RlIiwicmVmcmVzaFdpdGhGaWx0ZXJzIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/tracking/hooks/useFilterLogic.ts\n"));

/***/ })

});
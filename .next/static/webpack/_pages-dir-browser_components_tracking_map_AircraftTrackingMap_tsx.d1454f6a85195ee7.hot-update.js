"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_pages-dir-browser_components_tracking_map_AircraftTrackingMap_tsx",{

/***/ "(pages-dir-browser)/./lib/services/MapboxService.ts":
/*!***************************************!*\
  !*** ./lib/services/MapboxService.ts ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MapboxService: () => (/* binding */ MapboxService)\n/* harmony export */ });\n/* harmony import */ var _utils_getFlagImage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/getFlagImage */ \"(pages-dir-browser)/./utils/getFlagImage.ts\");\n\nclass MapboxService {\n    static formatCityCountry(locationString, isDetailed) {\n        if (!locationString) return '';\n        const parts = locationString.split(',').map((p)=>p.trim());\n        if (parts.length >= 2) {\n            const country = parts[parts.length - 1];\n            let city = parts[0];\n            if (parts.length >= 3 && parts[0] === parts[1]) city = parts[0];\n            return \"\".concat(city, \", \").concat(country);\n        }\n        return locationString;\n    }\n    static extractCountry(locationString) {\n        if (!locationString) return '';\n        const parts = locationString.split(',').map((p)=>p.trim());\n        return parts.length ? parts[parts.length - 1] : locationString;\n    }\n    static getLocationFlagUrl(locationString) {\n        if (!locationString) return null;\n        const country = this.extractCountry(locationString);\n        return (0,_utils_getFlagImage__WEBPACK_IMPORTED_MODULE_0__.getFlagImageUrl)(country);\n    }\n    static validateCoordinates(lat, lng) {\n        if (isNaN(lat) || isNaN(lng)) {\n            console.error(\"Invalid coordinates: lat=\".concat(lat, \", lng=\").concat(lng));\n            return false;\n        }\n        const isValidLat = lat >= -90 && lat <= 90;\n        const isValidLng = lng >= -180 && lng <= 180;\n        if (!isValidLat || !isValidLng) {\n            console.error(\"Invalid coordinates detected: lat=\".concat(lat, \", lng=\").concat(lng));\n            return false;\n        }\n        return true;\n    }\n    static async searchLocationWithMapbox(query) {\n        let limit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, types = arguments.length > 2 ? arguments[2] : void 0, countryCode = arguments.length > 3 ? arguments[3] : void 0;\n        try {\n            var _data_features;\n            const params = new URLSearchParams({\n                query,\n                limit: limit.toString()\n            });\n            if (types) params.append('types', types);\n            if (countryCode) params.append('country', countryCode);\n            const response = await fetch(\"/api/proxy/mapbox-geocode?\".concat(params.toString()), {\n                headers: {\n                    'Cache-Control': 'max-age=86400'\n                }\n            });\n            if (!response.ok) throw new Error(\"Mapbox geocoding API error: \".concat(response.status));\n            const data = await response.json();\n            if (!((_data_features = data.features) === null || _data_features === void 0 ? void 0 : _data_features.length)) return [];\n            return data.features.map((feature)=>{\n                const [lng, lat] = feature.center;\n                this.validateCoordinates(lat, lng);\n                return {\n                    lat,\n                    lng,\n                    name: feature.place_name,\n                    bbox: feature.bbox\n                };\n            });\n        } catch (error) {\n            console.error(\"Mapbox location search failed:\", error);\n            throw error;\n        }\n    }\n    static async getCoordinatesFromQuery(query) {\n        const coordsMatch = query.match(/^(-?\\d+(\\.\\d+)?),\\s*(-?\\d+(\\.\\d+)?)$/);\n        if (coordsMatch) {\n            const lat = parseFloat(coordsMatch[1]);\n            const lng = parseFloat(coordsMatch[3]);\n            return {\n                lat,\n                lng,\n                name: \"\".concat(lat, \", \").concat(lng)\n            };\n        }\n        const results = await this.searchLocationWithMapbox(query, 1, 'place,postcode,address,poi,neighborhood,region,locality');\n        return results.length ? {\n            ...results[0],\n            name: results[0].name\n        } : null;\n    }\n    static async getLocationSuggestions(query) {\n        let limit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;\n        if (!query || query.trim().length < 2) return [];\n        const locations = await this.searchLocationWithMapbox(query, Math.max(5, limit), 'place,postcode,address,poi,neighborhood,region,locality');\n        return locations.slice(0, limit).map((loc)=>({\n                name: loc.name,\n                lat: loc.lat,\n                lng: loc.lng,\n                placeType: loc.name.split(',')[0]\n            }));\n    }\n    static async getLocationNameFromCoordinates(lat, lng) {\n        if (isNaN(lat) || isNaN(lng)) return \"\".concat(lat.toFixed(4), \", \").concat(lng.toFixed(4));\n        const coords = \"\".concat(lng, \",\").concat(lat);\n        try {\n            var _data_features, _feature_context, _feature_context1;\n            const response = await fetch(\"/api/proxy/mapbox-geocode?query=\".concat(encodeURIComponent(coords)));\n            if (!response.ok) throw new Error(\"Geocoding error: \".concat(response.status));\n            const data = await response.json();\n            const feature = (_data_features = data.features) === null || _data_features === void 0 ? void 0 : _data_features[0];\n            if (!feature) return \"\".concat(lat.toFixed(4), \", \").concat(lng.toFixed(4));\n            const placeItem = (_feature_context = feature.context) === null || _feature_context === void 0 ? void 0 : _feature_context.find((item)=>item.id.startsWith('place.'));\n            const regionItem = (_feature_context1 = feature.context) === null || _feature_context1 === void 0 ? void 0 : _feature_context1.find((item)=>item.id.startsWith('region.'));\n            if (placeItem && regionItem) return \"\".concat(placeItem.text, \", \").concat(regionItem.text);\n            if (placeItem) return placeItem.text;\n            if (regionItem) return regionItem.text;\n            return feature.place_name || feature.text;\n        } catch (error) {\n            console.error(\"Reverse geocoding failed:\", error);\n            return \"\".concat(lat.toFixed(4), \", \").concat(lng.toFixed(4));\n        }\n    }\n    static async postalCodeToCoordinates(postalCode) {\n        let countryCode = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 'us';\n        try {\n            var _data_result_addressMatches_, _data_result_addressMatches, _data_result;\n            const response = await fetch(\"/api/proxy/geocode?zip=\".concat(postalCode, \"&country=\").concat(countryCode), {\n                headers: {\n                    'Cache-Control': 'no-cache, no-store'\n                }\n            });\n            if (!response.ok) {\n                const errText = await response.text();\n                console.error(\"Postal geocode error (\".concat(response.status, \"): \").concat(errText));\n                return null;\n            }\n            const data = await response.json();\n            const match = (_data_result = data.result) === null || _data_result === void 0 ? void 0 : (_data_result_addressMatches = _data_result.addressMatches) === null || _data_result_addressMatches === void 0 ? void 0 : (_data_result_addressMatches_ = _data_result_addressMatches[0]) === null || _data_result_addressMatches_ === void 0 ? void 0 : _data_result_addressMatches_.coordinates;\n            if (match) return {\n                lat: match.y,\n                lng: match.x\n            };\n            console.warn(\"No coordinates found for postal code: \".concat(postalCode));\n            return null;\n        } catch (error) {\n            console.error(\"Postal code geocoding failed:\", error);\n            return null;\n        }\n    }\n    constructor(){\n        this.extractCountryFromFeature = (feature)=>{\n            var _feature_context;\n            if (!feature) return '';\n            const countryContext = (_feature_context = feature.context) === null || _feature_context === void 0 ? void 0 : _feature_context.find((c)=>c.id.startsWith('country.'));\n            if (countryContext) {\n                return countryContext.text;\n            }\n            if (feature.id.startsWith('country.')) {\n                return feature.text;\n            }\n            // Fallback to parsing place_name (your original logic)\n            if (feature.place_name) {\n                const parts = feature.place_name.split(',').map((p)=>p.trim());\n                return parts.length ? parts[parts.length - 1] : '';\n            }\n            return '';\n        };\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2xpYi9zZXJ2aWNlcy9NYXBib3hTZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTJEO0FBOEJwRCxNQUFNQztJQUNYLE9BQU9DLGtCQUNMQyxjQUE2QixFQUM3QkMsVUFBbUIsRUFDWDtRQUNSLElBQUksQ0FBQ0QsZ0JBQWdCLE9BQU87UUFDNUIsTUFBTUUsUUFBa0JGLGVBQ3JCRyxLQUFLLENBQUMsS0FDTkMsR0FBRyxDQUFDLENBQUNDLElBQWNBLEVBQUVDLElBQUk7UUFDNUIsSUFBSUosTUFBTUssTUFBTSxJQUFJLEdBQUc7WUFDckIsTUFBTUMsVUFBa0JOLEtBQUssQ0FBQ0EsTUFBTUssTUFBTSxHQUFHLEVBQUU7WUFDL0MsSUFBSUUsT0FBZVAsS0FBSyxDQUFDLEVBQUU7WUFDM0IsSUFBSUEsTUFBTUssTUFBTSxJQUFJLEtBQUtMLEtBQUssQ0FBQyxFQUFFLEtBQUtBLEtBQUssQ0FBQyxFQUFFLEVBQUVPLE9BQU9QLEtBQUssQ0FBQyxFQUFFO1lBQy9ELE9BQU8sR0FBWU0sT0FBVEMsTUFBSyxNQUFZLE9BQVJEO1FBQ3JCO1FBQ0EsT0FBT1I7SUFDVDtJQXlCQSxPQUFPVSxlQUFlVixjQUE2QixFQUFVO1FBQzNELElBQUksQ0FBQ0EsZ0JBQWdCLE9BQU87UUFDNUIsTUFBTUUsUUFBUUYsZUFBZUcsS0FBSyxDQUFDLEtBQUtDLEdBQUcsQ0FBQyxDQUFDQyxJQUFNQSxFQUFFQyxJQUFJO1FBQ3pELE9BQU9KLE1BQU1LLE1BQU0sR0FBR0wsS0FBSyxDQUFDQSxNQUFNSyxNQUFNLEdBQUcsRUFBRSxHQUFHUDtJQUNsRDtJQUVBLE9BQU9XLG1CQUFtQlgsY0FBNkIsRUFBaUI7UUFDdEUsSUFBSSxDQUFDQSxnQkFBZ0IsT0FBTztRQUM1QixNQUFNUSxVQUFVLElBQUksQ0FBQ0UsY0FBYyxDQUFDVjtRQUNwQyxPQUFPSCxvRUFBZUEsQ0FBQ1c7SUFDekI7SUFFQSxPQUFPSSxvQkFBb0JDLEdBQVcsRUFBRUMsR0FBVyxFQUFXO1FBQzVELElBQUlDLE1BQU1GLFFBQVFFLE1BQU1ELE1BQU07WUFDNUJFLFFBQVFDLEtBQUssQ0FBQyw0QkFBd0NILE9BQVpELEtBQUksVUFBWSxPQUFKQztZQUN0RCxPQUFPO1FBQ1Q7UUFDQSxNQUFNSSxhQUFhTCxPQUFPLENBQUMsTUFBTUEsT0FBTztRQUN4QyxNQUFNTSxhQUFhTCxPQUFPLENBQUMsT0FBT0EsT0FBTztRQUN6QyxJQUFJLENBQUNJLGNBQWMsQ0FBQ0MsWUFBWTtZQUM5QkgsUUFBUUMsS0FBSyxDQUFDLHFDQUFpREgsT0FBWkQsS0FBSSxVQUFZLE9BQUpDO1lBQy9ELE9BQU87UUFDVDtRQUNBLE9BQU87SUFDVDtJQUVBLGFBQWFNLHlCQUNYQyxLQUFhLEVBV2I7WUFWQUMsUUFBQUEsaUVBQWdCLEdBQ2hCQyxzREFDQUM7UUFTQSxJQUFJO2dCQWdCR0M7WUFmTCxNQUFNQyxTQUFTLElBQUlDLGdCQUFnQjtnQkFBRU47Z0JBQU9DLE9BQU9BLE1BQU1NLFFBQVE7WUFBRztZQUNwRSxJQUFJTCxPQUFPRyxPQUFPRyxNQUFNLENBQUMsU0FBU047WUFDbEMsSUFBSUMsYUFBYUUsT0FBT0csTUFBTSxDQUFDLFdBQVdMO1lBRTFDLE1BQU1NLFdBQVcsTUFBTUMsTUFDckIsNkJBQStDLE9BQWxCTCxPQUFPRSxRQUFRLEtBQzVDO2dCQUNFSSxTQUFTO29CQUFFLGlCQUFpQjtnQkFBZ0I7WUFDOUM7WUFHRixJQUFJLENBQUNGLFNBQVNHLEVBQUUsRUFDZCxNQUFNLElBQUlDLE1BQU0sK0JBQStDLE9BQWhCSixTQUFTSyxNQUFNO1lBRWhFLE1BQU1WLE9BQXVCLE1BQU1LLFNBQVNNLElBQUk7WUFDaEQsSUFBSSxHQUFDWCxpQkFBQUEsS0FBS1ksUUFBUSxjQUFiWixxQ0FBQUEsZUFBZWxCLE1BQU0sR0FBRSxPQUFPLEVBQUU7WUFFckMsT0FBT2tCLEtBQUtZLFFBQVEsQ0FBQ2pDLEdBQUcsQ0FBQyxDQUFDa0M7Z0JBQ3hCLE1BQU0sQ0FBQ3hCLEtBQUtELElBQUksR0FBR3lCLFFBQVFDLE1BQU07Z0JBQ2pDLElBQUksQ0FBQzNCLG1CQUFtQixDQUFDQyxLQUFLQztnQkFDOUIsT0FBTztvQkFDTEQ7b0JBQ0FDO29CQUNBMEIsTUFBTUYsUUFBUUcsVUFBVTtvQkFDeEJDLE1BQU1KLFFBQVFJLElBQUk7Z0JBQ3BCO1lBQ0Y7UUFDRixFQUFFLE9BQU96QixPQUFPO1lBQ2RELFFBQVFDLEtBQUssQ0FBRSxrQ0FBaUNBO1lBQ2hELE1BQU1BO1FBQ1I7SUFDRjtJQUVBLGFBQWEwQix3QkFDWHRCLEtBQWEsRUFDK0M7UUFDNUQsTUFBTXVCLGNBQWN2QixNQUFNd0IsS0FBSyxDQUFDO1FBQ2hDLElBQUlELGFBQWE7WUFDZixNQUFNL0IsTUFBTWlDLFdBQVdGLFdBQVcsQ0FBQyxFQUFFO1lBQ3JDLE1BQU05QixNQUFNZ0MsV0FBV0YsV0FBVyxDQUFDLEVBQUU7WUFDckMsT0FBTztnQkFBRS9CO2dCQUFLQztnQkFBSzBCLE1BQU0sR0FBVzFCLE9BQVJELEtBQUksTUFBUSxPQUFKQztZQUFNO1FBQzVDO1FBRUEsTUFBTWlDLFVBQVUsTUFBTSxJQUFJLENBQUMzQix3QkFBd0IsQ0FDakRDLE9BQ0EsR0FDQTtRQUdGLE9BQU8wQixRQUFReEMsTUFBTSxHQUFHO1lBQUUsR0FBR3dDLE9BQU8sQ0FBQyxFQUFFO1lBQUVQLE1BQU1PLE9BQU8sQ0FBQyxFQUFFLENBQUNQLElBQUk7UUFBQyxJQUFJO0lBQ3JFO0lBRUEsYUFBYVEsdUJBQ1gzQixLQUFhLEVBU2I7WUFSQUMsUUFBQUEsaUVBQWdCO1FBU2hCLElBQUksQ0FBQ0QsU0FBU0EsTUFBTWYsSUFBSSxHQUFHQyxNQUFNLEdBQUcsR0FBRyxPQUFPLEVBQUU7UUFDaEQsTUFBTTBDLFlBQVksTUFBTSxJQUFJLENBQUM3Qix3QkFBd0IsQ0FDbkRDLE9BQ0E2QixLQUFLQyxHQUFHLENBQUMsR0FBRzdCLFFBQ1o7UUFHRixPQUFPMkIsVUFBVUcsS0FBSyxDQUFDLEdBQUc5QixPQUFPbEIsR0FBRyxDQUFDLENBQUNpRCxNQUFTO2dCQUM3Q2IsTUFBTWEsSUFBSWIsSUFBSTtnQkFDZDNCLEtBQUt3QyxJQUFJeEMsR0FBRztnQkFDWkMsS0FBS3VDLElBQUl2QyxHQUFHO2dCQUNad0MsV0FBV0QsSUFBSWIsSUFBSSxDQUFDckMsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQ25DO0lBQ0Y7SUFFQSxhQUFhb0QsK0JBQ1gxQyxHQUFXLEVBQ1hDLEdBQVcsRUFDYTtRQUN4QixJQUFJQyxNQUFNRixRQUFRRSxNQUFNRCxNQUFNLE9BQU8sR0FBc0JBLE9BQW5CRCxJQUFJMkMsT0FBTyxDQUFDLElBQUcsTUFBbUIsT0FBZjFDLElBQUkwQyxPQUFPLENBQUM7UUFDdkUsTUFBTUMsU0FBUyxHQUFVNUMsT0FBUEMsS0FBSSxLQUFPLE9BQUpEO1FBRXpCLElBQUk7Z0JBT2NZLGdCQUdFYSxrQkFHQ0E7WUFabkIsTUFBTVIsV0FBVyxNQUFNQyxNQUNyQixtQ0FBOEQsT0FBM0IyQixtQkFBbUJEO1lBRXhELElBQUksQ0FBQzNCLFNBQVNHLEVBQUUsRUFBRSxNQUFNLElBQUlDLE1BQU0sb0JBQW9DLE9BQWhCSixTQUFTSyxNQUFNO1lBRXJFLE1BQU1WLE9BQU8sTUFBTUssU0FBU00sSUFBSTtZQUNoQyxNQUFNRSxXQUFVYixpQkFBQUEsS0FBS1ksUUFBUSxjQUFiWixxQ0FBQUEsY0FBZSxDQUFDLEVBQUU7WUFDbEMsSUFBSSxDQUFDYSxTQUFTLE9BQU8sR0FBc0J4QixPQUFuQkQsSUFBSTJDLE9BQU8sQ0FBQyxJQUFHLE1BQW1CLE9BQWYxQyxJQUFJMEMsT0FBTyxDQUFDO1lBRXZELE1BQU1HLGFBQVlyQixtQkFBQUEsUUFBUXNCLE9BQU8sY0FBZnRCLHVDQUFBQSxpQkFBaUJ1QixJQUFJLENBQUMsQ0FBQ0MsT0FDdkNBLEtBQUtDLEVBQUUsQ0FBQ0MsVUFBVSxDQUFDO1lBRXJCLE1BQU1DLGNBQWEzQixvQkFBQUEsUUFBUXNCLE9BQU8sY0FBZnRCLHdDQUFBQSxrQkFBaUJ1QixJQUFJLENBQUMsQ0FBQ0MsT0FDeENBLEtBQUtDLEVBQUUsQ0FBQ0MsVUFBVSxDQUFDO1lBR3JCLElBQUlMLGFBQWFNLFlBQ2YsT0FBTyxHQUFzQkEsT0FBbkJOLFVBQVVPLElBQUksRUFBQyxNQUFvQixPQUFoQkQsV0FBV0MsSUFBSTtZQUM5QyxJQUFJUCxXQUFXLE9BQU9BLFVBQVVPLElBQUk7WUFDcEMsSUFBSUQsWUFBWSxPQUFPQSxXQUFXQyxJQUFJO1lBRXRDLE9BQU81QixRQUFRRyxVQUFVLElBQUlILFFBQVE0QixJQUFJO1FBQzNDLEVBQUUsT0FBT2pELE9BQU87WUFDZEQsUUFBUUMsS0FBSyxDQUFFLDZCQUE0QkE7WUFDM0MsT0FBTyxHQUFzQkgsT0FBbkJELElBQUkyQyxPQUFPLENBQUMsSUFBRyxNQUFtQixPQUFmMUMsSUFBSTBDLE9BQU8sQ0FBQztRQUMzQztJQUNGO0lBRUEsYUFBYVcsd0JBQ1hDLFVBQWtCLEVBRTRCO1lBRDlDNUMsY0FBQUEsaUVBQXNCO1FBRXRCLElBQUk7Z0JBZVlDLDhCQUFBQSw2QkFBQUE7WUFkZCxNQUFNSyxXQUFXLE1BQU1DLE1BQ3JCLDBCQUFnRFAsT0FBdEI0QyxZQUFXLGFBQXVCLE9BQVo1QyxjQUNoRDtnQkFDRVEsU0FBUztvQkFBRSxpQkFBaUI7Z0JBQXFCO1lBQ25EO1lBR0YsSUFBSSxDQUFDRixTQUFTRyxFQUFFLEVBQUU7Z0JBQ2hCLE1BQU1vQyxVQUFVLE1BQU12QyxTQUFTb0MsSUFBSTtnQkFDbkNsRCxRQUFRQyxLQUFLLENBQUMseUJBQThDb0QsT0FBckJ2QyxTQUFTSyxNQUFNLEVBQUMsT0FBYSxPQUFSa0M7Z0JBQzVELE9BQU87WUFDVDtZQUVBLE1BQU01QyxPQUFPLE1BQU1LLFNBQVNNLElBQUk7WUFDaEMsTUFBTVMsU0FBUXBCLGVBQUFBLEtBQUs2QyxNQUFNLGNBQVg3QyxvQ0FBQUEsOEJBQUFBLGFBQWE4QyxjQUFjLGNBQTNCOUMsbURBQUFBLCtCQUFBQSwyQkFBNkIsQ0FBQyxFQUFFLGNBQWhDQSxtREFBQUEsNkJBQWtDK0MsV0FBVztZQUMzRCxJQUFJM0IsT0FBTyxPQUFPO2dCQUFFaEMsS0FBS2dDLE1BQU00QixDQUFDO2dCQUFFM0QsS0FBSytCLE1BQU02QixDQUFDO1lBQUM7WUFFL0MxRCxRQUFRMkQsSUFBSSxDQUFDLHlDQUFvRCxPQUFYUDtZQUN0RCxPQUFPO1FBQ1QsRUFBRSxPQUFPbkQsT0FBTztZQUNkRCxRQUFRQyxLQUFLLENBQUUsaUNBQWdDQTtZQUMvQyxPQUFPO1FBQ1Q7SUFDRjs7YUE3TUEyRCw0QkFBNEIsQ0FBQ3RDO2dCQUdKQTtZQUZ2QixJQUFJLENBQUNBLFNBQVMsT0FBTztZQUVyQixNQUFNdUMsa0JBQWlCdkMsbUJBQUFBLFFBQVFzQixPQUFPLGNBQWZ0Qix1Q0FBQUEsaUJBQWlCdUIsSUFBSSxDQUFDLENBQUNpQixJQUM1Q0EsRUFBRWYsRUFBRSxDQUFDQyxVQUFVLENBQUM7WUFFbEIsSUFBSWEsZ0JBQWdCO2dCQUNsQixPQUFPQSxlQUFlWCxJQUFJO1lBQzVCO1lBRUEsSUFBSTVCLFFBQVF5QixFQUFFLENBQUNDLFVBQVUsQ0FBQyxhQUFhO2dCQUNyQyxPQUFPMUIsUUFBUTRCLElBQUk7WUFDckI7WUFFQSx1REFBdUQ7WUFDdkQsSUFBSTVCLFFBQVFHLFVBQVUsRUFBRTtnQkFDdEIsTUFBTXZDLFFBQVFvQyxRQUFRRyxVQUFVLENBQUN0QyxLQUFLLENBQUMsS0FBS0MsR0FBRyxDQUFDLENBQUNDLElBQU1BLEVBQUVDLElBQUk7Z0JBQzdELE9BQU9KLE1BQU1LLE1BQU0sR0FBR0wsS0FBSyxDQUFDQSxNQUFNSyxNQUFNLEdBQUcsRUFBRSxHQUFHO1lBQ2xEO1lBRUEsT0FBTztRQUNUOztBQXlMRiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxzYXRob1xcRG9jdW1lbnRzXFxQcm9qZWN0c1xcYWlyY3JhZnQtdHJhY2tpbmdcXGxpYlxcc2VydmljZXNcXE1hcGJveFNlcnZpY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0RmxhZ0ltYWdlVXJsIH0gZnJvbSAnLi4vLi4vdXRpbHMvZ2V0RmxhZ0ltYWdlJztcclxuXHJcbmludGVyZmFjZSBNYXBib3hGZWF0dXJlIHtcclxuICBpZDogc3RyaW5nO1xyXG4gIHR5cGU6IHN0cmluZztcclxuICBwbGFjZV90eXBlOiBzdHJpbmdbXTtcclxuICByZWxldmFuY2U6IG51bWJlcjtcclxuICBwcm9wZXJ0aWVzOiB7IFtrZXk6IHN0cmluZ106IGFueSB9O1xyXG4gIHRleHQ6IHN0cmluZztcclxuICBwbGFjZV9uYW1lOiBzdHJpbmc7XHJcbiAgY2VudGVyOiBbbnVtYmVyLCBudW1iZXJdO1xyXG4gIGdlb21ldHJ5OiB7IHR5cGU6IHN0cmluZzsgY29vcmRpbmF0ZXM6IFtudW1iZXIsIG51bWJlcl0gfTtcclxuICBiYm94PzogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XHJcbiAgY29udGV4dD86IEFycmF5PHsgaWQ6IHN0cmluZzsgdGV4dDogc3RyaW5nIH0+O1xyXG59XHJcblxyXG5pbnRlcmZhY2UgTWFwYm94UmVzcG9uc2Uge1xyXG4gIHR5cGU6IHN0cmluZztcclxuICBxdWVyeTogc3RyaW5nW107XHJcbiAgZmVhdHVyZXM6IE1hcGJveEZlYXR1cmVbXTtcclxuICBhdHRyaWJ1dGlvbjogc3RyaW5nO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEdlb2ZlbmNlUGFyYW1zIHtcclxuICBsYW1pbjogbnVtYmVyO1xyXG4gIGxhbWF4OiBudW1iZXI7XHJcbiAgbG9taW46IG51bWJlcjtcclxuICBsb21heDogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgTWFwYm94U2VydmljZSB7XHJcbiAgc3RhdGljIGZvcm1hdENpdHlDb3VudHJ5KFxyXG4gICAgbG9jYXRpb25TdHJpbmc6IHN0cmluZyB8IG51bGwsXHJcbiAgICBpc0RldGFpbGVkOiBib29sZWFuXHJcbiAgKTogc3RyaW5nIHtcclxuICAgIGlmICghbG9jYXRpb25TdHJpbmcpIHJldHVybiAnJztcclxuICAgIGNvbnN0IHBhcnRzOiBzdHJpbmdbXSA9IGxvY2F0aW9uU3RyaW5nXHJcbiAgICAgIC5zcGxpdCgnLCcpXHJcbiAgICAgIC5tYXAoKHA6IHN0cmluZykgPT4gcC50cmltKCkpO1xyXG4gICAgaWYgKHBhcnRzLmxlbmd0aCA+PSAyKSB7XHJcbiAgICAgIGNvbnN0IGNvdW50cnk6IHN0cmluZyA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdO1xyXG4gICAgICBsZXQgY2l0eTogc3RyaW5nID0gcGFydHNbMF07XHJcbiAgICAgIGlmIChwYXJ0cy5sZW5ndGggPj0gMyAmJiBwYXJ0c1swXSA9PT0gcGFydHNbMV0pIGNpdHkgPSBwYXJ0c1swXTtcclxuICAgICAgcmV0dXJuIGAke2NpdHl9LCAke2NvdW50cnl9YDtcclxuICAgIH1cclxuICAgIHJldHVybiBsb2NhdGlvblN0cmluZztcclxuICB9XHJcblxyXG4gIGV4dHJhY3RDb3VudHJ5RnJvbUZlYXR1cmUgPSAoZmVhdHVyZTogTWFwYm94RmVhdHVyZSk6IHN0cmluZyA9PiB7XHJcbiAgICBpZiAoIWZlYXR1cmUpIHJldHVybiAnJztcclxuXHJcbiAgICBjb25zdCBjb3VudHJ5Q29udGV4dCA9IGZlYXR1cmUuY29udGV4dD8uZmluZCgoYykgPT5cclxuICAgICAgYy5pZC5zdGFydHNXaXRoKCdjb3VudHJ5LicpXHJcbiAgICApO1xyXG4gICAgaWYgKGNvdW50cnlDb250ZXh0KSB7XHJcbiAgICAgIHJldHVybiBjb3VudHJ5Q29udGV4dC50ZXh0O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChmZWF0dXJlLmlkLnN0YXJ0c1dpdGgoJ2NvdW50cnkuJykpIHtcclxuICAgICAgcmV0dXJuIGZlYXR1cmUudGV4dDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBGYWxsYmFjayB0byBwYXJzaW5nIHBsYWNlX25hbWUgKHlvdXIgb3JpZ2luYWwgbG9naWMpXHJcbiAgICBpZiAoZmVhdHVyZS5wbGFjZV9uYW1lKSB7XHJcbiAgICAgIGNvbnN0IHBhcnRzID0gZmVhdHVyZS5wbGFjZV9uYW1lLnNwbGl0KCcsJykubWFwKChwKSA9PiBwLnRyaW0oKSk7XHJcbiAgICAgIHJldHVybiBwYXJ0cy5sZW5ndGggPyBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXSA6ICcnO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAnJztcclxuICB9O1xyXG5cclxuICBzdGF0aWMgZXh0cmFjdENvdW50cnkobG9jYXRpb25TdHJpbmc6IHN0cmluZyB8IG51bGwpOiBzdHJpbmcge1xyXG4gICAgaWYgKCFsb2NhdGlvblN0cmluZykgcmV0dXJuICcnO1xyXG4gICAgY29uc3QgcGFydHMgPSBsb2NhdGlvblN0cmluZy5zcGxpdCgnLCcpLm1hcCgocCkgPT4gcC50cmltKCkpO1xyXG4gICAgcmV0dXJuIHBhcnRzLmxlbmd0aCA/IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdIDogbG9jYXRpb25TdHJpbmc7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgZ2V0TG9jYXRpb25GbGFnVXJsKGxvY2F0aW9uU3RyaW5nOiBzdHJpbmcgfCBudWxsKTogc3RyaW5nIHwgbnVsbCB7XHJcbiAgICBpZiAoIWxvY2F0aW9uU3RyaW5nKSByZXR1cm4gbnVsbDtcclxuICAgIGNvbnN0IGNvdW50cnkgPSB0aGlzLmV4dHJhY3RDb3VudHJ5KGxvY2F0aW9uU3RyaW5nKTtcclxuICAgIHJldHVybiBnZXRGbGFnSW1hZ2VVcmwoY291bnRyeSk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgdmFsaWRhdGVDb29yZGluYXRlcyhsYXQ6IG51bWJlciwgbG5nOiBudW1iZXIpOiBib29sZWFuIHtcclxuICAgIGlmIChpc05hTihsYXQpIHx8IGlzTmFOKGxuZykpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgSW52YWxpZCBjb29yZGluYXRlczogbGF0PSR7bGF0fSwgbG5nPSR7bG5nfWApO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBjb25zdCBpc1ZhbGlkTGF0ID0gbGF0ID49IC05MCAmJiBsYXQgPD0gOTA7XHJcbiAgICBjb25zdCBpc1ZhbGlkTG5nID0gbG5nID49IC0xODAgJiYgbG5nIDw9IDE4MDtcclxuICAgIGlmICghaXNWYWxpZExhdCB8fCAhaXNWYWxpZExuZykge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBJbnZhbGlkIGNvb3JkaW5hdGVzIGRldGVjdGVkOiBsYXQ9JHtsYXR9LCBsbmc9JHtsbmd9YCk7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGFzeW5jIHNlYXJjaExvY2F0aW9uV2l0aE1hcGJveChcclxuICAgIHF1ZXJ5OiBzdHJpbmcsXHJcbiAgICBsaW1pdDogbnVtYmVyID0gMSxcclxuICAgIHR5cGVzPzogc3RyaW5nLFxyXG4gICAgY291bnRyeUNvZGU/OiBzdHJpbmdcclxuICApOiBQcm9taXNlPFxyXG4gICAgQXJyYXk8e1xyXG4gICAgICBsYXQ6IG51bWJlcjtcclxuICAgICAgbG5nOiBudW1iZXI7XHJcbiAgICAgIG5hbWU6IHN0cmluZztcclxuICAgICAgYmJveD86IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdO1xyXG4gICAgfT5cclxuICA+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoeyBxdWVyeSwgbGltaXQ6IGxpbWl0LnRvU3RyaW5nKCkgfSk7XHJcbiAgICAgIGlmICh0eXBlcykgcGFyYW1zLmFwcGVuZCgndHlwZXMnLCB0eXBlcyk7XHJcbiAgICAgIGlmIChjb3VudHJ5Q29kZSkgcGFyYW1zLmFwcGVuZCgnY291bnRyeScsIGNvdW50cnlDb2RlKTtcclxuXHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXHJcbiAgICAgICAgYC9hcGkvcHJveHkvbWFwYm94LWdlb2NvZGU/JHtwYXJhbXMudG9TdHJpbmcoKX1gLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIGhlYWRlcnM6IHsgJ0NhY2hlLUNvbnRyb2wnOiAnbWF4LWFnZT04NjQwMCcgfSxcclxuICAgICAgICB9XHJcbiAgICAgICk7XHJcblxyXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTWFwYm94IGdlb2NvZGluZyBBUEkgZXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xyXG5cclxuICAgICAgY29uc3QgZGF0YTogTWFwYm94UmVzcG9uc2UgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgIGlmICghZGF0YS5mZWF0dXJlcz8ubGVuZ3RoKSByZXR1cm4gW107XHJcblxyXG4gICAgICByZXR1cm4gZGF0YS5mZWF0dXJlcy5tYXAoKGZlYXR1cmUpID0+IHtcclxuICAgICAgICBjb25zdCBbbG5nLCBsYXRdID0gZmVhdHVyZS5jZW50ZXI7XHJcbiAgICAgICAgdGhpcy52YWxpZGF0ZUNvb3JkaW5hdGVzKGxhdCwgbG5nKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgbGF0LFxyXG4gICAgICAgICAgbG5nLFxyXG4gICAgICAgICAgbmFtZTogZmVhdHVyZS5wbGFjZV9uYW1lLFxyXG4gICAgICAgICAgYmJveDogZmVhdHVyZS5iYm94LFxyXG4gICAgICAgIH07XHJcbiAgICAgIH0pO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgTWFwYm94IGxvY2F0aW9uIHNlYXJjaCBmYWlsZWQ6YCwgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHN0YXRpYyBhc3luYyBnZXRDb29yZGluYXRlc0Zyb21RdWVyeShcclxuICAgIHF1ZXJ5OiBzdHJpbmdcclxuICApOiBQcm9taXNlPHsgbGF0OiBudW1iZXI7IGxuZzogbnVtYmVyOyBuYW1lOiBzdHJpbmcgfSB8IG51bGw+IHtcclxuICAgIGNvbnN0IGNvb3Jkc01hdGNoID0gcXVlcnkubWF0Y2goL14oLT9cXGQrKFxcLlxcZCspPyksXFxzKigtP1xcZCsoXFwuXFxkKyk/KSQvKTtcclxuICAgIGlmIChjb29yZHNNYXRjaCkge1xyXG4gICAgICBjb25zdCBsYXQgPSBwYXJzZUZsb2F0KGNvb3Jkc01hdGNoWzFdKTtcclxuICAgICAgY29uc3QgbG5nID0gcGFyc2VGbG9hdChjb29yZHNNYXRjaFszXSk7XHJcbiAgICAgIHJldHVybiB7IGxhdCwgbG5nLCBuYW1lOiBgJHtsYXR9LCAke2xuZ31gIH07XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHRoaXMuc2VhcmNoTG9jYXRpb25XaXRoTWFwYm94KFxyXG4gICAgICBxdWVyeSxcclxuICAgICAgMSxcclxuICAgICAgJ3BsYWNlLHBvc3Rjb2RlLGFkZHJlc3MscG9pLG5laWdoYm9yaG9vZCxyZWdpb24sbG9jYWxpdHknXHJcbiAgICApO1xyXG5cclxuICAgIHJldHVybiByZXN1bHRzLmxlbmd0aCA/IHsgLi4ucmVzdWx0c1swXSwgbmFtZTogcmVzdWx0c1swXS5uYW1lIH0gOiBudWxsO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGFzeW5jIGdldExvY2F0aW9uU3VnZ2VzdGlvbnMoXHJcbiAgICBxdWVyeTogc3RyaW5nLFxyXG4gICAgbGltaXQ6IG51bWJlciA9IDVcclxuICApOiBQcm9taXNlPFxyXG4gICAgQXJyYXk8e1xyXG4gICAgICBuYW1lOiBzdHJpbmc7XHJcbiAgICAgIGxhdDogbnVtYmVyO1xyXG4gICAgICBsbmc6IG51bWJlcjtcclxuICAgICAgcGxhY2VUeXBlOiBzdHJpbmc7XHJcbiAgICB9PlxyXG4gID4ge1xyXG4gICAgaWYgKCFxdWVyeSB8fCBxdWVyeS50cmltKCkubGVuZ3RoIDwgMikgcmV0dXJuIFtdO1xyXG4gICAgY29uc3QgbG9jYXRpb25zID0gYXdhaXQgdGhpcy5zZWFyY2hMb2NhdGlvbldpdGhNYXBib3goXHJcbiAgICAgIHF1ZXJ5LFxyXG4gICAgICBNYXRoLm1heCg1LCBsaW1pdCksXHJcbiAgICAgICdwbGFjZSxwb3N0Y29kZSxhZGRyZXNzLHBvaSxuZWlnaGJvcmhvb2QscmVnaW9uLGxvY2FsaXR5J1xyXG4gICAgKTtcclxuXHJcbiAgICByZXR1cm4gbG9jYXRpb25zLnNsaWNlKDAsIGxpbWl0KS5tYXAoKGxvYykgPT4gKHtcclxuICAgICAgbmFtZTogbG9jLm5hbWUsXHJcbiAgICAgIGxhdDogbG9jLmxhdCxcclxuICAgICAgbG5nOiBsb2MubG5nLFxyXG4gICAgICBwbGFjZVR5cGU6IGxvYy5uYW1lLnNwbGl0KCcsJylbMF0sXHJcbiAgICB9KSk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgYXN5bmMgZ2V0TG9jYXRpb25OYW1lRnJvbUNvb3JkaW5hdGVzKFxyXG4gICAgbGF0OiBudW1iZXIsXHJcbiAgICBsbmc6IG51bWJlclxyXG4gICk6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4ge1xyXG4gICAgaWYgKGlzTmFOKGxhdCkgfHwgaXNOYU4obG5nKSkgcmV0dXJuIGAke2xhdC50b0ZpeGVkKDQpfSwgJHtsbmcudG9GaXhlZCg0KX1gO1xyXG4gICAgY29uc3QgY29vcmRzID0gYCR7bG5nfSwke2xhdH1gO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXHJcbiAgICAgICAgYC9hcGkvcHJveHkvbWFwYm94LWdlb2NvZGU/cXVlcnk9JHtlbmNvZGVVUklDb21wb25lbnQoY29vcmRzKX1gXHJcbiAgICAgICk7XHJcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHRocm93IG5ldyBFcnJvcihgR2VvY29kaW5nIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcclxuXHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgIGNvbnN0IGZlYXR1cmUgPSBkYXRhLmZlYXR1cmVzPy5bMF07XHJcbiAgICAgIGlmICghZmVhdHVyZSkgcmV0dXJuIGAke2xhdC50b0ZpeGVkKDQpfSwgJHtsbmcudG9GaXhlZCg0KX1gO1xyXG5cclxuICAgICAgY29uc3QgcGxhY2VJdGVtID0gZmVhdHVyZS5jb250ZXh0Py5maW5kKChpdGVtOiBhbnkpID0+XHJcbiAgICAgICAgaXRlbS5pZC5zdGFydHNXaXRoKCdwbGFjZS4nKVxyXG4gICAgICApO1xyXG4gICAgICBjb25zdCByZWdpb25JdGVtID0gZmVhdHVyZS5jb250ZXh0Py5maW5kKChpdGVtOiBhbnkpID0+XHJcbiAgICAgICAgaXRlbS5pZC5zdGFydHNXaXRoKCdyZWdpb24uJylcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGlmIChwbGFjZUl0ZW0gJiYgcmVnaW9uSXRlbSlcclxuICAgICAgICByZXR1cm4gYCR7cGxhY2VJdGVtLnRleHR9LCAke3JlZ2lvbkl0ZW0udGV4dH1gO1xyXG4gICAgICBpZiAocGxhY2VJdGVtKSByZXR1cm4gcGxhY2VJdGVtLnRleHQ7XHJcbiAgICAgIGlmIChyZWdpb25JdGVtKSByZXR1cm4gcmVnaW9uSXRlbS50ZXh0O1xyXG5cclxuICAgICAgcmV0dXJuIGZlYXR1cmUucGxhY2VfbmFtZSB8fCBmZWF0dXJlLnRleHQ7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBSZXZlcnNlIGdlb2NvZGluZyBmYWlsZWQ6YCwgZXJyb3IpO1xyXG4gICAgICByZXR1cm4gYCR7bGF0LnRvRml4ZWQoNCl9LCAke2xuZy50b0ZpeGVkKDQpfWA7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgYXN5bmMgcG9zdGFsQ29kZVRvQ29vcmRpbmF0ZXMoXHJcbiAgICBwb3N0YWxDb2RlOiBzdHJpbmcsXHJcbiAgICBjb3VudHJ5Q29kZTogc3RyaW5nID0gJ3VzJ1xyXG4gICk6IFByb21pc2U8eyBsYXQ6IG51bWJlcjsgbG5nOiBudW1iZXIgfSB8IG51bGw+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXHJcbiAgICAgICAgYC9hcGkvcHJveHkvZ2VvY29kZT96aXA9JHtwb3N0YWxDb2RlfSZjb3VudHJ5PSR7Y291bnRyeUNvZGV9YCxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBoZWFkZXJzOiB7ICdDYWNoZS1Db250cm9sJzogJ25vLWNhY2hlLCBuby1zdG9yZScgfSxcclxuICAgICAgICB9XHJcbiAgICAgICk7XHJcblxyXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgY29uc3QgZXJyVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcclxuICAgICAgICBjb25zb2xlLmVycm9yKGBQb3N0YWwgZ2VvY29kZSBlcnJvciAoJHtyZXNwb25zZS5zdGF0dXN9KTogJHtlcnJUZXh0fWApO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICBjb25zdCBtYXRjaCA9IGRhdGEucmVzdWx0Py5hZGRyZXNzTWF0Y2hlcz8uWzBdPy5jb29yZGluYXRlcztcclxuICAgICAgaWYgKG1hdGNoKSByZXR1cm4geyBsYXQ6IG1hdGNoLnksIGxuZzogbWF0Y2gueCB9O1xyXG5cclxuICAgICAgY29uc29sZS53YXJuKGBObyBjb29yZGluYXRlcyBmb3VuZCBmb3IgcG9zdGFsIGNvZGU6ICR7cG9zdGFsQ29kZX1gKTtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBQb3N0YWwgY29kZSBnZW9jb2RpbmcgZmFpbGVkOmAsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiJdLCJuYW1lcyI6WyJnZXRGbGFnSW1hZ2VVcmwiLCJNYXBib3hTZXJ2aWNlIiwiZm9ybWF0Q2l0eUNvdW50cnkiLCJsb2NhdGlvblN0cmluZyIsImlzRGV0YWlsZWQiLCJwYXJ0cyIsInNwbGl0IiwibWFwIiwicCIsInRyaW0iLCJsZW5ndGgiLCJjb3VudHJ5IiwiY2l0eSIsImV4dHJhY3RDb3VudHJ5IiwiZ2V0TG9jYXRpb25GbGFnVXJsIiwidmFsaWRhdGVDb29yZGluYXRlcyIsImxhdCIsImxuZyIsImlzTmFOIiwiY29uc29sZSIsImVycm9yIiwiaXNWYWxpZExhdCIsImlzVmFsaWRMbmciLCJzZWFyY2hMb2NhdGlvbldpdGhNYXBib3giLCJxdWVyeSIsImxpbWl0IiwidHlwZXMiLCJjb3VudHJ5Q29kZSIsImRhdGEiLCJwYXJhbXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJ0b1N0cmluZyIsImFwcGVuZCIsInJlc3BvbnNlIiwiZmV0Y2giLCJoZWFkZXJzIiwib2siLCJFcnJvciIsInN0YXR1cyIsImpzb24iLCJmZWF0dXJlcyIsImZlYXR1cmUiLCJjZW50ZXIiLCJuYW1lIiwicGxhY2VfbmFtZSIsImJib3giLCJnZXRDb29yZGluYXRlc0Zyb21RdWVyeSIsImNvb3Jkc01hdGNoIiwibWF0Y2giLCJwYXJzZUZsb2F0IiwicmVzdWx0cyIsImdldExvY2F0aW9uU3VnZ2VzdGlvbnMiLCJsb2NhdGlvbnMiLCJNYXRoIiwibWF4Iiwic2xpY2UiLCJsb2MiLCJwbGFjZVR5cGUiLCJnZXRMb2NhdGlvbk5hbWVGcm9tQ29vcmRpbmF0ZXMiLCJ0b0ZpeGVkIiwiY29vcmRzIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwicGxhY2VJdGVtIiwiY29udGV4dCIsImZpbmQiLCJpdGVtIiwiaWQiLCJzdGFydHNXaXRoIiwicmVnaW9uSXRlbSIsInRleHQiLCJwb3N0YWxDb2RlVG9Db29yZGluYXRlcyIsInBvc3RhbENvZGUiLCJlcnJUZXh0IiwicmVzdWx0IiwiYWRkcmVzc01hdGNoZXMiLCJjb29yZGluYXRlcyIsInkiLCJ4Iiwid2FybiIsImV4dHJhY3RDb3VudHJ5RnJvbUZlYXR1cmUiLCJjb3VudHJ5Q29udGV4dCIsImMiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./lib/services/MapboxService.ts\n"));

/***/ })

});
"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_pages-dir-browser_components_tracking_map_AircraftTrackingMap_tsx",{

/***/ "(pages-dir-browser)/./components/tracking/hooks/useFilterLogic.ts":
/*!*****************************************************!*\
  !*** ./components/tracking/hooks/useFilterLogic.ts ***!
  \*****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useFilterLogic: () => (/* binding */ useFilterLogic)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _types_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/types/base */ \"(pages-dir-browser)/./types/base.ts\");\n/* harmony import */ var _context_EnhancedMapContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../context/EnhancedMapContext */ \"(pages-dir-browser)/./components/tracking/context/EnhancedMapContext.tsx\");\n/* harmony import */ var _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/services/openSkyTrackingService */ \"(pages-dir-browser)/./lib/services/openSkyTrackingService.ts\");\n/* harmony import */ var _lib_services_MapboxService__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../lib/services/MapboxService */ \"(pages-dir-browser)/./lib/services/MapboxService.ts\");\n/* harmony import */ var _lib_utils_geofenceAdapter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/lib/utils/geofenceAdapter */ \"(pages-dir-browser)/./lib/utils/geofenceAdapter.ts\");\n/* harmony import */ var _lib_utils_geofenceEnricher__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/lib/utils/geofenceEnricher */ \"(pages-dir-browser)/./lib/utils/geofenceEnricher.ts\");\n/* harmony import */ var _hooks_useGeolocationServices__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../hooks/useGeolocationServices */ \"(pages-dir-browser)/./components/tracking/hooks/useGeolocationServices.ts\");\n/* harmony import */ var _lib_services_geofencing__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../lib/services/geofencing */ \"(pages-dir-browser)/./lib/services/geofencing.ts\");\n/* harmony import */ var _hooks_useGeolocation__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../hooks/useGeolocation */ \"(pages-dir-browser)/./components/tracking/hooks/useGeolocation.ts\");\n/* harmony import */ var _config_map__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../config/map */ \"(pages-dir-browser)/./config/map.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\nfunction useFilterLogic() {\n    // Get context state and functions\n    const { selectedManufacturer, selectedModel, totalActive, selectManufacturer, selectModel, reset, fullRefresh, refreshPositions, mapInstance, updateAircraftData, clearGeofenceData, updateGeofenceAircraft, blockManufacturerApiCalls, setBlockManufacturerApiCalls, isManufacturerApiBlocked, setIsManufacturerApiBlocked, geofenceCenter, setGeofenceCenter, toggleGeofence, clearGeofence, displayedAircraft } = (0,_context_EnhancedMapContext__WEBPACK_IMPORTED_MODULE_2__.useEnhancedMapContext)();\n    // Use our combined geolocation services hook\n    const geolocationServices = (0,_hooks_useGeolocationServices__WEBPACK_IMPORTED_MODULE_7__.useGeolocationServices)();\n    // Local state\n    const [localLoading, setLocalLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [filterMode, setFilterMode] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [activeDropdown, setActiveDropdown] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [manufacturerSearchTerm, setManufacturerSearchTerm] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)('');\n    const [isRefreshing, setIsRefreshing] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [isRateLimited, setIsRateLimited] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [rateLimitTimer, setRateLimitTimer] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    // Geofence state\n    const [isGettingLocation, setIsGettingLocation] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [geofenceLocation, setGeofenceLocation] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)('');\n    const [geofenceRadius, setGeofenceRadius] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(25);\n    const [geofenceCoordinates, setGeofenceCoordinates] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [geofenceAircraft, setGeofenceAircraft] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [geofenceEnabled, setGeofenceEnabled] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [isGeofenceActive, setIsGeofenceActive] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [isSearchReady, setIsSearchReady] = react__WEBPACK_IMPORTED_MODULE_0___default().useState(false);\n    // Region state\n    const [activeRegion, setActiveRegion] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [regionOutline, setRegionOutline] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [selectedRegion, setSelectedRegion] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(_types_base__WEBPACK_IMPORTED_MODULE_1__.RegionCode.GLOBAL);\n    // Combined mode state\n    const [combinedModeReady, setCombinedModeReady] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    // Owner filter state\n    const allOwnerTypes = [\n        'individual',\n        'partnership',\n        'corp-owner',\n        'co-owned',\n        'llc',\n        'non-citizen-corp',\n        'airline',\n        'freight',\n        'medical',\n        'media',\n        'historical',\n        'flying-club',\n        'emergency',\n        'local-govt',\n        'education',\n        'federal-govt',\n        'flight-school',\n        'leasing-corp',\n        'military',\n        'unknown'\n    ];\n    const [ownerFilters, setOwnerFilters] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([\n        ...allOwnerTypes\n    ]);\n    // Refs for dropdown handling\n    const dropdownRefs = {\n        filter: (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),\n        manufacturer: (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),\n        model: (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),\n        location: (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),\n        region: (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),\n        owner: (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),\n        actions: (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null)\n    };\n    // Get geolocation hook - use the entire hook instance\n    const geolocation = (0,_hooks_useGeolocation__WEBPACK_IMPORTED_MODULE_9__.useGeolocation)(null);\n    // Geofence methods\n    // Fixed getUserLocation function to use the geolocation hook\n    const getUserLocation = async ()=>{\n        if (isRateLimited) {\n            alert(\"Rate limited. Please wait \".concat(rateLimitTimer || 30, \" seconds before trying to get location.\"));\n            return;\n        }\n        setIsGettingLocation(true);\n        try {\n            // Use the getCurrentPosition from our combined hook\n            const position = await geolocationServices.getCurrentPosition();\n            if (position) {\n                const { latitude, longitude } = position.coords;\n                // Update state with coordinates\n                setGeofenceCoordinates({\n                    lat: latitude,\n                    lng: longitude\n                });\n                setGeofenceCenter({\n                    lat: latitude,\n                    lng: longitude\n                });\n                // Update the location display with coordinates\n                setGeofenceLocation(\"\".concat(latitude.toFixed(6), \", \").concat(longitude.toFixed(6)));\n                // Automatically trigger the geofence search\n                try {\n                    const fetchedAircraft = await (0,_lib_services_geofencing__WEBPACK_IMPORTED_MODULE_8__.getAircraftNearLocation)(latitude, longitude, geofenceRadius);\n                    if (fetchedAircraft.length === 0) {\n                        alert(\"No aircraft found near your current location. Try increasing the radius.\");\n                        setIsGettingLocation(false);\n                        return;\n                    }\n                    // Process the aircraft data\n                    const adaptedAircraft = (0,_lib_utils_geofenceAdapter__WEBPACK_IMPORTED_MODULE_5__.adaptGeofenceAircraft)(fetchedAircraft);\n                    const enrichedAircraft = await (0,_lib_utils_geofenceEnricher__WEBPACK_IMPORTED_MODULE_6__.enrichGeofenceAircraft)(adaptedAircraft);\n                    // Save to local state\n                    setGeofenceAircraft(enrichedAircraft);\n                    // Clear existing aircraft data\n                    if (clearGeofenceData) {\n                        clearGeofenceData();\n                    }\n                    // Update the map with new aircraft\n                    updateGeofenceAircraft(enrichedAircraft);\n                    setIsGeofenceActive(true);\n                    // Center the map on user's location - SIMPLIFIED ZOOM LOGIC\n                    if (mapInstance) {\n                        // Don't modify zoom if it's already at an appropriate level\n                        const currentZoom = mapInstance.getZoom();\n                        const targetZoom = currentZoom <= 7 ? 9 : currentZoom;\n                        // Set the view directly to the user's location\n                        mapInstance.setView([\n                            latitude,\n                            longitude\n                        ], targetZoom);\n                        // Make sure the map reflects changes\n                        mapInstance.invalidateSize();\n                    }\n                    // If in geofence mode, ensure the filter mode is set correctly\n                    if (filterMode !== 'geofence' && filterMode !== 'both') {\n                        setFilterMode('geofence');\n                    }\n                } catch (error) {\n                    var _error_message;\n                    if (((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes('rate limit')) || error.status === 429) {\n                        handleRateLimit(30);\n                        // Still update the location even if we couldn't get aircraft\n                        if (mapInstance) {\n                            mapInstance.setView([\n                                latitude,\n                                longitude\n                            ], 9);\n                            mapInstance.invalidateSize();\n                        }\n                    } else {\n                        throw error;\n                    }\n                }\n                // Close the dropdown after selection\n                setActiveDropdown(null);\n            }\n        } catch (error) {\n            console.error('Error getting user location:', error);\n            alert('Unable to access your location. Please make sure location services are enabled in your browser.');\n        } finally{\n            setIsGettingLocation(false);\n        }\n    };\n    const processGeofenceSearch = async ()=>{\n        if (!geofenceLocation) return;\n        // Check if rate limited\n        if (isRateLimited) {\n            alert(\"Rate limited. Please wait \".concat(rateLimitTimer || 30, \" seconds before searching again.\"));\n            return;\n        }\n        // Block API calls while doing geofence search in combined mode\n        if (filterMode === 'both') {\n            _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].setBlockAllApiCalls(true);\n            setBlockManufacturerApiCalls(true);\n        }\n        // Set loading state\n        setLocalLoading(true);\n        try {\n            console.log('Searching for aircraft near location: \"'.concat(geofenceLocation, '\"'));\n            // This will handle Postal codes, place names, addresses, POIs, etc.\n            let fetchedAircraft;\n            try {\n                fetchedAircraft = await (0,_lib_services_geofencing__WEBPACK_IMPORTED_MODULE_8__.getAircraftNearSearchedLocation)(geofenceLocation, geofenceRadius);\n            } catch (error) {\n                var _error_message;\n                if (((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes('rate limit')) || error.status === 429) {\n                    const retryAfter = 30; // Default to 30 seconds if not specified\n                    handleRateLimit(retryAfter);\n                    setLocalLoading(false);\n                    return;\n                }\n                throw error;\n            }\n            // Get coordinates for the map\n            let locations;\n            try {\n                locations = await _lib_services_MapboxService__WEBPACK_IMPORTED_MODULE_4__.MapboxService.searchLocationWithMapbox(geofenceLocation, 1);\n            } catch (error) {\n                console.error('Error searching location with Mapbox:', error);\n                // Continue with aircraft data if available\n                locations = [];\n            }\n            let coordinates = null;\n            if (locations.length > 0) {\n                coordinates = {\n                    lat: locations[0].lat,\n                    lng: locations[0].lng\n                };\n                // Save the formatted location name\n                setGeofenceLocation(locations[0].name);\n            } else if (fetchedAircraft.length > 0 && fetchedAircraft[0].latitude && fetchedAircraft[0].longitude) {\n                // Fallback to first aircraft position\n                coordinates = {\n                    lat: fetchedAircraft[0].latitude,\n                    lng: fetchedAircraft[0].longitude\n                };\n            }\n            if (fetchedAircraft.length === 0) {\n                alert(\"No aircraft found near \".concat(geofenceLocation, \". Try increasing the radius or searching in a different area.\"));\n                setLocalLoading(false);\n                return;\n            }\n            // Update state with the coordinates\n            if (coordinates) {\n                setGeofenceCoordinates(coordinates);\n                setGeofenceCenter(coordinates);\n                setGeofenceRadius(geofenceRadius);\n            }\n            if (!isGeofenceActive) {\n                toggleGeofence();\n            } else if (!coordinates) {\n                throw new Error('Could not determine coordinates for the location');\n            }\n            console.log(\"Found \".concat(fetchedAircraft.length, \" aircraft in the area, preparing for display...\"));\n            // Ensure the data is in the right format\n            const adaptedAircraft = fetchedAircraft[0].MANUFACTURER !== undefined ? fetchedAircraft // Already in the right format\n             : (0,_lib_utils_geofenceAdapter__WEBPACK_IMPORTED_MODULE_5__.adaptGeofenceAircraft)(fetchedAircraft); // Needs adaptation\n            // Enrich with static data\n            console.log('Enriching geofence aircraft with static data...');\n            const enrichedAircraft = await (0,_lib_utils_geofenceEnricher__WEBPACK_IMPORTED_MODULE_6__.enrichGeofenceAircraft)(adaptedAircraft);\n            // Save the FULL set to local state\n            setGeofenceAircraft(enrichedAircraft);\n            setIsGeofenceActive(true);\n            // Clear existing aircraft data\n            if (clearGeofenceData) {\n                clearGeofenceData();\n            }\n            // If we're in combined mode and have a manufacturer, apply the combined filter\n            if (filterMode === 'both' && selectedManufacturer) {\n                // Make sure API calls remain blocked\n                _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].setBlockAllApiCalls(true);\n                setBlockManufacturerApiCalls(true);\n                setTimeout(()=>{\n                    applyCombinedFilters();\n                }, 100);\n            } else {\n                // Just show all aircraft in the geofence\n                updateGeofenceAircraft(enrichedAircraft);\n                // Center the map - SIMPLIFIED ZOOM LOGIC\n                if (mapInstance && coordinates) {\n                    // Get current zoom level\n                    const currentZoom = mapInstance.getZoom();\n                    // Use appropriate zoom level based on current view\n                    const targetZoom = currentZoom <= 7 ? 9 : currentZoom;\n                    // Set view to the coordinates\n                    mapInstance.setView([\n                        coordinates.lat,\n                        coordinates.lng\n                    ], targetZoom);\n                    // Ensure map is updated\n                    mapInstance.invalidateSize();\n                }\n            }\n            // Close dropdown after search\n            setActiveDropdown(null);\n        } catch (error) {\n            var _error_message1;\n            console.error('Error in geofence search:', error);\n            if (((_error_message1 = error.message) === null || _error_message1 === void 0 ? void 0 : _error_message1.includes('rate limit')) || error.status === 429) {\n                handleRateLimit(30);\n            } else {\n                alert(\"Error: \".concat(error instanceof Error ? error.message : 'Unknown error occurred'));\n            }\n        } finally{\n            setLocalLoading(false);\n        }\n    };\n    /**\r\n     * STEP 3: Fix toggleGeofenceState to better handle manually clicking the button\r\n     */ const toggleGeofenceState = (enabled)=>{\n        console.log('toggleGeofenceState called with:', enabled);\n        console.log('Current geofenceCoordinates:', geofenceCoordinates);\n        if (enabled) {\n            // Check if we have valid coordinates\n            if (geofenceCoordinates && typeof geofenceCoordinates.lat === 'number' && typeof geofenceCoordinates.lng === 'number' && !isNaN(geofenceCoordinates.lat) && !isNaN(geofenceCoordinates.lng)) {\n                console.log('Valid coordinates found, enabling geofence');\n                // Set flags first\n                setGeofenceEnabled(true);\n                setIsGeofenceActive(true);\n                // Call context toggle function if available\n                if (typeof toggleGeofence === 'function') {\n                    toggleGeofence();\n                }\n                // Display aircraft if we have them\n                if (geofenceAircraft && geofenceAircraft.length > 0) {\n                    console.log(\"Showing \".concat(geofenceAircraft.length, \" aircraft in geofence\"));\n                    updateGeofenceAircraft(geofenceAircraft);\n                } else {\n                    // No aircraft data yet, trigger a search\n                    console.log('No aircraft data yet, triggering search');\n                    setTimeout(()=>{\n                        processGeofenceSearch();\n                    }, 100);\n                }\n            } else {\n                // No valid coordinates\n                console.warn('No valid coordinates, showing alert');\n                alert('Please set a location before enabling geofence.\\n\\nClick anywhere on the map to set a location.');\n                setGeofenceEnabled(false);\n                setIsGeofenceActive(false);\n            }\n        } else {\n            // Disabling geofence\n            console.log('Disabling geofence');\n            setGeofenceEnabled(false);\n            setIsGeofenceActive(false);\n            // Clear geofence data if function available\n            if (typeof clearGeofenceData === 'function') {\n                clearGeofenceData();\n            }\n        }\n    };\n    // Effects\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect({\n        \"useFilterLogic.useEffect\": ()=>{\n            if (geofenceCoordinates) {\n                setIsSearchReady(true);\n            }\n        }\n    }[\"useFilterLogic.useEffect\"], [\n        geofenceCoordinates\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useFilterLogic.useEffect\": ()=>{\n            if (isRateLimited && rateLimitTimer) {\n                const timer = setTimeout({\n                    \"useFilterLogic.useEffect.timer\": ()=>{\n                        setIsRateLimited(false);\n                        setRateLimitTimer(null);\n                        console.log('Rate limit timer expired, resuming API calls');\n                    }\n                }[\"useFilterLogic.useEffect.timer\"], rateLimitTimer * 1000);\n                return ({\n                    \"useFilterLogic.useEffect\": ()=>clearTimeout(timer)\n                })[\"useFilterLogic.useEffect\"];\n            }\n        }\n    }[\"useFilterLogic.useEffect\"], [\n        isRateLimited,\n        rateLimitTimer\n    ]);\n    // Effect to sync geofence state\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useFilterLogic.useEffect\": ()=>{\n            // Update internal state when geofence is toggled externally\n            if (isGeofenceActive !== geofenceEnabled) {\n                setGeofenceEnabled(isGeofenceActive);\n            }\n        }\n    }[\"useFilterLogic.useEffect\"], [\n        isGeofenceActive\n    ]);\n    // Close dropdown when clicking outside\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useFilterLogic.useEffect\": ()=>{\n            const handleClickOutside = {\n                \"useFilterLogic.useEffect.handleClickOutside\": (event)=>{\n                    // Check if click is outside of all dropdowns\n                    const isOutsideAll = Object.values(dropdownRefs).every({\n                        \"useFilterLogic.useEffect.handleClickOutside.isOutsideAll\": (ref)=>!ref.current || !ref.current.contains(event.target)\n                    }[\"useFilterLogic.useEffect.handleClickOutside.isOutsideAll\"]);\n                    if (isOutsideAll) {\n                        setActiveDropdown(null);\n                    }\n                }\n            }[\"useFilterLogic.useEffect.handleClickOutside\"];\n            document.addEventListener('mousedown', handleClickOutside);\n            return ({\n                \"useFilterLogic.useEffect\": ()=>{\n                    document.removeEventListener('mousedown', handleClickOutside);\n                }\n            })[\"useFilterLogic.useEffect\"];\n        }\n    }[\"useFilterLogic.useEffect\"], []);\n    // Clean up region outline when component unmounts\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useFilterLogic.useEffect\": ()=>{\n            return ({\n                \"useFilterLogic.useEffect\": ()=>{\n                    if (regionOutline) {\n                        regionOutline.remove();\n                    }\n                }\n            })[\"useFilterLogic.useEffect\"];\n        }\n    }[\"useFilterLogic.useEffect\"], [\n        regionOutline\n    ]);\n    // Effect to handle map click for geofence\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useFilterLogic.useEffect\": ()=>{\n            const handleMapGeofenceClick = {\n                \"useFilterLogic.useEffect.handleMapGeofenceClick\": async (event)=>{\n                    try {\n                        // Cast the event to the proper type\n                        const customEvent = event;\n                        const { lat, lng } = customEvent.detail;\n                        // First update coordinates immediately\n                        setGeofenceCoordinates({\n                            lat,\n                            lng\n                        });\n                        // Then start an async operation to get the location name\n                        console.log(\"Getting location name for: \".concat(lat, \", \").concat(lng));\n                        // Temporarily show coordinates while fetching the name\n                        setGeofenceLocation(\"\".concat(lat.toFixed(6), \", \").concat(lng.toFixed(6)));\n                        // Get the friendly name asynchronously\n                        const locationName = await _lib_services_MapboxService__WEBPACK_IMPORTED_MODULE_4__.MapboxService.getLocationNameFromCoordinates(lat, lng);\n                        console.log(\"Got location name: \".concat(locationName));\n                        // Update with the friendly name once we have it\n                        if (locationName !== null) {\n                            setGeofenceLocation(locationName);\n                        }\n                        // Open the location dropdown if needed\n                        if (activeDropdown !== 'location') {\n                            setActiveDropdown('location');\n                        }\n                    } catch (error) {\n                        console.error('Error handling map click:', error);\n                    // Keep the coordinates display if there was an error\n                    }\n                }\n            }[\"useFilterLogic.useEffect.handleMapGeofenceClick\"];\n            // Add the event listener - use the standard event listener pattern\n            document.addEventListener('map-geofence-click', handleMapGeofenceClick);\n            // Clean up\n            return ({\n                \"useFilterLogic.useEffect\": ()=>{\n                    document.removeEventListener('map-geofence-click', handleMapGeofenceClick);\n                }\n            })[\"useFilterLogic.useEffect\"];\n        }\n    }[\"useFilterLogic.useEffect\"], [\n        setGeofenceLocation,\n        setGeofenceCoordinates,\n        setActiveDropdown,\n        activeDropdown\n    ]);\n    // Main methods\n    const toggleDropdown = (dropdown, event)=>{\n        if (activeDropdown === dropdown) {\n            setActiveDropdown(null);\n        } else {\n            setActiveDropdown(dropdown);\n        }\n        // Prevent events from bubbling up\n        event.stopPropagation();\n    };\n    const handleRateLimit = function() {\n        let retryAfter = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 30;\n        setIsRateLimited(true);\n        setRateLimitTimer(retryAfter);\n        console.log(\"Rate limited by API. Retry after \".concat(retryAfter, \"s\"));\n        // Block all API calls\n        _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].setBlockAllApiCalls(true);\n        setBlockManufacturerApiCalls(true);\n        // Show notification to user\n        if (retryAfter > 0) {\n            alert(\"Aircraft data refresh rate limited. Please wait \".concat(retryAfter, \" seconds before trying again.\"));\n        }\n    };\n    /**\r\n   * Toggle filter mode\r\n   */ const toggleFilterMode = (mode)=>{\n        setFilterMode(mode);\n        setActiveDropdown(null);\n        // Apply appropriate filters based on new mode\n        if (mode === 'region') {\n            // Block API calls in region mode\n            _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].setBlockAllApiCalls(true);\n            // Apply region filtering if we already have data\n            if (displayedAircraft && displayedAircraft.length > 0) {\n                filterAircraftByRegion(selectedRegion.toString());\n            }\n            // Clear manufacturer selection from the UI\n            selectManufacturer(null);\n            selectModel(null);\n            // If geofence is active, restore the full geofence data\n            if (geofenceCoordinates && geofenceAircraft.length > 0) {\n                updateGeofenceAircraft(geofenceAircraft);\n            }\n        } else if (mode === 'owner') {\n            // Filter displayed aircraft by owner type\n            if (displayedAircraft && displayedAircraft.length > 0) {\n                // First filter for valid coordinates\n                const aircraftWithValidCoords = displayedAircraft.filter((plane)=>typeof plane.latitude === 'number' && typeof plane.longitude === 'number' && !isNaN(plane.latitude) && !isNaN(plane.longitude));\n                // Apply owner type filter\n                let filteredByOwner = ownerFilters.length === 0 ? aircraftWithValidCoords : aircraftWithValidCoords.filter((aircraft)=>ownerFilters.includes(getAircraftOwnerType(aircraft)));\n                // Update display with filtered aircraft\n                if (clearGeofenceData) {\n                    clearGeofenceData();\n                }\n                updateGeofenceAircraft(filteredByOwner);\n            }\n        } else if (mode === 'both') {\n            // Both mode - BLOCK API CALLS\n            _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].setBlockAllApiCalls(true);\n            if (selectedManufacturer && isGeofenceActive && geofenceAircraft.length > 0) {\n                applyCombinedFilters();\n            } else {\n                // If one is missing, prompt the user\n                if (!selectedManufacturer && isGeofenceActive) {\n                    alert('Please select a manufacturer to use combined filter mode');\n                } else if (selectedManufacturer && !isGeofenceActive) {\n                    alert('Please set a location to use combined filter mode');\n                } else {\n                    alert('Please select both a manufacturer and location to use combined filter mode');\n                }\n            }\n        }\n    };\n    // Owner filter methods\n    const getAircraftOwnerType = (aircraft)=>{\n        const ownerType = aircraft.TYPE_REGISTRANT || 0;\n        return ownerTypeToString(ownerType);\n    };\n    const ownerTypeToString = (type)=>{\n        const typeNum = typeof type === 'string' ? parseInt(type, 10) : type;\n        const ownerTypeMap = {\n            1: 'individual',\n            2: 'partnership',\n            3: 'corp-owner',\n            4: 'co-owned',\n            7: 'llc',\n            8: 'non-citizen-corp',\n            9: 'airline',\n            10: 'freight',\n            11: 'medical',\n            12: 'media',\n            13: 'historical',\n            14: 'flying-club',\n            15: 'emergency',\n            16: 'local-govt',\n            17: 'education',\n            18: 'federal-govt',\n            19: 'flight-school',\n            20: 'leasing-corp',\n            21: 'military'\n        };\n        return ownerTypeMap[typeNum] || 'unknown';\n    };\n    const applyOwnerTypeFilter = (filters)=>{\n        // Skip filtering if all types are selected or none are selected\n        if (filters.length === 0 || filters.length === allOwnerTypes.length) {\n            return;\n        }\n        // Filter the aircraft based on selected owner types\n        if (displayedAircraft && displayedAircraft.length > 0) {\n            const filteredAircraft = displayedAircraft.filter((aircraft)=>{\n                const ownerType = getAircraftOwnerType(aircraft);\n                return filters.includes(ownerType);\n            });\n            // Update the displayed aircraft\n            if (clearGeofenceData) {\n                clearGeofenceData();\n            }\n            updateGeofenceAircraft(filteredAircraft);\n        }\n    };\n    const handleOwnerFilterChange = (updatedFilters)=>{\n        setOwnerFilters(updatedFilters);\n        // Apply the filter to your aircraft data\n        applyOwnerTypeFilter(updatedFilters);\n    };\n    const resetOwnerFilters = ()=>{\n        setOwnerFilters([\n            ...allOwnerTypes\n        ]);\n    };\n    // Region filter methods\n    const filterAircraftByRegion = (region)=>{\n        if (!displayedAircraft || displayedAircraft.length === 0) return;\n        setLocalLoading(true);\n        try {\n            // Get the bounds for the selected region\n            const boundsExpression = (0,_config_map__WEBPACK_IMPORTED_MODULE_10__.getBoundsByRegion)(region);\n            // Ensure bounds is in the correct format\n            if (!Array.isArray(boundsExpression) || boundsExpression.length !== 2) {\n                console.error(\"Invalid bounds format for region: \".concat(region), boundsExpression);\n                setLocalLoading(false);\n                return;\n            }\n            // Extract coordinates - Leaflet uses [lat, lng] format\n            const [[minLat, minLng], [maxLat, maxLng]] = boundsExpression;\n            console.log(\"Filtering by region: \".concat(region, \" with bounds:\"), {\n                minLat,\n                minLng,\n                maxLat,\n                maxLng\n            });\n            // Filter aircraft based on coordinates within the bounds\n            const filteredAircraft = displayedAircraft.filter((aircraft)=>{\n                // Check if aircraft has valid coordinates\n                if (typeof aircraft.latitude !== 'number' || typeof aircraft.longitude !== 'number' || isNaN(aircraft.latitude) || isNaN(aircraft.longitude)) {\n                    return false;\n                }\n                // Check if coordinates are within the bounds\n                return aircraft.latitude >= minLat && aircraft.latitude <= maxLat && aircraft.longitude >= minLng && aircraft.longitude <= maxLng;\n            });\n            // Update the display with filtered aircraft\n            if (clearGeofenceData) {\n                clearGeofenceData();\n            }\n            updateGeofenceAircraft(filteredAircraft);\n            console.log(\"Filtered to \".concat(filteredAircraft.length, \" aircraft in \").concat(region, \" region (out of \").concat(displayedAircraft.length, \" total)\"));\n        } catch (error) {\n            console.error('Error filtering aircraft by region:', error);\n        } finally{\n            setLocalLoading(false);\n        }\n    };\n    const handleRegionSelect = async (region)=>{\n        setActiveRegion(region);\n        setSelectedRegion(region);\n        setLocalLoading(true);\n        try {\n            // Set map bounds based on region\n            if (mapInstance) {\n                const bounds = (0,_config_map__WEBPACK_IMPORTED_MODULE_10__.getBoundsByRegion)(region);\n                // Get the appropriate zoom level for this region from your config\n                const zoomLevel = (0,_config_map__WEBPACK_IMPORTED_MODULE_10__.getZoomLevelForRegion)(region);\n                // First, set the appropriate zoom level\n                mapInstance.setZoom(zoomLevel);\n                // Then fit bounds with padding\n                const options = {\n                    padding: _config_map__WEBPACK_IMPORTED_MODULE_10__.MAP_CONFIG.PADDING.DEFAULT\n                };\n                mapInstance.fitBounds(bounds, options);\n                mapInstance.invalidateSize();\n                drawRegionOutline(region);\n            }\n            // Instead of immediately fetching aircraft data,\n            // just store the region selection for later use\n            console.log(\"Region selected. Waiting for manufacturer selection...\");\n            // Optionally, you could fetch just the count of aircraft in this region\n            // to give the user an idea of the data volume\n            const countResponse = await fetch(\"/api/tracking/region-count?region=\".concat(region));\n            if (countResponse.ok) {\n                const countData = await countResponse.json();\n                console.log(\"\".concat(countData.count, \" aircraft available in this region\"));\n            }\n            // Clear any previous aircraft data\n            if (clearGeofenceData) {\n                clearGeofenceData();\n            }\n        } catch (error) {\n            console.error('Error in region selection:', error);\n        } finally{\n            setLocalLoading(false);\n            setActiveDropdown(null);\n        }\n    };\n    const drawRegionOutline = (region)=>{\n        if (!mapInstance) return;\n        // Clear any existing outline\n        if (regionOutline) {\n            regionOutline.remove();\n        }\n        // Get the bounds for the selected region\n        const bounds = (0,_config_map__WEBPACK_IMPORTED_MODULE_10__.getBoundsByRegion)(region);\n        // Create a polygon from the bounds\n        const L = __webpack_require__(/*! leaflet */ \"(pages-dir-browser)/./node_modules/leaflet/dist/leaflet-src.js\");\n        const rectangle = L.rectangle(bounds, {\n            color: '#4f46e5',\n            weight: 3,\n            opacity: 0.7,\n            fill: true,\n            fillColor: '#4f46e5',\n            fillOpacity: 0.1,\n            dashArray: '5, 10',\n            interactive: false\n        });\n        // Add to map\n        rectangle.addTo(mapInstance);\n        // Update the state to include both the rectangle and the label\n        setRegionOutline({\n            remove: ()=>{\n                rectangle.remove();\n            }\n        });\n    };\n    // Manufacturer filter methods\n    const selectManufacturerAndClose = (value)=>{\n        // Close dropdown\n        setActiveDropdown(null);\n        setManufacturerSearchTerm('');\n        // If clearing the selection\n        if (value === '') {\n            selectManufacturer(null);\n            return;\n        }\n        // Set the manufacturer selection\n        selectManufacturer(value);\n        // If region is already selected, fetch filtered data\n        if (activeRegion !== null) {\n            fetchAircraftByRegionAndManufacturer(activeRegion, value);\n        } else {\n            // Otherwise, just proceed with manufacturer-only filtering as before\n            fetchManufacturerData(value);\n        }\n    };\n    const fetchManufacturerData = (manufacturer)=>{\n        if (isRateLimited) {\n            console.log(\"Skipping data fetch - rate limited for \".concat(rateLimitTimer, \"s\"));\n            return;\n        }\n        console.log(\"Fetching data for manufacturer: \".concat(manufacturer));\n        try {\n            // If you have a context function for this, call it after a slight delay\n            if (typeof refreshPositions === 'function') {\n                // Apply a small delay to prevent overwhelming the API\n                setTimeout(()=>{\n                    refreshPositions().catch((error)=>{\n                        var _error_message;\n                        if (((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes('rate limit')) || error.status === 429) {\n                            handleRateLimit(30);\n                        } else {\n                            console.error('Error fetching manufacturer data:', error);\n                        }\n                    });\n                }, 200);\n            }\n        } catch (error) {\n            var _error_message;\n            if (((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes('rate limit')) || error.status === 429) {\n                handleRateLimit(30);\n            } else {\n                console.error('Error scheduling manufacturer data fetch:', error);\n            }\n        }\n    };\n    const fetchAircraftByRegionAndManufacturer = async function(region, manufacturer) {\n        let page = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, limit = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 500;\n        if (!region || !manufacturer) {\n            console.log('Both region and manufacturer must be selected');\n            return;\n        }\n        setLocalLoading(true);\n        try {\n            const response = await fetch(\"/api/tracking/filtered-aircraft?region=\".concat(region, \"&manufacturer=\").concat(encodeURIComponent(manufacturer), \"&page=\").concat(page, \"&limit=\").concat(limit));\n            const data = await response.json();\n            const aircraftData = data.aircraft || [];\n            if (!response.ok) {\n                throw new Error(\"API error: \".concat(response.statusText));\n            }\n            // Process the filtered aircraft data\n            if (aircraftData.length > 0) {\n                const extendedAircraft = aircraftData.map((aircraft)=>{\n                    var _aircraft_OPERATOR;\n                    var _aircraft_OPERATOR_toLowerCase_includes;\n                    return {\n                        ...aircraft,\n                        type: aircraft.TYPE_AIRCRAFT || 'Unknown',\n                        isGovernment: (_aircraft_OPERATOR_toLowerCase_includes = (_aircraft_OPERATOR = aircraft.OPERATOR) === null || _aircraft_OPERATOR === void 0 ? void 0 : _aircraft_OPERATOR.toLowerCase().includes('government')) !== null && _aircraft_OPERATOR_toLowerCase_includes !== void 0 ? _aircraft_OPERATOR_toLowerCase_includes : false,\n                        REGION: aircraft.REGION,\n                        zoomLevel: undefined\n                    };\n                });\n                // Update the map\n                updateGeofenceAircraft(extendedAircraft);\n            } else {\n                console.log(\"No aircraft found for manufacturer \".concat(manufacturer, \" in region \").concat(region));\n            }\n        } catch (error) {\n            console.error('Error fetching filtered aircraft:', error);\n        } finally{\n            setLocalLoading(false);\n        }\n    };\n    // Model selection methods\n    const handleModelSelect = (value)=>{\n        selectModel(value === '' ? null : value);\n        setActiveDropdown(null);\n        // If in combined mode, reapply the filter\n        if (filterMode === 'both' && isGeofenceActive && selectedManufacturer) {\n            setTimeout(()=>{\n                applyCombinedFilters();\n            }, 100);\n        }\n    };\n    // Combined filter methods\n    const applyCombinedFilters = ()=>{\n        if (!selectedManufacturer || !isGeofenceActive || geofenceAircraft.length === 0) {\n            return;\n        }\n        setLocalLoading(true);\n        try {\n            console.log(\"Filtering \".concat(geofenceAircraft.length, \" aircraft by \").concat(selectedManufacturer));\n            // Filter the aircraft by manufacturer\n            let filteredAircraft = geofenceAircraft.filter((aircraft)=>{\n                var _aircraft_MANUFACTURER;\n                return ((_aircraft_MANUFACTURER = aircraft.MANUFACTURER) === null || _aircraft_MANUFACTURER === void 0 ? void 0 : _aircraft_MANUFACTURER.toLowerCase()) === selectedManufacturer.toLowerCase();\n            });\n            // Further filter by model if selected\n            if (selectedModel) {\n                filteredAircraft = filteredAircraft.filter((aircraft)=>{\n                    var _aircraft_MODEL;\n                    return ((_aircraft_MODEL = aircraft.MODEL) === null || _aircraft_MODEL === void 0 ? void 0 : _aircraft_MODEL.toLowerCase()) === selectedModel.toLowerCase();\n                });\n            }\n            console.log(\"Found \".concat(filteredAircraft.length, \" matching aircraft\"));\n            if (filteredAircraft.length === 0) {\n                alert(\"No \".concat(selectedManufacturer, \" aircraft found in this area.\"));\n                return;\n            }\n            // Clear display data\n            if (clearGeofenceData) {\n                clearGeofenceData();\n            }\n            // Update the display\n            updateGeofenceAircraft(filteredAircraft);\n        } catch (error) {\n            console.error('Error filtering aircraft:', error);\n        } finally{\n            setLocalLoading(false);\n        }\n    };\n    // Reset all filters\n    const clearAllFilters = ()=>{\n        console.log('Clearing all filters...');\n        // 1. Reset filter mode\n        setFilterMode('manufacturer');\n        // 2. Unblock API calls that might have been blocked\n        _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].setBlockAllApiCalls(false);\n        setBlockManufacturerApiCalls(false);\n        setIsManufacturerApiBlocked(false);\n        // 3. Clear manufacturer selection\n        selectManufacturer(null);\n        selectModel(null);\n        // 4. Clear geofence\n        setGeofenceLocation('');\n        setGeofenceCoordinates(null);\n        setGeofenceAircraft([]);\n        setGeofenceEnabled(false);\n        setIsGeofenceActive(false);\n        if (typeof clearGeofence === 'function') {\n            clearGeofence();\n        }\n        if (typeof clearGeofenceData === 'function') {\n            clearGeofenceData();\n        }\n        // 5. Reset owner filters to select all\n        setOwnerFilters([\n            ...allOwnerTypes\n        ]);\n        // 6. Clear region filter properly\n        setActiveRegion(null);\n        setSelectedRegion(_types_base__WEBPACK_IMPORTED_MODULE_1__.RegionCode.GLOBAL);\n        // Clear region outline from map\n        if (regionOutline) {\n            try {\n                // Handle different possible object structures\n                if (typeof regionOutline.remove === 'function') {\n                    regionOutline.remove();\n                } else if (regionOutline.rectangle && typeof regionOutline.rectangle.remove === 'function') {\n                    regionOutline.rectangle.remove();\n                }\n                // Clear any labels associated with the region\n                if (regionOutline.label && typeof regionOutline.label.remove === 'function') {\n                    regionOutline.label.remove();\n                }\n            } catch (error) {\n                console.error('Error removing region outline:', error);\n            }\n            // Always reset the region outline state\n            setRegionOutline(null);\n        }\n        // 7. Reset map view to global\n        if (mapInstance) {\n            // Use the predefined center and zoom level from your map config\n            mapInstance.setView(_config_map__WEBPACK_IMPORTED_MODULE_10__.MAP_CONFIG.CENTER, _config_map__WEBPACK_IMPORTED_MODULE_10__.MAP_CONFIG.DEFAULT_ZOOM);\n            mapInstance.invalidateSize();\n        }\n        // 8. Reset to initial aircraft data\n        if (typeof reset === 'function') {\n            reset();\n        } else if (typeof fullRefresh === 'function') {\n            fullRefresh();\n        }\n        // 9. Close any open dropdown\n        setActiveDropdown(null);\n        // 10. Reset rate limiting states\n        setIsRateLimited(false);\n        setRateLimitTimer(null);\n        // 11. Clear combined mode state\n        setCombinedModeReady(false);\n        // 12. Reset search terms\n        setManufacturerSearchTerm('');\n        // 13. Dispatch a custom event that other components can listen for\n        const clearEvent = new CustomEvent('ribbon-filters-cleared');\n        document.dispatchEvent(clearEvent);\n        console.log('All filters cleared successfully');\n    };\n    // Calculate combined loading state\n    const combinedLoading = localLoading;\n    return {\n        // State\n        filterMode,\n        activeDropdown,\n        selectedManufacturer,\n        selectedModel,\n        geofenceLocation,\n        geofenceRadius,\n        isGeofenceActive,\n        geofenceCoordinates,\n        getUserLocation,\n        activeRegion,\n        ownerFilters,\n        allOwnerTypes,\n        manufacturerSearchTerm,\n        combinedLoading,\n        isGettingLocation,\n        dropdownRefs,\n        localLoading,\n        isRateLimited,\n        selectedRegion,\n        isRefreshing,\n        isGeofencePlacementMode: false,\n        // Methods\n        toggleDropdown,\n        toggleFilterMode,\n        selectManufacturerAndClose,\n        handleModelSelect,\n        processGeofenceSearch,\n        handleOwnerFilterChange,\n        handleRegionSelect,\n        setManufacturerSearchTerm,\n        setGeofenceLocation,\n        setGeofenceRadius,\n        toggleGeofenceState,\n        clearAllFilters,\n        applyCombinedFilters,\n        getAircraftOwnerType,\n        setGeofenceCoordinates,\n        setGeofenceCenter,\n        updateGeofenceAircraft,\n        refreshWithFilters: ()=>{\n            // Implement refresh logic here\n            if (typeof refreshPositions === 'function') {\n                refreshPositions().catch((error)=>{\n                    console.error('Error refreshing positions:', error);\n                });\n            }\n        },\n        setActiveDropdown\n    };\n}\nfunction applyCombinedFilters() {\n    throw new Error('Function not implemented.');\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvdHJhY2tpbmcvaG9va3MvdXNlRmlsdGVyTG9naWMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFvRDtBQUMxQjtBQUNnQjtBQUU0QjtBQUNLO0FBQ1A7QUFDQTtBQUNFO0FBQ0c7QUFJL0I7QUFDZTtBQU01QjtBQTJCdEIsU0FBU2lCO0lBQ2Qsa0NBQWtDO0lBQ2xDLE1BQU0sRUFDSkMsb0JBQW9CLEVBQ3BCQyxhQUFhLEVBQ2JDLFdBQVcsRUFDWEMsa0JBQWtCLEVBQ2xCQyxXQUFXLEVBQ1hDLEtBQUssRUFDTEMsV0FBVyxFQUNYQyxnQkFBZ0IsRUFDaEJDLFdBQVcsRUFDWEMsa0JBQWtCLEVBQ2xCQyxpQkFBaUIsRUFDakJDLHNCQUFzQixFQUN0QkMseUJBQXlCLEVBQ3pCQyw0QkFBNEIsRUFDNUJDLHdCQUF3QixFQUN4QkMsMkJBQTJCLEVBQzNCQyxjQUFjLEVBQ2RDLGlCQUFpQixFQUNqQkMsY0FBYyxFQUNkQyxhQUFhLEVBQ2JDLGlCQUFpQixFQUNsQixHQUFHakMsa0ZBQXFCQTtJQUV6Qiw2Q0FBNkM7SUFDN0MsTUFBTWtDLHNCQUFzQjdCLHFGQUFzQkE7SUFFbEQsY0FBYztJQUNkLE1BQU0sQ0FBQzhCLGNBQWNDLGdCQUFnQixHQUFHekMsK0NBQVFBLENBQUM7SUFDakQsTUFBTSxDQUFDMEMsWUFBWUMsY0FBYyxHQUFHM0MsK0NBQVFBLENBQW9CO0lBQ2hFLE1BQU0sQ0FBQzRDLGdCQUFnQkMsa0JBQWtCLEdBQUc3QywrQ0FBUUEsQ0FBZ0I7SUFDcEUsTUFBTSxDQUFDOEMsd0JBQXdCQywwQkFBMEIsR0FBRy9DLCtDQUFRQSxDQUFDO0lBQ3JFLE1BQU0sQ0FBQ2dELGNBQWNDLGdCQUFnQixHQUFHakQsK0NBQVFBLENBQUM7SUFDakQsTUFBTSxDQUFDa0QsZUFBZUMsaUJBQWlCLEdBQUduRCwrQ0FBUUEsQ0FBQztJQUNuRCxNQUFNLENBQUNvRCxnQkFBZ0JDLGtCQUFrQixHQUFH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O1FBQ0EzSTtRQUNBVTtRQUNBRTtRQUNBc0U7UUFDQTBHO1FBQ0EzRztRQUNBcUM7UUFDQXhHO1FBQ0ExQjtRQUNBTjtRQUVBdU4sb0JBQW9CO1lBQ2xCLCtCQUErQjtZQUMvQixJQUFJLE9BQU8zTixxQkFBcUIsWUFBWTtnQkFDMUNBLG1CQUFtQmlNLEtBQUssQ0FBQyxDQUFDNUc7b0JBQ3hCSyxRQUFRTCxLQUFLLENBQUMsK0JBQStCQTtnQkFDL0M7WUFDRjtRQUNGO1FBQ0FqRTtJQUNGO0FBQ0Y7QUFFRixTQUFTbUY7SUFDUCxNQUFNLElBQUlKLE1BQU07QUFDbEIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcc2F0aG9cXERvY3VtZW50c1xcUHJvamVjdHNcXGFpcmNyYWZ0LXRyYWNraW5nXFxjb21wb25lbnRzXFx0cmFja2luZ1xcaG9va3NcXHVzZUZpbHRlckxvZ2ljLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVN0YXRlLCB1c2VSZWYsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgUmVnaW9uQ29kZSB9IGZyb20gJ0AvdHlwZXMvYmFzZSc7XHJcbmltcG9ydCB0eXBlIHsgRXh0ZW5kZWRBaXJjcmFmdCB9IGZyb20gJ0AvdHlwZXMvYmFzZSc7XHJcbmltcG9ydCB7IHVzZUVuaGFuY2VkTWFwQ29udGV4dCB9IGZyb20gJy4uL2NvbnRleHQvRW5oYW5jZWRNYXBDb250ZXh0JztcclxuaW1wb3J0IG9wZW5Ta3lUcmFja2luZ1NlcnZpY2UgZnJvbSAnQC9saWIvc2VydmljZXMvb3BlblNreVRyYWNraW5nU2VydmljZSc7XHJcbmltcG9ydCB7IE1hcGJveFNlcnZpY2UgfSBmcm9tICcuLi8uLi8uLi9saWIvc2VydmljZXMvTWFwYm94U2VydmljZSc7XHJcbmltcG9ydCB7IGFkYXB0R2VvZmVuY2VBaXJjcmFmdCB9IGZyb20gJ0AvbGliL3V0aWxzL2dlb2ZlbmNlQWRhcHRlcic7XHJcbmltcG9ydCB7IGVucmljaEdlb2ZlbmNlQWlyY3JhZnQgfSBmcm9tICdAL2xpYi91dGlscy9nZW9mZW5jZUVucmljaGVyJztcclxuaW1wb3J0IHsgdXNlR2VvbG9jYXRpb25TZXJ2aWNlcyB9IGZyb20gJy4uL2hvb2tzL3VzZUdlb2xvY2F0aW9uU2VydmljZXMnO1xyXG5pbXBvcnQge1xyXG4gIGdldEFpcmNyYWZ0TmVhckxvY2F0aW9uLFxyXG4gIGdldEFpcmNyYWZ0TmVhclNlYXJjaGVkTG9jYXRpb24sXHJcbn0gZnJvbSAnLi4vLi4vLi4vbGliL3NlcnZpY2VzL2dlb2ZlbmNpbmcnO1xyXG5pbXBvcnQgeyB1c2VHZW9sb2NhdGlvbiB9IGZyb20gJy4uL2hvb2tzL3VzZUdlb2xvY2F0aW9uJztcclxuXHJcbmltcG9ydCB7XHJcbiAgTUFQX0NPTkZJRyxcclxuICBnZXRCb3VuZHNCeVJlZ2lvbixcclxuICBnZXRab29tTGV2ZWxGb3JSZWdpb24sXHJcbn0gZnJvbSAnLi4vLi4vLi4vY29uZmlnL21hcCc7XHJcblxyXG5pbnRlcmZhY2UgRmlsdGVyTG9naWNSZXN1bHQge1xyXG4gIGdlb2ZlbmNlTG9jYXRpb246IHN0cmluZztcclxuICBnZW9mZW5jZVJhZGl1czogbnVtYmVyO1xyXG4gIGlzR2V0dGluZ0xvY2F0aW9uOiBib29sZWFuO1xyXG4gIGlzR2VvZmVuY2VBY3RpdmU6IGJvb2xlYW47XHJcbiAgZ2VvZmVuY2VDb29yZGluYXRlczogeyBsYXQ6IG51bWJlcjsgbG5nOiBudW1iZXIgfSB8IG51bGw7XHJcbiAgY29tYmluZWRMb2FkaW5nOiBib29sZWFuO1xyXG4gIHByb2Nlc3NHZW9mZW5jZVNlYXJjaDogKCkgPT4gdm9pZDtcclxuICB0b2dnbGVHZW9mZW5jZVN0YXRlOiAoYWN0aXZlOiBib29sZWFuKSA9PiB2b2lkO1xyXG4gIHNldEdlb2ZlbmNlTG9jYXRpb246IChsb2NhdGlvbjogc3RyaW5nKSA9PiB2b2lkO1xyXG4gIHNldEdlb2ZlbmNlUmFkaXVzOiAocmFkaXVzOiBudW1iZXIpID0+IHZvaWQ7XHJcbiAgc2V0R2VvZmVuY2VDb29yZGluYXRlczogKGNvb3JkczogeyBsYXQ6IG51bWJlcjsgbG5nOiBudW1iZXIgfSB8IG51bGwpID0+IHZvaWQ7XHJcbiAgc2V0R2VvZmVuY2VDZW50ZXI6IChjb29yZHM6IHsgbGF0OiBudW1iZXI7IGxuZzogbnVtYmVyIH0pID0+IHZvaWQ7XHJcbiAgdXBkYXRlR2VvZmVuY2VBaXJjcmFmdDogKGFpcmNyYWZ0OiBhbnlbXSkgPT4gdm9pZDtcclxufVxyXG5cclxudHlwZSBNYXBHZW9mZW5jZUNsaWNrRXZlbnQgPSBDdXN0b21FdmVudDx7IGxhdDogbnVtYmVyOyBsbmc6IG51bWJlciB9PjtcclxuXHJcbmV4cG9ydCB0eXBlIEZpbHRlck1vZGUgPVxyXG4gIHwgJ21hbnVmYWN0dXJlcidcclxuICB8ICdnZW9mZW5jZSdcclxuICB8ICdib3RoJ1xyXG4gIHwgJ293bmVyJ1xyXG4gIHwgJ3JlZ2lvbic7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlRmlsdGVyTG9naWMoKSB7XHJcbiAgLy8gR2V0IGNvbnRleHQgc3RhdGUgYW5kIGZ1bmN0aW9uc1xyXG4gIGNvbnN0IHtcclxuICAgIHNlbGVjdGVkTWFudWZhY3R1cmVyLFxyXG4gICAgc2VsZWN0ZWRNb2RlbCxcclxuICAgIHRvdGFsQWN0aXZlLFxyXG4gICAgc2VsZWN0TWFudWZhY3R1cmVyLFxyXG4gICAgc2VsZWN0TW9kZWwsXHJcbiAgICByZXNldCxcclxuICAgIGZ1bGxSZWZyZXNoLFxyXG4gICAgcmVmcmVzaFBvc2l0aW9ucyxcclxuICAgIG1hcEluc3RhbmNlLFxyXG4gICAgdXBkYXRlQWlyY3JhZnREYXRhLFxyXG4gICAgY2xlYXJHZW9mZW5jZURhdGEsXHJcbiAgICB1cGRhdGVHZW9mZW5jZUFpcmNyYWZ0LFxyXG4gICAgYmxvY2tNYW51ZmFjdHVyZXJBcGlDYWxscyxcclxuICAgIHNldEJsb2NrTWFudWZhY3R1cmVyQXBpQ2FsbHMsXHJcbiAgICBpc01hbnVmYWN0dXJlckFwaUJsb2NrZWQsXHJcbiAgICBzZXRJc01hbnVmYWN0dXJlckFwaUJsb2NrZWQsXHJcbiAgICBnZW9mZW5jZUNlbnRlcixcclxuICAgIHNldEdlb2ZlbmNlQ2VudGVyLFxyXG4gICAgdG9nZ2xlR2VvZmVuY2UsXHJcbiAgICBjbGVhckdlb2ZlbmNlLFxyXG4gICAgZGlzcGxheWVkQWlyY3JhZnQsXHJcbiAgfSA9IHVzZUVuaGFuY2VkTWFwQ29udGV4dCgpO1xyXG5cclxuICAvLyBVc2Ugb3VyIGNvbWJpbmVkIGdlb2xvY2F0aW9uIHNlcnZpY2VzIGhvb2tcclxuICBjb25zdCBnZW9sb2NhdGlvblNlcnZpY2VzID0gdXNlR2VvbG9jYXRpb25TZXJ2aWNlcygpO1xyXG5cclxuICAvLyBMb2NhbCBzdGF0ZVxyXG4gIGNvbnN0IFtsb2NhbExvYWRpbmcsIHNldExvY2FsTG9hZGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgY29uc3QgW2ZpbHRlck1vZGUsIHNldEZpbHRlck1vZGVdID0gdXNlU3RhdGU8RmlsdGVyTW9kZSB8IG51bGw+KG51bGwpO1xyXG4gIGNvbnN0IFthY3RpdmVEcm9wZG93biwgc2V0QWN0aXZlRHJvcGRvd25dID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XHJcbiAgY29uc3QgW21hbnVmYWN0dXJlclNlYXJjaFRlcm0sIHNldE1hbnVmYWN0dXJlclNlYXJjaFRlcm1dID0gdXNlU3RhdGUoJycpO1xyXG4gIGNvbnN0IFtpc1JlZnJlc2hpbmcsIHNldElzUmVmcmVzaGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgY29uc3QgW2lzUmF0ZUxpbWl0ZWQsIHNldElzUmF0ZUxpbWl0ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gIGNvbnN0IFtyYXRlTGltaXRUaW1lciwgc2V0UmF0ZUxpbWl0VGltZXJdID0gdXNlU3RhdGU8bnVtYmVyIHwgbnVsbD4obnVsbCk7XHJcblxyXG4gIC8vIEdlb2ZlbmNlIHN0YXRlXHJcbiAgY29uc3QgW2lzR2V0dGluZ0xvY2F0aW9uLCBzZXRJc0dldHRpbmdMb2NhdGlvbl0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgY29uc3QgW2dlb2ZlbmNlTG9jYXRpb24sIHNldEdlb2ZlbmNlTG9jYXRpb25dID0gdXNlU3RhdGU8c3RyaW5nPignJyk7XHJcbiAgY29uc3QgW2dlb2ZlbmNlUmFkaXVzLCBzZXRHZW9mZW5jZVJhZGl1c10gPSB1c2VTdGF0ZTxudW1iZXI+KDI1KTtcclxuICBjb25zdCBbZ2VvZmVuY2VDb29yZGluYXRlcywgc2V0R2VvZmVuY2VDb29yZGluYXRlc10gPSB1c2VTdGF0ZTx7XHJcbiAgICBsYXQ6IG51bWJlcjtcclxuICAgIGxuZzogbnVtYmVyO1xyXG4gIH0gfCBudWxsPihudWxsKTtcclxuICBjb25zdCBbZ2VvZmVuY2VBaXJjcmFmdCwgc2V0R2VvZmVuY2VBaXJjcmFmdF0gPSB1c2VTdGF0ZTxFeHRlbmRlZEFpcmNyYWZ0W10+KFxyXG4gICAgW11cclxuICApO1xyXG4gIGNvbnN0IFtnZW9mZW5jZUVuYWJsZWQsIHNldEdlb2ZlbmNlRW5hYmxlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgY29uc3QgW2lzR2VvZmVuY2VBY3RpdmUsIHNldElzR2VvZmVuY2VBY3RpdmVdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gIGNvbnN0IFtpc1NlYXJjaFJlYWR5LCBzZXRJc1NlYXJjaFJlYWR5XSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcclxuXHJcbiAgLy8gUmVnaW9uIHN0YXRlXHJcbiAgY29uc3QgW2FjdGl2ZVJlZ2lvbiwgc2V0QWN0aXZlUmVnaW9uXSA9IHVzZVN0YXRlPFJlZ2lvbkNvZGUgfCBzdHJpbmcgfCBudWxsPihcclxuICAgIG51bGxcclxuICApO1xyXG4gIGNvbnN0IFtyZWdpb25PdXRsaW5lLCBzZXRSZWdpb25PdXRsaW5lXSA9IHVzZVN0YXRlPGFueT4obnVsbCk7XHJcbiAgY29uc3QgW3NlbGVjdGVkUmVnaW9uLCBzZXRTZWxlY3RlZFJlZ2lvbl0gPSB1c2VTdGF0ZTxudW1iZXI+KFxyXG4gICAgUmVnaW9uQ29kZS5HTE9CQUxcclxuICApO1xyXG5cclxuICAvLyBDb21iaW5lZCBtb2RlIHN0YXRlXHJcbiAgY29uc3QgW2NvbWJpbmVkTW9kZVJlYWR5LCBzZXRDb21iaW5lZE1vZGVSZWFkeV0gPSB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XHJcblxyXG4gIC8vIE93bmVyIGZpbHRlciBzdGF0ZVxyXG4gIGNvbnN0IGFsbE93bmVyVHlwZXMgPSBbXHJcbiAgICAnaW5kaXZpZHVhbCcsXHJcbiAgICAncGFydG5lcnNoaXAnLFxyXG4gICAgJ2NvcnAtb3duZXInLFxyXG4gICAgJ2NvLW93bmVkJyxcclxuICAgICdsbGMnLFxyXG4gICAgJ25vbi1jaXRpemVuLWNvcnAnLFxyXG4gICAgJ2FpcmxpbmUnLFxyXG4gICAgJ2ZyZWlnaHQnLFxyXG4gICAgJ21lZGljYWwnLFxyXG4gICAgJ21lZGlhJyxcclxuICAgICdoaXN0b3JpY2FsJyxcclxuICAgICdmbHlpbmctY2x1YicsXHJcbiAgICAnZW1lcmdlbmN5JyxcclxuICAgICdsb2NhbC1nb3Z0JyxcclxuICAgICdlZHVjYXRpb24nLFxyXG4gICAgJ2ZlZGVyYWwtZ292dCcsXHJcbiAgICAnZmxpZ2h0LXNjaG9vbCcsXHJcbiAgICAnbGVhc2luZy1jb3JwJyxcclxuICAgICdtaWxpdGFyeScsXHJcbiAgICAndW5rbm93bicsXHJcbiAgXTtcclxuXHJcbiAgY29uc3QgW293bmVyRmlsdGVycywgc2V0T3duZXJGaWx0ZXJzXSA9IHVzZVN0YXRlPHN0cmluZ1tdPihbXHJcbiAgICAuLi5hbGxPd25lclR5cGVzLFxyXG4gIF0pO1xyXG5cclxuICAvLyBSZWZzIGZvciBkcm9wZG93biBoYW5kbGluZ1xyXG4gIGNvbnN0IGRyb3Bkb3duUmVmcyA9IHtcclxuICAgIGZpbHRlcjogdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKSxcclxuICAgIG1hbnVmYWN0dXJlcjogdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKSxcclxuICAgIG1vZGVsOiB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpLFxyXG4gICAgbG9jYXRpb246IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCksXHJcbiAgICByZWdpb246IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCksXHJcbiAgICBvd25lcjogdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKSxcclxuICAgIGFjdGlvbnM6IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCksXHJcbiAgfTtcclxuXHJcbiAgLy8gR2V0IGdlb2xvY2F0aW9uIGhvb2sgLSB1c2UgdGhlIGVudGlyZSBob29rIGluc3RhbmNlXHJcbiAgY29uc3QgZ2VvbG9jYXRpb24gPSB1c2VHZW9sb2NhdGlvbihudWxsKTtcclxuIFxyXG4gXHJcbiAvLyBHZW9mZW5jZSBtZXRob2RzXHJcbiAgLy8gRml4ZWQgZ2V0VXNlckxvY2F0aW9uIGZ1bmN0aW9uIHRvIHVzZSB0aGUgZ2VvbG9jYXRpb24gaG9va1xyXG5cclxuICAgIGNvbnN0IGdldFVzZXJMb2NhdGlvbiA9IGFzeW5jICgpID0+IHtcclxuICAgICAgaWYgKGlzUmF0ZUxpbWl0ZWQpIHtcclxuICAgICAgICBhbGVydChcclxuICAgICAgICAgIGBSYXRlIGxpbWl0ZWQuIFBsZWFzZSB3YWl0ICR7cmF0ZUxpbWl0VGltZXIgfHwgMzB9IHNlY29uZHMgYmVmb3JlIHRyeWluZyB0byBnZXQgbG9jYXRpb24uYFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzZXRJc0dldHRpbmdMb2NhdGlvbih0cnVlKTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICAvLyBVc2UgdGhlIGdldEN1cnJlbnRQb3NpdGlvbiBmcm9tIG91ciBjb21iaW5lZCBob29rXHJcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBhd2FpdCBnZW9sb2NhdGlvblNlcnZpY2VzLmdldEN1cnJlbnRQb3NpdGlvbigpO1xyXG5cclxuICAgICAgICBpZiAocG9zaXRpb24pIHtcclxuICAgICAgICAgIGNvbnN0IHsgbGF0aXR1ZGUsIGxvbmdpdHVkZSB9ID0gcG9zaXRpb24uY29vcmRzO1xyXG5cclxuICAgICAgICAgIC8vIFVwZGF0ZSBzdGF0ZSB3aXRoIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICBzZXRHZW9mZW5jZUNvb3JkaW5hdGVzKHsgbGF0OiBsYXRpdHVkZSwgbG5nOiBsb25naXR1ZGUgfSk7XHJcbiAgICAgICAgICBzZXRHZW9mZW5jZUNlbnRlcih7IGxhdDogbGF0aXR1ZGUsIGxuZzogbG9uZ2l0dWRlIH0pO1xyXG5cclxuICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgbG9jYXRpb24gZGlzcGxheSB3aXRoIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICBzZXRHZW9mZW5jZUxvY2F0aW9uKFxyXG4gICAgICAgICAgICBgJHtsYXRpdHVkZS50b0ZpeGVkKDYpfSwgJHtsb25naXR1ZGUudG9GaXhlZCg2KX1gXHJcbiAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgIC8vIEF1dG9tYXRpY2FsbHkgdHJpZ2dlciB0aGUgZ2VvZmVuY2Ugc2VhcmNoXHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBmZXRjaGVkQWlyY3JhZnQgPSBhd2FpdCBnZXRBaXJjcmFmdE5lYXJMb2NhdGlvbihcclxuICAgICAgICAgICAgICBsYXRpdHVkZSxcclxuICAgICAgICAgICAgICBsb25naXR1ZGUsXHJcbiAgICAgICAgICAgICAgZ2VvZmVuY2VSYWRpdXNcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChmZXRjaGVkQWlyY3JhZnQubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgYWxlcnQoXHJcbiAgICAgICAgICAgICAgICBgTm8gYWlyY3JhZnQgZm91bmQgbmVhciB5b3VyIGN1cnJlbnQgbG9jYXRpb24uIFRyeSBpbmNyZWFzaW5nIHRoZSByYWRpdXMuYFxyXG4gICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgc2V0SXNHZXR0aW5nTG9jYXRpb24oZmFsc2UpO1xyXG4gICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUHJvY2VzcyB0aGUgYWlyY3JhZnQgZGF0YVxyXG4gICAgICAgICAgICBjb25zdCBhZGFwdGVkQWlyY3JhZnQgPSBhZGFwdEdlb2ZlbmNlQWlyY3JhZnQoZmV0Y2hlZEFpcmNyYWZ0KTtcclxuICAgICAgICAgICAgY29uc3QgZW5yaWNoZWRBaXJjcmFmdCA9XHJcbiAgICAgICAgICAgICAgYXdhaXQgZW5yaWNoR2VvZmVuY2VBaXJjcmFmdChhZGFwdGVkQWlyY3JhZnQpO1xyXG5cclxuICAgICAgICAgICAgLy8gU2F2ZSB0byBsb2NhbCBzdGF0ZVxyXG4gICAgICAgICAgICBzZXRHZW9mZW5jZUFpcmNyYWZ0KGVucmljaGVkQWlyY3JhZnQpO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2xlYXIgZXhpc3RpbmcgYWlyY3JhZnQgZGF0YVxyXG4gICAgICAgICAgICBpZiAoY2xlYXJHZW9mZW5jZURhdGEpIHtcclxuICAgICAgICAgICAgICBjbGVhckdlb2ZlbmNlRGF0YSgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIG1hcCB3aXRoIG5ldyBhaXJjcmFmdFxyXG4gICAgICAgICAgICB1cGRhdGVHZW9mZW5jZUFpcmNyYWZ0KGVucmljaGVkQWlyY3JhZnQpO1xyXG4gICAgICAgICAgICBzZXRJc0dlb2ZlbmNlQWN0aXZlKHRydWUpO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2VudGVyIHRoZSBtYXAgb24gdXNlcidzIGxvY2F0aW9uIC0gU0lNUExJRklFRCBaT09NIExPR0lDXHJcbiAgICAgICAgICAgIGlmIChtYXBJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgIC8vIERvbid0IG1vZGlmeSB6b29tIGlmIGl0J3MgYWxyZWFkeSBhdCBhbiBhcHByb3ByaWF0ZSBsZXZlbFxyXG4gICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRab29tID0gbWFwSW5zdGFuY2UuZ2V0Wm9vbSgpO1xyXG4gICAgICAgICAgICAgIGNvbnN0IHRhcmdldFpvb20gPSBjdXJyZW50Wm9vbSA8PSA3ID8gOSA6IGN1cnJlbnRab29tO1xyXG5cclxuICAgICAgICAgICAgICAvLyBTZXQgdGhlIHZpZXcgZGlyZWN0bHkgdG8gdGhlIHVzZXIncyBsb2NhdGlvblxyXG4gICAgICAgICAgICAgIG1hcEluc3RhbmNlLnNldFZpZXcoW2xhdGl0dWRlLCBsb25naXR1ZGVdLCB0YXJnZXRab29tKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBtYXAgcmVmbGVjdHMgY2hhbmdlc1xyXG4gICAgICAgICAgICAgIG1hcEluc3RhbmNlLmludmFsaWRhdGVTaXplKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIElmIGluIGdlb2ZlbmNlIG1vZGUsIGVuc3VyZSB0aGUgZmlsdGVyIG1vZGUgaXMgc2V0IGNvcnJlY3RseVxyXG4gICAgICAgICAgICBpZiAoZmlsdGVyTW9kZSAhPT0gJ2dlb2ZlbmNlJyAmJiBmaWx0ZXJNb2RlICE9PSAnYm90aCcpIHtcclxuICAgICAgICAgICAgICBzZXRGaWx0ZXJNb2RlKCdnZW9mZW5jZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygncmF0ZSBsaW1pdCcpIHx8IGVycm9yLnN0YXR1cyA9PT0gNDI5KSB7XHJcbiAgICAgICAgICAgICAgaGFuZGxlUmF0ZUxpbWl0KDMwKTtcclxuICAgICAgICAgICAgICAvLyBTdGlsbCB1cGRhdGUgdGhlIGxvY2F0aW9uIGV2ZW4gaWYgd2UgY291bGRuJ3QgZ2V0IGFpcmNyYWZ0XHJcbiAgICAgICAgICAgICAgaWYgKG1hcEluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICBtYXBJbnN0YW5jZS5zZXRWaWV3KFtsYXRpdHVkZSwgbG9uZ2l0dWRlXSwgOSk7XHJcbiAgICAgICAgICAgICAgICBtYXBJbnN0YW5jZS5pbnZhbGlkYXRlU2l6ZSgpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIENsb3NlIHRoZSBkcm9wZG93biBhZnRlciBzZWxlY3Rpb25cclxuICAgICAgICAgIHNldEFjdGl2ZURyb3Bkb3duKG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHVzZXIgbG9jYXRpb246JywgZXJyb3IpO1xyXG4gICAgICAgIGFsZXJ0KFxyXG4gICAgICAgICAgJ1VuYWJsZSB0byBhY2Nlc3MgeW91ciBsb2NhdGlvbi4gUGxlYXNlIG1ha2Ugc3VyZSBsb2NhdGlvbiBzZXJ2aWNlcyBhcmUgZW5hYmxlZCBpbiB5b3VyIGJyb3dzZXIuJ1xyXG4gICAgICAgICk7XHJcbiAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgc2V0SXNHZXR0aW5nTG9jYXRpb24oZmFsc2UpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIFxyXG4gICAgY29uc3QgcHJvY2Vzc0dlb2ZlbmNlU2VhcmNoID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICBpZiAoIWdlb2ZlbmNlTG9jYXRpb24pIHJldHVybjtcclxuXHJcbiAgICAgIC8vIENoZWNrIGlmIHJhdGUgbGltaXRlZFxyXG4gICAgICBpZiAoaXNSYXRlTGltaXRlZCkge1xyXG4gICAgICAgIGFsZXJ0KFxyXG4gICAgICAgICAgYFJhdGUgbGltaXRlZC4gUGxlYXNlIHdhaXQgJHtyYXRlTGltaXRUaW1lciB8fCAzMH0gc2Vjb25kcyBiZWZvcmUgc2VhcmNoaW5nIGFnYWluLmBcclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQmxvY2sgQVBJIGNhbGxzIHdoaWxlIGRvaW5nIGdlb2ZlbmNlIHNlYXJjaCBpbiBjb21iaW5lZCBtb2RlXHJcbiAgICAgIGlmIChmaWx0ZXJNb2RlID09PSAnYm90aCcpIHtcclxuICAgICAgICBvcGVuU2t5VHJhY2tpbmdTZXJ2aWNlLnNldEJsb2NrQWxsQXBpQ2FsbHModHJ1ZSk7XHJcbiAgICAgICAgc2V0QmxvY2tNYW51ZmFjdHVyZXJBcGlDYWxscyh0cnVlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gU2V0IGxvYWRpbmcgc3RhdGVcclxuICAgICAgc2V0TG9jYWxMb2FkaW5nKHRydWUpO1xyXG5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgIGBTZWFyY2hpbmcgZm9yIGFpcmNyYWZ0IG5lYXIgbG9jYXRpb246IFwiJHtnZW9mZW5jZUxvY2F0aW9ufVwiYFxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIC8vIFRoaXMgd2lsbCBoYW5kbGUgUG9zdGFsIGNvZGVzLCBwbGFjZSBuYW1lcywgYWRkcmVzc2VzLCBQT0lzLCBldGMuXHJcbiAgICAgICAgbGV0IGZldGNoZWRBaXJjcmFmdDtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgZmV0Y2hlZEFpcmNyYWZ0ID0gYXdhaXQgZ2V0QWlyY3JhZnROZWFyU2VhcmNoZWRMb2NhdGlvbihcclxuICAgICAgICAgICAgZ2VvZmVuY2VMb2NhdGlvbixcclxuICAgICAgICAgICAgZ2VvZmVuY2VSYWRpdXNcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCdyYXRlIGxpbWl0JykgfHwgZXJyb3Iuc3RhdHVzID09PSA0MjkpIHtcclxuICAgICAgICAgICAgY29uc3QgcmV0cnlBZnRlciA9IDMwOyAvLyBEZWZhdWx0IHRvIDMwIHNlY29uZHMgaWYgbm90IHNwZWNpZmllZFxyXG4gICAgICAgICAgICBoYW5kbGVSYXRlTGltaXQocmV0cnlBZnRlcik7XHJcbiAgICAgICAgICAgIHNldExvY2FsTG9hZGluZyhmYWxzZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gR2V0IGNvb3JkaW5hdGVzIGZvciB0aGUgbWFwXHJcbiAgICAgICAgbGV0IGxvY2F0aW9uczogeyBsYXQ6IG51bWJlcjsgbG5nOiBudW1iZXI7IG5hbWU6IHN0cmluZyB9W107XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGxvY2F0aW9ucyA9IGF3YWl0IE1hcGJveFNlcnZpY2Uuc2VhcmNoTG9jYXRpb25XaXRoTWFwYm94KFxyXG4gICAgICAgICAgICBnZW9mZW5jZUxvY2F0aW9uLFxyXG4gICAgICAgICAgICAxXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzZWFyY2hpbmcgbG9jYXRpb24gd2l0aCBNYXBib3g6JywgZXJyb3IpO1xyXG4gICAgICAgICAgLy8gQ29udGludWUgd2l0aCBhaXJjcmFmdCBkYXRhIGlmIGF2YWlsYWJsZVxyXG4gICAgICAgICAgbG9jYXRpb25zID0gW107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgY29vcmRpbmF0ZXM6IHsgbGF0OiBudW1iZXI7IGxuZzogbnVtYmVyIH0gfCBudWxsID0gbnVsbDtcclxuXHJcbiAgICAgICAgaWYgKGxvY2F0aW9ucy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICBjb29yZGluYXRlcyA9IHtcclxuICAgICAgICAgICAgbGF0OiBsb2NhdGlvbnNbMF0ubGF0LFxyXG4gICAgICAgICAgICBsbmc6IGxvY2F0aW9uc1swXS5sbmcsXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgLy8gU2F2ZSB0aGUgZm9ybWF0dGVkIGxvY2F0aW9uIG5hbWVcclxuICAgICAgICAgIHNldEdlb2ZlbmNlTG9jYXRpb24obG9jYXRpb25zWzBdLm5hbWUpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgICAgICBmZXRjaGVkQWlyY3JhZnQubGVuZ3RoID4gMCAmJlxyXG4gICAgICAgICAgZmV0Y2hlZEFpcmNyYWZ0WzBdLmxhdGl0dWRlICYmXHJcbiAgICAgICAgICBmZXRjaGVkQWlyY3JhZnRbMF0ubG9uZ2l0dWRlXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAvLyBGYWxsYmFjayB0byBmaXJzdCBhaXJjcmFmdCBwb3NpdGlvblxyXG4gICAgICAgICAgY29vcmRpbmF0ZXMgPSB7XHJcbiAgICAgICAgICAgIGxhdDogZmV0Y2hlZEFpcmNyYWZ0WzBdLmxhdGl0dWRlLFxyXG4gICAgICAgICAgICBsbmc6IGZldGNoZWRBaXJjcmFmdFswXS5sb25naXR1ZGUsXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGZldGNoZWRBaXJjcmFmdC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgIGFsZXJ0KFxyXG4gICAgICAgICAgICBgTm8gYWlyY3JhZnQgZm91bmQgbmVhciAke2dlb2ZlbmNlTG9jYXRpb259LiBUcnkgaW5jcmVhc2luZyB0aGUgcmFkaXVzIG9yIHNlYXJjaGluZyBpbiBhIGRpZmZlcmVudCBhcmVhLmBcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICBzZXRMb2NhbExvYWRpbmcoZmFsc2UpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIHN0YXRlIHdpdGggdGhlIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgaWYgKGNvb3JkaW5hdGVzKSB7XHJcbiAgICAgICAgICBzZXRHZW9mZW5jZUNvb3JkaW5hdGVzKGNvb3JkaW5hdGVzKTtcclxuICAgICAgICAgIHNldEdlb2ZlbmNlQ2VudGVyKGNvb3JkaW5hdGVzKTtcclxuICAgICAgICAgIHNldEdlb2ZlbmNlUmFkaXVzKGdlb2ZlbmNlUmFkaXVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpc0dlb2ZlbmNlQWN0aXZlKSB7XHJcbiAgICAgICAgICB0b2dnbGVHZW9mZW5jZSgpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIWNvb3JkaW5hdGVzKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBkZXRlcm1pbmUgY29vcmRpbmF0ZXMgZm9yIHRoZSBsb2NhdGlvbicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICBgRm91bmQgJHtmZXRjaGVkQWlyY3JhZnQubGVuZ3RofSBhaXJjcmFmdCBpbiB0aGUgYXJlYSwgcHJlcGFyaW5nIGZvciBkaXNwbGF5Li4uYFxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIC8vIEVuc3VyZSB0aGUgZGF0YSBpcyBpbiB0aGUgcmlnaHQgZm9ybWF0XHJcbiAgICAgICAgY29uc3QgYWRhcHRlZEFpcmNyYWZ0ID1cclxuICAgICAgICAgIGZldGNoZWRBaXJjcmFmdFswXS5NQU5VRkFDVFVSRVIgIT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICA/IGZldGNoZWRBaXJjcmFmdCAvLyBBbHJlYWR5IGluIHRoZSByaWdodCBmb3JtYXRcclxuICAgICAgICAgICAgOiBhZGFwdEdlb2ZlbmNlQWlyY3JhZnQoZmV0Y2hlZEFpcmNyYWZ0KTsgLy8gTmVlZHMgYWRhcHRhdGlvblxyXG5cclxuICAgICAgICAvLyBFbnJpY2ggd2l0aCBzdGF0aWMgZGF0YVxyXG4gICAgICAgIGNvbnNvbGUubG9nKCdFbnJpY2hpbmcgZ2VvZmVuY2UgYWlyY3JhZnQgd2l0aCBzdGF0aWMgZGF0YS4uLicpO1xyXG4gICAgICAgIGNvbnN0IGVucmljaGVkQWlyY3JhZnQgPSBhd2FpdCBlbnJpY2hHZW9mZW5jZUFpcmNyYWZ0KGFkYXB0ZWRBaXJjcmFmdCk7XHJcblxyXG4gICAgICAgIC8vIFNhdmUgdGhlIEZVTEwgc2V0IHRvIGxvY2FsIHN0YXRlXHJcbiAgICAgICAgc2V0R2VvZmVuY2VBaXJjcmFmdChlbnJpY2hlZEFpcmNyYWZ0KTtcclxuICAgICAgICBzZXRJc0dlb2ZlbmNlQWN0aXZlKHRydWUpO1xyXG5cclxuICAgICAgICAvLyBDbGVhciBleGlzdGluZyBhaXJjcmFmdCBkYXRhXHJcbiAgICAgICAgaWYgKGNsZWFyR2VvZmVuY2VEYXRhKSB7XHJcbiAgICAgICAgICBjbGVhckdlb2ZlbmNlRGF0YSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSWYgd2UncmUgaW4gY29tYmluZWQgbW9kZSBhbmQgaGF2ZSBhIG1hbnVmYWN0dXJlciwgYXBwbHkgdGhlIGNvbWJpbmVkIGZpbHRlclxyXG4gICAgICAgIGlmIChmaWx0ZXJNb2RlID09PSAnYm90aCcgJiYgc2VsZWN0ZWRNYW51ZmFjdHVyZXIpIHtcclxuICAgICAgICAgIC8vIE1ha2Ugc3VyZSBBUEkgY2FsbHMgcmVtYWluIGJsb2NrZWRcclxuICAgICAgICAgIG9wZW5Ta3lUcmFja2luZ1NlcnZpY2Uuc2V0QmxvY2tBbGxBcGlDYWxscyh0cnVlKTtcclxuICAgICAgICAgIHNldEJsb2NrTWFudWZhY3R1cmVyQXBpQ2FsbHModHJ1ZSk7XHJcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgYXBwbHlDb21iaW5lZEZpbHRlcnMoKTtcclxuICAgICAgICAgIH0sIDEwMCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIEp1c3Qgc2hvdyBhbGwgYWlyY3JhZnQgaW4gdGhlIGdlb2ZlbmNlXHJcbiAgICAgICAgICB1cGRhdGVHZW9mZW5jZUFpcmNyYWZ0KGVucmljaGVkQWlyY3JhZnQpO1xyXG5cclxuICAgICAgICAgIC8vIENlbnRlciB0aGUgbWFwIC0gU0lNUExJRklFRCBaT09NIExPR0lDXHJcbiAgICAgICAgICBpZiAobWFwSW5zdGFuY2UgJiYgY29vcmRpbmF0ZXMpIHtcclxuICAgICAgICAgICAgLy8gR2V0IGN1cnJlbnQgem9vbSBsZXZlbFxyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50Wm9vbSA9IG1hcEluc3RhbmNlLmdldFpvb20oKTtcclxuICAgICAgICAgICAgLy8gVXNlIGFwcHJvcHJpYXRlIHpvb20gbGV2ZWwgYmFzZWQgb24gY3VycmVudCB2aWV3XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldFpvb20gPSBjdXJyZW50Wm9vbSA8PSA3ID8gOSA6IGN1cnJlbnRab29tO1xyXG5cclxuICAgICAgICAgICAgLy8gU2V0IHZpZXcgdG8gdGhlIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICAgIG1hcEluc3RhbmNlLnNldFZpZXcoW2Nvb3JkaW5hdGVzLmxhdCwgY29vcmRpbmF0ZXMubG5nXSwgdGFyZ2V0Wm9vbSk7XHJcblxyXG4gICAgICAgICAgICAvLyBFbnN1cmUgbWFwIGlzIHVwZGF0ZWRcclxuICAgICAgICAgICAgbWFwSW5zdGFuY2UuaW52YWxpZGF0ZVNpemUoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENsb3NlIGRyb3Bkb3duIGFmdGVyIHNlYXJjaFxyXG4gICAgICAgIHNldEFjdGl2ZURyb3Bkb3duKG51bGwpO1xyXG4gICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gZ2VvZmVuY2Ugc2VhcmNoOicsIGVycm9yKTtcclxuICAgICAgICBpZiAoZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ3JhdGUgbGltaXQnKSB8fCBlcnJvci5zdGF0dXMgPT09IDQyOSkge1xyXG4gICAgICAgICAgaGFuZGxlUmF0ZUxpbWl0KDMwKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgYWxlcnQoXHJcbiAgICAgICAgICAgIGBFcnJvcjogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yIG9jY3VycmVkJ31gXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICBzZXRMb2NhbExvYWRpbmcoZmFsc2UpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuIFxyXG4gICAgICAgIC8qKlxyXG4gICAgICogU1RFUCAzOiBGaXggdG9nZ2xlR2VvZmVuY2VTdGF0ZSB0byBiZXR0ZXIgaGFuZGxlIG1hbnVhbGx5IGNsaWNraW5nIHRoZSBidXR0b25cclxuICAgICAqL1xyXG4gICAgY29uc3QgdG9nZ2xlR2VvZmVuY2VTdGF0ZSA9IChlbmFibGVkOiBib29sZWFuKSA9PiB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCd0b2dnbGVHZW9mZW5jZVN0YXRlIGNhbGxlZCB3aXRoOicsIGVuYWJsZWQpO1xyXG4gICAgICBjb25zb2xlLmxvZygnQ3VycmVudCBnZW9mZW5jZUNvb3JkaW5hdGVzOicsIGdlb2ZlbmNlQ29vcmRpbmF0ZXMpO1xyXG5cclxuICAgICAgaWYgKGVuYWJsZWQpIHtcclxuICAgICAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIHZhbGlkIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgZ2VvZmVuY2VDb29yZGluYXRlcyAmJlxyXG4gICAgICAgICAgdHlwZW9mIGdlb2ZlbmNlQ29vcmRpbmF0ZXMubGF0ID09PSAnbnVtYmVyJyAmJlxyXG4gICAgICAgICAgdHlwZW9mIGdlb2ZlbmNlQ29vcmRpbmF0ZXMubG5nID09PSAnbnVtYmVyJyAmJlxyXG4gICAgICAgICAgIWlzTmFOKGdlb2ZlbmNlQ29vcmRpbmF0ZXMubGF0KSAmJlxyXG4gICAgICAgICAgIWlzTmFOKGdlb2ZlbmNlQ29vcmRpbmF0ZXMubG5nKVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coJ1ZhbGlkIGNvb3JkaW5hdGVzIGZvdW5kLCBlbmFibGluZyBnZW9mZW5jZScpO1xyXG5cclxuICAgICAgICAgIC8vIFNldCBmbGFncyBmaXJzdFxyXG4gICAgICAgICAgc2V0R2VvZmVuY2VFbmFibGVkKHRydWUpO1xyXG4gICAgICAgICAgc2V0SXNHZW9mZW5jZUFjdGl2ZSh0cnVlKTtcclxuXHJcbiAgICAgICAgICAvLyBDYWxsIGNvbnRleHQgdG9nZ2xlIGZ1bmN0aW9uIGlmIGF2YWlsYWJsZVxyXG4gICAgICAgICAgaWYgKHR5cGVvZiB0b2dnbGVHZW9mZW5jZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB0b2dnbGVHZW9mZW5jZSgpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIERpc3BsYXkgYWlyY3JhZnQgaWYgd2UgaGF2ZSB0aGVtXHJcbiAgICAgICAgICBpZiAoZ2VvZmVuY2VBaXJjcmFmdCAmJiBnZW9mZW5jZUFpcmNyYWZ0Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICAgICAgYFNob3dpbmcgJHtnZW9mZW5jZUFpcmNyYWZ0Lmxlbmd0aH0gYWlyY3JhZnQgaW4gZ2VvZmVuY2VgXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHVwZGF0ZUdlb2ZlbmNlQWlyY3JhZnQoZ2VvZmVuY2VBaXJjcmFmdCk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBObyBhaXJjcmFmdCBkYXRhIHlldCwgdHJpZ2dlciBhIHNlYXJjaFxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnTm8gYWlyY3JhZnQgZGF0YSB5ZXQsIHRyaWdnZXJpbmcgc2VhcmNoJyk7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgIHByb2Nlc3NHZW9mZW5jZVNlYXJjaCgpO1xyXG4gICAgICAgICAgICB9LCAxMDApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBObyB2YWxpZCBjb29yZGluYXRlc1xyXG4gICAgICAgICAgY29uc29sZS53YXJuKCdObyB2YWxpZCBjb29yZGluYXRlcywgc2hvd2luZyBhbGVydCcpO1xyXG4gICAgICAgICAgYWxlcnQoXHJcbiAgICAgICAgICAgICdQbGVhc2Ugc2V0IGEgbG9jYXRpb24gYmVmb3JlIGVuYWJsaW5nIGdlb2ZlbmNlLlxcblxcbkNsaWNrIGFueXdoZXJlIG9uIHRoZSBtYXAgdG8gc2V0IGEgbG9jYXRpb24uJ1xyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIHNldEdlb2ZlbmNlRW5hYmxlZChmYWxzZSk7XHJcbiAgICAgICAgICBzZXRJc0dlb2ZlbmNlQWN0aXZlKGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gRGlzYWJsaW5nIGdlb2ZlbmNlXHJcbiAgICAgICAgY29uc29sZS5sb2coJ0Rpc2FibGluZyBnZW9mZW5jZScpO1xyXG4gICAgICAgIHNldEdlb2ZlbmNlRW5hYmxlZChmYWxzZSk7XHJcbiAgICAgICAgc2V0SXNHZW9mZW5jZUFjdGl2ZShmYWxzZSk7XHJcblxyXG4gICAgICAgIC8vIENsZWFyIGdlb2ZlbmNlIGRhdGEgaWYgZnVuY3Rpb24gYXZhaWxhYmxlXHJcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhckdlb2ZlbmNlRGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgY2xlYXJHZW9mZW5jZURhdGEoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG5cclxuICAvLyBFZmZlY3RzXHJcblxyXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAoZ2VvZmVuY2VDb29yZGluYXRlcykge1xyXG4gICAgICBzZXRJc1NlYXJjaFJlYWR5KHRydWUpO1xyXG4gICAgfVxyXG4gIH0sIFtnZW9mZW5jZUNvb3JkaW5hdGVzXSk7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAoaXNSYXRlTGltaXRlZCAmJiByYXRlTGltaXRUaW1lcikge1xyXG4gICAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgIHNldElzUmF0ZUxpbWl0ZWQoZmFsc2UpO1xyXG4gICAgICAgIHNldFJhdGVMaW1pdFRpbWVyKG51bGwpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdSYXRlIGxpbWl0IHRpbWVyIGV4cGlyZWQsIHJlc3VtaW5nIEFQSSBjYWxscycpO1xyXG4gICAgICB9LCByYXRlTGltaXRUaW1lciAqIDEwMDApO1xyXG5cclxuICAgICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dCh0aW1lcik7XHJcbiAgICB9XHJcbiAgfSwgW2lzUmF0ZUxpbWl0ZWQsIHJhdGVMaW1pdFRpbWVyXSk7XHJcblxyXG4gIC8vIEVmZmVjdCB0byBzeW5jIGdlb2ZlbmNlIHN0YXRlXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIC8vIFVwZGF0ZSBpbnRlcm5hbCBzdGF0ZSB3aGVuIGdlb2ZlbmNlIGlzIHRvZ2dsZWQgZXh0ZXJuYWxseVxyXG4gICAgaWYgKGlzR2VvZmVuY2VBY3RpdmUgIT09IGdlb2ZlbmNlRW5hYmxlZCkge1xyXG4gICAgICBzZXRHZW9mZW5jZUVuYWJsZWQoaXNHZW9mZW5jZUFjdGl2ZSk7XHJcbiAgICB9XHJcbiAgfSwgW2lzR2VvZmVuY2VBY3RpdmVdKTtcclxuXHJcbiAgLy8gQ2xvc2UgZHJvcGRvd24gd2hlbiBjbGlja2luZyBvdXRzaWRlXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGNvbnN0IGhhbmRsZUNsaWNrT3V0c2lkZSA9IChldmVudDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAvLyBDaGVjayBpZiBjbGljayBpcyBvdXRzaWRlIG9mIGFsbCBkcm9wZG93bnNcclxuICAgICAgY29uc3QgaXNPdXRzaWRlQWxsID0gT2JqZWN0LnZhbHVlcyhkcm9wZG93blJlZnMpLmV2ZXJ5KFxyXG4gICAgICAgIChyZWYpID0+ICFyZWYuY3VycmVudCB8fCAhcmVmLmN1cnJlbnQuY29udGFpbnMoZXZlbnQudGFyZ2V0IGFzIE5vZGUpXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBpZiAoaXNPdXRzaWRlQWxsKSB7XHJcbiAgICAgICAgc2V0QWN0aXZlRHJvcGRvd24obnVsbCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgaGFuZGxlQ2xpY2tPdXRzaWRlKTtcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGhhbmRsZUNsaWNrT3V0c2lkZSk7XHJcbiAgICB9O1xyXG4gIH0sIFtdKTtcclxuXHJcbiAgLy8gQ2xlYW4gdXAgcmVnaW9uIG91dGxpbmUgd2hlbiBjb21wb25lbnQgdW5tb3VudHNcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgaWYgKHJlZ2lvbk91dGxpbmUpIHtcclxuICAgICAgICByZWdpb25PdXRsaW5lLnJlbW92ZSgpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH0sIFtyZWdpb25PdXRsaW5lXSk7XHJcblxyXG4gIC8vIEVmZmVjdCB0byBoYW5kbGUgbWFwIGNsaWNrIGZvciBnZW9mZW5jZVxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBjb25zdCBoYW5kbGVNYXBHZW9mZW5jZUNsaWNrID0gYXN5bmMgKGV2ZW50OiBFdmVudCkgPT4ge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIC8vIENhc3QgdGhlIGV2ZW50IHRvIHRoZSBwcm9wZXIgdHlwZVxyXG4gICAgICAgIGNvbnN0IGN1c3RvbUV2ZW50ID0gZXZlbnQgYXMgQ3VzdG9tRXZlbnQ8eyBsYXQ6IG51bWJlcjsgbG5nOiBudW1iZXIgfT47XHJcbiAgICAgICAgY29uc3QgeyBsYXQsIGxuZyB9ID0gY3VzdG9tRXZlbnQuZGV0YWlsO1xyXG5cclxuICAgICAgICAvLyBGaXJzdCB1cGRhdGUgY29vcmRpbmF0ZXMgaW1tZWRpYXRlbHlcclxuICAgICAgICBzZXRHZW9mZW5jZUNvb3JkaW5hdGVzKHsgbGF0LCBsbmcgfSk7XHJcblxyXG4gICAgICAgIC8vIFRoZW4gc3RhcnQgYW4gYXN5bmMgb3BlcmF0aW9uIHRvIGdldCB0aGUgbG9jYXRpb24gbmFtZVxyXG4gICAgICAgIGNvbnNvbGUubG9nKGBHZXR0aW5nIGxvY2F0aW9uIG5hbWUgZm9yOiAke2xhdH0sICR7bG5nfWApO1xyXG5cclxuICAgICAgICAvLyBUZW1wb3JhcmlseSBzaG93IGNvb3JkaW5hdGVzIHdoaWxlIGZldGNoaW5nIHRoZSBuYW1lXHJcbiAgICAgICAgc2V0R2VvZmVuY2VMb2NhdGlvbihgJHtsYXQudG9GaXhlZCg2KX0sICR7bG5nLnRvRml4ZWQoNil9YCk7XHJcblxyXG4gICAgICAgIC8vIEdldCB0aGUgZnJpZW5kbHkgbmFtZSBhc3luY2hyb25vdXNseVxyXG4gICAgICAgIGNvbnN0IGxvY2F0aW9uTmFtZSA9IGF3YWl0IE1hcGJveFNlcnZpY2UuZ2V0TG9jYXRpb25OYW1lRnJvbUNvb3JkaW5hdGVzKFxyXG4gICAgICAgICAgbGF0LFxyXG4gICAgICAgICAgbG5nXHJcbiAgICAgICAgKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhgR290IGxvY2F0aW9uIG5hbWU6ICR7bG9jYXRpb25OYW1lfWApO1xyXG5cclxuICAgICAgICAvLyBVcGRhdGUgd2l0aCB0aGUgZnJpZW5kbHkgbmFtZSBvbmNlIHdlIGhhdmUgaXRcclxuICAgICAgICBpZiAobG9jYXRpb25OYW1lICE9PSBudWxsKSB7XHJcbiAgICAgICAgICBzZXRHZW9mZW5jZUxvY2F0aW9uKGxvY2F0aW9uTmFtZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBPcGVuIHRoZSBsb2NhdGlvbiBkcm9wZG93biBpZiBuZWVkZWRcclxuICAgICAgICBpZiAoYWN0aXZlRHJvcGRvd24gIT09ICdsb2NhdGlvbicpIHtcclxuICAgICAgICAgIHNldEFjdGl2ZURyb3Bkb3duKCdsb2NhdGlvbicpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBoYW5kbGluZyBtYXAgY2xpY2s6JywgZXJyb3IpO1xyXG4gICAgICAgIC8vIEtlZXAgdGhlIGNvb3JkaW5hdGVzIGRpc3BsYXkgaWYgdGhlcmUgd2FzIGFuIGVycm9yXHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8gQWRkIHRoZSBldmVudCBsaXN0ZW5lciAtIHVzZSB0aGUgc3RhbmRhcmQgZXZlbnQgbGlzdGVuZXIgcGF0dGVyblxyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcclxuICAgICAgJ21hcC1nZW9mZW5jZS1jbGljaycsXHJcbiAgICAgIGhhbmRsZU1hcEdlb2ZlbmNlQ2xpY2sgYXMgRXZlbnRMaXN0ZW5lclxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBDbGVhbiB1cFxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcclxuICAgICAgICAnbWFwLWdlb2ZlbmNlLWNsaWNrJyxcclxuICAgICAgICBoYW5kbGVNYXBHZW9mZW5jZUNsaWNrIGFzIEV2ZW50TGlzdGVuZXJcclxuICAgICAgKTtcclxuICAgIH07XHJcbiAgfSwgW1xyXG4gICAgc2V0R2VvZmVuY2VMb2NhdGlvbixcclxuICAgIHNldEdlb2ZlbmNlQ29vcmRpbmF0ZXMsXHJcbiAgICBzZXRBY3RpdmVEcm9wZG93bixcclxuICAgIGFjdGl2ZURyb3Bkb3duLFxyXG4gIF0pO1xyXG5cclxuICAvLyBNYWluIG1ldGhvZHNcclxuICBjb25zdCB0b2dnbGVEcm9wZG93biA9IChkcm9wZG93bjogc3RyaW5nLCBldmVudDogUmVhY3QuTW91c2VFdmVudCkgPT4ge1xyXG4gICAgaWYgKGFjdGl2ZURyb3Bkb3duID09PSBkcm9wZG93bikge1xyXG4gICAgICBzZXRBY3RpdmVEcm9wZG93bihudWxsKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHNldEFjdGl2ZURyb3Bkb3duKGRyb3Bkb3duKTtcclxuICAgIH1cclxuICAgIC8vIFByZXZlbnQgZXZlbnRzIGZyb20gYnViYmxpbmcgdXBcclxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IGhhbmRsZVJhdGVMaW1pdCA9IChyZXRyeUFmdGVyOiBudW1iZXIgPSAzMCkgPT4ge1xyXG4gICAgc2V0SXNSYXRlTGltaXRlZCh0cnVlKTtcclxuICAgIHNldFJhdGVMaW1pdFRpbWVyKHJldHJ5QWZ0ZXIpO1xyXG4gICAgY29uc29sZS5sb2coYFJhdGUgbGltaXRlZCBieSBBUEkuIFJldHJ5IGFmdGVyICR7cmV0cnlBZnRlcn1zYCk7XHJcblxyXG4gICAgLy8gQmxvY2sgYWxsIEFQSSBjYWxsc1xyXG4gICAgb3BlblNreVRyYWNraW5nU2VydmljZS5zZXRCbG9ja0FsbEFwaUNhbGxzKHRydWUpO1xyXG4gICAgc2V0QmxvY2tNYW51ZmFjdHVyZXJBcGlDYWxscyh0cnVlKTtcclxuXHJcbiAgICAvLyBTaG93IG5vdGlmaWNhdGlvbiB0byB1c2VyXHJcbiAgICBpZiAocmV0cnlBZnRlciA+IDApIHtcclxuICAgICAgYWxlcnQoXHJcbiAgICAgICAgYEFpcmNyYWZ0IGRhdGEgcmVmcmVzaCByYXRlIGxpbWl0ZWQuIFBsZWFzZSB3YWl0ICR7cmV0cnlBZnRlcn0gc2Vjb25kcyBiZWZvcmUgdHJ5aW5nIGFnYWluLmBcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBUb2dnbGUgZmlsdGVyIG1vZGVcclxuICAgKi9cclxuICBjb25zdCB0b2dnbGVGaWx0ZXJNb2RlID0gKG1vZGU6IEZpbHRlck1vZGUpID0+IHtcclxuICAgIHNldEZpbHRlck1vZGUobW9kZSk7XHJcbiAgICBzZXRBY3RpdmVEcm9wZG93bihudWxsKTtcclxuXHJcbiAgICAvLyBBcHBseSBhcHByb3ByaWF0ZSBmaWx0ZXJzIGJhc2VkIG9uIG5ldyBtb2RlXHJcbiAgICBpZiAobW9kZSA9PT0gJ3JlZ2lvbicpIHtcclxuICAgICAgLy8gQmxvY2sgQVBJIGNhbGxzIGluIHJlZ2lvbiBtb2RlXHJcbiAgICAgIG9wZW5Ta3lUcmFja2luZ1NlcnZpY2Uuc2V0QmxvY2tBbGxBcGlDYWxscyh0cnVlKTtcclxuXHJcbiAgICAgIC8vIEFwcGx5IHJlZ2lvbiBmaWx0ZXJpbmcgaWYgd2UgYWxyZWFkeSBoYXZlIGRhdGFcclxuICAgICAgaWYgKGRpc3BsYXllZEFpcmNyYWZ0ICYmIGRpc3BsYXllZEFpcmNyYWZ0Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICBmaWx0ZXJBaXJjcmFmdEJ5UmVnaW9uKHNlbGVjdGVkUmVnaW9uLnRvU3RyaW5nKCkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDbGVhciBtYW51ZmFjdHVyZXIgc2VsZWN0aW9uIGZyb20gdGhlIFVJXHJcbiAgICAgIHNlbGVjdE1hbnVmYWN0dXJlcihudWxsKTtcclxuICAgICAgc2VsZWN0TW9kZWwobnVsbCk7XHJcblxyXG4gICAgICAvLyBJZiBnZW9mZW5jZSBpcyBhY3RpdmUsIHJlc3RvcmUgdGhlIGZ1bGwgZ2VvZmVuY2UgZGF0YVxyXG4gICAgICBpZiAoZ2VvZmVuY2VDb29yZGluYXRlcyAmJiBnZW9mZW5jZUFpcmNyYWZ0Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICB1cGRhdGVHZW9mZW5jZUFpcmNyYWZ0KGdlb2ZlbmNlQWlyY3JhZnQpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdvd25lcicpIHtcclxuICAgICAgLy8gRmlsdGVyIGRpc3BsYXllZCBhaXJjcmFmdCBieSBvd25lciB0eXBlXHJcbiAgICAgIGlmIChkaXNwbGF5ZWRBaXJjcmFmdCAmJiBkaXNwbGF5ZWRBaXJjcmFmdC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgLy8gRmlyc3QgZmlsdGVyIGZvciB2YWxpZCBjb29yZGluYXRlc1xyXG4gICAgICAgIGNvbnN0IGFpcmNyYWZ0V2l0aFZhbGlkQ29vcmRzID0gZGlzcGxheWVkQWlyY3JhZnQuZmlsdGVyKFxyXG4gICAgICAgICAgKHBsYW5lKSA9PlxyXG4gICAgICAgICAgICB0eXBlb2YgcGxhbmUubGF0aXR1ZGUgPT09ICdudW1iZXInICYmXHJcbiAgICAgICAgICAgIHR5cGVvZiBwbGFuZS5sb25naXR1ZGUgPT09ICdudW1iZXInICYmXHJcbiAgICAgICAgICAgICFpc05hTihwbGFuZS5sYXRpdHVkZSkgJiZcclxuICAgICAgICAgICAgIWlzTmFOKHBsYW5lLmxvbmdpdHVkZSlcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyBBcHBseSBvd25lciB0eXBlIGZpbHRlclxyXG4gICAgICAgIGxldCBmaWx0ZXJlZEJ5T3duZXIgPVxyXG4gICAgICAgICAgb3duZXJGaWx0ZXJzLmxlbmd0aCA9PT0gMFxyXG4gICAgICAgICAgICA/IGFpcmNyYWZ0V2l0aFZhbGlkQ29vcmRzXHJcbiAgICAgICAgICAgIDogYWlyY3JhZnRXaXRoVmFsaWRDb29yZHMuZmlsdGVyKChhaXJjcmFmdCkgPT5cclxuICAgICAgICAgICAgICAgIG93bmVyRmlsdGVycy5pbmNsdWRlcyhnZXRBaXJjcmFmdE93bmVyVHlwZShhaXJjcmFmdCkpXHJcbiAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIGRpc3BsYXkgd2l0aCBmaWx0ZXJlZCBhaXJjcmFmdFxyXG4gICAgICAgIGlmIChjbGVhckdlb2ZlbmNlRGF0YSkge1xyXG4gICAgICAgICAgY2xlYXJHZW9mZW5jZURhdGEoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdXBkYXRlR2VvZmVuY2VBaXJjcmFmdChmaWx0ZXJlZEJ5T3duZXIpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdib3RoJykge1xyXG4gICAgICAvLyBCb3RoIG1vZGUgLSBCTE9DSyBBUEkgQ0FMTFNcclxuICAgICAgb3BlblNreVRyYWNraW5nU2VydmljZS5zZXRCbG9ja0FsbEFwaUNhbGxzKHRydWUpO1xyXG5cclxuICAgICAgaWYgKFxyXG4gICAgICAgIHNlbGVjdGVkTWFudWZhY3R1cmVyICYmXHJcbiAgICAgICAgaXNHZW9mZW5jZUFjdGl2ZSAmJlxyXG4gICAgICAgIGdlb2ZlbmNlQWlyY3JhZnQubGVuZ3RoID4gMFxyXG4gICAgICApIHtcclxuICAgICAgICBhcHBseUNvbWJpbmVkRmlsdGVycygpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIElmIG9uZSBpcyBtaXNzaW5nLCBwcm9tcHQgdGhlIHVzZXJcclxuICAgICAgICBpZiAoIXNlbGVjdGVkTWFudWZhY3R1cmVyICYmIGlzR2VvZmVuY2VBY3RpdmUpIHtcclxuICAgICAgICAgIGFsZXJ0KCdQbGVhc2Ugc2VsZWN0IGEgbWFudWZhY3R1cmVyIHRvIHVzZSBjb21iaW5lZCBmaWx0ZXIgbW9kZScpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoc2VsZWN0ZWRNYW51ZmFjdHVyZXIgJiYgIWlzR2VvZmVuY2VBY3RpdmUpIHtcclxuICAgICAgICAgIGFsZXJ0KCdQbGVhc2Ugc2V0IGEgbG9jYXRpb24gdG8gdXNlIGNvbWJpbmVkIGZpbHRlciBtb2RlJyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGFsZXJ0KFxyXG4gICAgICAgICAgICAnUGxlYXNlIHNlbGVjdCBib3RoIGEgbWFudWZhY3R1cmVyIGFuZCBsb2NhdGlvbiB0byB1c2UgY29tYmluZWQgZmlsdGVyIG1vZGUnXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8vIE93bmVyIGZpbHRlciBtZXRob2RzXHJcbiAgY29uc3QgZ2V0QWlyY3JhZnRPd25lclR5cGUgPSAoYWlyY3JhZnQ6IEV4dGVuZGVkQWlyY3JhZnQpOiBzdHJpbmcgPT4ge1xyXG4gICAgY29uc3Qgb3duZXJUeXBlID0gYWlyY3JhZnQuVFlQRV9SRUdJU1RSQU5UIHx8IDA7XHJcbiAgICByZXR1cm4gb3duZXJUeXBlVG9TdHJpbmcob3duZXJUeXBlKTtcclxuICB9O1xyXG5cclxuICBjb25zdCBvd25lclR5cGVUb1N0cmluZyA9ICh0eXBlOiBudW1iZXIgfCBzdHJpbmcpOiBzdHJpbmcgPT4ge1xyXG4gICAgY29uc3QgdHlwZU51bSA9IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyA/IHBhcnNlSW50KHR5cGUsIDEwKSA6IHR5cGU7XHJcblxyXG4gICAgY29uc3Qgb3duZXJUeXBlTWFwOiBSZWNvcmQ8bnVtYmVyLCBzdHJpbmc+ID0ge1xyXG4gICAgICAxOiAnaW5kaXZpZHVhbCcsXHJcbiAgICAgIDI6ICdwYXJ0bmVyc2hpcCcsXHJcbiAgICAgIDM6ICdjb3JwLW93bmVyJyxcclxuICAgICAgNDogJ2NvLW93bmVkJyxcclxuICAgICAgNzogJ2xsYycsXHJcbiAgICAgIDg6ICdub24tY2l0aXplbi1jb3JwJyxcclxuICAgICAgOTogJ2FpcmxpbmUnLFxyXG4gICAgICAxMDogJ2ZyZWlnaHQnLFxyXG4gICAgICAxMTogJ21lZGljYWwnLFxyXG4gICAgICAxMjogJ21lZGlhJyxcclxuICAgICAgMTM6ICdoaXN0b3JpY2FsJyxcclxuICAgICAgMTQ6ICdmbHlpbmctY2x1YicsXHJcbiAgICAgIDE1OiAnZW1lcmdlbmN5JyxcclxuICAgICAgMTY6ICdsb2NhbC1nb3Z0JyxcclxuICAgICAgMTc6ICdlZHVjYXRpb24nLFxyXG4gICAgICAxODogJ2ZlZGVyYWwtZ292dCcsXHJcbiAgICAgIDE5OiAnZmxpZ2h0LXNjaG9vbCcsXHJcbiAgICAgIDIwOiAnbGVhc2luZy1jb3JwJyxcclxuICAgICAgMjE6ICdtaWxpdGFyeScsXHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBvd25lclR5cGVNYXBbdHlwZU51bV0gfHwgJ3Vua25vd24nO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IGFwcGx5T3duZXJUeXBlRmlsdGVyID0gKGZpbHRlcnM6IHN0cmluZ1tdKSA9PiB7XHJcbiAgICAvLyBTa2lwIGZpbHRlcmluZyBpZiBhbGwgdHlwZXMgYXJlIHNlbGVjdGVkIG9yIG5vbmUgYXJlIHNlbGVjdGVkXHJcbiAgICBpZiAoZmlsdGVycy5sZW5ndGggPT09IDAgfHwgZmlsdGVycy5sZW5ndGggPT09IGFsbE93bmVyVHlwZXMubGVuZ3RoKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBGaWx0ZXIgdGhlIGFpcmNyYWZ0IGJhc2VkIG9uIHNlbGVjdGVkIG93bmVyIHR5cGVzXHJcbiAgICBpZiAoZGlzcGxheWVkQWlyY3JhZnQgJiYgZGlzcGxheWVkQWlyY3JhZnQubGVuZ3RoID4gMCkge1xyXG4gICAgICBjb25zdCBmaWx0ZXJlZEFpcmNyYWZ0ID0gZGlzcGxheWVkQWlyY3JhZnQuZmlsdGVyKChhaXJjcmFmdCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IG93bmVyVHlwZSA9IGdldEFpcmNyYWZ0T3duZXJUeXBlKGFpcmNyYWZ0KTtcclxuICAgICAgICByZXR1cm4gZmlsdGVycy5pbmNsdWRlcyhvd25lclR5cGUpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIFVwZGF0ZSB0aGUgZGlzcGxheWVkIGFpcmNyYWZ0XHJcbiAgICAgIGlmIChjbGVhckdlb2ZlbmNlRGF0YSkge1xyXG4gICAgICAgIGNsZWFyR2VvZmVuY2VEYXRhKCk7XHJcbiAgICAgIH1cclxuICAgICAgdXBkYXRlR2VvZmVuY2VBaXJjcmFmdChmaWx0ZXJlZEFpcmNyYWZ0KTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBjb25zdCBoYW5kbGVPd25lckZpbHRlckNoYW5nZSA9ICh1cGRhdGVkRmlsdGVyczogc3RyaW5nW10pID0+IHtcclxuICAgIHNldE93bmVyRmlsdGVycyh1cGRhdGVkRmlsdGVycyk7XHJcbiAgICAvLyBBcHBseSB0aGUgZmlsdGVyIHRvIHlvdXIgYWlyY3JhZnQgZGF0YVxyXG4gICAgYXBwbHlPd25lclR5cGVGaWx0ZXIodXBkYXRlZEZpbHRlcnMpO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IHJlc2V0T3duZXJGaWx0ZXJzID0gKCkgPT4ge1xyXG4gICAgc2V0T3duZXJGaWx0ZXJzKFsuLi5hbGxPd25lclR5cGVzXSk7XHJcbiAgfTtcclxuXHJcbiAgLy8gUmVnaW9uIGZpbHRlciBtZXRob2RzXHJcbiAgY29uc3QgZmlsdGVyQWlyY3JhZnRCeVJlZ2lvbiA9IChyZWdpb246IHN0cmluZykgPT4ge1xyXG4gICAgaWYgKCFkaXNwbGF5ZWRBaXJjcmFmdCB8fCBkaXNwbGF5ZWRBaXJjcmFmdC5sZW5ndGggPT09IDApIHJldHVybjtcclxuICAgIHNldExvY2FsTG9hZGluZyh0cnVlKTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBHZXQgdGhlIGJvdW5kcyBmb3IgdGhlIHNlbGVjdGVkIHJlZ2lvblxyXG4gICAgICBjb25zdCBib3VuZHNFeHByZXNzaW9uID0gZ2V0Qm91bmRzQnlSZWdpb24ocmVnaW9uKTtcclxuXHJcbiAgICAgIC8vIEVuc3VyZSBib3VuZHMgaXMgaW4gdGhlIGNvcnJlY3QgZm9ybWF0XHJcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShib3VuZHNFeHByZXNzaW9uKSB8fCBib3VuZHNFeHByZXNzaW9uLmxlbmd0aCAhPT0gMikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXHJcbiAgICAgICAgICBgSW52YWxpZCBib3VuZHMgZm9ybWF0IGZvciByZWdpb246ICR7cmVnaW9ufWAsXHJcbiAgICAgICAgICBib3VuZHNFeHByZXNzaW9uXHJcbiAgICAgICAgKTtcclxuICAgICAgICBzZXRMb2NhbExvYWRpbmcoZmFsc2UpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRXh0cmFjdCBjb29yZGluYXRlcyAtIExlYWZsZXQgdXNlcyBbbGF0LCBsbmddIGZvcm1hdFxyXG4gICAgICBjb25zdCBbW21pbkxhdCwgbWluTG5nXSwgW21heExhdCwgbWF4TG5nXV0gPSBib3VuZHNFeHByZXNzaW9uO1xyXG5cclxuICAgICAgY29uc29sZS5sb2coYEZpbHRlcmluZyBieSByZWdpb246ICR7cmVnaW9ufSB3aXRoIGJvdW5kczpgLCB7XHJcbiAgICAgICAgbWluTGF0LFxyXG4gICAgICAgIG1pbkxuZyxcclxuICAgICAgICBtYXhMYXQsXHJcbiAgICAgICAgbWF4TG5nLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIEZpbHRlciBhaXJjcmFmdCBiYXNlZCBvbiBjb29yZGluYXRlcyB3aXRoaW4gdGhlIGJvdW5kc1xyXG4gICAgICBjb25zdCBmaWx0ZXJlZEFpcmNyYWZ0ID0gZGlzcGxheWVkQWlyY3JhZnQuZmlsdGVyKChhaXJjcmFmdCkgPT4ge1xyXG4gICAgICAgIC8vIENoZWNrIGlmIGFpcmNyYWZ0IGhhcyB2YWxpZCBjb29yZGluYXRlc1xyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgIHR5cGVvZiBhaXJjcmFmdC5sYXRpdHVkZSAhPT0gJ251bWJlcicgfHxcclxuICAgICAgICAgIHR5cGVvZiBhaXJjcmFmdC5sb25naXR1ZGUgIT09ICdudW1iZXInIHx8XHJcbiAgICAgICAgICBpc05hTihhaXJjcmFmdC5sYXRpdHVkZSkgfHxcclxuICAgICAgICAgIGlzTmFOKGFpcmNyYWZ0LmxvbmdpdHVkZSlcclxuICAgICAgICApIHtcclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENoZWNrIGlmIGNvb3JkaW5hdGVzIGFyZSB3aXRoaW4gdGhlIGJvdW5kc1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICBhaXJjcmFmdC5sYXRpdHVkZSA+PSBtaW5MYXQgJiZcclxuICAgICAgICAgIGFpcmNyYWZ0LmxhdGl0dWRlIDw9IG1heExhdCAmJlxyXG4gICAgICAgICAgYWlyY3JhZnQubG9uZ2l0dWRlID49IG1pbkxuZyAmJlxyXG4gICAgICAgICAgYWlyY3JhZnQubG9uZ2l0dWRlIDw9IG1heExuZ1xyXG4gICAgICAgICk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gVXBkYXRlIHRoZSBkaXNwbGF5IHdpdGggZmlsdGVyZWQgYWlyY3JhZnRcclxuICAgICAgaWYgKGNsZWFyR2VvZmVuY2VEYXRhKSB7XHJcbiAgICAgICAgY2xlYXJHZW9mZW5jZURhdGEoKTtcclxuICAgICAgfVxyXG4gICAgICB1cGRhdGVHZW9mZW5jZUFpcmNyYWZ0KGZpbHRlcmVkQWlyY3JhZnQpO1xyXG4gICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICBgRmlsdGVyZWQgdG8gJHtmaWx0ZXJlZEFpcmNyYWZ0Lmxlbmd0aH0gYWlyY3JhZnQgaW4gJHtyZWdpb259IHJlZ2lvbiAob3V0IG9mICR7ZGlzcGxheWVkQWlyY3JhZnQubGVuZ3RofSB0b3RhbClgXHJcbiAgICAgICk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmaWx0ZXJpbmcgYWlyY3JhZnQgYnkgcmVnaW9uOicsIGVycm9yKTtcclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgIHNldExvY2FsTG9hZGluZyhmYWxzZSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgaGFuZGxlUmVnaW9uU2VsZWN0ID0gYXN5bmMgKHJlZ2lvbjogUmVnaW9uQ29kZSkgPT4ge1xyXG4gICAgc2V0QWN0aXZlUmVnaW9uKHJlZ2lvbik7XHJcbiAgICBzZXRTZWxlY3RlZFJlZ2lvbihyZWdpb24pO1xyXG4gICAgc2V0TG9jYWxMb2FkaW5nKHRydWUpO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIFNldCBtYXAgYm91bmRzIGJhc2VkIG9uIHJlZ2lvblxyXG4gICAgICBpZiAobWFwSW5zdGFuY2UpIHtcclxuICAgICAgICBjb25zdCBib3VuZHMgPSBnZXRCb3VuZHNCeVJlZ2lvbihyZWdpb24pO1xyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIGFwcHJvcHJpYXRlIHpvb20gbGV2ZWwgZm9yIHRoaXMgcmVnaW9uIGZyb20geW91ciBjb25maWdcclxuICAgICAgICBjb25zdCB6b29tTGV2ZWwgPSBnZXRab29tTGV2ZWxGb3JSZWdpb24ocmVnaW9uKTtcclxuXHJcbiAgICAgICAgLy8gRmlyc3QsIHNldCB0aGUgYXBwcm9wcmlhdGUgem9vbSBsZXZlbFxyXG4gICAgICAgIG1hcEluc3RhbmNlLnNldFpvb20oem9vbUxldmVsKTtcclxuXHJcbiAgICAgICAgLy8gVGhlbiBmaXQgYm91bmRzIHdpdGggcGFkZGluZ1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICBwYWRkaW5nOiBNQVBfQ09ORklHLlBBRERJTkcuREVGQVVMVCxcclxuICAgICAgICAgIC8vIERvbid0IHNldCBtYXhab29tIGhlcmUgYXMgd2Ugd2FudCB0aGUgcmVnaW9uIHRvIGJlIHByb3Blcmx5IGRpc3BsYXllZFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIG1hcEluc3RhbmNlLmZpdEJvdW5kcyhib3VuZHMgYXMgYW55LCBvcHRpb25zKTtcclxuICAgICAgICBtYXBJbnN0YW5jZS5pbnZhbGlkYXRlU2l6ZSgpO1xyXG4gICAgICAgIGRyYXdSZWdpb25PdXRsaW5lKHJlZ2lvbik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEluc3RlYWQgb2YgaW1tZWRpYXRlbHkgZmV0Y2hpbmcgYWlyY3JhZnQgZGF0YSxcclxuICAgICAgLy8ganVzdCBzdG9yZSB0aGUgcmVnaW9uIHNlbGVjdGlvbiBmb3IgbGF0ZXIgdXNlXHJcbiAgICAgIGNvbnNvbGUubG9nKGBSZWdpb24gc2VsZWN0ZWQuIFdhaXRpbmcgZm9yIG1hbnVmYWN0dXJlciBzZWxlY3Rpb24uLi5gKTtcclxuXHJcbiAgICAgIC8vIE9wdGlvbmFsbHksIHlvdSBjb3VsZCBmZXRjaCBqdXN0IHRoZSBjb3VudCBvZiBhaXJjcmFmdCBpbiB0aGlzIHJlZ2lvblxyXG4gICAgICAvLyB0byBnaXZlIHRoZSB1c2VyIGFuIGlkZWEgb2YgdGhlIGRhdGEgdm9sdW1lXHJcbiAgICAgIGNvbnN0IGNvdW50UmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcclxuICAgICAgICBgL2FwaS90cmFja2luZy9yZWdpb24tY291bnQ/cmVnaW9uPSR7cmVnaW9ufWBcclxuICAgICAgKTtcclxuICAgICAgaWYgKGNvdW50UmVzcG9uc2Uub2spIHtcclxuICAgICAgICBjb25zdCBjb3VudERhdGEgPSBhd2FpdCBjb3VudFJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhgJHtjb3VudERhdGEuY291bnR9IGFpcmNyYWZ0IGF2YWlsYWJsZSBpbiB0aGlzIHJlZ2lvbmApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDbGVhciBhbnkgcHJldmlvdXMgYWlyY3JhZnQgZGF0YVxyXG4gICAgICBpZiAoY2xlYXJHZW9mZW5jZURhdGEpIHtcclxuICAgICAgICBjbGVhckdlb2ZlbmNlRGF0YSgpO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiByZWdpb24gc2VsZWN0aW9uOicsIGVycm9yKTtcclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgIHNldExvY2FsTG9hZGluZyhmYWxzZSk7XHJcbiAgICAgIHNldEFjdGl2ZURyb3Bkb3duKG51bGwpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGNvbnN0IGRyYXdSZWdpb25PdXRsaW5lID0gKHJlZ2lvbjogUmVnaW9uQ29kZSkgPT4ge1xyXG4gICAgaWYgKCFtYXBJbnN0YW5jZSkgcmV0dXJuO1xyXG5cclxuICAgIC8vIENsZWFyIGFueSBleGlzdGluZyBvdXRsaW5lXHJcbiAgICBpZiAocmVnaW9uT3V0bGluZSkge1xyXG4gICAgICByZWdpb25PdXRsaW5lLnJlbW92ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEdldCB0aGUgYm91bmRzIGZvciB0aGUgc2VsZWN0ZWQgcmVnaW9uXHJcbiAgICBjb25zdCBib3VuZHMgPSBnZXRCb3VuZHNCeVJlZ2lvbihyZWdpb24pIGFzIFtcclxuICAgICAgW251bWJlciwgbnVtYmVyXSxcclxuICAgICAgW251bWJlciwgbnVtYmVyXSxcclxuICAgIF07XHJcblxyXG4gICAgLy8gQ3JlYXRlIGEgcG9seWdvbiBmcm9tIHRoZSBib3VuZHNcclxuICAgIGNvbnN0IEwgPSByZXF1aXJlKCdsZWFmbGV0Jyk7XHJcbiAgICBjb25zdCByZWN0YW5nbGUgPSBMLnJlY3RhbmdsZShib3VuZHMsIHtcclxuICAgICAgY29sb3I6ICcjNGY0NmU1JywgLy8gSW5kaWdvIGNvbG9yIG1hdGNoaW5nIHlvdXIgVUlcclxuICAgICAgd2VpZ2h0OiAzLFxyXG4gICAgICBvcGFjaXR5OiAwLjcsXHJcbiAgICAgIGZpbGw6IHRydWUsXHJcbiAgICAgIGZpbGxDb2xvcjogJyM0ZjQ2ZTUnLFxyXG4gICAgICBmaWxsT3BhY2l0eTogMC4xLFxyXG4gICAgICBkYXNoQXJyYXk6ICc1LCAxMCcsIC8vIE9wdGlvbmFsOiBjcmVhdGVzIGEgZGFzaGVkIGxpbmVcclxuICAgICAgaW50ZXJhY3RpdmU6IGZhbHNlLCAvLyBQcmV2ZW50cyB0aGUgcmVjdGFuZ2xlIGZyb20gY2FwdHVyaW5nIG1vdXNlIGV2ZW50c1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gQWRkIHRvIG1hcFxyXG4gICAgcmVjdGFuZ2xlLmFkZFRvKG1hcEluc3RhbmNlKTtcclxuXHJcbiAgICAvLyBVcGRhdGUgdGhlIHN0YXRlIHRvIGluY2x1ZGUgYm90aCB0aGUgcmVjdGFuZ2xlIGFuZCB0aGUgbGFiZWxcclxuICAgIHNldFJlZ2lvbk91dGxpbmUoe1xyXG4gICAgICByZW1vdmU6ICgpID0+IHtcclxuICAgICAgICByZWN0YW5nbGUucmVtb3ZlKCk7XHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAgIC8vIE1hbnVmYWN0dXJlciBmaWx0ZXIgbWV0aG9kc1xyXG4gICAgY29uc3Qgc2VsZWN0TWFudWZhY3R1cmVyQW5kQ2xvc2UgPSAodmFsdWU6IHN0cmluZykgPT4ge1xyXG4gICAgICAvLyBDbG9zZSBkcm9wZG93blxyXG4gICAgICBzZXRBY3RpdmVEcm9wZG93bihudWxsKTtcclxuICAgICAgc2V0TWFudWZhY3R1cmVyU2VhcmNoVGVybSgnJyk7XHJcblxyXG4gICAgICAvLyBJZiBjbGVhcmluZyB0aGUgc2VsZWN0aW9uXHJcbiAgICAgIGlmICh2YWx1ZSA9PT0gJycpIHtcclxuICAgICAgICBzZWxlY3RNYW51ZmFjdHVyZXIobnVsbCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBTZXQgdGhlIG1hbnVmYWN0dXJlciBzZWxlY3Rpb25cclxuICAgICAgc2VsZWN0TWFudWZhY3R1cmVyKHZhbHVlKTtcclxuXHJcbiAgICAgIC8vIElmIHJlZ2lvbiBpcyBhbHJlYWR5IHNlbGVjdGVkLCBmZXRjaCBmaWx0ZXJlZCBkYXRhXHJcbiAgICAgIGlmIChhY3RpdmVSZWdpb24gIT09IG51bGwpIHtcclxuICAgICAgICBmZXRjaEFpcmNyYWZ0QnlSZWdpb25BbmRNYW51ZmFjdHVyZXIoYWN0aXZlUmVnaW9uIGFzIFJlZ2lvbkNvZGUsIHZhbHVlKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBPdGhlcndpc2UsIGp1c3QgcHJvY2VlZCB3aXRoIG1hbnVmYWN0dXJlci1vbmx5IGZpbHRlcmluZyBhcyBiZWZvcmVcclxuICAgICAgICBmZXRjaE1hbnVmYWN0dXJlckRhdGEodmFsdWUpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IGZldGNoTWFudWZhY3R1cmVyRGF0YSA9IChtYW51ZmFjdHVyZXI6IHN0cmluZykgPT4ge1xyXG4gICAgICBpZiAoaXNSYXRlTGltaXRlZCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgYFNraXBwaW5nIGRhdGEgZmV0Y2ggLSByYXRlIGxpbWl0ZWQgZm9yICR7cmF0ZUxpbWl0VGltZXJ9c2BcclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc29sZS5sb2coYEZldGNoaW5nIGRhdGEgZm9yIG1hbnVmYWN0dXJlcjogJHttYW51ZmFjdHVyZXJ9YCk7XHJcblxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIC8vIElmIHlvdSBoYXZlIGEgY29udGV4dCBmdW5jdGlvbiBmb3IgdGhpcywgY2FsbCBpdCBhZnRlciBhIHNsaWdodCBkZWxheVxyXG4gICAgICAgIGlmICh0eXBlb2YgcmVmcmVzaFBvc2l0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgLy8gQXBwbHkgYSBzbWFsbCBkZWxheSB0byBwcmV2ZW50IG92ZXJ3aGVsbWluZyB0aGUgQVBJXHJcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgcmVmcmVzaFBvc2l0aW9ucygpLmNhdGNoKChlcnJvcjogYW55KSA9PiB7XHJcbiAgICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ3JhdGUgbGltaXQnKSB8fFxyXG4gICAgICAgICAgICAgICAgZXJyb3Iuc3RhdHVzID09PSA0MjlcclxuICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZVJhdGVMaW1pdCgzMCk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIG1hbnVmYWN0dXJlciBkYXRhOicsIGVycm9yKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfSwgMjAwKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgICAgICBpZiAoZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ3JhdGUgbGltaXQnKSB8fCBlcnJvci5zdGF0dXMgPT09IDQyOSkge1xyXG4gICAgICAgICAgaGFuZGxlUmF0ZUxpbWl0KDMwKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igc2NoZWR1bGluZyBtYW51ZmFjdHVyZXIgZGF0YSBmZXRjaDonLCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IGZldGNoQWlyY3JhZnRCeVJlZ2lvbkFuZE1hbnVmYWN0dXJlciA9IGFzeW5jIChcclxuICAgICAgcmVnaW9uOiBSZWdpb25Db2RlLFxyXG4gICAgICBtYW51ZmFjdHVyZXI6IHN0cmluZyxcclxuICAgICAgcGFnZTogbnVtYmVyID0gMSxcclxuICAgICAgbGltaXQ6IG51bWJlciA9IDUwMFxyXG4gICAgKSA9PiB7XHJcbiAgICAgIGlmICghcmVnaW9uIHx8ICFtYW51ZmFjdHVyZXIpIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnQm90aCByZWdpb24gYW5kIG1hbnVmYWN0dXJlciBtdXN0IGJlIHNlbGVjdGVkJyk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzZXRMb2NhbExvYWRpbmcodHJ1ZSk7XHJcblxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXHJcbiAgICAgICAgICBgL2FwaS90cmFja2luZy9maWx0ZXJlZC1haXJjcmFmdD9yZWdpb249JHtyZWdpb259Jm1hbnVmYWN0dXJlcj0ke2VuY29kZVVSSUNvbXBvbmVudChtYW51ZmFjdHVyZXIpfSZwYWdlPSR7cGFnZX0mbGltaXQ9JHtsaW1pdH1gXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICBjb25zdCBhaXJjcmFmdERhdGEgPSBkYXRhLmFpcmNyYWZ0IHx8IFtdO1xyXG5cclxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFQSSBlcnJvcjogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUHJvY2VzcyB0aGUgZmlsdGVyZWQgYWlyY3JhZnQgZGF0YVxyXG4gICAgICAgIGlmIChhaXJjcmFmdERhdGEubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgLy8gVHJhbnNmb3JtIHRvIEV4dGVuZGVkQWlyY3JhZnRcclxuICAgICAgICAgIGludGVyZmFjZSBBaXJjcmFmdERhdGEge1xyXG4gICAgICAgICAgICBUWVBFX0FJUkNSQUZUPzogc3RyaW5nO1xyXG4gICAgICAgICAgICBPUEVSQVRPUj86IHN0cmluZztcclxuICAgICAgICAgICAgUkVHSU9OOiBudW1iZXI7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgY29uc3QgZXh0ZW5kZWRBaXJjcmFmdDogRXh0ZW5kZWRBaXJjcmFmdFtdID0gYWlyY3JhZnREYXRhLm1hcChcclxuICAgICAgICAgICAgKGFpcmNyYWZ0OiBBaXJjcmFmdERhdGEpID0+ICh7XHJcbiAgICAgICAgICAgICAgLi4uYWlyY3JhZnQsXHJcbiAgICAgICAgICAgICAgdHlwZTogYWlyY3JhZnQuVFlQRV9BSVJDUkFGVCB8fCAnVW5rbm93bicsXHJcbiAgICAgICAgICAgICAgaXNHb3Zlcm5tZW50OlxyXG4gICAgICAgICAgICAgICAgYWlyY3JhZnQuT1BFUkFUT1I/LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2dvdmVybm1lbnQnKSA/P1xyXG4gICAgICAgICAgICAgICAgZmFsc2UsXHJcbiAgICAgICAgICAgICAgUkVHSU9OOiBhaXJjcmFmdC5SRUdJT04sXHJcbiAgICAgICAgICAgICAgem9vbUxldmVsOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgbWFwXHJcbiAgICAgICAgICB1cGRhdGVHZW9mZW5jZUFpcmNyYWZ0KGV4dGVuZGVkQWlyY3JhZnQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgICAgYE5vIGFpcmNyYWZ0IGZvdW5kIGZvciBtYW51ZmFjdHVyZXIgJHttYW51ZmFjdHVyZXJ9IGluIHJlZ2lvbiAke3JlZ2lvbn1gXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBmaWx0ZXJlZCBhaXJjcmFmdDonLCBlcnJvcik7XHJcbiAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgc2V0TG9jYWxMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBNb2RlbCBzZWxlY3Rpb24gbWV0aG9kc1xyXG4gICAgY29uc3QgaGFuZGxlTW9kZWxTZWxlY3QgPSAodmFsdWU6IHN0cmluZykgPT4ge1xyXG4gICAgICBzZWxlY3RNb2RlbCh2YWx1ZSA9PT0gJycgPyBudWxsIDogdmFsdWUpO1xyXG4gICAgICBzZXRBY3RpdmVEcm9wZG93bihudWxsKTtcclxuXHJcbiAgICAgIC8vIElmIGluIGNvbWJpbmVkIG1vZGUsIHJlYXBwbHkgdGhlIGZpbHRlclxyXG4gICAgICBpZiAoZmlsdGVyTW9kZSA9PT0gJ2JvdGgnICYmIGlzR2VvZmVuY2VBY3RpdmUgJiYgc2VsZWN0ZWRNYW51ZmFjdHVyZXIpIHtcclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgIGFwcGx5Q29tYmluZWRGaWx0ZXJzKCk7XHJcbiAgICAgICAgfSwgMTAwKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBDb21iaW5lZCBmaWx0ZXIgbWV0aG9kc1xyXG4gICAgY29uc3QgYXBwbHlDb21iaW5lZEZpbHRlcnMgPSAoKSA9PiB7XHJcbiAgICAgIGlmIChcclxuICAgICAgICAhc2VsZWN0ZWRNYW51ZmFjdHVyZXIgfHxcclxuICAgICAgICAhaXNHZW9mZW5jZUFjdGl2ZSB8fFxyXG4gICAgICAgIGdlb2ZlbmNlQWlyY3JhZnQubGVuZ3RoID09PSAwXHJcbiAgICAgICkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgc2V0TG9jYWxMb2FkaW5nKHRydWUpO1xyXG5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgIGBGaWx0ZXJpbmcgJHtnZW9mZW5jZUFpcmNyYWZ0Lmxlbmd0aH0gYWlyY3JhZnQgYnkgJHtzZWxlY3RlZE1hbnVmYWN0dXJlcn1gXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gRmlsdGVyIHRoZSBhaXJjcmFmdCBieSBtYW51ZmFjdHVyZXJcclxuICAgICAgICBsZXQgZmlsdGVyZWRBaXJjcmFmdCA9IGdlb2ZlbmNlQWlyY3JhZnQuZmlsdGVyKFxyXG4gICAgICAgICAgKGFpcmNyYWZ0KSA9PlxyXG4gICAgICAgICAgICBhaXJjcmFmdC5NQU5VRkFDVFVSRVI/LnRvTG93ZXJDYXNlKCkgPT09XHJcbiAgICAgICAgICAgIHNlbGVjdGVkTWFudWZhY3R1cmVyLnRvTG93ZXJDYXNlKClcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyBGdXJ0aGVyIGZpbHRlciBieSBtb2RlbCBpZiBzZWxlY3RlZFxyXG4gICAgICAgIGlmIChzZWxlY3RlZE1vZGVsKSB7XHJcbiAgICAgICAgICBmaWx0ZXJlZEFpcmNyYWZ0ID0gZmlsdGVyZWRBaXJjcmFmdC5maWx0ZXIoXHJcbiAgICAgICAgICAgIChhaXJjcmFmdCkgPT5cclxuICAgICAgICAgICAgICBhaXJjcmFmdC5NT0RFTD8udG9Mb3dlckNhc2UoKSA9PT0gc2VsZWN0ZWRNb2RlbC50b0xvd2VyQ2FzZSgpXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coYEZvdW5kICR7ZmlsdGVyZWRBaXJjcmFmdC5sZW5ndGh9IG1hdGNoaW5nIGFpcmNyYWZ0YCk7XHJcblxyXG4gICAgICAgIGlmIChmaWx0ZXJlZEFpcmNyYWZ0Lmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgYWxlcnQoYE5vICR7c2VsZWN0ZWRNYW51ZmFjdHVyZXJ9IGFpcmNyYWZ0IGZvdW5kIGluIHRoaXMgYXJlYS5gKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENsZWFyIGRpc3BsYXkgZGF0YVxyXG4gICAgICAgIGlmIChjbGVhckdlb2ZlbmNlRGF0YSkge1xyXG4gICAgICAgICAgY2xlYXJHZW9mZW5jZURhdGEoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgZGlzcGxheVxyXG4gICAgICAgIHVwZGF0ZUdlb2ZlbmNlQWlyY3JhZnQoZmlsdGVyZWRBaXJjcmFmdCk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmlsdGVyaW5nIGFpcmNyYWZ0OicsIGVycm9yKTtcclxuICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICBzZXRMb2NhbExvYWRpbmcoZmFsc2UpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFJlc2V0IGFsbCBmaWx0ZXJzXHJcbiAgICBjb25zdCBjbGVhckFsbEZpbHRlcnMgPSAoKSA9PiB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdDbGVhcmluZyBhbGwgZmlsdGVycy4uLicpO1xyXG5cclxuICAgICAgLy8gMS4gUmVzZXQgZmlsdGVyIG1vZGVcclxuICAgICAgc2V0RmlsdGVyTW9kZSgnbWFudWZhY3R1cmVyJyk7XHJcblxyXG4gICAgICAvLyAyLiBVbmJsb2NrIEFQSSBjYWxscyB0aGF0IG1pZ2h0IGhhdmUgYmVlbiBibG9ja2VkXHJcbiAgICAgIG9wZW5Ta3lUcmFja2luZ1NlcnZpY2Uuc2V0QmxvY2tBbGxBcGlDYWxscyhmYWxzZSk7XHJcbiAgICAgIHNldEJsb2NrTWFudWZhY3R1cmVyQXBpQ2FsbHMoZmFsc2UpO1xyXG4gICAgICBzZXRJc01hbnVmYWN0dXJlckFwaUJsb2NrZWQoZmFsc2UpO1xyXG5cclxuICAgICAgLy8gMy4gQ2xlYXIgbWFudWZhY3R1cmVyIHNlbGVjdGlvblxyXG4gICAgICBzZWxlY3RNYW51ZmFjdHVyZXIobnVsbCk7XHJcbiAgICAgIHNlbGVjdE1vZGVsKG51bGwpO1xyXG5cclxuICAgICAgLy8gNC4gQ2xlYXIgZ2VvZmVuY2VcclxuICAgICAgc2V0R2VvZmVuY2VMb2NhdGlvbignJyk7XHJcbiAgICAgIHNldEdlb2ZlbmNlQ29vcmRpbmF0ZXMobnVsbCk7XHJcbiAgICAgIHNldEdlb2ZlbmNlQWlyY3JhZnQoW10pO1xyXG4gICAgICBzZXRHZW9mZW5jZUVuYWJsZWQoZmFsc2UpO1xyXG4gICAgICBzZXRJc0dlb2ZlbmNlQWN0aXZlKGZhbHNlKTtcclxuICAgICAgaWYgKHR5cGVvZiBjbGVhckdlb2ZlbmNlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgY2xlYXJHZW9mZW5jZSgpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0eXBlb2YgY2xlYXJHZW9mZW5jZURhdGEgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICBjbGVhckdlb2ZlbmNlRGF0YSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyA1LiBSZXNldCBvd25lciBmaWx0ZXJzIHRvIHNlbGVjdCBhbGxcclxuICAgICAgc2V0T3duZXJGaWx0ZXJzKFsuLi5hbGxPd25lclR5cGVzXSk7XHJcblxyXG4gICAgICAvLyA2LiBDbGVhciByZWdpb24gZmlsdGVyIHByb3Blcmx5XHJcbiAgICAgIHNldEFjdGl2ZVJlZ2lvbihudWxsKTtcclxuICAgICAgc2V0U2VsZWN0ZWRSZWdpb24oUmVnaW9uQ29kZS5HTE9CQUwpO1xyXG5cclxuICAgICAgLy8gQ2xlYXIgcmVnaW9uIG91dGxpbmUgZnJvbSBtYXBcclxuICAgICAgaWYgKHJlZ2lvbk91dGxpbmUpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgLy8gSGFuZGxlIGRpZmZlcmVudCBwb3NzaWJsZSBvYmplY3Qgc3RydWN0dXJlc1xyXG4gICAgICAgICAgaWYgKHR5cGVvZiByZWdpb25PdXRsaW5lLnJlbW92ZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICByZWdpb25PdXRsaW5lLnJlbW92ZSgpO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChcclxuICAgICAgICAgICAgcmVnaW9uT3V0bGluZS5yZWN0YW5nbGUgJiZcclxuICAgICAgICAgICAgdHlwZW9mIHJlZ2lvbk91dGxpbmUucmVjdGFuZ2xlLnJlbW92ZSA9PT0gJ2Z1bmN0aW9uJ1xyXG4gICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIHJlZ2lvbk91dGxpbmUucmVjdGFuZ2xlLnJlbW92ZSgpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIENsZWFyIGFueSBsYWJlbHMgYXNzb2NpYXRlZCB3aXRoIHRoZSByZWdpb25cclxuICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgcmVnaW9uT3V0bGluZS5sYWJlbCAmJlxyXG4gICAgICAgICAgICB0eXBlb2YgcmVnaW9uT3V0bGluZS5sYWJlbC5yZW1vdmUgPT09ICdmdW5jdGlvbidcclxuICAgICAgICAgICkge1xyXG4gICAgICAgICAgICByZWdpb25PdXRsaW5lLmxhYmVsLnJlbW92ZSgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZW1vdmluZyByZWdpb24gb3V0bGluZTonLCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBbHdheXMgcmVzZXQgdGhlIHJlZ2lvbiBvdXRsaW5lIHN0YXRlXHJcbiAgICAgICAgc2V0UmVnaW9uT3V0bGluZShudWxsKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gNy4gUmVzZXQgbWFwIHZpZXcgdG8gZ2xvYmFsXHJcbiAgICAgIGlmIChtYXBJbnN0YW5jZSkge1xyXG4gICAgICAgIC8vIFVzZSB0aGUgcHJlZGVmaW5lZCBjZW50ZXIgYW5kIHpvb20gbGV2ZWwgZnJvbSB5b3VyIG1hcCBjb25maWdcclxuICAgICAgICBtYXBJbnN0YW5jZS5zZXRWaWV3KE1BUF9DT05GSUcuQ0VOVEVSLCBNQVBfQ09ORklHLkRFRkFVTFRfWk9PTSk7XHJcbiAgICAgICAgbWFwSW5zdGFuY2UuaW52YWxpZGF0ZVNpemUoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gOC4gUmVzZXQgdG8gaW5pdGlhbCBhaXJjcmFmdCBkYXRhXHJcbiAgICAgIGlmICh0eXBlb2YgcmVzZXQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICByZXNldCgpO1xyXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmdWxsUmVmcmVzaCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIGZ1bGxSZWZyZXNoKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIDkuIENsb3NlIGFueSBvcGVuIGRyb3Bkb3duXHJcbiAgICAgIHNldEFjdGl2ZURyb3Bkb3duKG51bGwpO1xyXG5cclxuICAgICAgLy8gMTAuIFJlc2V0IHJhdGUgbGltaXRpbmcgc3RhdGVzXHJcbiAgICAgIHNldElzUmF0ZUxpbWl0ZWQoZmFsc2UpO1xyXG4gICAgICBzZXRSYXRlTGltaXRUaW1lcihudWxsKTtcclxuXHJcbiAgICAgIC8vIDExLiBDbGVhciBjb21iaW5lZCBtb2RlIHN0YXRlXHJcbiAgICAgIHNldENvbWJpbmVkTW9kZVJlYWR5KGZhbHNlKTtcclxuXHJcbiAgICAgIC8vIDEyLiBSZXNldCBzZWFyY2ggdGVybXNcclxuICAgICAgc2V0TWFudWZhY3R1cmVyU2VhcmNoVGVybSgnJyk7XHJcblxyXG4gICAgICAvLyAxMy4gRGlzcGF0Y2ggYSBjdXN0b20gZXZlbnQgdGhhdCBvdGhlciBjb21wb25lbnRzIGNhbiBsaXN0ZW4gZm9yXHJcbiAgICAgIGNvbnN0IGNsZWFyRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ3JpYmJvbi1maWx0ZXJzLWNsZWFyZWQnKTtcclxuICAgICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChjbGVhckV2ZW50KTtcclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKCdBbGwgZmlsdGVycyBjbGVhcmVkIHN1Y2Nlc3NmdWxseScpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgY29tYmluZWQgbG9hZGluZyBzdGF0ZVxyXG4gICAgY29uc3QgY29tYmluZWRMb2FkaW5nID0gbG9jYWxMb2FkaW5nO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIC8vIFN0YXRlXHJcbiAgICAgIGZpbHRlck1vZGUsXHJcbiAgICAgIGFjdGl2ZURyb3Bkb3duLFxyXG4gICAgICBzZWxlY3RlZE1hbnVmYWN0dXJlcixcclxuICAgICAgc2VsZWN0ZWRNb2RlbCxcclxuICAgICAgZ2VvZmVuY2VMb2NhdGlvbixcclxuICAgICAgZ2VvZmVuY2VSYWRpdXMsXHJcbiAgICAgIGlzR2VvZmVuY2VBY3RpdmUsXHJcbiAgICAgIGdlb2ZlbmNlQ29vcmRpbmF0ZXMsXHJcbiAgICAgIGdldFVzZXJMb2NhdGlvbixcclxuICAgICAgYWN0aXZlUmVnaW9uLFxyXG4gICAgICBvd25lckZpbHRlcnMsXHJcbiAgICAgIGFsbE93bmVyVHlwZXMsXHJcbiAgICAgIG1hbnVmYWN0dXJlclNlYXJjaFRlcm0sXHJcbiAgICAgIGNvbWJpbmVkTG9hZGluZyxcclxuICAgICAgaXNHZXR0aW5nTG9jYXRpb24sXHJcbiAgICAgIGRyb3Bkb3duUmVmcyxcclxuICAgICAgbG9jYWxMb2FkaW5nLFxyXG4gICAgICBpc1JhdGVMaW1pdGVkLFxyXG4gICAgICBzZWxlY3RlZFJlZ2lvbixcclxuICAgICAgaXNSZWZyZXNoaW5nLFxyXG4gICAgICBpc0dlb2ZlbmNlUGxhY2VtZW50TW9kZTogZmFsc2UsIC8vIEluaXRpYWxpemUgd2l0aCBhIGRlZmF1bHQgdmFsdWVcclxuXHJcbiAgICAgIC8vIE1ldGhvZHNcclxuICAgICAgdG9nZ2xlRHJvcGRvd24sXHJcbiAgICAgIHRvZ2dsZUZpbHRlck1vZGUsXHJcbiAgICAgIHNlbGVjdE1hbnVmYWN0dXJlckFuZENsb3NlLFxyXG4gICAgICBoYW5kbGVNb2RlbFNlbGVjdCxcclxuICAgICAgcHJvY2Vzc0dlb2ZlbmNlU2VhcmNoLFxyXG4gICAgICBoYW5kbGVPd25lckZpbHRlckNoYW5nZSxcclxuICAgICAgaGFuZGxlUmVnaW9uU2VsZWN0LFxyXG4gICAgICBzZXRNYW51ZmFjdHVyZXJTZWFyY2hUZXJtLFxyXG4gICAgICBzZXRHZW9mZW5jZUxvY2F0aW9uLFxyXG4gICAgICBzZXRHZW9mZW5jZVJhZGl1cyxcclxuICAgICAgdG9nZ2xlR2VvZmVuY2VTdGF0ZSxcclxuICAgICAgY2xlYXJBbGxGaWx0ZXJzLFxyXG4gICAgICBhcHBseUNvbWJpbmVkRmlsdGVycyxcclxuICAgICAgZ2V0QWlyY3JhZnRPd25lclR5cGUsXHJcbiAgICAgIHNldEdlb2ZlbmNlQ29vcmRpbmF0ZXMsXHJcbiAgICAgIHNldEdlb2ZlbmNlQ2VudGVyLFxyXG4gICAgICB1cGRhdGVHZW9mZW5jZUFpcmNyYWZ0LFxyXG5cclxuICAgICAgcmVmcmVzaFdpdGhGaWx0ZXJzOiAoKSA9PiB7XHJcbiAgICAgICAgLy8gSW1wbGVtZW50IHJlZnJlc2ggbG9naWMgaGVyZVxyXG4gICAgICAgIGlmICh0eXBlb2YgcmVmcmVzaFBvc2l0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgcmVmcmVzaFBvc2l0aW9ucygpLmNhdGNoKChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZWZyZXNoaW5nIHBvc2l0aW9uczonLCBlcnJvcik7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIHNldEFjdGl2ZURyb3Bkb3duLCAvLyBBZGQgdGhpcyBsaW5lIGlmIHlvdSBoYXZlIHRoaXMgZnVuY3Rpb25cclxuICAgIH07XHJcbiAgfTtcclxuXHJcbmZ1bmN0aW9uIGFwcGx5Q29tYmluZWRGaWx0ZXJzKCkge1xyXG4gIHRocm93IG5ldyBFcnJvcignRnVuY3Rpb24gbm90IGltcGxlbWVudGVkLicpO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZVJlZiIsInVzZUVmZmVjdCIsIlJlYWN0IiwiUmVnaW9uQ29kZSIsInVzZUVuaGFuY2VkTWFwQ29udGV4dCIsIm9wZW5Ta3lUcmFja2luZ1NlcnZpY2UiLCJNYXBib3hTZXJ2aWNlIiwiYWRhcHRHZW9mZW5jZUFpcmNyYWZ0IiwiZW5yaWNoR2VvZmVuY2VBaXJjcmFmdCIsInVzZUdlb2xvY2F0aW9uU2VydmljZXMiLCJnZXRBaXJjcmFmdE5lYXJMb2NhdGlvbiIsImdldEFpcmNyYWZ0TmVhclNlYXJjaGVkTG9jYXRpb24iLCJ1c2VHZW9sb2NhdGlvbiIsIk1BUF9DT05GSUciLCJnZXRCb3VuZHNCeVJlZ2lvbiIsImdldFpvb21MZXZlbEZvclJlZ2lvbiIsInVzZUZpbHRlckxvZ2ljIiwic2VsZWN0ZWRNYW51ZmFjdHVyZXIiLCJzZWxlY3RlZE1vZGVsIiwidG90YWxBY3RpdmUiLCJzZWxlY3RNYW51ZmFjdHVyZXIiLCJzZWxlY3RNb2RlbCIsInJlc2V0IiwiZnVsbFJlZnJlc2giLCJyZWZyZXNoUG9zaXRpb25zIiwibWFwSW5zdGFuY2UiLCJ1cGRhdGVBaXJjcmFmdERhdGEiLCJjbGVhckdlb2ZlbmNlRGF0YSIsInVwZGF0ZUdlb2ZlbmNlQWlyY3JhZnQiLCJibG9ja01hbnVmYWN0dXJlckFwaUNhbGxzIiwic2V0QmxvY2tNYW51ZmFjdHVyZXJBcGlDYWxscyIsImlzTWFudWZhY3R1cmVyQXBpQmxvY2tlZCIsInNldElzTWFudWZhY3R1cmVyQXBpQmxvY2tlZCIsImdlb2ZlbmNlQ2VudGVyIiwic2V0R2VvZmVuY2VDZW50ZXIiLCJ0b2dnbGVHZW9mZW5jZSIsImNsZWFyR2VvZmVuY2UiLCJkaXNwbGF5ZWRBaXJjcmFmdCIsImdlb2xvY2F0aW9uU2VydmljZXMiLCJsb2NhbExvYWRpbmciLCJzZXRMb2NhbExvYWRpbmciLCJmaWx0ZXJNb2RlIiwic2V0RmlsdGVyTW9kZSIsImFjdGl2ZURyb3Bkb3duIiwic2V0QWN0aXZlRHJvcGRvd24iLCJtYW51ZmFjdHVyZXJTZWFyY2hUZXJtIiwic2V0TWFudWZhY3R1cmVyU2VhcmNoVGVybSIsImlzUmVmcmVzaGluZyIsInNldElzUmVmcmVzaGluZyIsImlzUmF0ZUxpbWl0ZWQiLCJzZXRJc1JhdGVMaW1pdGVkIiwicmF0ZUxpbWl0VGltZXIiLCJzZXRSYXRlTGltaXRUaW1lciIsImlzR2V0dGluZ0xvY2F0aW9uIiwic2V0SXNHZXR0aW5nTG9jYXRpb24iLCJnZW9mZW5jZUxvY2F0aW9uIiwic2V0R2VvZmVuY2VMb2NhdGlvbiIsImdlb2ZlbmNlUmFkaXVzIiwic2V0R2VvZmVuY2VSYWRpdXMiLCJnZW9mZW5jZUNvb3JkaW5hdGVzIiwic2V0R2VvZmVuY2VDb29yZGluYXRlcyIsImdlb2ZlbmNlQWlyY3JhZnQiLCJzZXRHZW9mZW5jZUFpcmNyYWZ0IiwiZ2VvZmVuY2VFbmFibGVkIiwic2V0R2VvZmVuY2VFbmFibGVkIiwiaXNHZW9mZW5jZUFjdGl2ZSIsInNldElzR2VvZmVuY2VBY3RpdmUiLCJpc1NlYXJjaFJlYWR5Iiwic2V0SXNTZWFyY2hSZWFkeSIsImFjdGl2ZVJlZ2lvbiIsInNldEFjdGl2ZVJlZ2lvbiIsInJlZ2lvbk91dGxpbmUiLCJzZXRSZWdpb25PdXRsaW5lIiwic2VsZWN0ZWRSZWdpb24iLCJzZXRTZWxlY3RlZFJlZ2lvbiIsIkdMT0JBTCIsImNvbWJpbmVkTW9kZVJlYWR5Iiwic2V0Q29tYmluZWRNb2RlUmVhZHkiLCJhbGxPd25lclR5cGVzIiwib3duZXJGaWx0ZXJzIiwic2V0T3duZXJGaWx0ZXJzIiwiZHJvcGRvd25SZWZzIiwiZmlsdGVyIiwibWFudWZhY3R1cmVyIiwibW9kZWwiLCJsb2NhdGlvbiIsInJlZ2lvbiIsIm93bmVyIiwiYWN0aW9ucyIsImdlb2xvY2F0aW9uIiwiZ2V0VXNlckxvY2F0aW9uIiwiYWxlcnQiLCJwb3NpdGlvbiIsImdldEN1cnJlbnRQb3NpdGlvbiIsImxhdGl0dWRlIiwibG9uZ2l0dWRlIiwiY29vcmRzIiwibGF0IiwibG5nIiwidG9GaXhlZCIsImZldGNoZWRBaXJjcmFmdCIsImxlbmd0aCIsImFkYXB0ZWRBaXJjcmFmdCIsImVucmljaGVkQWlyY3JhZnQiLCJjdXJyZW50Wm9vbSIsImdldFpvb20iLCJ0YXJnZXRab29tIiwic2V0VmlldyIsImludmFsaWRhdGVTaXplIiwiZXJyb3IiLCJtZXNzYWdlIiwiaW5jbHVkZXMiLCJzdGF0dXMiLCJoYW5kbGVSYXRlTGltaXQiLCJjb25zb2xlIiwicHJvY2Vzc0dlb2ZlbmNlU2VhcmNoIiwic2V0QmxvY2tBbGxBcGlDYWxscyIsImxvZyIsInJldHJ5QWZ0ZXIiLCJsb2NhdGlvbnMiLCJzZWFyY2hMb2NhdGlvbldpdGhNYXBib3giLCJjb29yZGluYXRlcyIsIm5hbWUiLCJFcnJvciIsIk1BTlVGQUNUVVJFUiIsInVuZGVmaW5lZCIsInNldFRpbWVvdXQiLCJhcHBseUNvbWJpbmVkRmlsdGVycyIsInRvZ2dsZUdlb2ZlbmNlU3RhdGUiLCJlbmFibGVkIiwiaXNOYU4iLCJ3YXJuIiwidGltZXIiLCJjbGVhclRpbWVvdXQiLCJoYW5kbGVDbGlja091dHNpZGUiLCJldmVudCIsImlzT3V0c2lkZUFsbCIsIk9iamVjdCIsInZhbHVlcyIsImV2ZXJ5IiwicmVmIiwiY3VycmVudCIsImNvbnRhaW5zIiwidGFyZ2V0IiwiZG9jdW1lbnQiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInJlbW92ZSIsImhhbmRsZU1hcEdlb2ZlbmNlQ2xpY2siLCJjdXN0b21FdmVudCIsImRldGFpbCIsImxvY2F0aW9uTmFtZSIsImdldExvY2F0aW9uTmFtZUZyb21Db29yZGluYXRlcyIsInRvZ2dsZURyb3Bkb3duIiwiZHJvcGRvd24iLCJzdG9wUHJvcGFnYXRpb24iLCJ0b2dnbGVGaWx0ZXJNb2RlIiwibW9kZSIsImZpbHRlckFpcmNyYWZ0QnlSZWdpb24iLCJ0b1N0cmluZyIsImFpcmNyYWZ0V2l0aFZhbGlkQ29vcmRzIiwicGxhbmUiLCJmaWx0ZXJlZEJ5T3duZXIiLCJhaXJjcmFmdCIsImdldEFpcmNyYWZ0T3duZXJUeXBlIiwib3duZXJUeXBlIiwiVFlQRV9SRUdJU1RSQU5UIiwib3duZXJUeXBlVG9TdHJpbmciLCJ0eXBlIiwidHlwZU51bSIsInBhcnNlSW50Iiwib3duZXJUeXBlTWFwIiwiYXBwbHlPd25lclR5cGVGaWx0ZXIiLCJmaWx0ZXJzIiwiZmlsdGVyZWRBaXJjcmFmdCIsImhhbmRsZU93bmVyRmlsdGVyQ2hhbmdlIiwidXBkYXRlZEZpbHRlcnMiLCJyZXNldE93bmVyRmlsdGVycyIsImJvdW5kc0V4cHJlc3Npb24iLCJBcnJheSIsImlzQXJyYXkiLCJtaW5MYXQiLCJtaW5MbmciLCJtYXhMYXQiLCJtYXhMbmciLCJoYW5kbGVSZWdpb25TZWxlY3QiLCJib3VuZHMiLCJ6b29tTGV2ZWwiLCJzZXRab29tIiwib3B0aW9ucyIsInBhZGRpbmciLCJQQURESU5HIiwiREVGQVVMVCIsImZpdEJvdW5kcyIsImRyYXdSZWdpb25PdXRsaW5lIiwiY291bnRSZXNwb25zZSIsImZldGNoIiwib2siLCJjb3VudERhdGEiLCJqc29uIiwiY291bnQiLCJMIiwicmVxdWlyZSIsInJlY3RhbmdsZSIsImNvbG9yIiwid2VpZ2h0Iiwib3BhY2l0eSIsImZpbGwiLCJmaWxsQ29sb3IiLCJmaWxsT3BhY2l0eSIsImRhc2hBcnJheSIsImludGVyYWN0aXZlIiwiYWRkVG8iLCJzZWxlY3RNYW51ZmFjdHVyZXJBbmRDbG9zZSIsInZhbHVlIiwiZmV0Y2hBaXJjcmFmdEJ5UmVnaW9uQW5kTWFudWZhY3R1cmVyIiwiZmV0Y2hNYW51ZmFjdHVyZXJEYXRhIiwiY2F0Y2giLCJwYWdlIiwibGltaXQiLCJyZXNwb25zZSIsImVuY29kZVVSSUNvbXBvbmVudCIsImRhdGEiLCJhaXJjcmFmdERhdGEiLCJzdGF0dXNUZXh0IiwiZXh0ZW5kZWRBaXJjcmFmdCIsIm1hcCIsIlRZUEVfQUlSQ1JBRlQiLCJpc0dvdmVybm1lbnQiLCJPUEVSQVRPUiIsInRvTG93ZXJDYXNlIiwiUkVHSU9OIiwiaGFuZGxlTW9kZWxTZWxlY3QiLCJNT0RFTCIsImNsZWFyQWxsRmlsdGVycyIsImxhYmVsIiwiQ0VOVEVSIiwiREVGQVVMVF9aT09NIiwiY2xlYXJFdmVudCIsIkN1c3RvbUV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsImNvbWJpbmVkTG9hZGluZyIsImlzR2VvZmVuY2VQbGFjZW1lbnRNb2RlIiwicmVmcmVzaFdpdGhGaWx0ZXJzIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/tracking/hooks/useFilterLogic.ts\n"));

/***/ })

});
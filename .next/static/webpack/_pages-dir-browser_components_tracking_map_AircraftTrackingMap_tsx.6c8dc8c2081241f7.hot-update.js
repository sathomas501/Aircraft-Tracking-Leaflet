"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_pages-dir-browser_components_tracking_map_AircraftTrackingMap_tsx",{

/***/ "(pages-dir-browser)/./components/tracking/hooks/useGeofencePanel.ts":
/*!*******************************************************!*\
  !*** ./components/tracking/hooks/useGeofencePanel.ts ***!
  \*******************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useGeofencePanel: () => (/* binding */ useGeofencePanel)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_services_MapboxService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../lib/services/MapboxService */ \"(pages-dir-browser)/./lib/services/MapboxService.ts\");\n/* harmony import */ var _lib_services_geofencing__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../lib/services/geofencing */ \"(pages-dir-browser)/./lib/services/geofencing.ts\");\n// hooks/useGeofencePanel.ts\n\n\n\nfunction useGeofencePanel(options) {\n    const { geofenceRadius, setGeofenceLocation, setGeofenceCoordinates, setGeofenceCenter, processGeofenceSearch, updateGeofenceAircraft, isGeofenceActive, toggleGeofenceState, setActiveDropdown, mapInstance } = options;\n    // Panel UI state\n    const [panelPosition, setPanelPosition] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        x: window.innerWidth - 340,\n        y: 100\n    });\n    const [showPanel, setShowPanel] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [tempCoordinates, setTempCoordinates] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [isSearching, setIsSearching] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [locationName, setLocationName] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [isLoadingLocation, setIsLoadingLocation] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    // Default position for the panel - right side of screen\n    // Panel control methods\n    const openPanel = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useGeofencePanel.useCallback[openPanel]\": ()=>{\n            // Calculate position on right side of screen with some margin\n            const rightPosition = window.innerWidth - 340; // 300px width + 40px margin\n            const topPosition = 100; // 100px from top\n            // Update panel position\n            setPanelPosition({\n                x: rightPosition,\n                y: topPosition\n            });\n            // Show the panel\n            setShowPanel(true);\n            // Close dropdown\n            options.setActiveDropdown(null);\n            // Dispatch event for map mode\n            const event = new CustomEvent('enable-geofence-placement', {\n                detail: {\n                    active: true\n                }\n            });\n            document.dispatchEvent(event);\n        }\n    }[\"useGeofencePanel.useCallback[openPanel]\"], [\n        options.setActiveDropdown\n    ]);\n    const closePanel = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useGeofencePanel.useCallback[closePanel]\": ()=>{\n            setShowPanel(false);\n            setTempCoordinates(null);\n            setLocationName(null);\n            // Dispatch event to notify map that we're exiting geofence placement mode\n            const event = new CustomEvent('enable-geofence-placement', {\n                detail: {\n                    active: false\n                }\n            });\n            document.dispatchEvent(event);\n        }\n    }[\"useGeofencePanel.useCallback[closePanel]\"], []);\n    const resetPanel = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useGeofencePanel.useCallback[resetPanel]\": ()=>{\n            setTempCoordinates(null);\n            setLocationName(null);\n        }\n    }[\"useGeofencePanel.useCallback[resetPanel]\"], []);\n    // Make sure any panel action keeps the dropdown closed\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useGeofencePanel.useEffect\": ()=>{\n            if (showPanel) {\n                // Keep dropdown closed while panel is open\n                options.setActiveDropdown(null);\n            }\n        }\n    }[\"useGeofencePanel.useEffect\"], [\n        showPanel,\n        options.setActiveDropdown\n    ]);\n    // Fetch location name whenever coordinates change\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useGeofencePanel.useEffect\": ()=>{\n            if (!tempCoordinates) return;\n            setIsLoadingLocation(true);\n            _lib_services_MapboxService__WEBPACK_IMPORTED_MODULE_1__.MapboxService.getLocationNameFromCoordinates(tempCoordinates.lat, tempCoordinates.lng).then({\n                \"useGeofencePanel.useEffect\": (name)=>{\n                    setLocationName(name);\n                }\n            }[\"useGeofencePanel.useEffect\"]).catch({\n                \"useGeofencePanel.useEffect\": (error)=>{\n                    console.error('Error fetching location name:', error);\n                }\n            }[\"useGeofencePanel.useEffect\"]).finally({\n                \"useGeofencePanel.useEffect\": ()=>{\n                    setIsLoadingLocation(false);\n                }\n            }[\"useGeofencePanel.useEffect\"]);\n        }\n    }[\"useGeofencePanel.useEffect\"], [\n        tempCoordinates\n    ]);\n    // Handle search from panel\n    const handlePanelSearch = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useGeofencePanel.useCallback[handlePanelSearch]\": async (lat, lng)=>{\n            if (!lat || !lng || isSearching) return;\n            setIsSearching(true);\n            try {\n                // Get location name\n                const locationName = await _lib_services_MapboxService__WEBPACK_IMPORTED_MODULE_1__.MapboxService.getLocationNameFromCoordinates(lat, lng);\n                // Set location in filter logic\n                if (locationName) {\n                    setGeofenceLocation(locationName);\n                } else {\n                    // Fallback to coordinates if no name found\n                    setGeofenceLocation(\"\".concat(lat.toFixed(4), \", \").concat(lng.toFixed(4)));\n                }\n                // Update coordinates\n                setGeofenceCoordinates({\n                    lat,\n                    lng\n                });\n                setGeofenceCenter({\n                    lat,\n                    lng\n                });\n                // Get aircraft data near this location\n                const fetchedAircraft = await (0,_lib_services_geofencing__WEBPACK_IMPORTED_MODULE_2__.getAircraftNearLocation)(lat, lng, geofenceRadius || 25);\n                if (fetchedAircraft.length > 0) {\n                    // Update aircraft data\n                    updateGeofenceAircraft(fetchedAircraft);\n                    // Activate geofence if not already active\n                    if (!isGeofenceActive) {\n                        toggleGeofenceState(true);\n                    }\n                } else {\n                    console.log('No aircraft found near clicked location');\n                }\n                // Center the map on this location\n                if (mapInstance && typeof mapInstance.setView === 'function') {\n                    // Get current zoom level\n                    const currentZoom = mapInstance.getZoom();\n                    // Use appropriate zoom level based on current view\n                    const targetZoom = currentZoom <= 7 ? 9 : currentZoom;\n                    // Set view to the coordinates\n                    mapInstance.setView([\n                        lat,\n                        lng\n                    ], targetZoom);\n                    mapInstance.invalidateSize();\n                }\n            } catch (error) {\n                console.error('Error searching from panel:', error);\n            } finally{\n                setIsSearching(false);\n            }\n        }\n    }[\"useGeofencePanel.useCallback[handlePanelSearch]\"], [\n        isSearching,\n        geofenceRadius,\n        setGeofenceLocation,\n        setGeofenceCoordinates,\n        setGeofenceCenter,\n        updateGeofenceAircraft,\n        isGeofenceActive,\n        toggleGeofenceState,\n        mapInstance\n    ]);\n    // Listen for map clicks when panel is open\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useGeofencePanel.useEffect\": ()=>{\n            if (!showPanel) return;\n            const handleMapClick = {\n                \"useGeofencePanel.useEffect.handleMapClick\": (e)=>{\n                    const { lat, lng } = e.detail;\n                    setTempCoordinates({\n                        lat,\n                        lng\n                    });\n                }\n            }[\"useGeofencePanel.useEffect.handleMapClick\"];\n            // Add event listener for map clicks\n            document.addEventListener('map-geofence-click', handleMapClick);\n            // Cleanup listener when component unmounts or panel closes\n            return ({\n                \"useGeofencePanel.useEffect\": ()=>{\n                    document.removeEventListener('map-geofence-click', handleMapClick);\n                }\n            })[\"useGeofencePanel.useEffect\"];\n        }\n    }[\"useGeofencePanel.useEffect\"], [\n        showPanel\n    ]);\n    // Listen for the clear all filters event\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useGeofencePanel.useEffect\": ()=>{\n            const handleClearAllFilters = {\n                \"useGeofencePanel.useEffect.handleClearAllFilters\": ()=>{\n                    // Close the floating panel when filters are cleared\n                    if (showPanel) {\n                        closePanel();\n                    }\n                }\n            }[\"useGeofencePanel.useEffect.handleClearAllFilters\"];\n            // Add event listener for the clear all filters event\n            document.addEventListener('ribbon-filters-cleared', handleClearAllFilters);\n            // Clean up\n            return ({\n                \"useGeofencePanel.useEffect\": ()=>{\n                    document.removeEventListener('ribbon-filters-cleared', handleClearAllFilters);\n                }\n            })[\"useGeofencePanel.useEffect\"];\n        }\n    }[\"useGeofencePanel.useEffect\"], [\n        showPanel,\n        closePanel\n    ]);\n    return {\n        showPanel,\n        tempCoordinates,\n        isSearching,\n        locationName,\n        isLoadingLocation,\n        setTempCoordinates,\n        openPanel,\n        closePanel,\n        resetPanel,\n        handlePanelSearch\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvdHJhY2tpbmcvaG9va3MvdXNlR2VvZmVuY2VQYW5lbC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLDRCQUE0QjtBQUM2QjtBQUNXO0FBQ087QUFvQnBFLFNBQVNLLGlCQUFpQkMsT0FBNkI7SUFDNUQsTUFBTSxFQUNKQyxjQUFjLEVBQ2RDLG1CQUFtQixFQUNuQkMsc0JBQXNCLEVBQ3RCQyxpQkFBaUIsRUFDakJDLHFCQUFxQixFQUNyQkMsc0JBQXNCLEVBQ3RCQyxnQkFBZ0IsRUFDaEJDLG1CQUFtQixFQUNuQkMsaUJBQWlCLEVBQ2pCQyxXQUFXLEVBQ1osR0FBR1Y7SUFFSixpQkFBaUI7SUFDakIsTUFBTSxDQUFDVyxlQUFlQyxpQkFBaUIsR0FBR2xCLCtDQUFRQSxDQUFDO1FBQ2pEbUIsR0FBR0MsT0FBT0MsVUFBVSxHQUFHO1FBQ3ZCQyxHQUFHO0lBQ0w7SUFDQSxNQUFNLENBQUNDLFdBQVdDLGFBQWEsR0FBR3hCLCtDQUFRQSxDQUFDO0lBQzNDLE1BQU0sQ0FBQ3lCLGlCQUFpQkMsbUJBQW1CLEdBQUcxQiwrQ0FBUUEsQ0FDcEQ7SUFFRixNQUFNLENBQUMyQixhQUFhQyxlQUFlLEdBQUc1QiwrQ0FBUUEsQ0FBQztJQUMvQyxNQUFNLENBQUM2QixjQUFjQyxnQkFBZ0IsR0FBRzlCLCtDQUFRQSxDQUFnQjtJQUNoRSxNQUFNLENBQUMrQixtQkFBbUJDLHFCQUFxQixHQUFHaEMsK0NBQVFBLENBQUM7SUFDM0Qsd0RBQXdEO0lBRXhELHdCQUF3QjtJQUN4QixNQUFNaUMsWUFBWS9CLGtEQUFXQTttREFBQztZQUM1Qiw4REFBOEQ7WUFDOUQsTUFBTWdDLGdCQUFnQmQsT0FBT0MsVUFBVSxHQUFHLEtBQUssNEJBQTRCO1lBQzNFLE1BQU1jLGNBQWMsS0FBSyxpQkFBaUI7WUFFMUMsd0JBQXdCO1lBQ3hCakIsaUJBQWlCO2dCQUFFQyxHQUFHZTtnQkFBZVosR0FBR2E7WUFBWTtZQUVwRCxpQkFBaUI7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RG9jdW1lbnRzXFxQcm9qZWN0c1xcYWlyY3JhZnQtdHJhY2tpbmdcXGNvbXBvbmVudHNcXHRyYWNraW5nXFxob29rc1xcdXNlR2VvZmVuY2VQYW5lbC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBob29rcy91c2VHZW9mZW5jZVBhbmVsLnRzXHJcbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyBNYXBib3hTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vLi4vbGliL3NlcnZpY2VzL01hcGJveFNlcnZpY2UnO1xyXG5pbXBvcnQgeyBnZXRBaXJjcmFmdE5lYXJMb2NhdGlvbiB9IGZyb20gJy4uLy4uLy4uL2xpYi9zZXJ2aWNlcy9nZW9mZW5jaW5nJztcclxuXHJcbmludGVyZmFjZSBDb29yZGluYXRlcyB7XHJcbiAgbGF0OiBudW1iZXI7XHJcbiAgbG5nOiBudW1iZXI7XHJcbn1cclxuXHJcbmludGVyZmFjZSBHZW9mZW5jZVBhbmVsT3B0aW9ucyB7XHJcbiAgZ2VvZmVuY2VSYWRpdXM6IG51bWJlcjtcclxuICBzZXRHZW9mZW5jZUxvY2F0aW9uOiAobG9jYXRpb246IHN0cmluZykgPT4gdm9pZDtcclxuICBzZXRHZW9mZW5jZUNvb3JkaW5hdGVzOiAoY29vcmRpbmF0ZXM6IENvb3JkaW5hdGVzIHwgbnVsbCkgPT4gdm9pZDtcclxuICBzZXRHZW9mZW5jZUNlbnRlcjogKGNvb3JkaW5hdGVzOiBDb29yZGluYXRlcykgPT4gdm9pZDtcclxuICB1cGRhdGVHZW9mZW5jZUFpcmNyYWZ0OiAoYWlyY3JhZnQ6IGFueVtdKSA9PiB2b2lkO1xyXG4gIGlzR2VvZmVuY2VBY3RpdmU6IGJvb2xlYW47XHJcbiAgcHJvY2Vzc0dlb2ZlbmNlU2VhcmNoOiAoKSA9PiB2b2lkO1xyXG4gIHRvZ2dsZUdlb2ZlbmNlU3RhdGU6IChhY3RpdmU6IGJvb2xlYW4pID0+IHZvaWQ7XHJcbiAgc2V0QWN0aXZlRHJvcGRvd246IChkcm9wZG93bjogc3RyaW5nIHwgbnVsbCkgPT4gdm9pZDtcclxuICBtYXBJbnN0YW5jZTogYW55O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlR2VvZmVuY2VQYW5lbChvcHRpb25zOiBHZW9mZW5jZVBhbmVsT3B0aW9ucykge1xyXG4gIGNvbnN0IHtcclxuICAgIGdlb2ZlbmNlUmFkaXVzLFxyXG4gICAgc2V0R2VvZmVuY2VMb2NhdGlvbixcclxuICAgIHNldEdlb2ZlbmNlQ29vcmRpbmF0ZXMsXHJcbiAgICBzZXRHZW9mZW5jZUNlbnRlcixcclxuICAgIHByb2Nlc3NHZW9mZW5jZVNlYXJjaCxcclxuICAgIHVwZGF0ZUdlb2ZlbmNlQWlyY3JhZnQsXHJcbiAgICBpc0dlb2ZlbmNlQWN0aXZlLFxyXG4gICAgdG9nZ2xlR2VvZmVuY2VTdGF0ZSxcclxuICAgIHNldEFjdGl2ZURyb3Bkb3duLFxyXG4gICAgbWFwSW5zdGFuY2UsXHJcbiAgfSA9IG9wdGlvbnM7XHJcblxyXG4gIC8vIFBhbmVsIFVJIHN0YXRlXHJcbiAgY29uc3QgW3BhbmVsUG9zaXRpb24sIHNldFBhbmVsUG9zaXRpb25dID0gdXNlU3RhdGUoe1xyXG4gICAgeDogd2luZG93LmlubmVyV2lkdGggLSAzNDAsXHJcbiAgICB5OiAxMDAsXHJcbiAgfSk7XHJcbiAgY29uc3QgW3Nob3dQYW5lbCwgc2V0U2hvd1BhbmVsXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICBjb25zdCBbdGVtcENvb3JkaW5hdGVzLCBzZXRUZW1wQ29vcmRpbmF0ZXNdID0gdXNlU3RhdGU8Q29vcmRpbmF0ZXMgfCBudWxsPihcclxuICAgIG51bGxcclxuICApO1xyXG4gIGNvbnN0IFtpc1NlYXJjaGluZywgc2V0SXNTZWFyY2hpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gIGNvbnN0IFtsb2NhdGlvbk5hbWUsIHNldExvY2F0aW9uTmFtZV0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcclxuICBjb25zdCBbaXNMb2FkaW5nTG9jYXRpb24sIHNldElzTG9hZGluZ0xvY2F0aW9uXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAvLyBEZWZhdWx0IHBvc2l0aW9uIGZvciB0aGUgcGFuZWwgLSByaWdodCBzaWRlIG9mIHNjcmVlblxyXG5cclxuICAvLyBQYW5lbCBjb250cm9sIG1ldGhvZHNcclxuICBjb25zdCBvcGVuUGFuZWwgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAvLyBDYWxjdWxhdGUgcG9zaXRpb24gb24gcmlnaHQgc2lkZSBvZiBzY3JlZW4gd2l0aCBzb21lIG1hcmdpblxyXG4gICAgY29uc3QgcmlnaHRQb3NpdGlvbiA9IHdpbmRvdy5pbm5lcldpZHRoIC0gMzQwOyAvLyAzMDBweCB3aWR0aCArIDQwcHggbWFyZ2luXHJcbiAgICBjb25zdCB0b3BQb3NpdGlvbiA9IDEwMDsgLy8gMTAwcHggZnJvbSB0b3BcclxuXHJcbiAgICAvLyBVcGRhdGUgcGFuZWwgcG9zaXRpb25cclxuICAgIHNldFBhbmVsUG9zaXRpb24oeyB4OiByaWdodFBvc2l0aW9uLCB5OiB0b3BQb3NpdGlvbiB9KTtcclxuXHJcbiAgICAvLyBTaG93IHRoZSBwYW5lbFxyXG4gICAgc2V0U2hvd1BhbmVsKHRydWUpO1xyXG5cclxuICAgIC8vIENsb3NlIGRyb3Bkb3duXHJcbiAgICBvcHRpb25zLnNldEFjdGl2ZURyb3Bkb3duKG51bGwpO1xyXG5cclxuICAgIC8vIERpc3BhdGNoIGV2ZW50IGZvciBtYXAgbW9kZVxyXG4gICAgY29uc3QgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2VuYWJsZS1nZW9mZW5jZS1wbGFjZW1lbnQnLCB7XHJcbiAgICAgIGRldGFpbDogeyBhY3RpdmU6IHRydWUgfSxcclxuICAgIH0pO1xyXG4gICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XHJcbiAgfSwgW29wdGlvbnMuc2V0QWN0aXZlRHJvcGRvd25dKTtcclxuXHJcbiAgY29uc3QgY2xvc2VQYW5lbCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgIHNldFNob3dQYW5lbChmYWxzZSk7XHJcbiAgICBzZXRUZW1wQ29vcmRpbmF0ZXMobnVsbCk7XHJcbiAgICBzZXRMb2NhdGlvbk5hbWUobnVsbCk7XHJcblxyXG4gICAgLy8gRGlzcGF0Y2ggZXZlbnQgdG8gbm90aWZ5IG1hcCB0aGF0IHdlJ3JlIGV4aXRpbmcgZ2VvZmVuY2UgcGxhY2VtZW50IG1vZGVcclxuICAgIGNvbnN0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdlbmFibGUtZ2VvZmVuY2UtcGxhY2VtZW50Jywge1xyXG4gICAgICBkZXRhaWw6IHsgYWN0aXZlOiBmYWxzZSB9LFxyXG4gICAgfSk7XHJcbiAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcclxuICB9LCBbXSk7XHJcblxyXG4gIGNvbnN0IHJlc2V0UGFuZWwgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICBzZXRUZW1wQ29vcmRpbmF0ZXMobnVsbCk7XHJcbiAgICBzZXRMb2NhdGlvbk5hbWUobnVsbCk7XHJcbiAgfSwgW10pO1xyXG5cclxuICAvLyBNYWtlIHN1cmUgYW55IHBhbmVsIGFjdGlvbiBrZWVwcyB0aGUgZHJvcGRvd24gY2xvc2VkXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmIChzaG93UGFuZWwpIHtcclxuICAgICAgLy8gS2VlcCBkcm9wZG93biBjbG9zZWQgd2hpbGUgcGFuZWwgaXMgb3BlblxyXG4gICAgICBvcHRpb25zLnNldEFjdGl2ZURyb3Bkb3duKG51bGwpO1xyXG4gICAgfVxyXG4gIH0sIFtzaG93UGFuZWwsIG9wdGlvbnMuc2V0QWN0aXZlRHJvcGRvd25dKTtcclxuXHJcbiAgLy8gRmV0Y2ggbG9jYXRpb24gbmFtZSB3aGVuZXZlciBjb29yZGluYXRlcyBjaGFuZ2VcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKCF0ZW1wQ29vcmRpbmF0ZXMpIHJldHVybjtcclxuXHJcbiAgICBzZXRJc0xvYWRpbmdMb2NhdGlvbih0cnVlKTtcclxuXHJcbiAgICBNYXBib3hTZXJ2aWNlLmdldExvY2F0aW9uTmFtZUZyb21Db29yZGluYXRlcyhcclxuICAgICAgdGVtcENvb3JkaW5hdGVzLmxhdCxcclxuICAgICAgdGVtcENvb3JkaW5hdGVzLmxuZ1xyXG4gICAgKVxyXG4gICAgICAudGhlbigobmFtZSkgPT4ge1xyXG4gICAgICAgIHNldExvY2F0aW9uTmFtZShuYW1lKTtcclxuICAgICAgfSlcclxuICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGxvY2F0aW9uIG5hbWU6JywgZXJyb3IpO1xyXG4gICAgICB9KVxyXG4gICAgICAuZmluYWxseSgoKSA9PiB7XHJcbiAgICAgICAgc2V0SXNMb2FkaW5nTG9jYXRpb24oZmFsc2UpO1xyXG4gICAgICB9KTtcclxuICB9LCBbdGVtcENvb3JkaW5hdGVzXSk7XHJcblxyXG4gIC8vIEhhbmRsZSBzZWFyY2ggZnJvbSBwYW5lbFxyXG4gIGNvbnN0IGhhbmRsZVBhbmVsU2VhcmNoID0gdXNlQ2FsbGJhY2soXHJcbiAgICBhc3luYyAobGF0OiBudW1iZXIsIGxuZzogbnVtYmVyKSA9PiB7XHJcbiAgICAgIGlmICghbGF0IHx8ICFsbmcgfHwgaXNTZWFyY2hpbmcpIHJldHVybjtcclxuXHJcbiAgICAgIHNldElzU2VhcmNoaW5nKHRydWUpO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIC8vIEdldCBsb2NhdGlvbiBuYW1lXHJcbiAgICAgICAgY29uc3QgbG9jYXRpb25OYW1lID0gYXdhaXQgTWFwYm94U2VydmljZS5nZXRMb2NhdGlvbk5hbWVGcm9tQ29vcmRpbmF0ZXMoXHJcbiAgICAgICAgICBsYXQsXHJcbiAgICAgICAgICBsbmdcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyBTZXQgbG9jYXRpb24gaW4gZmlsdGVyIGxvZ2ljXHJcbiAgICAgICAgaWYgKGxvY2F0aW9uTmFtZSkge1xyXG4gICAgICAgICAgc2V0R2VvZmVuY2VMb2NhdGlvbihsb2NhdGlvbk5hbWUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBGYWxsYmFjayB0byBjb29yZGluYXRlcyBpZiBubyBuYW1lIGZvdW5kXHJcbiAgICAgICAgICBzZXRHZW9mZW5jZUxvY2F0aW9uKGAke2xhdC50b0ZpeGVkKDQpfSwgJHtsbmcudG9GaXhlZCg0KX1gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSBjb29yZGluYXRlc1xyXG4gICAgICAgIHNldEdlb2ZlbmNlQ29vcmRpbmF0ZXMoeyBsYXQsIGxuZyB9KTtcclxuICAgICAgICBzZXRHZW9mZW5jZUNlbnRlcih7IGxhdCwgbG5nIH0pO1xyXG5cclxuICAgICAgICAvLyBHZXQgYWlyY3JhZnQgZGF0YSBuZWFyIHRoaXMgbG9jYXRpb25cclxuICAgICAgICBjb25zdCBmZXRjaGVkQWlyY3JhZnQgPSBhd2FpdCBnZXRBaXJjcmFmdE5lYXJMb2NhdGlvbihcclxuICAgICAgICAgIGxhdCxcclxuICAgICAgICAgIGxuZyxcclxuICAgICAgICAgIGdlb2ZlbmNlUmFkaXVzIHx8IDI1XHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgaWYgKGZldGNoZWRBaXJjcmFmdC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAvLyBVcGRhdGUgYWlyY3JhZnQgZGF0YVxyXG4gICAgICAgICAgdXBkYXRlR2VvZmVuY2VBaXJjcmFmdChmZXRjaGVkQWlyY3JhZnQpO1xyXG5cclxuICAgICAgICAgIC8vIEFjdGl2YXRlIGdlb2ZlbmNlIGlmIG5vdCBhbHJlYWR5IGFjdGl2ZVxyXG4gICAgICAgICAgaWYgKCFpc0dlb2ZlbmNlQWN0aXZlKSB7XHJcbiAgICAgICAgICAgIHRvZ2dsZUdlb2ZlbmNlU3RhdGUodHJ1ZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKCdObyBhaXJjcmFmdCBmb3VuZCBuZWFyIGNsaWNrZWQgbG9jYXRpb24nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENlbnRlciB0aGUgbWFwIG9uIHRoaXMgbG9jYXRpb25cclxuICAgICAgICBpZiAobWFwSW5zdGFuY2UgJiYgdHlwZW9mIG1hcEluc3RhbmNlLnNldFZpZXcgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgIC8vIEdldCBjdXJyZW50IHpvb20gbGV2ZWxcclxuICAgICAgICAgIGNvbnN0IGN1cnJlbnRab29tID0gbWFwSW5zdGFuY2UuZ2V0Wm9vbSgpO1xyXG4gICAgICAgICAgLy8gVXNlIGFwcHJvcHJpYXRlIHpvb20gbGV2ZWwgYmFzZWQgb24gY3VycmVudCB2aWV3XHJcbiAgICAgICAgICBjb25zdCB0YXJnZXRab29tID0gY3VycmVudFpvb20gPD0gNyA/IDkgOiBjdXJyZW50Wm9vbTtcclxuXHJcbiAgICAgICAgICAvLyBTZXQgdmlldyB0byB0aGUgY29vcmRpbmF0ZXNcclxuICAgICAgICAgIG1hcEluc3RhbmNlLnNldFZpZXcoW2xhdCwgbG5nXSwgdGFyZ2V0Wm9vbSk7XHJcbiAgICAgICAgICBtYXBJbnN0YW5jZS5pbnZhbGlkYXRlU2l6ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzZWFyY2hpbmcgZnJvbSBwYW5lbDonLCBlcnJvcik7XHJcbiAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgc2V0SXNTZWFyY2hpbmcoZmFsc2UpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgW1xyXG4gICAgICBpc1NlYXJjaGluZyxcclxuICAgICAgZ2VvZmVuY2VSYWRpdXMsXHJcbiAgICAgIHNldEdlb2ZlbmNlTG9jYXRpb24sXHJcbiAgICAgIHNldEdlb2ZlbmNlQ29vcmRpbmF0ZXMsXHJcbiAgICAgIHNldEdlb2ZlbmNlQ2VudGVyLFxyXG4gICAgICB1cGRhdGVHZW9mZW5jZUFpcmNyYWZ0LFxyXG4gICAgICBpc0dlb2ZlbmNlQWN0aXZlLFxyXG4gICAgICB0b2dnbGVHZW9mZW5jZVN0YXRlLFxyXG4gICAgICBtYXBJbnN0YW5jZSxcclxuICAgIF1cclxuICApO1xyXG5cclxuICAvLyBMaXN0ZW4gZm9yIG1hcCBjbGlja3Mgd2hlbiBwYW5lbCBpcyBvcGVuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmICghc2hvd1BhbmVsKSByZXR1cm47XHJcblxyXG4gICAgY29uc3QgaGFuZGxlTWFwQ2xpY2sgPSAoZTogQ3VzdG9tRXZlbnQ8eyBsYXQ6IG51bWJlcjsgbG5nOiBudW1iZXIgfT4pID0+IHtcclxuICAgICAgY29uc3QgeyBsYXQsIGxuZyB9ID0gZS5kZXRhaWw7XHJcbiAgICAgIHNldFRlbXBDb29yZGluYXRlcyh7IGxhdCwgbG5nIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBBZGQgZXZlbnQgbGlzdGVuZXIgZm9yIG1hcCBjbGlja3NcclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXHJcbiAgICAgICdtYXAtZ2VvZmVuY2UtY2xpY2snLFxyXG4gICAgICBoYW5kbGVNYXBDbGljayBhcyBFdmVudExpc3RlbmVyXHJcbiAgICApO1xyXG5cclxuICAgIC8vIENsZWFudXAgbGlzdGVuZXIgd2hlbiBjb21wb25lbnQgdW5tb3VudHMgb3IgcGFuZWwgY2xvc2VzXHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFxyXG4gICAgICAgICdtYXAtZ2VvZmVuY2UtY2xpY2snLFxyXG4gICAgICAgIGhhbmRsZU1hcENsaWNrIGFzIEV2ZW50TGlzdGVuZXJcclxuICAgICAgKTtcclxuICAgIH07XHJcbiAgfSwgW3Nob3dQYW5lbF0pO1xyXG5cclxuICAvLyBMaXN0ZW4gZm9yIHRoZSBjbGVhciBhbGwgZmlsdGVycyBldmVudFxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBjb25zdCBoYW5kbGVDbGVhckFsbEZpbHRlcnMgPSAoKSA9PiB7XHJcbiAgICAgIC8vIENsb3NlIHRoZSBmbG9hdGluZyBwYW5lbCB3aGVuIGZpbHRlcnMgYXJlIGNsZWFyZWRcclxuICAgICAgaWYgKHNob3dQYW5lbCkge1xyXG4gICAgICAgIGNsb3NlUGFuZWwoKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBBZGQgZXZlbnQgbGlzdGVuZXIgZm9yIHRoZSBjbGVhciBhbGwgZmlsdGVycyBldmVudFxyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncmliYm9uLWZpbHRlcnMtY2xlYXJlZCcsIGhhbmRsZUNsZWFyQWxsRmlsdGVycyk7XHJcblxyXG4gICAgLy8gQ2xlYW4gdXBcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXHJcbiAgICAgICAgJ3JpYmJvbi1maWx0ZXJzLWNsZWFyZWQnLFxyXG4gICAgICAgIGhhbmRsZUNsZWFyQWxsRmlsdGVyc1xyXG4gICAgICApO1xyXG4gICAgfTtcclxuICB9LCBbc2hvd1BhbmVsLCBjbG9zZVBhbmVsXSk7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBzaG93UGFuZWwsXHJcbiAgICB0ZW1wQ29vcmRpbmF0ZXMsXHJcbiAgICBpc1NlYXJjaGluZyxcclxuICAgIGxvY2F0aW9uTmFtZSxcclxuICAgIGlzTG9hZGluZ0xvY2F0aW9uLFxyXG4gICAgc2V0VGVtcENvb3JkaW5hdGVzLFxyXG4gICAgb3BlblBhbmVsLFxyXG4gICAgY2xvc2VQYW5lbCxcclxuICAgIHJlc2V0UGFuZWwsXHJcbiAgICBoYW5kbGVQYW5lbFNlYXJjaCxcclxuICB9O1xyXG59XHJcbiJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZUNhbGxiYWNrIiwiTWFwYm94U2VydmljZSIsImdldEFpcmNyYWZ0TmVhckxvY2F0aW9uIiwidXNlR2VvZmVuY2VQYW5lbCIsIm9wdGlvbnMiLCJnZW9mZW5jZVJhZGl1cyIsInNldEdlb2ZlbmNlTG9jYXRpb24iLCJzZXRHZW9mZW5jZUNvb3JkaW5hdGVzIiwic2V0R2VvZmVuY2VDZW50ZXIiLCJwcm9jZXNzR2VvZmVuY2VTZWFyY2giLCJ1cGRhdGVHZW9mZW5jZUFpcmNyYWZ0IiwiaXNHZW9mZW5jZUFjdGl2ZSIsInRvZ2dsZUdlb2ZlbmNlU3RhdGUiLCJzZXRBY3RpdmVEcm9wZG93biIsIm1hcEluc3RhbmNlIiwicGFuZWxQb3NpdGlvbiIsInNldFBhbmVsUG9zaXRpb24iLCJ4Iiwid2luZG93IiwiaW5uZXJXaWR0aCIsInkiLCJzaG93UGFuZWwiLCJzZXRTaG93UGFuZWwiLCJ0ZW1wQ29vcmRpbmF0ZXMiLCJzZXRUZW1wQ29vcmRpbmF0ZXMiLCJpc1NlYXJjaGluZyIsInNldElzU2VhcmNoaW5nIiwibG9jYXRpb25OYW1lIiwic2V0TG9jYXRpb25OYW1lIiwiaXNMb2FkaW5nTG9jYXRpb24iLCJzZXRJc0xvYWRpbmdMb2NhdGlvbiIsIm9wZW5QYW5lbCIsInJpZ2h0UG9zaXRpb24iLCJ0b3BQb3NpdGlvbiIsImV2ZW50IiwiQ3VzdG9tRXZlbnQiLCJkZXRhaWwiLCJhY3RpdmUiLCJkb2N1bWVudCIsImRpc3BhdGNoRXZlbnQiLCJjbG9zZVBhbmVsIiwicmVzZXRQYW5lbCIsImdldExvY2F0aW9uTmFtZUZyb21Db29yZGluYXRlcyIsImxhdCIsImxuZyIsInRoZW4iLCJuYW1lIiwiY2F0Y2giLCJlcnJvciIsImNvbnNvbGUiLCJmaW5hbGx5IiwiaGFuZGxlUGFuZWxTZWFyY2giLCJ0b0ZpeGVkIiwiZmV0Y2hlZEFpcmNyYWZ0IiwibGVuZ3RoIiwibG9nIiwic2V0VmlldyIsImN1cnJlbnRab29tIiwiZ2V0Wm9vbSIsInRhcmdldFpvb20iLCJpbnZhbGlkYXRlU2l6ZSIsImhhbmRsZU1hcENsaWNrIiwiZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiaGFuZGxlQ2xlYXJBbGxGaWx0ZXJzIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/tracking/hooks/useGeofencePanel.ts\n"));

/***/ })

});
"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_pages-dir-browser_components_tracking_map_AircraftTrackingMap_tsx",{

/***/ "(pages-dir-browser)/./components/tracking/hooks/useFilterLogic.ts":
/*!*****************************************************!*\
  !*** ./components/tracking/hooks/useFilterLogic.ts ***!
  \*****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useFilterLogic: () => (/* binding */ useFilterLogic)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _types_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/types/base */ \"(pages-dir-browser)/./types/base.ts\");\n/* harmony import */ var _context_EnhancedMapContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../context/EnhancedMapContext */ \"(pages-dir-browser)/./components/tracking/context/EnhancedMapContext.tsx\");\n/* harmony import */ var _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/services/openSkyTrackingService */ \"(pages-dir-browser)/./lib/services/openSkyTrackingService.ts\");\n/* harmony import */ var _lib_services_MapboxService__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../lib/services/MapboxService */ \"(pages-dir-browser)/./lib/services/MapboxService.ts\");\n/* harmony import */ var _lib_utils_geofenceAdapter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/lib/utils/geofenceAdapter */ \"(pages-dir-browser)/./lib/utils/geofenceAdapter.ts\");\n/* harmony import */ var _lib_utils_geofenceEnricher__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/lib/utils/geofenceEnricher */ \"(pages-dir-browser)/./lib/utils/geofenceEnricher.ts\");\n/* harmony import */ var _lib_services_geofencing__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../lib/services/geofencing */ \"(pages-dir-browser)/./lib/services/geofencing.ts\");\n/* harmony import */ var _hooks_useGeolocation__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../hooks/useGeolocation */ \"(pages-dir-browser)/./components/tracking/hooks/useGeolocation.ts\");\n/* harmony import */ var _config_map__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../config/map */ \"(pages-dir-browser)/./config/map.ts\");\n\n\n\n\n\n\n\n\n\n\n\nfunction useFilterLogic() {\n    // Get context state and functions\n    const { selectedManufacturer, selectedModel, totalActive, selectManufacturer, selectModel, reset, fullRefresh, refreshPositions, mapInstance, updateAircraftData, clearGeofenceData, updateGeofenceAircraft, blockManufacturerApiCalls, setBlockManufacturerApiCalls, isManufacturerApiBlocked, setIsManufacturerApiBlocked, geofenceCenter, setGeofenceCenter, toggleGeofence, clearGeofence, displayedAircraft } = (0,_context_EnhancedMapContext__WEBPACK_IMPORTED_MODULE_2__.useEnhancedMapContext)();\n    // Get geolocation hook\n    const { locationName, isLoadingLocation, getCurrentPosition } = (0,_hooks_useGeolocation__WEBPACK_IMPORTED_MODULE_8__.useGeolocation)(null);\n    // Local state\n    const [localLoading, setLocalLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [filterMode, setFilterMode] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [activeDropdown, setActiveDropdown] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [manufacturerSearchTerm, setManufacturerSearchTerm] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)('');\n    const [isRefreshing, setIsRefreshing] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [isRateLimited, setIsRateLimited] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [rateLimitTimer, setRateLimitTimer] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    // Geofence state\n    const [isGettingLocation, setIsGettingLocation] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [geofenceLocation, setGeofenceLocation] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)('');\n    const [geofenceRadius, setGeofenceRadius] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(25);\n    const [geofenceCoordinates, setGeofenceCoordinates] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [geofenceAircraft, setGeofenceAircraft] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [geofenceEnabled, setGeofenceEnabled] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [isGeofenceActive, setIsGeofenceActive] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [isSearchReady, setIsSearchReady] = react__WEBPACK_IMPORTED_MODULE_0___default().useState(false);\n    // Region state\n    const [activeRegion, setActiveRegion] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [regionOutline, setRegionOutline] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [selectedRegion, setSelectedRegion] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(_types_base__WEBPACK_IMPORTED_MODULE_1__.RegionCode.GLOBAL);\n    // Combined mode state\n    const [combinedModeReady, setCombinedModeReady] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    // Owner filter state\n    const allOwnerTypes = [\n        'individual',\n        'partnership',\n        'corp-owner',\n        'co-owned',\n        'llc',\n        'non-citizen-corp',\n        'airline',\n        'freight',\n        'medical',\n        'media',\n        'historical',\n        'flying-club',\n        'emergency',\n        'local-govt',\n        'education',\n        'federal-govt',\n        'flight-school',\n        'leasing-corp',\n        'military',\n        'unknown'\n    ];\n    const [ownerFilters, setOwnerFilters] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([\n        ...allOwnerTypes\n    ]);\n    // Refs for dropdown handling\n    const dropdownRefs = {\n        filter: (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),\n        manufacturer: (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),\n        model: (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),\n        location: (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),\n        region: (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),\n        owner: (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),\n        actions: (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null)\n    };\n    // Get geolocation hook - use the entire hook instance\n    const geolocation = (0,_hooks_useGeolocation__WEBPACK_IMPORTED_MODULE_8__.useGeolocation)(null);\n    // Effects\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect({\n        \"useFilterLogic.useEffect\": ()=>{\n            if (geofenceCoordinates) {\n                setIsSearchReady(true);\n            }\n        }\n    }[\"useFilterLogic.useEffect\"], [\n        geofenceCoordinates\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useFilterLogic.useEffect\": ()=>{\n            if (isRateLimited && rateLimitTimer) {\n                const timer = setTimeout({\n                    \"useFilterLogic.useEffect.timer\": ()=>{\n                        setIsRateLimited(false);\n                        setRateLimitTimer(null);\n                        console.log('Rate limit timer expired, resuming API calls');\n                    }\n                }[\"useFilterLogic.useEffect.timer\"], rateLimitTimer * 1000);\n                return ({\n                    \"useFilterLogic.useEffect\": ()=>clearTimeout(timer)\n                })[\"useFilterLogic.useEffect\"];\n            }\n        }\n    }[\"useFilterLogic.useEffect\"], [\n        isRateLimited,\n        rateLimitTimer\n    ]);\n    // Effect to sync geofence state\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useFilterLogic.useEffect\": ()=>{\n            // Update internal state when geofence is toggled externally\n            if (isGeofenceActive !== geofenceEnabled) {\n                setGeofenceEnabled(isGeofenceActive);\n            }\n        }\n    }[\"useFilterLogic.useEffect\"], [\n        isGeofenceActive\n    ]);\n    // Close dropdown when clicking outside\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useFilterLogic.useEffect\": ()=>{\n            const handleClickOutside = {\n                \"useFilterLogic.useEffect.handleClickOutside\": (event)=>{\n                    // Check if click is outside of all dropdowns\n                    const isOutsideAll = Object.values(dropdownRefs).every({\n                        \"useFilterLogic.useEffect.handleClickOutside.isOutsideAll\": (ref)=>!ref.current || !ref.current.contains(event.target)\n                    }[\"useFilterLogic.useEffect.handleClickOutside.isOutsideAll\"]);\n                    if (isOutsideAll) {\n                        setActiveDropdown(null);\n                    }\n                }\n            }[\"useFilterLogic.useEffect.handleClickOutside\"];\n            document.addEventListener('mousedown', handleClickOutside);\n            return ({\n                \"useFilterLogic.useEffect\": ()=>{\n                    document.removeEventListener('mousedown', handleClickOutside);\n                }\n            })[\"useFilterLogic.useEffect\"];\n        }\n    }[\"useFilterLogic.useEffect\"], []);\n    // Clean up region outline when component unmounts\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useFilterLogic.useEffect\": ()=>{\n            return ({\n                \"useFilterLogic.useEffect\": ()=>{\n                    if (regionOutline) {\n                        regionOutline.remove();\n                    }\n                }\n            })[\"useFilterLogic.useEffect\"];\n        }\n    }[\"useFilterLogic.useEffect\"], [\n        regionOutline\n    ]);\n    // Effect to handle map click for geofence\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useFilterLogic.useEffect\": ()=>{\n            const handleMapGeofenceClick = {\n                \"useFilterLogic.useEffect.handleMapGeofenceClick\": async (event)=>{\n                    try {\n                        // Cast the event to the proper type\n                        const customEvent = event;\n                        const { lat, lng } = customEvent.detail;\n                        // First update coordinates immediately\n                        setGeofenceCoordinates({\n                            lat,\n                            lng\n                        });\n                        // Then start an async operation to get the location name\n                        console.log(\"Getting location name for: \".concat(lat, \", \").concat(lng));\n                        // Temporarily show coordinates while fetching the name\n                        setGeofenceLocation(\"\".concat(lat.toFixed(6), \", \").concat(lng.toFixed(6)));\n                        // Get the friendly name asynchronously\n                        const locationName = await _lib_services_MapboxService__WEBPACK_IMPORTED_MODULE_4__.MapboxService.getLocationNameFromCoordinates(lat, lng);\n                        console.log(\"Got location name: \".concat(locationName));\n                        // Update with the friendly name once we have it\n                        if (locationName !== null) {\n                            setGeofenceLocation(locationName);\n                        }\n                        // Open the location dropdown if needed\n                        if (activeDropdown !== 'location') {\n                            setActiveDropdown('location');\n                        }\n                    } catch (error) {\n                        console.error('Error handling map click:', error);\n                    // Keep the coordinates display if there was an error\n                    }\n                }\n            }[\"useFilterLogic.useEffect.handleMapGeofenceClick\"];\n            // Add the event listener - use the standard event listener pattern\n            document.addEventListener('map-geofence-click', handleMapGeofenceClick);\n            // Clean up\n            return ({\n                \"useFilterLogic.useEffect\": ()=>{\n                    document.removeEventListener('map-geofence-click', handleMapGeofenceClick);\n                }\n            })[\"useFilterLogic.useEffect\"];\n        }\n    }[\"useFilterLogic.useEffect\"], [\n        setGeofenceLocation,\n        setGeofenceCoordinates,\n        setActiveDropdown,\n        activeDropdown\n    ]);\n    // Main methods\n    const toggleDropdown = (dropdown, event)=>{\n        if (activeDropdown === dropdown) {\n            setActiveDropdown(null);\n        } else {\n            setActiveDropdown(dropdown);\n        }\n        // Prevent events from bubbling up\n        event.stopPropagation();\n    };\n    const handleRateLimit = function() {\n        let retryAfter = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 30;\n        setIsRateLimited(true);\n        setRateLimitTimer(retryAfter);\n        console.log(\"Rate limited by API. Retry after \".concat(retryAfter, \"s\"));\n        // Block all API calls\n        _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].setBlockAllApiCalls(true);\n        setBlockManufacturerApiCalls(true);\n        // Show notification to user\n        if (retryAfter > 0) {\n            alert(\"Aircraft data refresh rate limited. Please wait \".concat(retryAfter, \" seconds before trying again.\"));\n        }\n    };\n    /**\r\n   * Toggle filter mode\r\n   */ const toggleFilterMode = (mode)=>{\n        setFilterMode(mode);\n        setActiveDropdown(null);\n        // Apply appropriate filters based on new mode\n        if (mode === 'region') {\n            // Block API calls in region mode\n            _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].setBlockAllApiCalls(true);\n            // Apply region filtering if we already have data\n            if (displayedAircraft && displayedAircraft.length > 0) {\n                filterAircraftByRegion(selectedRegion.toString());\n            }\n            // Clear manufacturer selection from the UI\n            selectManufacturer(null);\n            selectModel(null);\n            // If geofence is active, restore the full geofence data\n            if (geofenceCoordinates && geofenceAircraft.length > 0) {\n                updateGeofenceAircraft(geofenceAircraft);\n            }\n        } else if (mode === 'owner') {\n            // Filter displayed aircraft by owner type\n            if (displayedAircraft && displayedAircraft.length > 0) {\n                // First filter for valid coordinates\n                const aircraftWithValidCoords = displayedAircraft.filter((plane)=>typeof plane.latitude === 'number' && typeof plane.longitude === 'number' && !isNaN(plane.latitude) && !isNaN(plane.longitude));\n                // Apply owner type filter\n                let filteredByOwner = ownerFilters.length === 0 ? aircraftWithValidCoords : aircraftWithValidCoords.filter((aircraft)=>ownerFilters.includes(getAircraftOwnerType(aircraft)));\n                // Update display with filtered aircraft\n                if (clearGeofenceData) {\n                    clearGeofenceData();\n                }\n                updateGeofenceAircraft(filteredByOwner);\n            }\n        } else if (mode === 'both') {\n            // Both mode - BLOCK API CALLS\n            _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].setBlockAllApiCalls(true);\n            if (selectedManufacturer && isGeofenceActive && geofenceAircraft.length > 0) {\n                applyCombinedFilters();\n            } else {\n                // If one is missing, prompt the user\n                if (!selectedManufacturer && isGeofenceActive) {\n                    alert('Please select a manufacturer to use combined filter mode');\n                } else if (selectedManufacturer && !isGeofenceActive) {\n                    alert('Please set a location to use combined filter mode');\n                } else {\n                    alert('Please select both a manufacturer and location to use combined filter mode');\n                }\n            }\n        }\n    };\n    // Owner filter methods\n    const getAircraftOwnerType = (aircraft)=>{\n        const ownerType = aircraft.TYPE_REGISTRANT || 0;\n        return ownerTypeToString(ownerType);\n    };\n    const ownerTypeToString = (type)=>{\n        const typeNum = typeof type === 'string' ? parseInt(type, 10) : type;\n        const ownerTypeMap = {\n            1: 'individual',\n            2: 'partnership',\n            3: 'corp-owner',\n            4: 'co-owned',\n            7: 'llc',\n            8: 'non-citizen-corp',\n            9: 'airline',\n            10: 'freight',\n            11: 'medical',\n            12: 'media',\n            13: 'historical',\n            14: 'flying-club',\n            15: 'emergency',\n            16: 'local-govt',\n            17: 'education',\n            18: 'federal-govt',\n            19: 'flight-school',\n            20: 'leasing-corp',\n            21: 'military'\n        };\n        return ownerTypeMap[typeNum] || 'unknown';\n    };\n    const applyOwnerTypeFilter = (filters)=>{\n        // Skip filtering if all types are selected or none are selected\n        if (filters.length === 0 || filters.length === allOwnerTypes.length) {\n            return;\n        }\n        // Filter the aircraft based on selected owner types\n        if (displayedAircraft && displayedAircraft.length > 0) {\n            const filteredAircraft = displayedAircraft.filter((aircraft)=>{\n                const ownerType = getAircraftOwnerType(aircraft);\n                return filters.includes(ownerType);\n            });\n            // Update the displayed aircraft\n            if (clearGeofenceData) {\n                clearGeofenceData();\n            }\n            updateGeofenceAircraft(filteredAircraft);\n        }\n    };\n    const handleOwnerFilterChange = (updatedFilters)=>{\n        setOwnerFilters(updatedFilters);\n        // Apply the filter to your aircraft data\n        applyOwnerTypeFilter(updatedFilters);\n    };\n    const resetOwnerFilters = ()=>{\n        setOwnerFilters([\n            ...allOwnerTypes\n        ]);\n    };\n    // Region filter methods\n    const filterAircraftByRegion = (region)=>{\n        if (!displayedAircraft || displayedAircraft.length === 0) return;\n        setLocalLoading(true);\n        try {\n            // Get the bounds for the selected region\n            const boundsExpression = (0,_config_map__WEBPACK_IMPORTED_MODULE_9__.getBoundsByRegion)(region);\n            // Ensure bounds is in the correct format\n            if (!Array.isArray(boundsExpression) || boundsExpression.length !== 2) {\n                console.error(\"Invalid bounds format for region: \".concat(region), boundsExpression);\n                setLocalLoading(false);\n                return;\n            }\n            // Extract coordinates - Leaflet uses [lat, lng] format\n            const [[minLat, minLng], [maxLat, maxLng]] = boundsExpression;\n            console.log(\"Filtering by region: \".concat(region, \" with bounds:\"), {\n                minLat,\n                minLng,\n                maxLat,\n                maxLng\n            });\n            // Filter aircraft based on coordinates within the bounds\n            const filteredAircraft = displayedAircraft.filter((aircraft)=>{\n                // Check if aircraft has valid coordinates\n                if (typeof aircraft.latitude !== 'number' || typeof aircraft.longitude !== 'number' || isNaN(aircraft.latitude) || isNaN(aircraft.longitude)) {\n                    return false;\n                }\n                // Check if coordinates are within the bounds\n                return aircraft.latitude >= minLat && aircraft.latitude <= maxLat && aircraft.longitude >= minLng && aircraft.longitude <= maxLng;\n            });\n            // Update the display with filtered aircraft\n            if (clearGeofenceData) {\n                clearGeofenceData();\n            }\n            updateGeofenceAircraft(filteredAircraft);\n            console.log(\"Filtered to \".concat(filteredAircraft.length, \" aircraft in \").concat(region, \" region (out of \").concat(displayedAircraft.length, \" total)\"));\n        } catch (error) {\n            console.error('Error filtering aircraft by region:', error);\n        } finally{\n            setLocalLoading(false);\n        }\n    };\n    const handleRegionSelect = async (region)=>{\n        setActiveRegion(region);\n        setSelectedRegion(region);\n        setLocalLoading(true);\n        try {\n            // Set map bounds based on region\n            if (mapInstance) {\n                const bounds = (0,_config_map__WEBPACK_IMPORTED_MODULE_9__.getBoundsByRegion)(region);\n                // Get the appropriate zoom level for this region from your config\n                const zoomLevel = (0,_config_map__WEBPACK_IMPORTED_MODULE_9__.getZoomLevelForRegion)(region);\n                // First, set the appropriate zoom level\n                mapInstance.setZoom(zoomLevel);\n                // Then fit bounds with padding\n                const options = {\n                    padding: _config_map__WEBPACK_IMPORTED_MODULE_9__.MAP_CONFIG.PADDING.DEFAULT\n                };\n                mapInstance.fitBounds(bounds, options);\n                mapInstance.invalidateSize();\n                drawRegionOutline(region);\n            }\n            // Instead of immediately fetching aircraft data,\n            // just store the region selection for later use\n            console.log(\"Region selected. Waiting for manufacturer selection...\");\n            // Optionally, you could fetch just the count of aircraft in this region\n            // to give the user an idea of the data volume\n            const countResponse = await fetch(\"/api/tracking/region-count?region=\".concat(region));\n            if (countResponse.ok) {\n                const countData = await countResponse.json();\n                console.log(\"\".concat(countData.count, \" aircraft available in this region\"));\n            }\n            // Clear any previous aircraft data\n            if (clearGeofenceData) {\n                clearGeofenceData();\n            }\n        } catch (error) {\n            console.error('Error in region selection:', error);\n        } finally{\n            setLocalLoading(false);\n            setActiveDropdown(null);\n        }\n    };\n    const drawRegionOutline = (region)=>{\n        if (!mapInstance) return;\n        // Clear any existing outline\n        if (regionOutline) {\n            regionOutline.remove();\n        }\n        // Get the bounds for the selected region\n        const bounds = (0,_config_map__WEBPACK_IMPORTED_MODULE_9__.getBoundsByRegion)(region);\n        // Create a polygon from the bounds\n        const L = __webpack_require__(/*! leaflet */ \"(pages-dir-browser)/./node_modules/leaflet/dist/leaflet-src.js\");\n        const rectangle = L.rectangle(bounds, {\n            color: '#4f46e5',\n            weight: 3,\n            opacity: 0.7,\n            fill: true,\n            fillColor: '#4f46e5',\n            fillOpacity: 0.1,\n            dashArray: '5, 10',\n            interactive: false\n        });\n        // Add to map\n        rectangle.addTo(mapInstance);\n        // Update the state to include both the rectangle and the label\n        setRegionOutline({\n            remove: ()=>{\n                rectangle.remove();\n            }\n        });\n    };\n    // Geofence methods\n    // Fixed getUserLocation function\n    const getUserLocation = async ()=>{\n        if (isRateLimited) {\n            alert(\"Rate limited. Please wait \".concat(rateLimitTimer || 30, \" seconds before trying to get location.\"));\n            return;\n        }\n        setIsGettingLocation(true);\n        try {\n            // Use the function directly from the hook instance\n            const position = await getCurrentPosition();\n            if (position) {\n                const { latitude, longitude } = position.coords;\n                // Update state with coordinates\n                setGeofenceCoordinates({\n                    lat: latitude,\n                    lng: longitude\n                });\n                setGeofenceCenter({\n                    lat: latitude,\n                    lng: longitude\n                });\n                // Update the location display with coordinates\n                setGeofenceLocation(\"\".concat(latitude.toFixed(6), \", \").concat(longitude.toFixed(6)));\n                // Automatically trigger the geofence search\n                try {\n                    const fetchedAircraft = await (0,_lib_services_geofencing__WEBPACK_IMPORTED_MODULE_7__.getAircraftNearLocation)(latitude, longitude, geofenceRadius);\n                    if (fetchedAircraft.length === 0) {\n                        alert(\"No aircraft found near your current location. Try increasing the radius.\");\n                        setIsGettingLocation(false);\n                        return;\n                    }\n                    // Process the aircraft data\n                    const adaptedAircraft = (0,_lib_utils_geofenceAdapter__WEBPACK_IMPORTED_MODULE_5__.adaptGeofenceAircraft)(fetchedAircraft);\n                    const enrichedAircraft = await (0,_lib_utils_geofenceEnricher__WEBPACK_IMPORTED_MODULE_6__.enrichGeofenceAircraft)(adaptedAircraft);\n                    // Save to local state\n                    setGeofenceAircraft(enrichedAircraft);\n                    // Clear existing aircraft data\n                    if (clearGeofenceData) {\n                        clearGeofenceData();\n                    }\n                    // Update the map with new aircraft\n                    updateGeofenceAircraft(enrichedAircraft);\n                    setIsGeofenceActive(true);\n                    // Center the map on user's location - SIMPLIFIED ZOOM LOGIC\n                    if (mapInstance) {\n                        // Don't modify zoom if it's already at an appropriate level\n                        const currentZoom = mapInstance.getZoom();\n                        const targetZoom = currentZoom <= 7 ? 9 : currentZoom;\n                        // Set the view directly to the user's location\n                        mapInstance.setView([\n                            latitude,\n                            longitude\n                        ], targetZoom);\n                        // Make sure the map reflects changes\n                        mapInstance.invalidateSize();\n                    }\n                    // If in geofence mode, ensure the filter mode is set correctly\n                    if (filterMode !== 'geofence' && filterMode !== 'both') {\n                        setFilterMode('geofence');\n                    }\n                } catch (error) {\n                    var _error_message;\n                    if (((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes('rate limit')) || error.status === 429) {\n                        handleRateLimit(30);\n                        // Still update the location even if we couldn't get aircraft\n                        if (mapInstance) {\n                            mapInstance.setView([\n                                latitude,\n                                longitude\n                            ], 9);\n                            mapInstance.invalidateSize();\n                        }\n                    } else {\n                        throw error;\n                    }\n                }\n                // Close the dropdown after selection\n                setActiveDropdown(null);\n            }\n        } catch (error) {\n            console.error('Error getting user location:', error);\n            alert('Unable to access your location. Please make sure location services are enabled in your browser.');\n        } finally{\n            setIsGettingLocation(false);\n        }\n    };\n    const processGeofenceSearch = async ()=>{\n        if (!geofenceLocation) return;\n        // Check if rate limited\n        if (isRateLimited) {\n            alert(\"Rate limited. Please wait \".concat(rateLimitTimer || 30, \" seconds before searching again.\"));\n            return;\n        }\n        // Block API calls while doing geofence search in combined mode\n        if (filterMode === 'both') {\n            _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].setBlockAllApiCalls(true);\n            setBlockManufacturerApiCalls(true);\n        }\n        // Set loading state\n        setLocalLoading(true);\n        try {\n            console.log('Searching for aircraft near location: \"'.concat(geofenceLocation, '\"'));\n            // This will handle Postal codes, place names, addresses, POIs, etc.\n            let fetchedAircraft;\n            try {\n                fetchedAircraft = await (0,_lib_services_geofencing__WEBPACK_IMPORTED_MODULE_7__.getAircraftNearSearchedLocation)(geofenceLocation, geofenceRadius);\n            } catch (error) {\n                var _error_message;\n                if (((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes('rate limit')) || error.status === 429) {\n                    const retryAfter = 30; // Default to 30 seconds if not specified\n                    handleRateLimit(retryAfter);\n                    setLocalLoading(false);\n                    return;\n                }\n                throw error;\n            }\n            // Get coordinates for the map\n            let locations;\n            try {\n                locations = await _lib_services_MapboxService__WEBPACK_IMPORTED_MODULE_4__.MapboxService.searchLocationWithMapbox(geofenceLocation, 1);\n            } catch (error) {\n                console.error('Error searching location with Mapbox:', error);\n                // Continue with aircraft data if available\n                locations = [];\n            }\n            let coordinates = null;\n            if (locations.length > 0) {\n                coordinates = {\n                    lat: locations[0].lat,\n                    lng: locations[0].lng\n                };\n                // Save the formatted location name\n                setGeofenceLocation(locations[0].name);\n            } else if (fetchedAircraft.length > 0 && fetchedAircraft[0].latitude && fetchedAircraft[0].longitude) {\n                // Fallback to first aircraft position\n                coordinates = {\n                    lat: fetchedAircraft[0].latitude,\n                    lng: fetchedAircraft[0].longitude\n                };\n            }\n            if (fetchedAircraft.length === 0) {\n                alert(\"No aircraft found near \".concat(geofenceLocation, \". Try increasing the radius or searching in a different area.\"));\n                setLocalLoading(false);\n                return;\n            }\n            // Update state with the coordinates\n            if (coordinates) {\n                setGeofenceCoordinates(coordinates);\n                setGeofenceCenter(coordinates);\n                setGeofenceRadius(geofenceRadius);\n            }\n            if (!isGeofenceActive) {\n                toggleGeofence();\n            } else if (!coordinates) {\n                throw new Error('Could not determine coordinates for the location');\n            }\n            console.log(\"Found \".concat(fetchedAircraft.length, \" aircraft in the area, preparing for display...\"));\n            // Ensure the data is in the right format\n            const adaptedAircraft = fetchedAircraft[0].MANUFACTURER !== undefined ? fetchedAircraft // Already in the right format\n             : (0,_lib_utils_geofenceAdapter__WEBPACK_IMPORTED_MODULE_5__.adaptGeofenceAircraft)(fetchedAircraft); // Needs adaptation\n            // Enrich with static data\n            console.log('Enriching geofence aircraft with static data...');\n            const enrichedAircraft = await (0,_lib_utils_geofenceEnricher__WEBPACK_IMPORTED_MODULE_6__.enrichGeofenceAircraft)(adaptedAircraft);\n            // Save the FULL set to local state\n            setGeofenceAircraft(enrichedAircraft);\n            setIsGeofenceActive(true);\n            // Clear existing aircraft data\n            if (clearGeofenceData) {\n                clearGeofenceData();\n            }\n            // If we're in combined mode and have a manufacturer, apply the combined filter\n            if (filterMode === 'both' && selectedManufacturer) {\n                // Make sure API calls remain blocked\n                _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].setBlockAllApiCalls(true);\n                setBlockManufacturerApiCalls(true);\n                setTimeout(()=>{\n                    applyCombinedFilters();\n                }, 100);\n            } else {\n                // Just show all aircraft in the geofence\n                updateGeofenceAircraft(enrichedAircraft);\n                // Center the map - SIMPLIFIED ZOOM LOGIC\n                if (mapInstance && coordinates) {\n                    // Get current zoom level\n                    const currentZoom = mapInstance.getZoom();\n                    // Use appropriate zoom level based on current view\n                    const targetZoom = currentZoom <= 7 ? 9 : currentZoom;\n                    // Set view to the coordinates\n                    mapInstance.setView([\n                        coordinates.lat,\n                        coordinates.lng\n                    ], targetZoom);\n                    // Ensure map is updated\n                    mapInstance.invalidateSize();\n                }\n            }\n            // Close dropdown after search\n            setActiveDropdown(null);\n        } catch (error) {\n            var _error_message1;\n            console.error('Error in geofence search:', error);\n            if (((_error_message1 = error.message) === null || _error_message1 === void 0 ? void 0 : _error_message1.includes('rate limit')) || error.status === 429) {\n                handleRateLimit(30);\n            } else {\n                alert(\"Error: \".concat(error instanceof Error ? error.message : 'Unknown error occurred'));\n            }\n        } finally{\n            setLocalLoading(false);\n        }\n    };\n    /**\r\n   * STEP 3: Fix toggleGeofenceState to better handle manually clicking the button\r\n   */ const toggleGeofenceState = (enabled)=>{\n        console.log('toggleGeofenceState called with:', enabled);\n        console.log('Current geofenceCoordinates:', geofenceCoordinates);\n        if (enabled) {\n            // Check if we have valid coordinates\n            if (geofenceCoordinates && typeof geofenceCoordinates.lat === 'number' && typeof geofenceCoordinates.lng === 'number' && !isNaN(geofenceCoordinates.lat) && !isNaN(geofenceCoordinates.lng)) {\n                console.log('Valid coordinates found, enabling geofence');\n                // Set flags first\n                setGeofenceEnabled(true);\n                setIsGeofenceActive(true);\n                // Call context toggle function if available\n                if (typeof toggleGeofence === 'function') {\n                    toggleGeofence();\n                }\n                // Display aircraft if we have them\n                if (geofenceAircraft && geofenceAircraft.length > 0) {\n                    console.log(\"Showing \".concat(geofenceAircraft.length, \" aircraft in geofence\"));\n                    updateGeofenceAircraft(geofenceAircraft);\n                } else {\n                    // No aircraft data yet, trigger a search\n                    console.log('No aircraft data yet, triggering search');\n                    setTimeout(()=>{\n                        processGeofenceSearch();\n                    }, 100);\n                }\n            } else {\n                // No valid coordinates\n                console.warn('No valid coordinates, showing alert');\n                alert('Please set a location before enabling geofence.\\n\\nClick anywhere on the map to set a location.');\n                setGeofenceEnabled(false);\n                setIsGeofenceActive(false);\n            }\n        } else {\n            // Disabling geofence\n            console.log('Disabling geofence');\n            setGeofenceEnabled(false);\n            setIsGeofenceActive(false);\n            // Clear geofence data if function available\n            if (typeof clearGeofenceData === 'function') {\n                clearGeofenceData();\n            }\n        }\n    };\n    // Manufacturer filter methods\n    const selectManufacturerAndClose = (value)=>{\n        // Close dropdown\n        setActiveDropdown(null);\n        setManufacturerSearchTerm('');\n        // If clearing the selection\n        if (value === '') {\n            selectManufacturer(null);\n            return;\n        }\n        // Set the manufacturer selection\n        selectManufacturer(value);\n        // If region is already selected, fetch filtered data\n        if (activeRegion !== null) {\n            fetchAircraftByRegionAndManufacturer(activeRegion, value);\n        } else {\n            // Otherwise, just proceed with manufacturer-only filtering as before\n            fetchManufacturerData(value);\n        }\n    };\n    const fetchManufacturerData = (manufacturer)=>{\n        if (isRateLimited) {\n            console.log(\"Skipping data fetch - rate limited for \".concat(rateLimitTimer, \"s\"));\n            return;\n        }\n        console.log(\"Fetching data for manufacturer: \".concat(manufacturer));\n        try {\n            // If you have a context function for this, call it after a slight delay\n            if (typeof refreshPositions === 'function') {\n                // Apply a small delay to prevent overwhelming the API\n                setTimeout(()=>{\n                    refreshPositions().catch((error)=>{\n                        var _error_message;\n                        if (((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes('rate limit')) || error.status === 429) {\n                            handleRateLimit(30);\n                        } else {\n                            console.error('Error fetching manufacturer data:', error);\n                        }\n                    });\n                }, 200);\n            }\n        } catch (error) {\n            var _error_message;\n            if (((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes('rate limit')) || error.status === 429) {\n                handleRateLimit(30);\n            } else {\n                console.error('Error scheduling manufacturer data fetch:', error);\n            }\n        }\n    };\n    const fetchAircraftByRegionAndManufacturer = async function(region, manufacturer) {\n        let page = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, limit = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 500;\n        if (!region || !manufacturer) {\n            console.log('Both region and manufacturer must be selected');\n            return;\n        }\n        setLocalLoading(true);\n        try {\n            const response = await fetch(\"/api/tracking/filtered-aircraft?region=\".concat(region, \"&manufacturer=\").concat(encodeURIComponent(manufacturer), \"&page=\").concat(page, \"&limit=\").concat(limit));\n            const data = await response.json();\n            const aircraftData = data.aircraft || [];\n            if (!response.ok) {\n                throw new Error(\"API error: \".concat(response.statusText));\n            }\n            // Process the filtered aircraft data\n            if (aircraftData.length > 0) {\n                const extendedAircraft = aircraftData.map((aircraft)=>{\n                    var _aircraft_OPERATOR;\n                    var _aircraft_OPERATOR_toLowerCase_includes;\n                    return {\n                        ...aircraft,\n                        type: aircraft.TYPE_AIRCRAFT || 'Unknown',\n                        isGovernment: (_aircraft_OPERATOR_toLowerCase_includes = (_aircraft_OPERATOR = aircraft.OPERATOR) === null || _aircraft_OPERATOR === void 0 ? void 0 : _aircraft_OPERATOR.toLowerCase().includes('government')) !== null && _aircraft_OPERATOR_toLowerCase_includes !== void 0 ? _aircraft_OPERATOR_toLowerCase_includes : false,\n                        REGION: aircraft.REGION,\n                        zoomLevel: undefined\n                    };\n                });\n                // Update the map\n                updateGeofenceAircraft(extendedAircraft);\n            } else {\n                console.log(\"No aircraft found for manufacturer \".concat(manufacturer, \" in region \").concat(region));\n            }\n        } catch (error) {\n            console.error('Error fetching filtered aircraft:', error);\n        } finally{\n            setLocalLoading(false);\n        }\n    };\n    // Model selection methods\n    const handleModelSelect = (value)=>{\n        selectModel(value === '' ? null : value);\n        setActiveDropdown(null);\n        // If in combined mode, reapply the filter\n        if (filterMode === 'both' && isGeofenceActive && selectedManufacturer) {\n            setTimeout(()=>{\n                applyCombinedFilters();\n            }, 100);\n        }\n    };\n    // Combined filter methods\n    const applyCombinedFilters = ()=>{\n        if (!selectedManufacturer || !isGeofenceActive || geofenceAircraft.length === 0) {\n            return;\n        }\n        setLocalLoading(true);\n        try {\n            console.log(\"Filtering \".concat(geofenceAircraft.length, \" aircraft by \").concat(selectedManufacturer));\n            // Filter the aircraft by manufacturer\n            let filteredAircraft = geofenceAircraft.filter((aircraft)=>{\n                var _aircraft_MANUFACTURER;\n                return ((_aircraft_MANUFACTURER = aircraft.MANUFACTURER) === null || _aircraft_MANUFACTURER === void 0 ? void 0 : _aircraft_MANUFACTURER.toLowerCase()) === selectedManufacturer.toLowerCase();\n            });\n            // Further filter by model if selected\n            if (selectedModel) {\n                filteredAircraft = filteredAircraft.filter((aircraft)=>{\n                    var _aircraft_MODEL;\n                    return ((_aircraft_MODEL = aircraft.MODEL) === null || _aircraft_MODEL === void 0 ? void 0 : _aircraft_MODEL.toLowerCase()) === selectedModel.toLowerCase();\n                });\n            }\n            console.log(\"Found \".concat(filteredAircraft.length, \" matching aircraft\"));\n            if (filteredAircraft.length === 0) {\n                alert(\"No \".concat(selectedManufacturer, \" aircraft found in this area.\"));\n                return;\n            }\n            // Clear display data\n            if (clearGeofenceData) {\n                clearGeofenceData();\n            }\n            // Update the display\n            updateGeofenceAircraft(filteredAircraft);\n        } catch (error) {\n            console.error('Error filtering aircraft:', error);\n        } finally{\n            setLocalLoading(false);\n        }\n    };\n    // Reset all filters\n    const clearAllFilters = ()=>{\n        console.log('Clearing all filters...');\n        // 1. Reset filter mode\n        setFilterMode('manufacturer');\n        // 2. Unblock API calls that might have been blocked\n        _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].setBlockAllApiCalls(false);\n        setBlockManufacturerApiCalls(false);\n        setIsManufacturerApiBlocked(false);\n        // 3. Clear manufacturer selection\n        selectManufacturer(null);\n        selectModel(null);\n        // 4. Clear geofence\n        setGeofenceLocation('');\n        setGeofenceCoordinates(null);\n        setGeofenceAircraft([]);\n        setGeofenceEnabled(false);\n        setIsGeofenceActive(false);\n        if (typeof clearGeofence === 'function') {\n            clearGeofence();\n        }\n        if (typeof clearGeofenceData === 'function') {\n            clearGeofenceData();\n        }\n        // 5. Reset owner filters to select all\n        setOwnerFilters([\n            ...allOwnerTypes\n        ]);\n        // 6. Clear region filter properly\n        setActiveRegion(null);\n        setSelectedRegion(_types_base__WEBPACK_IMPORTED_MODULE_1__.RegionCode.GLOBAL);\n        // Clear region outline from map\n        if (regionOutline) {\n            try {\n                // Handle different possible object structures\n                if (typeof regionOutline.remove === 'function') {\n                    regionOutline.remove();\n                } else if (regionOutline.rectangle && typeof regionOutline.rectangle.remove === 'function') {\n                    regionOutline.rectangle.remove();\n                }\n                // Clear any labels associated with the region\n                if (regionOutline.label && typeof regionOutline.label.remove === 'function') {\n                    regionOutline.label.remove();\n                }\n            } catch (error) {\n                console.error('Error removing region outline:', error);\n            }\n            // Always reset the region outline state\n            setRegionOutline(null);\n        }\n        // 7. Reset map view to global\n        if (mapInstance) {\n            // Use the predefined center and zoom level from your map config\n            mapInstance.setView(_config_map__WEBPACK_IMPORTED_MODULE_9__.MAP_CONFIG.CENTER, _config_map__WEBPACK_IMPORTED_MODULE_9__.MAP_CONFIG.DEFAULT_ZOOM);\n            mapInstance.invalidateSize();\n        }\n        // 8. Reset to initial aircraft data\n        if (typeof reset === 'function') {\n            reset();\n        } else if (typeof fullRefresh === 'function') {\n            fullRefresh();\n        }\n        // 9. Close any open dropdown\n        setActiveDropdown(null);\n        // 10. Reset rate limiting states\n        setIsRateLimited(false);\n        setRateLimitTimer(null);\n        // 11. Clear combined mode state\n        setCombinedModeReady(false);\n        // 12. Reset search terms\n        setManufacturerSearchTerm('');\n        // 13. Dispatch a custom event that other components can listen for\n        const clearEvent = new CustomEvent('ribbon-filters-cleared');\n        document.dispatchEvent(clearEvent);\n        console.log('All filters cleared successfully');\n    };\n    // Calculate combined loading state\n    const combinedLoading = localLoading;\n    return {\n        // State\n        filterMode,\n        activeDropdown,\n        selectedManufacturer,\n        selectedModel,\n        geofenceLocation,\n        geofenceRadius,\n        isGeofenceActive,\n        geofenceCoordinates,\n        getUserLocation,\n        activeRegion,\n        ownerFilters,\n        allOwnerTypes,\n        manufacturerSearchTerm,\n        combinedLoading,\n        isGettingLocation,\n        dropdownRefs,\n        localLoading,\n        isRateLimited,\n        selectedRegion,\n        isRefreshing,\n        isGeofencePlacementMode: false,\n        // Methods\n        toggleDropdown,\n        toggleFilterMode,\n        selectManufacturerAndClose,\n        handleModelSelect,\n        getUserLocation,\n        processGeofenceSearch,\n        handleOwnerFilterChange,\n        handleRegionSelect,\n        setManufacturerSearchTerm,\n        setGeofenceLocation,\n        setGeofenceRadius,\n        toggleGeofenceState,\n        clearAllFilters,\n        applyCombinedFilters,\n        getAircraftOwnerType,\n        refreshWithFilters: ()=>{\n            // Implement refresh logic here\n            if (typeof refreshPositions === 'function') {\n                refreshPositions().catch((error)=>{\n                    console.error('Error refreshing positions:', error);\n                });\n            }\n        },\n        setActiveDropdown,\n        setGeofenceCoordinates,\n        setGeofenceCenter,\n        updateGeofenceAircraft\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvdHJhY2tpbmcvaG9va3MvdXNlRmlsdGVyTG9naWMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQW9EO0FBQzFCO0FBQ2dCO0FBRTRCO0FBQ0s7QUFDUDtBQUNBO0FBQ0U7QUFJNUI7QUFDZTtBQUs1QjtBQVd0QixTQUFTZ0I7SUFDZCxrQ0FBa0M7SUFDbEMsTUFBTSxFQUNKQyxvQkFBb0IsRUFDcEJDLGFBQWEsRUFDYkMsV0FBVyxFQUNYQyxrQkFBa0IsRUFDbEJDLFdBQVcsRUFDWEMsS0FBSyxFQUNMQyxXQUFXLEVBQ1hDLGdCQUFnQixFQUNoQkMsV0FBVyxFQUNYQyxrQkFBa0IsRUFDbEJDLGlCQUFpQixFQUNqQkMsc0JBQXNCLEVBQ3RCQyx5QkFBeUIsRUFDekJDLDRCQUE0QixFQUM1QkMsd0JBQXdCLEVBQ3hCQywyQkFBMkIsRUFDM0JDLGNBQWMsRUFDZEMsaUJBQWlCLEVBQ2pCQyxjQUFjLEVBQ2RDLGFBQWEsRUFDYkMsaUJBQWlCLEVBQ2xCLEdBQUdoQyxrRkFBcUJBO0lBRXpCLHVCQUF1QjtJQUN2QixNQUFNLEVBQUVpQyxZQUFZLEVBQUVDLGlCQUFpQixFQUFFQyxrQkFBa0IsRUFBRSxHQUMzRDVCLHFFQUFjQSxDQUFDO0lBRWpCLGNBQWM7SUFDZCxNQUFNLENBQUM2QixjQUFjQyxnQkFBZ0IsR0FBRzFDLCtDQUFRQSxDQUFDO0lBQ2pELE1BQU0sQ0FBQzJDLFlBQVlDLGNBQWMsR0FBRzVDLCtDQUFRQSxDQUFvQjtJQUNoRSxNQUFNLENBQUM2QyxnQkFBZ0JDLGtCQUFrQixHQUFHOUMsK0NBQVFBLENBQWdCO0lBQ3BFLE1BQU0sQ0FBQytDLHdCQUF3QkMsMEJBQTBCLEdBQUdoRCwrQ0FBUUEsQ0FBQztJQUNyRSxNQUFNLENBQUNpRCxjQUFjQyxnQkFBZ0IsR0FBR2xELCtDQUFRQSxDQUFDO0lBQ2pELE1BQU0sQ0FBQ21ELGVBQWVDLGlCQUFpQixHQUFHcEQsK0NBQVFBLENBQUM7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QjtRQUNBaU0seUJBQXlCO1FBRXpCLFVBQVU7UUFDVjNIO1FBQ0FPO1FBQ0F1RjtRQUNBbUI7UUFDQTFDO1FBQ0FZO1FBQ0FuRDtRQUNBVTtRQUNBakg7UUFDQVU7UUFDQUU7UUFDQXNKO1FBQ0F3QjtRQUNBOUY7UUFDQUQ7UUFFQXdHLG9CQUFvQjtZQUNsQiwrQkFBK0I7WUFDL0IsSUFBSSxPQUFPM04scUJBQXFCLFlBQVk7Z0JBQzFDQSxtQkFBbUJpTSxLQUFLLENBQUMsQ0FBQ25HO29CQUN4QnhCLFFBQVF3QixLQUFLLENBQUMsK0JBQStCQTtnQkFDL0M7WUFDRjtRQUNGO1FBQ0F4RTtRQUVBZ0I7UUFDQTVCO1FBQ0FOO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxzYXRob1xcRG9jdW1lbnRzXFxQcm9qZWN0c1xcYWlyY3JhZnQtdHJhY2tpbmdcXGNvbXBvbmVudHNcXHRyYWNraW5nXFxob29rc1xcdXNlRmlsdGVyTG9naWMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlU3RhdGUsIHVzZVJlZiwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyBSZWdpb25Db2RlIH0gZnJvbSAnQC90eXBlcy9iYXNlJztcclxuaW1wb3J0IHR5cGUgeyBFeHRlbmRlZEFpcmNyYWZ0IH0gZnJvbSAnQC90eXBlcy9iYXNlJztcclxuaW1wb3J0IHsgdXNlRW5oYW5jZWRNYXBDb250ZXh0IH0gZnJvbSAnLi4vY29udGV4dC9FbmhhbmNlZE1hcENvbnRleHQnO1xyXG5pbXBvcnQgb3BlblNreVRyYWNraW5nU2VydmljZSBmcm9tICdAL2xpYi9zZXJ2aWNlcy9vcGVuU2t5VHJhY2tpbmdTZXJ2aWNlJztcclxuaW1wb3J0IHsgTWFwYm94U2VydmljZSB9IGZyb20gJy4uLy4uLy4uL2xpYi9zZXJ2aWNlcy9NYXBib3hTZXJ2aWNlJztcclxuaW1wb3J0IHsgYWRhcHRHZW9mZW5jZUFpcmNyYWZ0IH0gZnJvbSAnQC9saWIvdXRpbHMvZ2VvZmVuY2VBZGFwdGVyJztcclxuaW1wb3J0IHsgZW5yaWNoR2VvZmVuY2VBaXJjcmFmdCB9IGZyb20gJ0AvbGliL3V0aWxzL2dlb2ZlbmNlRW5yaWNoZXInO1xyXG5pbXBvcnQge1xyXG4gIGdldEFpcmNyYWZ0TmVhckxvY2F0aW9uLFxyXG4gIGdldEFpcmNyYWZ0TmVhclNlYXJjaGVkTG9jYXRpb24sXHJcbn0gZnJvbSAnLi4vLi4vLi4vbGliL3NlcnZpY2VzL2dlb2ZlbmNpbmcnO1xyXG5pbXBvcnQgeyB1c2VHZW9sb2NhdGlvbiB9IGZyb20gJy4uL2hvb2tzL3VzZUdlb2xvY2F0aW9uJztcclxuaW1wb3J0IHtcclxuICBNQVBfQ09ORklHLFxyXG4gIGdldEJvdW5kc0J5UmVnaW9uLFxyXG4gIGdldFpvb21MZXZlbEZvclJlZ2lvbixcclxufSBmcm9tICcuLi8uLi8uLi9jb25maWcvbWFwJztcclxuXHJcbnR5cGUgTWFwR2VvZmVuY2VDbGlja0V2ZW50ID0gQ3VzdG9tRXZlbnQ8eyBsYXQ6IG51bWJlcjsgbG5nOiBudW1iZXIgfT47XHJcblxyXG5leHBvcnQgdHlwZSBGaWx0ZXJNb2RlID1cclxuICB8ICdtYW51ZmFjdHVyZXInXHJcbiAgfCAnZ2VvZmVuY2UnXHJcbiAgfCAnYm90aCdcclxuICB8ICdvd25lcidcclxuICB8ICdyZWdpb24nO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUZpbHRlckxvZ2ljKCkge1xyXG4gIC8vIEdldCBjb250ZXh0IHN0YXRlIGFuZCBmdW5jdGlvbnNcclxuICBjb25zdCB7XHJcbiAgICBzZWxlY3RlZE1hbnVmYWN0dXJlcixcclxuICAgIHNlbGVjdGVkTW9kZWwsXHJcbiAgICB0b3RhbEFjdGl2ZSxcclxuICAgIHNlbGVjdE1hbnVmYWN0dXJlcixcclxuICAgIHNlbGVjdE1vZGVsLFxyXG4gICAgcmVzZXQsXHJcbiAgICBmdWxsUmVmcmVzaCxcclxuICAgIHJlZnJlc2hQb3NpdGlvbnMsXHJcbiAgICBtYXBJbnN0YW5jZSxcclxuICAgIHVwZGF0ZUFpcmNyYWZ0RGF0YSxcclxuICAgIGNsZWFyR2VvZmVuY2VEYXRhLFxyXG4gICAgdXBkYXRlR2VvZmVuY2VBaXJjcmFmdCxcclxuICAgIGJsb2NrTWFudWZhY3R1cmVyQXBpQ2FsbHMsXHJcbiAgICBzZXRCbG9ja01hbnVmYWN0dXJlckFwaUNhbGxzLFxyXG4gICAgaXNNYW51ZmFjdHVyZXJBcGlCbG9ja2VkLFxyXG4gICAgc2V0SXNNYW51ZmFjdHVyZXJBcGlCbG9ja2VkLFxyXG4gICAgZ2VvZmVuY2VDZW50ZXIsXHJcbiAgICBzZXRHZW9mZW5jZUNlbnRlcixcclxuICAgIHRvZ2dsZUdlb2ZlbmNlLFxyXG4gICAgY2xlYXJHZW9mZW5jZSxcclxuICAgIGRpc3BsYXllZEFpcmNyYWZ0LFxyXG4gIH0gPSB1c2VFbmhhbmNlZE1hcENvbnRleHQoKTtcclxuXHJcbiAgLy8gR2V0IGdlb2xvY2F0aW9uIGhvb2tcclxuICBjb25zdCB7IGxvY2F0aW9uTmFtZSwgaXNMb2FkaW5nTG9jYXRpb24sIGdldEN1cnJlbnRQb3NpdGlvbiB9ID1cclxuICAgIHVzZUdlb2xvY2F0aW9uKG51bGwpO1xyXG5cclxuICAvLyBMb2NhbCBzdGF0ZVxyXG4gIGNvbnN0IFtsb2NhbExvYWRpbmcsIHNldExvY2FsTG9hZGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgY29uc3QgW2ZpbHRlck1vZGUsIHNldEZpbHRlck1vZGVdID0gdXNlU3RhdGU8RmlsdGVyTW9kZSB8IG51bGw+KG51bGwpO1xyXG4gIGNvbnN0IFthY3RpdmVEcm9wZG93biwgc2V0QWN0aXZlRHJvcGRvd25dID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XHJcbiAgY29uc3QgW21hbnVmYWN0dXJlclNlYXJjaFRlcm0sIHNldE1hbnVmYWN0dXJlclNlYXJjaFRlcm1dID0gdXNlU3RhdGUoJycpO1xyXG4gIGNvbnN0IFtpc1JlZnJlc2hpbmcsIHNldElzUmVmcmVzaGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgY29uc3QgW2lzUmF0ZUxpbWl0ZWQsIHNldElzUmF0ZUxpbWl0ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gIGNvbnN0IFtyYXRlTGltaXRUaW1lciwgc2V0UmF0ZUxpbWl0VGltZXJdID0gdXNlU3RhdGU8bnVtYmVyIHwgbnVsbD4obnVsbCk7XHJcblxyXG4gIC8vIEdlb2ZlbmNlIHN0YXRlXHJcbiAgY29uc3QgW2lzR2V0dGluZ0xvY2F0aW9uLCBzZXRJc0dldHRpbmdMb2NhdGlvbl0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgY29uc3QgW2dlb2ZlbmNlTG9jYXRpb24sIHNldEdlb2ZlbmNlTG9jYXRpb25dID0gdXNlU3RhdGU8c3RyaW5nPignJyk7XHJcbiAgY29uc3QgW2dlb2ZlbmNlUmFkaXVzLCBzZXRHZW9mZW5jZVJhZGl1c10gPSB1c2VTdGF0ZTxudW1iZXI+KDI1KTtcclxuICBjb25zdCBbZ2VvZmVuY2VDb29yZGluYXRlcywgc2V0R2VvZmVuY2VDb29yZGluYXRlc10gPSB1c2VTdGF0ZTx7XHJcbiAgICBsYXQ6IG51bWJlcjtcclxuICAgIGxuZzogbnVtYmVyO1xyXG4gIH0gfCBudWxsPihudWxsKTtcclxuICBjb25zdCBbZ2VvZmVuY2VBaXJjcmFmdCwgc2V0R2VvZmVuY2VBaXJjcmFmdF0gPSB1c2VTdGF0ZTxFeHRlbmRlZEFpcmNyYWZ0W10+KFxyXG4gICAgW11cclxuICApO1xyXG4gIGNvbnN0IFtnZW9mZW5jZUVuYWJsZWQsIHNldEdlb2ZlbmNlRW5hYmxlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgY29uc3QgW2lzR2VvZmVuY2VBY3RpdmUsIHNldElzR2VvZmVuY2VBY3RpdmVdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gIGNvbnN0IFtpc1NlYXJjaFJlYWR5LCBzZXRJc1NlYXJjaFJlYWR5XSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcclxuXHJcbiAgLy8gUmVnaW9uIHN0YXRlXHJcbiAgY29uc3QgW2FjdGl2ZVJlZ2lvbiwgc2V0QWN0aXZlUmVnaW9uXSA9IHVzZVN0YXRlPFJlZ2lvbkNvZGUgfCBzdHJpbmcgfCBudWxsPihcclxuICAgIG51bGxcclxuICApO1xyXG4gIGNvbnN0IFtyZWdpb25PdXRsaW5lLCBzZXRSZWdpb25PdXRsaW5lXSA9IHVzZVN0YXRlPGFueT4obnVsbCk7XHJcbiAgY29uc3QgW3NlbGVjdGVkUmVnaW9uLCBzZXRTZWxlY3RlZFJlZ2lvbl0gPSB1c2VTdGF0ZTxudW1iZXI+KFxyXG4gICAgUmVnaW9uQ29kZS5HTE9CQUxcclxuICApO1xyXG5cclxuICAvLyBDb21iaW5lZCBtb2RlIHN0YXRlXHJcbiAgY29uc3QgW2NvbWJpbmVkTW9kZVJlYWR5LCBzZXRDb21iaW5lZE1vZGVSZWFkeV0gPSB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XHJcblxyXG4gIC8vIE93bmVyIGZpbHRlciBzdGF0ZVxyXG4gIGNvbnN0IGFsbE93bmVyVHlwZXMgPSBbXHJcbiAgICAnaW5kaXZpZHVhbCcsXHJcbiAgICAncGFydG5lcnNoaXAnLFxyXG4gICAgJ2NvcnAtb3duZXInLFxyXG4gICAgJ2NvLW93bmVkJyxcclxuICAgICdsbGMnLFxyXG4gICAgJ25vbi1jaXRpemVuLWNvcnAnLFxyXG4gICAgJ2FpcmxpbmUnLFxyXG4gICAgJ2ZyZWlnaHQnLFxyXG4gICAgJ21lZGljYWwnLFxyXG4gICAgJ21lZGlhJyxcclxuICAgICdoaXN0b3JpY2FsJyxcclxuICAgICdmbHlpbmctY2x1YicsXHJcbiAgICAnZW1lcmdlbmN5JyxcclxuICAgICdsb2NhbC1nb3Z0JyxcclxuICAgICdlZHVjYXRpb24nLFxyXG4gICAgJ2ZlZGVyYWwtZ292dCcsXHJcbiAgICAnZmxpZ2h0LXNjaG9vbCcsXHJcbiAgICAnbGVhc2luZy1jb3JwJyxcclxuICAgICdtaWxpdGFyeScsXHJcbiAgICAndW5rbm93bicsXHJcbiAgXTtcclxuXHJcbiAgY29uc3QgW293bmVyRmlsdGVycywgc2V0T3duZXJGaWx0ZXJzXSA9IHVzZVN0YXRlPHN0cmluZ1tdPihbXHJcbiAgICAuLi5hbGxPd25lclR5cGVzLFxyXG4gIF0pO1xyXG5cclxuICAvLyBSZWZzIGZvciBkcm9wZG93biBoYW5kbGluZ1xyXG4gIGNvbnN0IGRyb3Bkb3duUmVmcyA9IHtcclxuICAgIGZpbHRlcjogdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKSxcclxuICAgIG1hbnVmYWN0dXJlcjogdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKSxcclxuICAgIG1vZGVsOiB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpLFxyXG4gICAgbG9jYXRpb246IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCksXHJcbiAgICByZWdpb246IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCksXHJcbiAgICBvd25lcjogdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKSxcclxuICAgIGFjdGlvbnM6IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCksXHJcbiAgfTtcclxuXHJcbiAgLy8gR2V0IGdlb2xvY2F0aW9uIGhvb2sgLSB1c2UgdGhlIGVudGlyZSBob29rIGluc3RhbmNlXHJcbiAgY29uc3QgZ2VvbG9jYXRpb24gPSB1c2VHZW9sb2NhdGlvbihudWxsKTtcclxuICAvLyBFZmZlY3RzXHJcblxyXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAoZ2VvZmVuY2VDb29yZGluYXRlcykge1xyXG4gICAgICBzZXRJc1NlYXJjaFJlYWR5KHRydWUpO1xyXG4gICAgfVxyXG4gIH0sIFtnZW9mZW5jZUNvb3JkaW5hdGVzXSk7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAoaXNSYXRlTGltaXRlZCAmJiByYXRlTGltaXRUaW1lcikge1xyXG4gICAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgIHNldElzUmF0ZUxpbWl0ZWQoZmFsc2UpO1xyXG4gICAgICAgIHNldFJhdGVMaW1pdFRpbWVyKG51bGwpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdSYXRlIGxpbWl0IHRpbWVyIGV4cGlyZWQsIHJlc3VtaW5nIEFQSSBjYWxscycpO1xyXG4gICAgICB9LCByYXRlTGltaXRUaW1lciAqIDEwMDApO1xyXG5cclxuICAgICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dCh0aW1lcik7XHJcbiAgICB9XHJcbiAgfSwgW2lzUmF0ZUxpbWl0ZWQsIHJhdGVMaW1pdFRpbWVyXSk7XHJcblxyXG4gIC8vIEVmZmVjdCB0byBzeW5jIGdlb2ZlbmNlIHN0YXRlXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIC8vIFVwZGF0ZSBpbnRlcm5hbCBzdGF0ZSB3aGVuIGdlb2ZlbmNlIGlzIHRvZ2dsZWQgZXh0ZXJuYWxseVxyXG4gICAgaWYgKGlzR2VvZmVuY2VBY3RpdmUgIT09IGdlb2ZlbmNlRW5hYmxlZCkge1xyXG4gICAgICBzZXRHZW9mZW5jZUVuYWJsZWQoaXNHZW9mZW5jZUFjdGl2ZSk7XHJcbiAgICB9XHJcbiAgfSwgW2lzR2VvZmVuY2VBY3RpdmVdKTtcclxuXHJcbiAgLy8gQ2xvc2UgZHJvcGRvd24gd2hlbiBjbGlja2luZyBvdXRzaWRlXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGNvbnN0IGhhbmRsZUNsaWNrT3V0c2lkZSA9IChldmVudDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAvLyBDaGVjayBpZiBjbGljayBpcyBvdXRzaWRlIG9mIGFsbCBkcm9wZG93bnNcclxuICAgICAgY29uc3QgaXNPdXRzaWRlQWxsID0gT2JqZWN0LnZhbHVlcyhkcm9wZG93blJlZnMpLmV2ZXJ5KFxyXG4gICAgICAgIChyZWYpID0+ICFyZWYuY3VycmVudCB8fCAhcmVmLmN1cnJlbnQuY29udGFpbnMoZXZlbnQudGFyZ2V0IGFzIE5vZGUpXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBpZiAoaXNPdXRzaWRlQWxsKSB7XHJcbiAgICAgICAgc2V0QWN0aXZlRHJvcGRvd24obnVsbCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgaGFuZGxlQ2xpY2tPdXRzaWRlKTtcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGhhbmRsZUNsaWNrT3V0c2lkZSk7XHJcbiAgICB9O1xyXG4gIH0sIFtdKTtcclxuXHJcbiAgLy8gQ2xlYW4gdXAgcmVnaW9uIG91dGxpbmUgd2hlbiBjb21wb25lbnQgdW5tb3VudHNcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgaWYgKHJlZ2lvbk91dGxpbmUpIHtcclxuICAgICAgICByZWdpb25PdXRsaW5lLnJlbW92ZSgpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH0sIFtyZWdpb25PdXRsaW5lXSk7XHJcblxyXG4gIC8vIEVmZmVjdCB0byBoYW5kbGUgbWFwIGNsaWNrIGZvciBnZW9mZW5jZVxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBjb25zdCBoYW5kbGVNYXBHZW9mZW5jZUNsaWNrID0gYXN5bmMgKGV2ZW50OiBFdmVudCkgPT4ge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIC8vIENhc3QgdGhlIGV2ZW50IHRvIHRoZSBwcm9wZXIgdHlwZVxyXG4gICAgICAgIGNvbnN0IGN1c3RvbUV2ZW50ID0gZXZlbnQgYXMgQ3VzdG9tRXZlbnQ8eyBsYXQ6IG51bWJlcjsgbG5nOiBudW1iZXIgfT47XHJcbiAgICAgICAgY29uc3QgeyBsYXQsIGxuZyB9ID0gY3VzdG9tRXZlbnQuZGV0YWlsO1xyXG5cclxuICAgICAgICAvLyBGaXJzdCB1cGRhdGUgY29vcmRpbmF0ZXMgaW1tZWRpYXRlbHlcclxuICAgICAgICBzZXRHZW9mZW5jZUNvb3JkaW5hdGVzKHsgbGF0LCBsbmcgfSk7XHJcblxyXG4gICAgICAgIC8vIFRoZW4gc3RhcnQgYW4gYXN5bmMgb3BlcmF0aW9uIHRvIGdldCB0aGUgbG9jYXRpb24gbmFtZVxyXG4gICAgICAgIGNvbnNvbGUubG9nKGBHZXR0aW5nIGxvY2F0aW9uIG5hbWUgZm9yOiAke2xhdH0sICR7bG5nfWApO1xyXG5cclxuICAgICAgICAvLyBUZW1wb3JhcmlseSBzaG93IGNvb3JkaW5hdGVzIHdoaWxlIGZldGNoaW5nIHRoZSBuYW1lXHJcbiAgICAgICAgc2V0R2VvZmVuY2VMb2NhdGlvbihgJHtsYXQudG9GaXhlZCg2KX0sICR7bG5nLnRvRml4ZWQoNil9YCk7XHJcblxyXG4gICAgICAgIC8vIEdldCB0aGUgZnJpZW5kbHkgbmFtZSBhc3luY2hyb25vdXNseVxyXG4gICAgICAgIGNvbnN0IGxvY2F0aW9uTmFtZSA9IGF3YWl0IE1hcGJveFNlcnZpY2UuZ2V0TG9jYXRpb25OYW1lRnJvbUNvb3JkaW5hdGVzKFxyXG4gICAgICAgICAgbGF0LFxyXG4gICAgICAgICAgbG5nXHJcbiAgICAgICAgKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhgR290IGxvY2F0aW9uIG5hbWU6ICR7bG9jYXRpb25OYW1lfWApO1xyXG5cclxuICAgICAgICAvLyBVcGRhdGUgd2l0aCB0aGUgZnJpZW5kbHkgbmFtZSBvbmNlIHdlIGhhdmUgaXRcclxuICAgICAgICBpZiAobG9jYXRpb25OYW1lICE9PSBudWxsKSB7XHJcbiAgICAgICAgICBzZXRHZW9mZW5jZUxvY2F0aW9uKGxvY2F0aW9uTmFtZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBPcGVuIHRoZSBsb2NhdGlvbiBkcm9wZG93biBpZiBuZWVkZWRcclxuICAgICAgICBpZiAoYWN0aXZlRHJvcGRvd24gIT09ICdsb2NhdGlvbicpIHtcclxuICAgICAgICAgIHNldEFjdGl2ZURyb3Bkb3duKCdsb2NhdGlvbicpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBoYW5kbGluZyBtYXAgY2xpY2s6JywgZXJyb3IpO1xyXG4gICAgICAgIC8vIEtlZXAgdGhlIGNvb3JkaW5hdGVzIGRpc3BsYXkgaWYgdGhlcmUgd2FzIGFuIGVycm9yXHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8gQWRkIHRoZSBldmVudCBsaXN0ZW5lciAtIHVzZSB0aGUgc3RhbmRhcmQgZXZlbnQgbGlzdGVuZXIgcGF0dGVyblxyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcclxuICAgICAgJ21hcC1nZW9mZW5jZS1jbGljaycsXHJcbiAgICAgIGhhbmRsZU1hcEdlb2ZlbmNlQ2xpY2sgYXMgRXZlbnRMaXN0ZW5lclxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBDbGVhbiB1cFxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcclxuICAgICAgICAnbWFwLWdlb2ZlbmNlLWNsaWNrJyxcclxuICAgICAgICBoYW5kbGVNYXBHZW9mZW5jZUNsaWNrIGFzIEV2ZW50TGlzdGVuZXJcclxuICAgICAgKTtcclxuICAgIH07XHJcbiAgfSwgW1xyXG4gICAgc2V0R2VvZmVuY2VMb2NhdGlvbixcclxuICAgIHNldEdlb2ZlbmNlQ29vcmRpbmF0ZXMsXHJcbiAgICBzZXRBY3RpdmVEcm9wZG93bixcclxuICAgIGFjdGl2ZURyb3Bkb3duLFxyXG4gIF0pO1xyXG5cclxuICAvLyBNYWluIG1ldGhvZHNcclxuICBjb25zdCB0b2dnbGVEcm9wZG93biA9IChkcm9wZG93bjogc3RyaW5nLCBldmVudDogUmVhY3QuTW91c2VFdmVudCkgPT4ge1xyXG4gICAgaWYgKGFjdGl2ZURyb3Bkb3duID09PSBkcm9wZG93bikge1xyXG4gICAgICBzZXRBY3RpdmVEcm9wZG93bihudWxsKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHNldEFjdGl2ZURyb3Bkb3duKGRyb3Bkb3duKTtcclxuICAgIH1cclxuICAgIC8vIFByZXZlbnQgZXZlbnRzIGZyb20gYnViYmxpbmcgdXBcclxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IGhhbmRsZVJhdGVMaW1pdCA9IChyZXRyeUFmdGVyOiBudW1iZXIgPSAzMCkgPT4ge1xyXG4gICAgc2V0SXNSYXRlTGltaXRlZCh0cnVlKTtcclxuICAgIHNldFJhdGVMaW1pdFRpbWVyKHJldHJ5QWZ0ZXIpO1xyXG4gICAgY29uc29sZS5sb2coYFJhdGUgbGltaXRlZCBieSBBUEkuIFJldHJ5IGFmdGVyICR7cmV0cnlBZnRlcn1zYCk7XHJcblxyXG4gICAgLy8gQmxvY2sgYWxsIEFQSSBjYWxsc1xyXG4gICAgb3BlblNreVRyYWNraW5nU2VydmljZS5zZXRCbG9ja0FsbEFwaUNhbGxzKHRydWUpO1xyXG4gICAgc2V0QmxvY2tNYW51ZmFjdHVyZXJBcGlDYWxscyh0cnVlKTtcclxuXHJcbiAgICAvLyBTaG93IG5vdGlmaWNhdGlvbiB0byB1c2VyXHJcbiAgICBpZiAocmV0cnlBZnRlciA+IDApIHtcclxuICAgICAgYWxlcnQoXHJcbiAgICAgICAgYEFpcmNyYWZ0IGRhdGEgcmVmcmVzaCByYXRlIGxpbWl0ZWQuIFBsZWFzZSB3YWl0ICR7cmV0cnlBZnRlcn0gc2Vjb25kcyBiZWZvcmUgdHJ5aW5nIGFnYWluLmBcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBUb2dnbGUgZmlsdGVyIG1vZGVcclxuICAgKi9cclxuICBjb25zdCB0b2dnbGVGaWx0ZXJNb2RlID0gKG1vZGU6IEZpbHRlck1vZGUpID0+IHtcclxuICAgIHNldEZpbHRlck1vZGUobW9kZSk7XHJcbiAgICBzZXRBY3RpdmVEcm9wZG93bihudWxsKTtcclxuXHJcbiAgICAvLyBBcHBseSBhcHByb3ByaWF0ZSBmaWx0ZXJzIGJhc2VkIG9uIG5ldyBtb2RlXHJcbiAgICBpZiAobW9kZSA9PT0gJ3JlZ2lvbicpIHtcclxuICAgICAgLy8gQmxvY2sgQVBJIGNhbGxzIGluIHJlZ2lvbiBtb2RlXHJcbiAgICAgIG9wZW5Ta3lUcmFja2luZ1NlcnZpY2Uuc2V0QmxvY2tBbGxBcGlDYWxscyh0cnVlKTtcclxuXHJcbiAgICAgIC8vIEFwcGx5IHJlZ2lvbiBmaWx0ZXJpbmcgaWYgd2UgYWxyZWFkeSBoYXZlIGRhdGFcclxuICAgICAgaWYgKGRpc3BsYXllZEFpcmNyYWZ0ICYmIGRpc3BsYXllZEFpcmNyYWZ0Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICBmaWx0ZXJBaXJjcmFmdEJ5UmVnaW9uKHNlbGVjdGVkUmVnaW9uLnRvU3RyaW5nKCkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDbGVhciBtYW51ZmFjdHVyZXIgc2VsZWN0aW9uIGZyb20gdGhlIFVJXHJcbiAgICAgIHNlbGVjdE1hbnVmYWN0dXJlcihudWxsKTtcclxuICAgICAgc2VsZWN0TW9kZWwobnVsbCk7XHJcblxyXG4gICAgICAvLyBJZiBnZW9mZW5jZSBpcyBhY3RpdmUsIHJlc3RvcmUgdGhlIGZ1bGwgZ2VvZmVuY2UgZGF0YVxyXG4gICAgICBpZiAoZ2VvZmVuY2VDb29yZGluYXRlcyAmJiBnZW9mZW5jZUFpcmNyYWZ0Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICB1cGRhdGVHZW9mZW5jZUFpcmNyYWZ0KGdlb2ZlbmNlQWlyY3JhZnQpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdvd25lcicpIHtcclxuICAgICAgLy8gRmlsdGVyIGRpc3BsYXllZCBhaXJjcmFmdCBieSBvd25lciB0eXBlXHJcbiAgICAgIGlmIChkaXNwbGF5ZWRBaXJjcmFmdCAmJiBkaXNwbGF5ZWRBaXJjcmFmdC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgLy8gRmlyc3QgZmlsdGVyIGZvciB2YWxpZCBjb29yZGluYXRlc1xyXG4gICAgICAgIGNvbnN0IGFpcmNyYWZ0V2l0aFZhbGlkQ29vcmRzID0gZGlzcGxheWVkQWlyY3JhZnQuZmlsdGVyKFxyXG4gICAgICAgICAgKHBsYW5lKSA9PlxyXG4gICAgICAgICAgICB0eXBlb2YgcGxhbmUubGF0aXR1ZGUgPT09ICdudW1iZXInICYmXHJcbiAgICAgICAgICAgIHR5cGVvZiBwbGFuZS5sb25naXR1ZGUgPT09ICdudW1iZXInICYmXHJcbiAgICAgICAgICAgICFpc05hTihwbGFuZS5sYXRpdHVkZSkgJiZcclxuICAgICAgICAgICAgIWlzTmFOKHBsYW5lLmxvbmdpdHVkZSlcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyBBcHBseSBvd25lciB0eXBlIGZpbHRlclxyXG4gICAgICAgIGxldCBmaWx0ZXJlZEJ5T3duZXIgPVxyXG4gICAgICAgICAgb3duZXJGaWx0ZXJzLmxlbmd0aCA9PT0gMFxyXG4gICAgICAgICAgICA/IGFpcmNyYWZ0V2l0aFZhbGlkQ29vcmRzXHJcbiAgICAgICAgICAgIDogYWlyY3JhZnRXaXRoVmFsaWRDb29yZHMuZmlsdGVyKChhaXJjcmFmdCkgPT5cclxuICAgICAgICAgICAgICAgIG93bmVyRmlsdGVycy5pbmNsdWRlcyhnZXRBaXJjcmFmdE93bmVyVHlwZShhaXJjcmFmdCkpXHJcbiAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIGRpc3BsYXkgd2l0aCBmaWx0ZXJlZCBhaXJjcmFmdFxyXG4gICAgICAgIGlmIChjbGVhckdlb2ZlbmNlRGF0YSkge1xyXG4gICAgICAgICAgY2xlYXJHZW9mZW5jZURhdGEoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdXBkYXRlR2VvZmVuY2VBaXJjcmFmdChmaWx0ZXJlZEJ5T3duZXIpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdib3RoJykge1xyXG4gICAgICAvLyBCb3RoIG1vZGUgLSBCTE9DSyBBUEkgQ0FMTFNcclxuICAgICAgb3BlblNreVRyYWNraW5nU2VydmljZS5zZXRCbG9ja0FsbEFwaUNhbGxzKHRydWUpO1xyXG5cclxuICAgICAgaWYgKFxyXG4gICAgICAgIHNlbGVjdGVkTWFudWZhY3R1cmVyICYmXHJcbiAgICAgICAgaXNHZW9mZW5jZUFjdGl2ZSAmJlxyXG4gICAgICAgIGdlb2ZlbmNlQWlyY3JhZnQubGVuZ3RoID4gMFxyXG4gICAgICApIHtcclxuICAgICAgICBhcHBseUNvbWJpbmVkRmlsdGVycygpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIElmIG9uZSBpcyBtaXNzaW5nLCBwcm9tcHQgdGhlIHVzZXJcclxuICAgICAgICBpZiAoIXNlbGVjdGVkTWFudWZhY3R1cmVyICYmIGlzR2VvZmVuY2VBY3RpdmUpIHtcclxuICAgICAgICAgIGFsZXJ0KCdQbGVhc2Ugc2VsZWN0IGEgbWFudWZhY3R1cmVyIHRvIHVzZSBjb21iaW5lZCBmaWx0ZXIgbW9kZScpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoc2VsZWN0ZWRNYW51ZmFjdHVyZXIgJiYgIWlzR2VvZmVuY2VBY3RpdmUpIHtcclxuICAgICAgICAgIGFsZXJ0KCdQbGVhc2Ugc2V0IGEgbG9jYXRpb24gdG8gdXNlIGNvbWJpbmVkIGZpbHRlciBtb2RlJyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGFsZXJ0KFxyXG4gICAgICAgICAgICAnUGxlYXNlIHNlbGVjdCBib3RoIGEgbWFudWZhY3R1cmVyIGFuZCBsb2NhdGlvbiB0byB1c2UgY29tYmluZWQgZmlsdGVyIG1vZGUnXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8vIE93bmVyIGZpbHRlciBtZXRob2RzXHJcbiAgY29uc3QgZ2V0QWlyY3JhZnRPd25lclR5cGUgPSAoYWlyY3JhZnQ6IEV4dGVuZGVkQWlyY3JhZnQpOiBzdHJpbmcgPT4ge1xyXG4gICAgY29uc3Qgb3duZXJUeXBlID0gYWlyY3JhZnQuVFlQRV9SRUdJU1RSQU5UIHx8IDA7XHJcbiAgICByZXR1cm4gb3duZXJUeXBlVG9TdHJpbmcob3duZXJUeXBlKTtcclxuICB9O1xyXG5cclxuICBjb25zdCBvd25lclR5cGVUb1N0cmluZyA9ICh0eXBlOiBudW1iZXIgfCBzdHJpbmcpOiBzdHJpbmcgPT4ge1xyXG4gICAgY29uc3QgdHlwZU51bSA9IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyA/IHBhcnNlSW50KHR5cGUsIDEwKSA6IHR5cGU7XHJcblxyXG4gICAgY29uc3Qgb3duZXJUeXBlTWFwOiBSZWNvcmQ8bnVtYmVyLCBzdHJpbmc+ID0ge1xyXG4gICAgICAxOiAnaW5kaXZpZHVhbCcsXHJcbiAgICAgIDI6ICdwYXJ0bmVyc2hpcCcsXHJcbiAgICAgIDM6ICdjb3JwLW93bmVyJyxcclxuICAgICAgNDogJ2NvLW93bmVkJyxcclxuICAgICAgNzogJ2xsYycsXHJcbiAgICAgIDg6ICdub24tY2l0aXplbi1jb3JwJyxcclxuICAgICAgOTogJ2FpcmxpbmUnLFxyXG4gICAgICAxMDogJ2ZyZWlnaHQnLFxyXG4gICAgICAxMTogJ21lZGljYWwnLFxyXG4gICAgICAxMjogJ21lZGlhJyxcclxuICAgICAgMTM6ICdoaXN0b3JpY2FsJyxcclxuICAgICAgMTQ6ICdmbHlpbmctY2x1YicsXHJcbiAgICAgIDE1OiAnZW1lcmdlbmN5JyxcclxuICAgICAgMTY6ICdsb2NhbC1nb3Z0JyxcclxuICAgICAgMTc6ICdlZHVjYXRpb24nLFxyXG4gICAgICAxODogJ2ZlZGVyYWwtZ292dCcsXHJcbiAgICAgIDE5OiAnZmxpZ2h0LXNjaG9vbCcsXHJcbiAgICAgIDIwOiAnbGVhc2luZy1jb3JwJyxcclxuICAgICAgMjE6ICdtaWxpdGFyeScsXHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBvd25lclR5cGVNYXBbdHlwZU51bV0gfHwgJ3Vua25vd24nO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IGFwcGx5T3duZXJUeXBlRmlsdGVyID0gKGZpbHRlcnM6IHN0cmluZ1tdKSA9PiB7XHJcbiAgICAvLyBTa2lwIGZpbHRlcmluZyBpZiBhbGwgdHlwZXMgYXJlIHNlbGVjdGVkIG9yIG5vbmUgYXJlIHNlbGVjdGVkXHJcbiAgICBpZiAoZmlsdGVycy5sZW5ndGggPT09IDAgfHwgZmlsdGVycy5sZW5ndGggPT09IGFsbE93bmVyVHlwZXMubGVuZ3RoKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBGaWx0ZXIgdGhlIGFpcmNyYWZ0IGJhc2VkIG9uIHNlbGVjdGVkIG93bmVyIHR5cGVzXHJcbiAgICBpZiAoZGlzcGxheWVkQWlyY3JhZnQgJiYgZGlzcGxheWVkQWlyY3JhZnQubGVuZ3RoID4gMCkge1xyXG4gICAgICBjb25zdCBmaWx0ZXJlZEFpcmNyYWZ0ID0gZGlzcGxheWVkQWlyY3JhZnQuZmlsdGVyKChhaXJjcmFmdCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IG93bmVyVHlwZSA9IGdldEFpcmNyYWZ0T3duZXJUeXBlKGFpcmNyYWZ0KTtcclxuICAgICAgICByZXR1cm4gZmlsdGVycy5pbmNsdWRlcyhvd25lclR5cGUpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIFVwZGF0ZSB0aGUgZGlzcGxheWVkIGFpcmNyYWZ0XHJcbiAgICAgIGlmIChjbGVhckdlb2ZlbmNlRGF0YSkge1xyXG4gICAgICAgIGNsZWFyR2VvZmVuY2VEYXRhKCk7XHJcbiAgICAgIH1cclxuICAgICAgdXBkYXRlR2VvZmVuY2VBaXJjcmFmdChmaWx0ZXJlZEFpcmNyYWZ0KTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBjb25zdCBoYW5kbGVPd25lckZpbHRlckNoYW5nZSA9ICh1cGRhdGVkRmlsdGVyczogc3RyaW5nW10pID0+IHtcclxuICAgIHNldE93bmVyRmlsdGVycyh1cGRhdGVkRmlsdGVycyk7XHJcbiAgICAvLyBBcHBseSB0aGUgZmlsdGVyIHRvIHlvdXIgYWlyY3JhZnQgZGF0YVxyXG4gICAgYXBwbHlPd25lclR5cGVGaWx0ZXIodXBkYXRlZEZpbHRlcnMpO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IHJlc2V0T3duZXJGaWx0ZXJzID0gKCkgPT4ge1xyXG4gICAgc2V0T3duZXJGaWx0ZXJzKFsuLi5hbGxPd25lclR5cGVzXSk7XHJcbiAgfTtcclxuXHJcbiAgLy8gUmVnaW9uIGZpbHRlciBtZXRob2RzXHJcbiAgY29uc3QgZmlsdGVyQWlyY3JhZnRCeVJlZ2lvbiA9IChyZWdpb246IHN0cmluZykgPT4ge1xyXG4gICAgaWYgKCFkaXNwbGF5ZWRBaXJjcmFmdCB8fCBkaXNwbGF5ZWRBaXJjcmFmdC5sZW5ndGggPT09IDApIHJldHVybjtcclxuICAgIHNldExvY2FsTG9hZGluZyh0cnVlKTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBHZXQgdGhlIGJvdW5kcyBmb3IgdGhlIHNlbGVjdGVkIHJlZ2lvblxyXG4gICAgICBjb25zdCBib3VuZHNFeHByZXNzaW9uID0gZ2V0Qm91bmRzQnlSZWdpb24ocmVnaW9uKTtcclxuXHJcbiAgICAgIC8vIEVuc3VyZSBib3VuZHMgaXMgaW4gdGhlIGNvcnJlY3QgZm9ybWF0XHJcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShib3VuZHNFeHByZXNzaW9uKSB8fCBib3VuZHNFeHByZXNzaW9uLmxlbmd0aCAhPT0gMikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXHJcbiAgICAgICAgICBgSW52YWxpZCBib3VuZHMgZm9ybWF0IGZvciByZWdpb246ICR7cmVnaW9ufWAsXHJcbiAgICAgICAgICBib3VuZHNFeHByZXNzaW9uXHJcbiAgICAgICAgKTtcclxuICAgICAgICBzZXRMb2NhbExvYWRpbmcoZmFsc2UpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRXh0cmFjdCBjb29yZGluYXRlcyAtIExlYWZsZXQgdXNlcyBbbGF0LCBsbmddIGZvcm1hdFxyXG4gICAgICBjb25zdCBbW21pbkxhdCwgbWluTG5nXSwgW21heExhdCwgbWF4TG5nXV0gPSBib3VuZHNFeHByZXNzaW9uO1xyXG5cclxuICAgICAgY29uc29sZS5sb2coYEZpbHRlcmluZyBieSByZWdpb246ICR7cmVnaW9ufSB3aXRoIGJvdW5kczpgLCB7XHJcbiAgICAgICAgbWluTGF0LFxyXG4gICAgICAgIG1pbkxuZyxcclxuICAgICAgICBtYXhMYXQsXHJcbiAgICAgICAgbWF4TG5nLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIEZpbHRlciBhaXJjcmFmdCBiYXNlZCBvbiBjb29yZGluYXRlcyB3aXRoaW4gdGhlIGJvdW5kc1xyXG4gICAgICBjb25zdCBmaWx0ZXJlZEFpcmNyYWZ0ID0gZGlzcGxheWVkQWlyY3JhZnQuZmlsdGVyKChhaXJjcmFmdCkgPT4ge1xyXG4gICAgICAgIC8vIENoZWNrIGlmIGFpcmNyYWZ0IGhhcyB2YWxpZCBjb29yZGluYXRlc1xyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgIHR5cGVvZiBhaXJjcmFmdC5sYXRpdHVkZSAhPT0gJ251bWJlcicgfHxcclxuICAgICAgICAgIHR5cGVvZiBhaXJjcmFmdC5sb25naXR1ZGUgIT09ICdudW1iZXInIHx8XHJcbiAgICAgICAgICBpc05hTihhaXJjcmFmdC5sYXRpdHVkZSkgfHxcclxuICAgICAgICAgIGlzTmFOKGFpcmNyYWZ0LmxvbmdpdHVkZSlcclxuICAgICAgICApIHtcclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENoZWNrIGlmIGNvb3JkaW5hdGVzIGFyZSB3aXRoaW4gdGhlIGJvdW5kc1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICBhaXJjcmFmdC5sYXRpdHVkZSA+PSBtaW5MYXQgJiZcclxuICAgICAgICAgIGFpcmNyYWZ0LmxhdGl0dWRlIDw9IG1heExhdCAmJlxyXG4gICAgICAgICAgYWlyY3JhZnQubG9uZ2l0dWRlID49IG1pbkxuZyAmJlxyXG4gICAgICAgICAgYWlyY3JhZnQubG9uZ2l0dWRlIDw9IG1heExuZ1xyXG4gICAgICAgICk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gVXBkYXRlIHRoZSBkaXNwbGF5IHdpdGggZmlsdGVyZWQgYWlyY3JhZnRcclxuICAgICAgaWYgKGNsZWFyR2VvZmVuY2VEYXRhKSB7XHJcbiAgICAgICAgY2xlYXJHZW9mZW5jZURhdGEoKTtcclxuICAgICAgfVxyXG4gICAgICB1cGRhdGVHZW9mZW5jZUFpcmNyYWZ0KGZpbHRlcmVkQWlyY3JhZnQpO1xyXG4gICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICBgRmlsdGVyZWQgdG8gJHtmaWx0ZXJlZEFpcmNyYWZ0Lmxlbmd0aH0gYWlyY3JhZnQgaW4gJHtyZWdpb259IHJlZ2lvbiAob3V0IG9mICR7ZGlzcGxheWVkQWlyY3JhZnQubGVuZ3RofSB0b3RhbClgXHJcbiAgICAgICk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmaWx0ZXJpbmcgYWlyY3JhZnQgYnkgcmVnaW9uOicsIGVycm9yKTtcclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgIHNldExvY2FsTG9hZGluZyhmYWxzZSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgaGFuZGxlUmVnaW9uU2VsZWN0ID0gYXN5bmMgKHJlZ2lvbjogUmVnaW9uQ29kZSkgPT4ge1xyXG4gICAgc2V0QWN0aXZlUmVnaW9uKHJlZ2lvbik7XHJcbiAgICBzZXRTZWxlY3RlZFJlZ2lvbihyZWdpb24pO1xyXG4gICAgc2V0TG9jYWxMb2FkaW5nKHRydWUpO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIFNldCBtYXAgYm91bmRzIGJhc2VkIG9uIHJlZ2lvblxyXG4gICAgICBpZiAobWFwSW5zdGFuY2UpIHtcclxuICAgICAgICBjb25zdCBib3VuZHMgPSBnZXRCb3VuZHNCeVJlZ2lvbihyZWdpb24pO1xyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIGFwcHJvcHJpYXRlIHpvb20gbGV2ZWwgZm9yIHRoaXMgcmVnaW9uIGZyb20geW91ciBjb25maWdcclxuICAgICAgICBjb25zdCB6b29tTGV2ZWwgPSBnZXRab29tTGV2ZWxGb3JSZWdpb24ocmVnaW9uKTtcclxuXHJcbiAgICAgICAgLy8gRmlyc3QsIHNldCB0aGUgYXBwcm9wcmlhdGUgem9vbSBsZXZlbFxyXG4gICAgICAgIG1hcEluc3RhbmNlLnNldFpvb20oem9vbUxldmVsKTtcclxuXHJcbiAgICAgICAgLy8gVGhlbiBmaXQgYm91bmRzIHdpdGggcGFkZGluZ1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICBwYWRkaW5nOiBNQVBfQ09ORklHLlBBRERJTkcuREVGQVVMVCxcclxuICAgICAgICAgIC8vIERvbid0IHNldCBtYXhab29tIGhlcmUgYXMgd2Ugd2FudCB0aGUgcmVnaW9uIHRvIGJlIHByb3Blcmx5IGRpc3BsYXllZFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIG1hcEluc3RhbmNlLmZpdEJvdW5kcyhib3VuZHMgYXMgYW55LCBvcHRpb25zKTtcclxuICAgICAgICBtYXBJbnN0YW5jZS5pbnZhbGlkYXRlU2l6ZSgpO1xyXG4gICAgICAgIGRyYXdSZWdpb25PdXRsaW5lKHJlZ2lvbik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEluc3RlYWQgb2YgaW1tZWRpYXRlbHkgZmV0Y2hpbmcgYWlyY3JhZnQgZGF0YSxcclxuICAgICAgLy8ganVzdCBzdG9yZSB0aGUgcmVnaW9uIHNlbGVjdGlvbiBmb3IgbGF0ZXIgdXNlXHJcbiAgICAgIGNvbnNvbGUubG9nKGBSZWdpb24gc2VsZWN0ZWQuIFdhaXRpbmcgZm9yIG1hbnVmYWN0dXJlciBzZWxlY3Rpb24uLi5gKTtcclxuXHJcbiAgICAgIC8vIE9wdGlvbmFsbHksIHlvdSBjb3VsZCBmZXRjaCBqdXN0IHRoZSBjb3VudCBvZiBhaXJjcmFmdCBpbiB0aGlzIHJlZ2lvblxyXG4gICAgICAvLyB0byBnaXZlIHRoZSB1c2VyIGFuIGlkZWEgb2YgdGhlIGRhdGEgdm9sdW1lXHJcbiAgICAgIGNvbnN0IGNvdW50UmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcclxuICAgICAgICBgL2FwaS90cmFja2luZy9yZWdpb24tY291bnQ/cmVnaW9uPSR7cmVnaW9ufWBcclxuICAgICAgKTtcclxuICAgICAgaWYgKGNvdW50UmVzcG9uc2Uub2spIHtcclxuICAgICAgICBjb25zdCBjb3VudERhdGEgPSBhd2FpdCBjb3VudFJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhgJHtjb3VudERhdGEuY291bnR9IGFpcmNyYWZ0IGF2YWlsYWJsZSBpbiB0aGlzIHJlZ2lvbmApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDbGVhciBhbnkgcHJldmlvdXMgYWlyY3JhZnQgZGF0YVxyXG4gICAgICBpZiAoY2xlYXJHZW9mZW5jZURhdGEpIHtcclxuICAgICAgICBjbGVhckdlb2ZlbmNlRGF0YSgpO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiByZWdpb24gc2VsZWN0aW9uOicsIGVycm9yKTtcclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgIHNldExvY2FsTG9hZGluZyhmYWxzZSk7XHJcbiAgICAgIHNldEFjdGl2ZURyb3Bkb3duKG51bGwpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGNvbnN0IGRyYXdSZWdpb25PdXRsaW5lID0gKHJlZ2lvbjogUmVnaW9uQ29kZSkgPT4ge1xyXG4gICAgaWYgKCFtYXBJbnN0YW5jZSkgcmV0dXJuO1xyXG5cclxuICAgIC8vIENsZWFyIGFueSBleGlzdGluZyBvdXRsaW5lXHJcbiAgICBpZiAocmVnaW9uT3V0bGluZSkge1xyXG4gICAgICByZWdpb25PdXRsaW5lLnJlbW92ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEdldCB0aGUgYm91bmRzIGZvciB0aGUgc2VsZWN0ZWQgcmVnaW9uXHJcbiAgICBjb25zdCBib3VuZHMgPSBnZXRCb3VuZHNCeVJlZ2lvbihyZWdpb24pIGFzIFtcclxuICAgICAgW251bWJlciwgbnVtYmVyXSxcclxuICAgICAgW251bWJlciwgbnVtYmVyXSxcclxuICAgIF07XHJcblxyXG4gICAgLy8gQ3JlYXRlIGEgcG9seWdvbiBmcm9tIHRoZSBib3VuZHNcclxuICAgIGNvbnN0IEwgPSByZXF1aXJlKCdsZWFmbGV0Jyk7XHJcbiAgICBjb25zdCByZWN0YW5nbGUgPSBMLnJlY3RhbmdsZShib3VuZHMsIHtcclxuICAgICAgY29sb3I6ICcjNGY0NmU1JywgLy8gSW5kaWdvIGNvbG9yIG1hdGNoaW5nIHlvdXIgVUlcclxuICAgICAgd2VpZ2h0OiAzLFxyXG4gICAgICBvcGFjaXR5OiAwLjcsXHJcbiAgICAgIGZpbGw6IHRydWUsXHJcbiAgICAgIGZpbGxDb2xvcjogJyM0ZjQ2ZTUnLFxyXG4gICAgICBmaWxsT3BhY2l0eTogMC4xLFxyXG4gICAgICBkYXNoQXJyYXk6ICc1LCAxMCcsIC8vIE9wdGlvbmFsOiBjcmVhdGVzIGEgZGFzaGVkIGxpbmVcclxuICAgICAgaW50ZXJhY3RpdmU6IGZhbHNlLCAvLyBQcmV2ZW50cyB0aGUgcmVjdGFuZ2xlIGZyb20gY2FwdHVyaW5nIG1vdXNlIGV2ZW50c1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gQWRkIHRvIG1hcFxyXG4gICAgcmVjdGFuZ2xlLmFkZFRvKG1hcEluc3RhbmNlKTtcclxuXHJcbiAgICAvLyBVcGRhdGUgdGhlIHN0YXRlIHRvIGluY2x1ZGUgYm90aCB0aGUgcmVjdGFuZ2xlIGFuZCB0aGUgbGFiZWxcclxuICAgIHNldFJlZ2lvbk91dGxpbmUoe1xyXG4gICAgICByZW1vdmU6ICgpID0+IHtcclxuICAgICAgICByZWN0YW5nbGUucmVtb3ZlKCk7XHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvLyBHZW9mZW5jZSBtZXRob2RzXHJcbiAgLy8gRml4ZWQgZ2V0VXNlckxvY2F0aW9uIGZ1bmN0aW9uXHJcbiAgY29uc3QgZ2V0VXNlckxvY2F0aW9uID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgaWYgKGlzUmF0ZUxpbWl0ZWQpIHtcclxuICAgICAgYWxlcnQoXHJcbiAgICAgICAgYFJhdGUgbGltaXRlZC4gUGxlYXNlIHdhaXQgJHtyYXRlTGltaXRUaW1lciB8fCAzMH0gc2Vjb25kcyBiZWZvcmUgdHJ5aW5nIHRvIGdldCBsb2NhdGlvbi5gXHJcbiAgICAgICk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBzZXRJc0dldHRpbmdMb2NhdGlvbih0cnVlKTtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIFVzZSB0aGUgZnVuY3Rpb24gZGlyZWN0bHkgZnJvbSB0aGUgaG9vayBpbnN0YW5jZVxyXG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGF3YWl0IGdldEN1cnJlbnRQb3NpdGlvbigpO1xyXG5cclxuICAgICAgaWYgKHBvc2l0aW9uKSB7XHJcbiAgICAgICAgY29uc3QgeyBsYXRpdHVkZSwgbG9uZ2l0dWRlIH0gPSBwb3NpdGlvbi5jb29yZHM7XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSBzdGF0ZSB3aXRoIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgc2V0R2VvZmVuY2VDb29yZGluYXRlcyh7IGxhdDogbGF0aXR1ZGUsIGxuZzogbG9uZ2l0dWRlIH0pO1xyXG4gICAgICAgIHNldEdlb2ZlbmNlQ2VudGVyKHsgbGF0OiBsYXRpdHVkZSwgbG5nOiBsb25naXR1ZGUgfSk7XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgbG9jYXRpb24gZGlzcGxheSB3aXRoIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgc2V0R2VvZmVuY2VMb2NhdGlvbihgJHtsYXRpdHVkZS50b0ZpeGVkKDYpfSwgJHtsb25naXR1ZGUudG9GaXhlZCg2KX1gKTtcclxuXHJcbiAgICAgICAgLy8gQXV0b21hdGljYWxseSB0cmlnZ2VyIHRoZSBnZW9mZW5jZSBzZWFyY2hcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3QgZmV0Y2hlZEFpcmNyYWZ0ID0gYXdhaXQgZ2V0QWlyY3JhZnROZWFyTG9jYXRpb24oXHJcbiAgICAgICAgICAgIGxhdGl0dWRlLFxyXG4gICAgICAgICAgICBsb25naXR1ZGUsXHJcbiAgICAgICAgICAgIGdlb2ZlbmNlUmFkaXVzXHJcbiAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgIGlmIChmZXRjaGVkQWlyY3JhZnQubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIGFsZXJ0KFxyXG4gICAgICAgICAgICAgIGBObyBhaXJjcmFmdCBmb3VuZCBuZWFyIHlvdXIgY3VycmVudCBsb2NhdGlvbi4gVHJ5IGluY3JlYXNpbmcgdGhlIHJhZGl1cy5gXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHNldElzR2V0dGluZ0xvY2F0aW9uKGZhbHNlKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFByb2Nlc3MgdGhlIGFpcmNyYWZ0IGRhdGFcclxuICAgICAgICAgIGNvbnN0IGFkYXB0ZWRBaXJjcmFmdCA9IGFkYXB0R2VvZmVuY2VBaXJjcmFmdChmZXRjaGVkQWlyY3JhZnQpO1xyXG4gICAgICAgICAgY29uc3QgZW5yaWNoZWRBaXJjcmFmdCA9XHJcbiAgICAgICAgICAgIGF3YWl0IGVucmljaEdlb2ZlbmNlQWlyY3JhZnQoYWRhcHRlZEFpcmNyYWZ0KTtcclxuXHJcbiAgICAgICAgICAvLyBTYXZlIHRvIGxvY2FsIHN0YXRlXHJcbiAgICAgICAgICBzZXRHZW9mZW5jZUFpcmNyYWZ0KGVucmljaGVkQWlyY3JhZnQpO1xyXG5cclxuICAgICAgICAgIC8vIENsZWFyIGV4aXN0aW5nIGFpcmNyYWZ0IGRhdGFcclxuICAgICAgICAgIGlmIChjbGVhckdlb2ZlbmNlRGF0YSkge1xyXG4gICAgICAgICAgICBjbGVhckdlb2ZlbmNlRGF0YSgpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgbWFwIHdpdGggbmV3IGFpcmNyYWZ0XHJcbiAgICAgICAgICB1cGRhdGVHZW9mZW5jZUFpcmNyYWZ0KGVucmljaGVkQWlyY3JhZnQpO1xyXG4gICAgICAgICAgc2V0SXNHZW9mZW5jZUFjdGl2ZSh0cnVlKTtcclxuXHJcbiAgICAgICAgICAvLyBDZW50ZXIgdGhlIG1hcCBvbiB1c2VyJ3MgbG9jYXRpb24gLSBTSU1QTElGSUVEIFpPT00gTE9HSUNcclxuICAgICAgICAgIGlmIChtYXBJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAvLyBEb24ndCBtb2RpZnkgem9vbSBpZiBpdCdzIGFscmVhZHkgYXQgYW4gYXBwcm9wcmlhdGUgbGV2ZWxcclxuICAgICAgICAgICAgY29uc3QgY3VycmVudFpvb20gPSBtYXBJbnN0YW5jZS5nZXRab29tKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldFpvb20gPSBjdXJyZW50Wm9vbSA8PSA3ID8gOSA6IGN1cnJlbnRab29tO1xyXG5cclxuICAgICAgICAgICAgLy8gU2V0IHRoZSB2aWV3IGRpcmVjdGx5IHRvIHRoZSB1c2VyJ3MgbG9jYXRpb25cclxuICAgICAgICAgICAgbWFwSW5zdGFuY2Uuc2V0VmlldyhbbGF0aXR1ZGUsIGxvbmdpdHVkZV0sIHRhcmdldFpvb20pO1xyXG5cclxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBtYXAgcmVmbGVjdHMgY2hhbmdlc1xyXG4gICAgICAgICAgICBtYXBJbnN0YW5jZS5pbnZhbGlkYXRlU2l6ZSgpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIElmIGluIGdlb2ZlbmNlIG1vZGUsIGVuc3VyZSB0aGUgZmlsdGVyIG1vZGUgaXMgc2V0IGNvcnJlY3RseVxyXG4gICAgICAgICAgaWYgKGZpbHRlck1vZGUgIT09ICdnZW9mZW5jZScgJiYgZmlsdGVyTW9kZSAhPT0gJ2JvdGgnKSB7XHJcbiAgICAgICAgICAgIHNldEZpbHRlck1vZGUoJ2dlb2ZlbmNlJyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCdyYXRlIGxpbWl0JykgfHwgZXJyb3Iuc3RhdHVzID09PSA0MjkpIHtcclxuICAgICAgICAgICAgaGFuZGxlUmF0ZUxpbWl0KDMwKTtcclxuICAgICAgICAgICAgLy8gU3RpbGwgdXBkYXRlIHRoZSBsb2NhdGlvbiBldmVuIGlmIHdlIGNvdWxkbid0IGdldCBhaXJjcmFmdFxyXG4gICAgICAgICAgICBpZiAobWFwSW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgICBtYXBJbnN0YW5jZS5zZXRWaWV3KFtsYXRpdHVkZSwgbG9uZ2l0dWRlXSwgOSk7XHJcbiAgICAgICAgICAgICAgbWFwSW5zdGFuY2UuaW52YWxpZGF0ZVNpemUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDbG9zZSB0aGUgZHJvcGRvd24gYWZ0ZXIgc2VsZWN0aW9uXHJcbiAgICAgICAgc2V0QWN0aXZlRHJvcGRvd24obnVsbCk7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgdXNlciBsb2NhdGlvbjonLCBlcnJvcik7XHJcbiAgICAgIGFsZXJ0KFxyXG4gICAgICAgICdVbmFibGUgdG8gYWNjZXNzIHlvdXIgbG9jYXRpb24uIFBsZWFzZSBtYWtlIHN1cmUgbG9jYXRpb24gc2VydmljZXMgYXJlIGVuYWJsZWQgaW4geW91ciBicm93c2VyLidcclxuICAgICAgKTtcclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgIHNldElzR2V0dGluZ0xvY2F0aW9uKGZhbHNlKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBjb25zdCBwcm9jZXNzR2VvZmVuY2VTZWFyY2ggPSBhc3luYyAoKSA9PiB7XHJcbiAgICBpZiAoIWdlb2ZlbmNlTG9jYXRpb24pIHJldHVybjtcclxuXHJcbiAgICAvLyBDaGVjayBpZiByYXRlIGxpbWl0ZWRcclxuICAgIGlmIChpc1JhdGVMaW1pdGVkKSB7XHJcbiAgICAgIGFsZXJ0KFxyXG4gICAgICAgIGBSYXRlIGxpbWl0ZWQuIFBsZWFzZSB3YWl0ICR7cmF0ZUxpbWl0VGltZXIgfHwgMzB9IHNlY29uZHMgYmVmb3JlIHNlYXJjaGluZyBhZ2Fpbi5gXHJcbiAgICAgICk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBCbG9jayBBUEkgY2FsbHMgd2hpbGUgZG9pbmcgZ2VvZmVuY2Ugc2VhcmNoIGluIGNvbWJpbmVkIG1vZGVcclxuICAgIGlmIChmaWx0ZXJNb2RlID09PSAnYm90aCcpIHtcclxuICAgICAgb3BlblNreVRyYWNraW5nU2VydmljZS5zZXRCbG9ja0FsbEFwaUNhbGxzKHRydWUpO1xyXG4gICAgICBzZXRCbG9ja01hbnVmYWN0dXJlckFwaUNhbGxzKHRydWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNldCBsb2FkaW5nIHN0YXRlXHJcbiAgICBzZXRMb2NhbExvYWRpbmcodHJ1ZSk7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgYFNlYXJjaGluZyBmb3IgYWlyY3JhZnQgbmVhciBsb2NhdGlvbjogXCIke2dlb2ZlbmNlTG9jYXRpb259XCJgXHJcbiAgICAgICk7XHJcblxyXG4gICAgICAvLyBUaGlzIHdpbGwgaGFuZGxlIFBvc3RhbCBjb2RlcywgcGxhY2UgbmFtZXMsIGFkZHJlc3NlcywgUE9JcywgZXRjLlxyXG4gICAgICBsZXQgZmV0Y2hlZEFpcmNyYWZ0O1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGZldGNoZWRBaXJjcmFmdCA9IGF3YWl0IGdldEFpcmNyYWZ0TmVhclNlYXJjaGVkTG9jYXRpb24oXHJcbiAgICAgICAgICBnZW9mZW5jZUxvY2F0aW9uLFxyXG4gICAgICAgICAgZ2VvZmVuY2VSYWRpdXNcclxuICAgICAgICApO1xyXG4gICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCdyYXRlIGxpbWl0JykgfHwgZXJyb3Iuc3RhdHVzID09PSA0MjkpIHtcclxuICAgICAgICAgIGNvbnN0IHJldHJ5QWZ0ZXIgPSAzMDsgLy8gRGVmYXVsdCB0byAzMCBzZWNvbmRzIGlmIG5vdCBzcGVjaWZpZWRcclxuICAgICAgICAgIGhhbmRsZVJhdGVMaW1pdChyZXRyeUFmdGVyKTtcclxuICAgICAgICAgIHNldExvY2FsTG9hZGluZyhmYWxzZSk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBHZXQgY29vcmRpbmF0ZXMgZm9yIHRoZSBtYXBcclxuICAgICAgbGV0IGxvY2F0aW9uczogeyBsYXQ6IG51bWJlcjsgbG5nOiBudW1iZXI7IG5hbWU6IHN0cmluZyB9W107XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgbG9jYXRpb25zID0gYXdhaXQgTWFwYm94U2VydmljZS5zZWFyY2hMb2NhdGlvbldpdGhNYXBib3goXHJcbiAgICAgICAgICBnZW9mZW5jZUxvY2F0aW9uLFxyXG4gICAgICAgICAgMVxyXG4gICAgICAgICk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igc2VhcmNoaW5nIGxvY2F0aW9uIHdpdGggTWFwYm94OicsIGVycm9yKTtcclxuICAgICAgICAvLyBDb250aW51ZSB3aXRoIGFpcmNyYWZ0IGRhdGEgaWYgYXZhaWxhYmxlXHJcbiAgICAgICAgbG9jYXRpb25zID0gW107XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCBjb29yZGluYXRlczogeyBsYXQ6IG51bWJlcjsgbG5nOiBudW1iZXIgfSB8IG51bGwgPSBudWxsO1xyXG5cclxuICAgICAgaWYgKGxvY2F0aW9ucy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgY29vcmRpbmF0ZXMgPSB7XHJcbiAgICAgICAgICBsYXQ6IGxvY2F0aW9uc1swXS5sYXQsXHJcbiAgICAgICAgICBsbmc6IGxvY2F0aW9uc1swXS5sbmcsXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBTYXZlIHRoZSBmb3JtYXR0ZWQgbG9jYXRpb24gbmFtZVxyXG4gICAgICAgIHNldEdlb2ZlbmNlTG9jYXRpb24obG9jYXRpb25zWzBdLm5hbWUpO1xyXG4gICAgICB9IGVsc2UgaWYgKFxyXG4gICAgICAgIGZldGNoZWRBaXJjcmFmdC5sZW5ndGggPiAwICYmXHJcbiAgICAgICAgZmV0Y2hlZEFpcmNyYWZ0WzBdLmxhdGl0dWRlICYmXHJcbiAgICAgICAgZmV0Y2hlZEFpcmNyYWZ0WzBdLmxvbmdpdHVkZVxyXG4gICAgICApIHtcclxuICAgICAgICAvLyBGYWxsYmFjayB0byBmaXJzdCBhaXJjcmFmdCBwb3NpdGlvblxyXG4gICAgICAgIGNvb3JkaW5hdGVzID0ge1xyXG4gICAgICAgICAgbGF0OiBmZXRjaGVkQWlyY3JhZnRbMF0ubGF0aXR1ZGUsXHJcbiAgICAgICAgICBsbmc6IGZldGNoZWRBaXJjcmFmdFswXS5sb25naXR1ZGUsXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGZldGNoZWRBaXJjcmFmdC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICBhbGVydChcclxuICAgICAgICAgIGBObyBhaXJjcmFmdCBmb3VuZCBuZWFyICR7Z2VvZmVuY2VMb2NhdGlvbn0uIFRyeSBpbmNyZWFzaW5nIHRoZSByYWRpdXMgb3Igc2VhcmNoaW5nIGluIGEgZGlmZmVyZW50IGFyZWEuYFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgc2V0TG9jYWxMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFVwZGF0ZSBzdGF0ZSB3aXRoIHRoZSBjb29yZGluYXRlc1xyXG4gICAgICBpZiAoY29vcmRpbmF0ZXMpIHtcclxuICAgICAgICBzZXRHZW9mZW5jZUNvb3JkaW5hdGVzKGNvb3JkaW5hdGVzKTtcclxuICAgICAgICBzZXRHZW9mZW5jZUNlbnRlcihjb29yZGluYXRlcyk7XHJcbiAgICAgICAgc2V0R2VvZmVuY2VSYWRpdXMoZ2VvZmVuY2VSYWRpdXMpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghaXNHZW9mZW5jZUFjdGl2ZSkge1xyXG4gICAgICAgIHRvZ2dsZUdlb2ZlbmNlKCk7XHJcbiAgICAgIH0gZWxzZSBpZiAoIWNvb3JkaW5hdGVzKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZGV0ZXJtaW5lIGNvb3JkaW5hdGVzIGZvciB0aGUgbG9jYXRpb24nKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgYEZvdW5kICR7ZmV0Y2hlZEFpcmNyYWZ0Lmxlbmd0aH0gYWlyY3JhZnQgaW4gdGhlIGFyZWEsIHByZXBhcmluZyBmb3IgZGlzcGxheS4uLmBcclxuICAgICAgKTtcclxuXHJcbiAgICAgIC8vIEVuc3VyZSB0aGUgZGF0YSBpcyBpbiB0aGUgcmlnaHQgZm9ybWF0XHJcbiAgICAgIGNvbnN0IGFkYXB0ZWRBaXJjcmFmdCA9XHJcbiAgICAgICAgZmV0Y2hlZEFpcmNyYWZ0WzBdLk1BTlVGQUNUVVJFUiAhPT0gdW5kZWZpbmVkXHJcbiAgICAgICAgICA/IGZldGNoZWRBaXJjcmFmdCAvLyBBbHJlYWR5IGluIHRoZSByaWdodCBmb3JtYXRcclxuICAgICAgICAgIDogYWRhcHRHZW9mZW5jZUFpcmNyYWZ0KGZldGNoZWRBaXJjcmFmdCk7IC8vIE5lZWRzIGFkYXB0YXRpb25cclxuXHJcbiAgICAgIC8vIEVucmljaCB3aXRoIHN0YXRpYyBkYXRhXHJcbiAgICAgIGNvbnNvbGUubG9nKCdFbnJpY2hpbmcgZ2VvZmVuY2UgYWlyY3JhZnQgd2l0aCBzdGF0aWMgZGF0YS4uLicpO1xyXG4gICAgICBjb25zdCBlbnJpY2hlZEFpcmNyYWZ0ID0gYXdhaXQgZW5yaWNoR2VvZmVuY2VBaXJjcmFmdChhZGFwdGVkQWlyY3JhZnQpO1xyXG5cclxuICAgICAgLy8gU2F2ZSB0aGUgRlVMTCBzZXQgdG8gbG9jYWwgc3RhdGVcclxuICAgICAgc2V0R2VvZmVuY2VBaXJjcmFmdChlbnJpY2hlZEFpcmNyYWZ0KTtcclxuICAgICAgc2V0SXNHZW9mZW5jZUFjdGl2ZSh0cnVlKTtcclxuXHJcbiAgICAgIC8vIENsZWFyIGV4aXN0aW5nIGFpcmNyYWZ0IGRhdGFcclxuICAgICAgaWYgKGNsZWFyR2VvZmVuY2VEYXRhKSB7XHJcbiAgICAgICAgY2xlYXJHZW9mZW5jZURhdGEoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSWYgd2UncmUgaW4gY29tYmluZWQgbW9kZSBhbmQgaGF2ZSBhIG1hbnVmYWN0dXJlciwgYXBwbHkgdGhlIGNvbWJpbmVkIGZpbHRlclxyXG4gICAgICBpZiAoZmlsdGVyTW9kZSA9PT0gJ2JvdGgnICYmIHNlbGVjdGVkTWFudWZhY3R1cmVyKSB7XHJcbiAgICAgICAgLy8gTWFrZSBzdXJlIEFQSSBjYWxscyByZW1haW4gYmxvY2tlZFxyXG4gICAgICAgIG9wZW5Ta3lUcmFja2luZ1NlcnZpY2Uuc2V0QmxvY2tBbGxBcGlDYWxscyh0cnVlKTtcclxuICAgICAgICBzZXRCbG9ja01hbnVmYWN0dXJlckFwaUNhbGxzKHRydWUpO1xyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgYXBwbHlDb21iaW5lZEZpbHRlcnMoKTtcclxuICAgICAgICB9LCAxMDApO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIEp1c3Qgc2hvdyBhbGwgYWlyY3JhZnQgaW4gdGhlIGdlb2ZlbmNlXHJcbiAgICAgICAgdXBkYXRlR2VvZmVuY2VBaXJjcmFmdChlbnJpY2hlZEFpcmNyYWZ0KTtcclxuXHJcbiAgICAgICAgLy8gQ2VudGVyIHRoZSBtYXAgLSBTSU1QTElGSUVEIFpPT00gTE9HSUNcclxuICAgICAgICBpZiAobWFwSW5zdGFuY2UgJiYgY29vcmRpbmF0ZXMpIHtcclxuICAgICAgICAgIC8vIEdldCBjdXJyZW50IHpvb20gbGV2ZWxcclxuICAgICAgICAgIGNvbnN0IGN1cnJlbnRab29tID0gbWFwSW5zdGFuY2UuZ2V0Wm9vbSgpO1xyXG4gICAgICAgICAgLy8gVXNlIGFwcHJvcHJpYXRlIHpvb20gbGV2ZWwgYmFzZWQgb24gY3VycmVudCB2aWV3XHJcbiAgICAgICAgICBjb25zdCB0YXJnZXRab29tID0gY3VycmVudFpvb20gPD0gNyA/IDkgOiBjdXJyZW50Wm9vbTtcclxuXHJcbiAgICAgICAgICAvLyBTZXQgdmlldyB0byB0aGUgY29vcmRpbmF0ZXNcclxuICAgICAgICAgIG1hcEluc3RhbmNlLnNldFZpZXcoW2Nvb3JkaW5hdGVzLmxhdCwgY29vcmRpbmF0ZXMubG5nXSwgdGFyZ2V0Wm9vbSk7XHJcblxyXG4gICAgICAgICAgLy8gRW5zdXJlIG1hcCBpcyB1cGRhdGVkXHJcbiAgICAgICAgICBtYXBJbnN0YW5jZS5pbnZhbGlkYXRlU2l6ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2xvc2UgZHJvcGRvd24gYWZ0ZXIgc2VhcmNoXHJcbiAgICAgIHNldEFjdGl2ZURyb3Bkb3duKG51bGwpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBnZW9mZW5jZSBzZWFyY2g6JywgZXJyb3IpO1xyXG4gICAgICBpZiAoZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ3JhdGUgbGltaXQnKSB8fCBlcnJvci5zdGF0dXMgPT09IDQyOSkge1xyXG4gICAgICAgIGhhbmRsZVJhdGVMaW1pdCgzMCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYWxlcnQoXHJcbiAgICAgICAgICBgRXJyb3I6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvciBvY2N1cnJlZCd9YFxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgIHNldExvY2FsTG9hZGluZyhmYWxzZSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogU1RFUCAzOiBGaXggdG9nZ2xlR2VvZmVuY2VTdGF0ZSB0byBiZXR0ZXIgaGFuZGxlIG1hbnVhbGx5IGNsaWNraW5nIHRoZSBidXR0b25cclxuICAgKi9cclxuICBjb25zdCB0b2dnbGVHZW9mZW5jZVN0YXRlID0gKGVuYWJsZWQ6IGJvb2xlYW4pID0+IHtcclxuICAgIGNvbnNvbGUubG9nKCd0b2dnbGVHZW9mZW5jZVN0YXRlIGNhbGxlZCB3aXRoOicsIGVuYWJsZWQpO1xyXG4gICAgY29uc29sZS5sb2coJ0N1cnJlbnQgZ2VvZmVuY2VDb29yZGluYXRlczonLCBnZW9mZW5jZUNvb3JkaW5hdGVzKTtcclxuXHJcbiAgICBpZiAoZW5hYmxlZCkge1xyXG4gICAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIHZhbGlkIGNvb3JkaW5hdGVzXHJcbiAgICAgIGlmIChcclxuICAgICAgICBnZW9mZW5jZUNvb3JkaW5hdGVzICYmXHJcbiAgICAgICAgdHlwZW9mIGdlb2ZlbmNlQ29vcmRpbmF0ZXMubGF0ID09PSAnbnVtYmVyJyAmJlxyXG4gICAgICAgIHR5cGVvZiBnZW9mZW5jZUNvb3JkaW5hdGVzLmxuZyA9PT0gJ251bWJlcicgJiZcclxuICAgICAgICAhaXNOYU4oZ2VvZmVuY2VDb29yZGluYXRlcy5sYXQpICYmXHJcbiAgICAgICAgIWlzTmFOKGdlb2ZlbmNlQ29vcmRpbmF0ZXMubG5nKVxyXG4gICAgICApIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnVmFsaWQgY29vcmRpbmF0ZXMgZm91bmQsIGVuYWJsaW5nIGdlb2ZlbmNlJyk7XHJcblxyXG4gICAgICAgIC8vIFNldCBmbGFncyBmaXJzdFxyXG4gICAgICAgIHNldEdlb2ZlbmNlRW5hYmxlZCh0cnVlKTtcclxuICAgICAgICBzZXRJc0dlb2ZlbmNlQWN0aXZlKHRydWUpO1xyXG5cclxuICAgICAgICAvLyBDYWxsIGNvbnRleHQgdG9nZ2xlIGZ1bmN0aW9uIGlmIGF2YWlsYWJsZVxyXG4gICAgICAgIGlmICh0eXBlb2YgdG9nZ2xlR2VvZmVuY2UgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgIHRvZ2dsZUdlb2ZlbmNlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEaXNwbGF5IGFpcmNyYWZ0IGlmIHdlIGhhdmUgdGhlbVxyXG4gICAgICAgIGlmIChnZW9mZW5jZUFpcmNyYWZ0ICYmIGdlb2ZlbmNlQWlyY3JhZnQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICAgIGBTaG93aW5nICR7Z2VvZmVuY2VBaXJjcmFmdC5sZW5ndGh9IGFpcmNyYWZ0IGluIGdlb2ZlbmNlYFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIHVwZGF0ZUdlb2ZlbmNlQWlyY3JhZnQoZ2VvZmVuY2VBaXJjcmFmdCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIE5vIGFpcmNyYWZ0IGRhdGEgeWV0LCB0cmlnZ2VyIGEgc2VhcmNoXHJcbiAgICAgICAgICBjb25zb2xlLmxvZygnTm8gYWlyY3JhZnQgZGF0YSB5ZXQsIHRyaWdnZXJpbmcgc2VhcmNoJyk7XHJcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgcHJvY2Vzc0dlb2ZlbmNlU2VhcmNoKCk7XHJcbiAgICAgICAgICB9LCAxMDApO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBObyB2YWxpZCBjb29yZGluYXRlc1xyXG4gICAgICAgIGNvbnNvbGUud2FybignTm8gdmFsaWQgY29vcmRpbmF0ZXMsIHNob3dpbmcgYWxlcnQnKTtcclxuICAgICAgICBhbGVydChcclxuICAgICAgICAgICdQbGVhc2Ugc2V0IGEgbG9jYXRpb24gYmVmb3JlIGVuYWJsaW5nIGdlb2ZlbmNlLlxcblxcbkNsaWNrIGFueXdoZXJlIG9uIHRoZSBtYXAgdG8gc2V0IGEgbG9jYXRpb24uJ1xyXG4gICAgICAgICk7XHJcbiAgICAgICAgc2V0R2VvZmVuY2VFbmFibGVkKGZhbHNlKTtcclxuICAgICAgICBzZXRJc0dlb2ZlbmNlQWN0aXZlKGZhbHNlKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gRGlzYWJsaW5nIGdlb2ZlbmNlXHJcbiAgICAgIGNvbnNvbGUubG9nKCdEaXNhYmxpbmcgZ2VvZmVuY2UnKTtcclxuICAgICAgc2V0R2VvZmVuY2VFbmFibGVkKGZhbHNlKTtcclxuICAgICAgc2V0SXNHZW9mZW5jZUFjdGl2ZShmYWxzZSk7XHJcblxyXG4gICAgICAvLyBDbGVhciBnZW9mZW5jZSBkYXRhIGlmIGZ1bmN0aW9uIGF2YWlsYWJsZVxyXG4gICAgICBpZiAodHlwZW9mIGNsZWFyR2VvZmVuY2VEYXRhID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgY2xlYXJHZW9mZW5jZURhdGEoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8vIE1hbnVmYWN0dXJlciBmaWx0ZXIgbWV0aG9kc1xyXG4gIGNvbnN0IHNlbGVjdE1hbnVmYWN0dXJlckFuZENsb3NlID0gKHZhbHVlOiBzdHJpbmcpID0+IHtcclxuICAgIC8vIENsb3NlIGRyb3Bkb3duXHJcbiAgICBzZXRBY3RpdmVEcm9wZG93bihudWxsKTtcclxuICAgIHNldE1hbnVmYWN0dXJlclNlYXJjaFRlcm0oJycpO1xyXG5cclxuICAgIC8vIElmIGNsZWFyaW5nIHRoZSBzZWxlY3Rpb25cclxuICAgIGlmICh2YWx1ZSA9PT0gJycpIHtcclxuICAgICAgc2VsZWN0TWFudWZhY3R1cmVyKG51bGwpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU2V0IHRoZSBtYW51ZmFjdHVyZXIgc2VsZWN0aW9uXHJcbiAgICBzZWxlY3RNYW51ZmFjdHVyZXIodmFsdWUpO1xyXG5cclxuICAgIC8vIElmIHJlZ2lvbiBpcyBhbHJlYWR5IHNlbGVjdGVkLCBmZXRjaCBmaWx0ZXJlZCBkYXRhXHJcbiAgICBpZiAoYWN0aXZlUmVnaW9uICE9PSBudWxsKSB7XHJcbiAgICAgIGZldGNoQWlyY3JhZnRCeVJlZ2lvbkFuZE1hbnVmYWN0dXJlcihhY3RpdmVSZWdpb24gYXMgUmVnaW9uQ29kZSwgdmFsdWUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gT3RoZXJ3aXNlLCBqdXN0IHByb2NlZWQgd2l0aCBtYW51ZmFjdHVyZXItb25seSBmaWx0ZXJpbmcgYXMgYmVmb3JlXHJcbiAgICAgIGZldGNoTWFudWZhY3R1cmVyRGF0YSh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgZmV0Y2hNYW51ZmFjdHVyZXJEYXRhID0gKG1hbnVmYWN0dXJlcjogc3RyaW5nKSA9PiB7XHJcbiAgICBpZiAoaXNSYXRlTGltaXRlZCkge1xyXG4gICAgICBjb25zb2xlLmxvZyhgU2tpcHBpbmcgZGF0YSBmZXRjaCAtIHJhdGUgbGltaXRlZCBmb3IgJHtyYXRlTGltaXRUaW1lcn1zYCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zb2xlLmxvZyhgRmV0Y2hpbmcgZGF0YSBmb3IgbWFudWZhY3R1cmVyOiAke21hbnVmYWN0dXJlcn1gKTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBJZiB5b3UgaGF2ZSBhIGNvbnRleHQgZnVuY3Rpb24gZm9yIHRoaXMsIGNhbGwgaXQgYWZ0ZXIgYSBzbGlnaHQgZGVsYXlcclxuICAgICAgaWYgKHR5cGVvZiByZWZyZXNoUG9zaXRpb25zID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgLy8gQXBwbHkgYSBzbWFsbCBkZWxheSB0byBwcmV2ZW50IG92ZXJ3aGVsbWluZyB0aGUgQVBJXHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICByZWZyZXNoUG9zaXRpb25zKCkuY2F0Y2goKGVycm9yOiBhbnkpID0+IHtcclxuICAgICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCdyYXRlIGxpbWl0JykgfHwgZXJyb3Iuc3RhdHVzID09PSA0MjkpIHtcclxuICAgICAgICAgICAgICBoYW5kbGVSYXRlTGltaXQoMzApO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIG1hbnVmYWN0dXJlciBkYXRhOicsIGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSwgMjAwKTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgICBpZiAoZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ3JhdGUgbGltaXQnKSB8fCBlcnJvci5zdGF0dXMgPT09IDQyOSkge1xyXG4gICAgICAgIGhhbmRsZVJhdGVMaW1pdCgzMCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igc2NoZWR1bGluZyBtYW51ZmFjdHVyZXIgZGF0YSBmZXRjaDonLCBlcnJvcik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG5cclxuICBjb25zdCBmZXRjaEFpcmNyYWZ0QnlSZWdpb25BbmRNYW51ZmFjdHVyZXIgPSBhc3luYyAoXHJcbiAgICByZWdpb246IFJlZ2lvbkNvZGUsXHJcbiAgICBtYW51ZmFjdHVyZXI6IHN0cmluZyxcclxuICAgIHBhZ2U6IG51bWJlciA9IDEsXHJcbiAgICBsaW1pdDogbnVtYmVyID0gNTAwXHJcbiAgKSA9PiB7XHJcbiAgICBpZiAoIXJlZ2lvbiB8fCAhbWFudWZhY3R1cmVyKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdCb3RoIHJlZ2lvbiBhbmQgbWFudWZhY3R1cmVyIG11c3QgYmUgc2VsZWN0ZWQnKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHNldExvY2FsTG9hZGluZyh0cnVlKTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFxyXG4gICAgICAgIGAvYXBpL3RyYWNraW5nL2ZpbHRlcmVkLWFpcmNyYWZ0P3JlZ2lvbj0ke3JlZ2lvbn0mbWFudWZhY3R1cmVyPSR7ZW5jb2RlVVJJQ29tcG9uZW50KG1hbnVmYWN0dXJlcil9JnBhZ2U9JHtwYWdlfSZsaW1pdD0ke2xpbWl0fWBcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgIGNvbnN0IGFpcmNyYWZ0RGF0YSA9IGRhdGEuYWlyY3JhZnQgfHwgW107XHJcblxyXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBUEkgZXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUHJvY2VzcyB0aGUgZmlsdGVyZWQgYWlyY3JhZnQgZGF0YVxyXG4gICAgICBpZiAoYWlyY3JhZnREYXRhLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAvLyBUcmFuc2Zvcm0gdG8gRXh0ZW5kZWRBaXJjcmFmdFxyXG4gICAgICAgIGludGVyZmFjZSBBaXJjcmFmdERhdGEge1xyXG4gICAgICAgICAgVFlQRV9BSVJDUkFGVD86IHN0cmluZztcclxuICAgICAgICAgIE9QRVJBVE9SPzogc3RyaW5nO1xyXG4gICAgICAgICAgUkVHSU9OOiBudW1iZXI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBleHRlbmRlZEFpcmNyYWZ0OiBFeHRlbmRlZEFpcmNyYWZ0W10gPSBhaXJjcmFmdERhdGEubWFwKFxyXG4gICAgICAgICAgKGFpcmNyYWZ0OiBBaXJjcmFmdERhdGEpID0+ICh7XHJcbiAgICAgICAgICAgIC4uLmFpcmNyYWZ0LFxyXG4gICAgICAgICAgICB0eXBlOiBhaXJjcmFmdC5UWVBFX0FJUkNSQUZUIHx8ICdVbmtub3duJyxcclxuICAgICAgICAgICAgaXNHb3Zlcm5tZW50OlxyXG4gICAgICAgICAgICAgIGFpcmNyYWZ0Lk9QRVJBVE9SPy50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdnb3Zlcm5tZW50JykgPz8gZmFsc2UsXHJcbiAgICAgICAgICAgIFJFR0lPTjogYWlyY3JhZnQuUkVHSU9OLFxyXG4gICAgICAgICAgICB6b29tTGV2ZWw6IHVuZGVmaW5lZCxcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBtYXBcclxuICAgICAgICB1cGRhdGVHZW9mZW5jZUFpcmNyYWZ0KGV4dGVuZGVkQWlyY3JhZnQpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgYE5vIGFpcmNyYWZ0IGZvdW5kIGZvciBtYW51ZmFjdHVyZXIgJHttYW51ZmFjdHVyZXJ9IGluIHJlZ2lvbiAke3JlZ2lvbn1gXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgZmlsdGVyZWQgYWlyY3JhZnQ6JywgZXJyb3IpO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgc2V0TG9jYWxMb2FkaW5nKGZhbHNlKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvLyBNb2RlbCBzZWxlY3Rpb24gbWV0aG9kc1xyXG4gIGNvbnN0IGhhbmRsZU1vZGVsU2VsZWN0ID0gKHZhbHVlOiBzdHJpbmcpID0+IHtcclxuICAgIHNlbGVjdE1vZGVsKHZhbHVlID09PSAnJyA/IG51bGwgOiB2YWx1ZSk7XHJcbiAgICBzZXRBY3RpdmVEcm9wZG93bihudWxsKTtcclxuXHJcbiAgICAvLyBJZiBpbiBjb21iaW5lZCBtb2RlLCByZWFwcGx5IHRoZSBmaWx0ZXJcclxuICAgIGlmIChmaWx0ZXJNb2RlID09PSAnYm90aCcgJiYgaXNHZW9mZW5jZUFjdGl2ZSAmJiBzZWxlY3RlZE1hbnVmYWN0dXJlcikge1xyXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICBhcHBseUNvbWJpbmVkRmlsdGVycygpO1xyXG4gICAgICB9LCAxMDApO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8vIENvbWJpbmVkIGZpbHRlciBtZXRob2RzXHJcbiAgY29uc3QgYXBwbHlDb21iaW5lZEZpbHRlcnMgPSAoKSA9PiB7XHJcbiAgICBpZiAoXHJcbiAgICAgICFzZWxlY3RlZE1hbnVmYWN0dXJlciB8fFxyXG4gICAgICAhaXNHZW9mZW5jZUFjdGl2ZSB8fFxyXG4gICAgICBnZW9mZW5jZUFpcmNyYWZ0Lmxlbmd0aCA9PT0gMFxyXG4gICAgKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBzZXRMb2NhbExvYWRpbmcodHJ1ZSk7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgYEZpbHRlcmluZyAke2dlb2ZlbmNlQWlyY3JhZnQubGVuZ3RofSBhaXJjcmFmdCBieSAke3NlbGVjdGVkTWFudWZhY3R1cmVyfWBcclxuICAgICAgKTtcclxuXHJcbiAgICAgIC8vIEZpbHRlciB0aGUgYWlyY3JhZnQgYnkgbWFudWZhY3R1cmVyXHJcbiAgICAgIGxldCBmaWx0ZXJlZEFpcmNyYWZ0ID0gZ2VvZmVuY2VBaXJjcmFmdC5maWx0ZXIoXHJcbiAgICAgICAgKGFpcmNyYWZ0KSA9PlxyXG4gICAgICAgICAgYWlyY3JhZnQuTUFOVUZBQ1RVUkVSPy50b0xvd2VyQ2FzZSgpID09PVxyXG4gICAgICAgICAgc2VsZWN0ZWRNYW51ZmFjdHVyZXIudG9Mb3dlckNhc2UoKVxyXG4gICAgICApO1xyXG5cclxuICAgICAgLy8gRnVydGhlciBmaWx0ZXIgYnkgbW9kZWwgaWYgc2VsZWN0ZWRcclxuICAgICAgaWYgKHNlbGVjdGVkTW9kZWwpIHtcclxuICAgICAgICBmaWx0ZXJlZEFpcmNyYWZ0ID0gZmlsdGVyZWRBaXJjcmFmdC5maWx0ZXIoXHJcbiAgICAgICAgICAoYWlyY3JhZnQpID0+XHJcbiAgICAgICAgICAgIGFpcmNyYWZ0Lk1PREVMPy50b0xvd2VyQ2FzZSgpID09PSBzZWxlY3RlZE1vZGVsLnRvTG93ZXJDYXNlKClcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zb2xlLmxvZyhgRm91bmQgJHtmaWx0ZXJlZEFpcmNyYWZ0Lmxlbmd0aH0gbWF0Y2hpbmcgYWlyY3JhZnRgKTtcclxuXHJcbiAgICAgIGlmIChmaWx0ZXJlZEFpcmNyYWZ0Lmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIGFsZXJ0KGBObyAke3NlbGVjdGVkTWFudWZhY3R1cmVyfSBhaXJjcmFmdCBmb3VuZCBpbiB0aGlzIGFyZWEuYCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDbGVhciBkaXNwbGF5IGRhdGFcclxuICAgICAgaWYgKGNsZWFyR2VvZmVuY2VEYXRhKSB7XHJcbiAgICAgICAgY2xlYXJHZW9mZW5jZURhdGEoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVXBkYXRlIHRoZSBkaXNwbGF5XHJcbiAgICAgIHVwZGF0ZUdlb2ZlbmNlQWlyY3JhZnQoZmlsdGVyZWRBaXJjcmFmdCk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmaWx0ZXJpbmcgYWlyY3JhZnQ6JywgZXJyb3IpO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgc2V0TG9jYWxMb2FkaW5nKGZhbHNlKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvLyBSZXNldCBhbGwgZmlsdGVyc1xyXG4gIGNvbnN0IGNsZWFyQWxsRmlsdGVycyA9ICgpID0+IHtcclxuICAgIGNvbnNvbGUubG9nKCdDbGVhcmluZyBhbGwgZmlsdGVycy4uLicpO1xyXG5cclxuICAgIC8vIDEuIFJlc2V0IGZpbHRlciBtb2RlXHJcbiAgICBzZXRGaWx0ZXJNb2RlKCdtYW51ZmFjdHVyZXInKTtcclxuXHJcbiAgICAvLyAyLiBVbmJsb2NrIEFQSSBjYWxscyB0aGF0IG1pZ2h0IGhhdmUgYmVlbiBibG9ja2VkXHJcbiAgICBvcGVuU2t5VHJhY2tpbmdTZXJ2aWNlLnNldEJsb2NrQWxsQXBpQ2FsbHMoZmFsc2UpO1xyXG4gICAgc2V0QmxvY2tNYW51ZmFjdHVyZXJBcGlDYWxscyhmYWxzZSk7XHJcbiAgICBzZXRJc01hbnVmYWN0dXJlckFwaUJsb2NrZWQoZmFsc2UpO1xyXG5cclxuICAgIC8vIDMuIENsZWFyIG1hbnVmYWN0dXJlciBzZWxlY3Rpb25cclxuICAgIHNlbGVjdE1hbnVmYWN0dXJlcihudWxsKTtcclxuICAgIHNlbGVjdE1vZGVsKG51bGwpO1xyXG5cclxuICAgIC8vIDQuIENsZWFyIGdlb2ZlbmNlXHJcbiAgICBzZXRHZW9mZW5jZUxvY2F0aW9uKCcnKTtcclxuICAgIHNldEdlb2ZlbmNlQ29vcmRpbmF0ZXMobnVsbCk7XHJcbiAgICBzZXRHZW9mZW5jZUFpcmNyYWZ0KFtdKTtcclxuICAgIHNldEdlb2ZlbmNlRW5hYmxlZChmYWxzZSk7XHJcbiAgICBzZXRJc0dlb2ZlbmNlQWN0aXZlKGZhbHNlKTtcclxuICAgIGlmICh0eXBlb2YgY2xlYXJHZW9mZW5jZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICBjbGVhckdlb2ZlbmNlKCk7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIGNsZWFyR2VvZmVuY2VEYXRhID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIGNsZWFyR2VvZmVuY2VEYXRhKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gNS4gUmVzZXQgb3duZXIgZmlsdGVycyB0byBzZWxlY3QgYWxsXHJcbiAgICBzZXRPd25lckZpbHRlcnMoWy4uLmFsbE93bmVyVHlwZXNdKTtcclxuXHJcbiAgICAvLyA2LiBDbGVhciByZWdpb24gZmlsdGVyIHByb3Blcmx5XHJcbiAgICBzZXRBY3RpdmVSZWdpb24obnVsbCk7XHJcbiAgICBzZXRTZWxlY3RlZFJlZ2lvbihSZWdpb25Db2RlLkdMT0JBTCk7XHJcblxyXG4gICAgLy8gQ2xlYXIgcmVnaW9uIG91dGxpbmUgZnJvbSBtYXBcclxuICAgIGlmIChyZWdpb25PdXRsaW5lKSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgLy8gSGFuZGxlIGRpZmZlcmVudCBwb3NzaWJsZSBvYmplY3Qgc3RydWN0dXJlc1xyXG4gICAgICAgIGlmICh0eXBlb2YgcmVnaW9uT3V0bGluZS5yZW1vdmUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgIHJlZ2lvbk91dGxpbmUucmVtb3ZlKCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChcclxuICAgICAgICAgIHJlZ2lvbk91dGxpbmUucmVjdGFuZ2xlICYmXHJcbiAgICAgICAgICB0eXBlb2YgcmVnaW9uT3V0bGluZS5yZWN0YW5nbGUucmVtb3ZlID09PSAnZnVuY3Rpb24nXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICByZWdpb25PdXRsaW5lLnJlY3RhbmdsZS5yZW1vdmUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENsZWFyIGFueSBsYWJlbHMgYXNzb2NpYXRlZCB3aXRoIHRoZSByZWdpb25cclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICByZWdpb25PdXRsaW5lLmxhYmVsICYmXHJcbiAgICAgICAgICB0eXBlb2YgcmVnaW9uT3V0bGluZS5sYWJlbC5yZW1vdmUgPT09ICdmdW5jdGlvbidcclxuICAgICAgICApIHtcclxuICAgICAgICAgIHJlZ2lvbk91dGxpbmUubGFiZWwucmVtb3ZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlbW92aW5nIHJlZ2lvbiBvdXRsaW5lOicsIGVycm9yKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQWx3YXlzIHJlc2V0IHRoZSByZWdpb24gb3V0bGluZSBzdGF0ZVxyXG4gICAgICBzZXRSZWdpb25PdXRsaW5lKG51bGwpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIDcuIFJlc2V0IG1hcCB2aWV3IHRvIGdsb2JhbFxyXG4gICAgaWYgKG1hcEluc3RhbmNlKSB7XHJcbiAgICAgIC8vIFVzZSB0aGUgcHJlZGVmaW5lZCBjZW50ZXIgYW5kIHpvb20gbGV2ZWwgZnJvbSB5b3VyIG1hcCBjb25maWdcclxuICAgICAgbWFwSW5zdGFuY2Uuc2V0VmlldyhNQVBfQ09ORklHLkNFTlRFUiwgTUFQX0NPTkZJRy5ERUZBVUxUX1pPT00pO1xyXG4gICAgICBtYXBJbnN0YW5jZS5pbnZhbGlkYXRlU2l6ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIDguIFJlc2V0IHRvIGluaXRpYWwgYWlyY3JhZnQgZGF0YVxyXG4gICAgaWYgKHR5cGVvZiByZXNldCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICByZXNldCgpO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZnVsbFJlZnJlc2ggPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgZnVsbFJlZnJlc2goKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyA5LiBDbG9zZSBhbnkgb3BlbiBkcm9wZG93blxyXG4gICAgc2V0QWN0aXZlRHJvcGRvd24obnVsbCk7XHJcblxyXG4gICAgLy8gMTAuIFJlc2V0IHJhdGUgbGltaXRpbmcgc3RhdGVzXHJcbiAgICBzZXRJc1JhdGVMaW1pdGVkKGZhbHNlKTtcclxuICAgIHNldFJhdGVMaW1pdFRpbWVyKG51bGwpO1xyXG5cclxuICAgIC8vIDExLiBDbGVhciBjb21iaW5lZCBtb2RlIHN0YXRlXHJcbiAgICBzZXRDb21iaW5lZE1vZGVSZWFkeShmYWxzZSk7XHJcblxyXG4gICAgLy8gMTIuIFJlc2V0IHNlYXJjaCB0ZXJtc1xyXG4gICAgc2V0TWFudWZhY3R1cmVyU2VhcmNoVGVybSgnJyk7XHJcblxyXG4gICAgLy8gMTMuIERpc3BhdGNoIGEgY3VzdG9tIGV2ZW50IHRoYXQgb3RoZXIgY29tcG9uZW50cyBjYW4gbGlzdGVuIGZvclxyXG4gICAgY29uc3QgY2xlYXJFdmVudCA9IG5ldyBDdXN0b21FdmVudCgncmliYm9uLWZpbHRlcnMtY2xlYXJlZCcpO1xyXG4gICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChjbGVhckV2ZW50KTtcclxuXHJcbiAgICBjb25zb2xlLmxvZygnQWxsIGZpbHRlcnMgY2xlYXJlZCBzdWNjZXNzZnVsbHknKTtcclxuICB9O1xyXG5cclxuICAvLyBDYWxjdWxhdGUgY29tYmluZWQgbG9hZGluZyBzdGF0ZVxyXG4gIGNvbnN0IGNvbWJpbmVkTG9hZGluZyA9IGxvY2FsTG9hZGluZztcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIC8vIFN0YXRlXHJcbiAgICBmaWx0ZXJNb2RlLFxyXG4gICAgYWN0aXZlRHJvcGRvd24sXHJcbiAgICBzZWxlY3RlZE1hbnVmYWN0dXJlcixcclxuICAgIHNlbGVjdGVkTW9kZWwsXHJcbiAgICBnZW9mZW5jZUxvY2F0aW9uLFxyXG4gICAgZ2VvZmVuY2VSYWRpdXMsXHJcbiAgICBpc0dlb2ZlbmNlQWN0aXZlLFxyXG4gICAgZ2VvZmVuY2VDb29yZGluYXRlcyxcclxuICAgIGdldFVzZXJMb2NhdGlvbixcclxuICAgIGFjdGl2ZVJlZ2lvbixcclxuICAgIG93bmVyRmlsdGVycyxcclxuICAgIGFsbE93bmVyVHlwZXMsXHJcbiAgICBtYW51ZmFjdHVyZXJTZWFyY2hUZXJtLFxyXG4gICAgY29tYmluZWRMb2FkaW5nLFxyXG4gICAgaXNHZXR0aW5nTG9jYXRpb24sXHJcbiAgICBkcm9wZG93blJlZnMsXHJcbiAgICBsb2NhbExvYWRpbmcsXHJcbiAgICBpc1JhdGVMaW1pdGVkLFxyXG4gICAgc2VsZWN0ZWRSZWdpb24sXHJcbiAgICBpc1JlZnJlc2hpbmcsXHJcbiAgICBpc0dlb2ZlbmNlUGxhY2VtZW50TW9kZTogZmFsc2UsIC8vIEluaXRpYWxpemUgd2l0aCBhIGRlZmF1bHQgdmFsdWVcclxuXHJcbiAgICAvLyBNZXRob2RzXHJcbiAgICB0b2dnbGVEcm9wZG93bixcclxuICAgIHRvZ2dsZUZpbHRlck1vZGUsXHJcbiAgICBzZWxlY3RNYW51ZmFjdHVyZXJBbmRDbG9zZSxcclxuICAgIGhhbmRsZU1vZGVsU2VsZWN0LFxyXG4gICAgZ2V0VXNlckxvY2F0aW9uLFxyXG4gICAgcHJvY2Vzc0dlb2ZlbmNlU2VhcmNoLFxyXG4gICAgaGFuZGxlT3duZXJGaWx0ZXJDaGFuZ2UsXHJcbiAgICBoYW5kbGVSZWdpb25TZWxlY3QsXHJcbiAgICBzZXRNYW51ZmFjdHVyZXJTZWFyY2hUZXJtLFxyXG4gICAgc2V0R2VvZmVuY2VMb2NhdGlvbixcclxuICAgIHNldEdlb2ZlbmNlUmFkaXVzLFxyXG4gICAgdG9nZ2xlR2VvZmVuY2VTdGF0ZSxcclxuICAgIGNsZWFyQWxsRmlsdGVycyxcclxuICAgIGFwcGx5Q29tYmluZWRGaWx0ZXJzLFxyXG4gICAgZ2V0QWlyY3JhZnRPd25lclR5cGUsXHJcblxyXG4gICAgcmVmcmVzaFdpdGhGaWx0ZXJzOiAoKSA9PiB7XHJcbiAgICAgIC8vIEltcGxlbWVudCByZWZyZXNoIGxvZ2ljIGhlcmVcclxuICAgICAgaWYgKHR5cGVvZiByZWZyZXNoUG9zaXRpb25zID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgcmVmcmVzaFBvc2l0aW9ucygpLmNhdGNoKChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVmcmVzaGluZyBwb3NpdGlvbnM6JywgZXJyb3IpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgc2V0QWN0aXZlRHJvcGRvd24sIC8vIEFkZCB0aGlzIGxpbmUgaWYgeW91IGhhdmUgdGhpcyBmdW5jdGlvblxyXG5cclxuICAgIHNldEdlb2ZlbmNlQ29vcmRpbmF0ZXMsXHJcbiAgICBzZXRHZW9mZW5jZUNlbnRlcixcclxuICAgIHVwZGF0ZUdlb2ZlbmNlQWlyY3JhZnQsXHJcbiAgfTtcclxufVxyXG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VSZWYiLCJ1c2VFZmZlY3QiLCJSZWFjdCIsIlJlZ2lvbkNvZGUiLCJ1c2VFbmhhbmNlZE1hcENvbnRleHQiLCJvcGVuU2t5VHJhY2tpbmdTZXJ2aWNlIiwiTWFwYm94U2VydmljZSIsImFkYXB0R2VvZmVuY2VBaXJjcmFmdCIsImVucmljaEdlb2ZlbmNlQWlyY3JhZnQiLCJnZXRBaXJjcmFmdE5lYXJMb2NhdGlvbiIsImdldEFpcmNyYWZ0TmVhclNlYXJjaGVkTG9jYXRpb24iLCJ1c2VHZW9sb2NhdGlvbiIsIk1BUF9DT05GSUciLCJnZXRCb3VuZHNCeVJlZ2lvbiIsImdldFpvb21MZXZlbEZvclJlZ2lvbiIsInVzZUZpbHRlckxvZ2ljIiwic2VsZWN0ZWRNYW51ZmFjdHVyZXIiLCJzZWxlY3RlZE1vZGVsIiwidG90YWxBY3RpdmUiLCJzZWxlY3RNYW51ZmFjdHVyZXIiLCJzZWxlY3RNb2RlbCIsInJlc2V0IiwiZnVsbFJlZnJlc2giLCJyZWZyZXNoUG9zaXRpb25zIiwibWFwSW5zdGFuY2UiLCJ1cGRhdGVBaXJjcmFmdERhdGEiLCJjbGVhckdlb2ZlbmNlRGF0YSIsInVwZGF0ZUdlb2ZlbmNlQWlyY3JhZnQiLCJibG9ja01hbnVmYWN0dXJlckFwaUNhbGxzIiwic2V0QmxvY2tNYW51ZmFjdHVyZXJBcGlDYWxscyIsImlzTWFudWZhY3R1cmVyQXBpQmxvY2tlZCIsInNldElzTWFudWZhY3R1cmVyQXBpQmxvY2tlZCIsImdlb2ZlbmNlQ2VudGVyIiwic2V0R2VvZmVuY2VDZW50ZXIiLCJ0b2dnbGVHZW9mZW5jZSIsImNsZWFyR2VvZmVuY2UiLCJkaXNwbGF5ZWRBaXJjcmFmdCIsImxvY2F0aW9uTmFtZSIsImlzTG9hZGluZ0xvY2F0aW9uIiwiZ2V0Q3VycmVudFBvc2l0aW9uIiwibG9jYWxMb2FkaW5nIiwic2V0TG9jYWxMb2FkaW5nIiwiZmlsdGVyTW9kZSIsInNldEZpbHRlck1vZGUiLCJhY3RpdmVEcm9wZG93biIsInNldEFjdGl2ZURyb3Bkb3duIiwibWFudWZhY3R1cmVyU2VhcmNoVGVybSIsInNldE1hbnVmYWN0dXJlclNlYXJjaFRlcm0iLCJpc1JlZnJlc2hpbmciLCJzZXRJc1JlZnJlc2hpbmciLCJpc1JhdGVMaW1pdGVkIiwic2V0SXNSYXRlTGltaXRlZCIsInJhdGVMaW1pdFRpbWVyIiwic2V0UmF0ZUxpbWl0VGltZXIiLCJpc0dldHRpbmdMb2NhdGlvbiIsInNldElzR2V0dGluZ0xvY2F0aW9uIiwiZ2VvZmVuY2VMb2NhdGlvbiIsInNldEdlb2ZlbmNlTG9jYXRpb24iLCJnZW9mZW5jZVJhZGl1cyIsInNldEdlb2ZlbmNlUmFkaXVzIiwiZ2VvZmVuY2VDb29yZGluYXRlcyIsInNldEdlb2ZlbmNlQ29vcmRpbmF0ZXMiLCJnZW9mZW5jZUFpcmNyYWZ0Iiwic2V0R2VvZmVuY2VBaXJjcmFmdCIsImdlb2ZlbmNlRW5hYmxlZCIsInNldEdlb2ZlbmNlRW5hYmxlZCIsImlzR2VvZmVuY2VBY3RpdmUiLCJzZXRJc0dlb2ZlbmNlQWN0aXZlIiwiaXNTZWFyY2hSZWFkeSIsInNldElzU2VhcmNoUmVhZHkiLCJhY3RpdmVSZWdpb24iLCJzZXRBY3RpdmVSZWdpb24iLCJyZWdpb25PdXRsaW5lIiwic2V0UmVnaW9uT3V0bGluZSIsInNlbGVjdGVkUmVnaW9uIiwic2V0U2VsZWN0ZWRSZWdpb24iLCJHTE9CQUwiLCJjb21iaW5lZE1vZGVSZWFkeSIsInNldENvbWJpbmVkTW9kZVJlYWR5IiwiYWxsT3duZXJUeXBlcyIsIm93bmVyRmlsdGVycyIsInNldE93bmVyRmlsdGVycyIsImRyb3Bkb3duUmVmcyIsImZpbHRlciIsIm1hbnVmYWN0dXJlciIsIm1vZGVsIiwibG9jYXRpb24iLCJyZWdpb24iLCJvd25lciIsImFjdGlvbnMiLCJnZW9sb2NhdGlvbiIsInRpbWVyIiwic2V0VGltZW91dCIsImNvbnNvbGUiLCJsb2ciLCJjbGVhclRpbWVvdXQiLCJoYW5kbGVDbGlja091dHNpZGUiLCJldmVudCIsImlzT3V0c2lkZUFsbCIsIk9iamVjdCIsInZhbHVlcyIsImV2ZXJ5IiwicmVmIiwiY3VycmVudCIsImNvbnRhaW5zIiwidGFyZ2V0IiwiZG9jdW1lbnQiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInJlbW92ZSIsImhhbmRsZU1hcEdlb2ZlbmNlQ2xpY2siLCJjdXN0b21FdmVudCIsImxhdCIsImxuZyIsImRldGFpbCIsInRvRml4ZWQiLCJnZXRMb2NhdGlvbk5hbWVGcm9tQ29vcmRpbmF0ZXMiLCJlcnJvciIsInRvZ2dsZURyb3Bkb3duIiwiZHJvcGRvd24iLCJzdG9wUHJvcGFnYXRpb24iLCJoYW5kbGVSYXRlTGltaXQiLCJyZXRyeUFmdGVyIiwic2V0QmxvY2tBbGxBcGlDYWxscyIsImFsZXJ0IiwidG9nZ2xlRmlsdGVyTW9kZSIsIm1vZGUiLCJsZW5ndGgiLCJmaWx0ZXJBaXJjcmFmdEJ5UmVnaW9uIiwidG9TdHJpbmciLCJhaXJjcmFmdFdpdGhWYWxpZENvb3JkcyIsInBsYW5lIiwibGF0aXR1ZGUiLCJsb25naXR1ZGUiLCJpc05hTiIsImZpbHRlcmVkQnlPd25lciIsImFpcmNyYWZ0IiwiaW5jbHVkZXMiLCJnZXRBaXJjcmFmdE93bmVyVHlwZSIsImFwcGx5Q29tYmluZWRGaWx0ZXJzIiwib3duZXJUeXBlIiwiVFlQRV9SRUdJU1RSQU5UIiwib3duZXJUeXBlVG9TdHJpbmciLCJ0eXBlIiwidHlwZU51bSIsInBhcnNlSW50Iiwib3duZXJUeXBlTWFwIiwiYXBwbHlPd25lclR5cGVGaWx0ZXIiLCJmaWx0ZXJzIiwiZmlsdGVyZWRBaXJjcmFmdCIsImhhbmRsZU93bmVyRmlsdGVyQ2hhbmdlIiwidXBkYXRlZEZpbHRlcnMiLCJyZXNldE93bmVyRmlsdGVycyIsImJvdW5kc0V4cHJlc3Npb24iLCJBcnJheSIsImlzQXJyYXkiLCJtaW5MYXQiLCJtaW5MbmciLCJtYXhMYXQiLCJtYXhMbmciLCJoYW5kbGVSZWdpb25TZWxlY3QiLCJib3VuZHMiLCJ6b29tTGV2ZWwiLCJzZXRab29tIiwib3B0aW9ucyIsInBhZGRpbmciLCJQQURESU5HIiwiREVGQVVMVCIsImZpdEJvdW5kcyIsImludmFsaWRhdGVTaXplIiwiZHJhd1JlZ2lvbk91dGxpbmUiLCJjb3VudFJlc3BvbnNlIiwiZmV0Y2giLCJvayIsImNvdW50RGF0YSIsImpzb24iLCJjb3VudCIsIkwiLCJyZXF1aXJlIiwicmVjdGFuZ2xlIiwiY29sb3IiLCJ3ZWlnaHQiLCJvcGFjaXR5IiwiZmlsbCIsImZpbGxDb2xvciIsImZpbGxPcGFjaXR5IiwiZGFzaEFycmF5IiwiaW50ZXJhY3RpdmUiLCJhZGRUbyIsImdldFVzZXJMb2NhdGlvbiIsInBvc2l0aW9uIiwiY29vcmRzIiwiZmV0Y2hlZEFpcmNyYWZ0IiwiYWRhcHRlZEFpcmNyYWZ0IiwiZW5yaWNoZWRBaXJjcmFmdCIsImN1cnJlbnRab29tIiwiZ2V0Wm9vbSIsInRhcmdldFpvb20iLCJzZXRWaWV3IiwibWVzc2FnZSIsInN0YXR1cyIsInByb2Nlc3NHZW9mZW5jZVNlYXJjaCIsImxvY2F0aW9ucyIsInNlYXJjaExvY2F0aW9uV2l0aE1hcGJveCIsImNvb3JkaW5hdGVzIiwibmFtZSIsIkVycm9yIiwiTUFOVUZBQ1RVUkVSIiwidW5kZWZpbmVkIiwidG9nZ2xlR2VvZmVuY2VTdGF0ZSIsImVuYWJsZWQiLCJ3YXJuIiwic2VsZWN0TWFudWZhY3R1cmVyQW5kQ2xvc2UiLCJ2YWx1ZSIsImZldGNoQWlyY3JhZnRCeVJlZ2lvbkFuZE1hbnVmYWN0dXJlciIsImZldGNoTWFudWZhY3R1cmVyRGF0YSIsImNhdGNoIiwicGFnZSIsImxpbWl0IiwicmVzcG9uc2UiLCJlbmNvZGVVUklDb21wb25lbnQiLCJkYXRhIiwiYWlyY3JhZnREYXRhIiwic3RhdHVzVGV4dCIsImV4dGVuZGVkQWlyY3JhZnQiLCJtYXAiLCJUWVBFX0FJUkNSQUZUIiwiaXNHb3Zlcm5tZW50IiwiT1BFUkFUT1IiLCJ0b0xvd2VyQ2FzZSIsIlJFR0lPTiIsImhhbmRsZU1vZGVsU2VsZWN0IiwiTU9ERUwiLCJjbGVhckFsbEZpbHRlcnMiLCJsYWJlbCIsIkNFTlRFUiIsIkRFRkFVTFRfWk9PTSIsImNsZWFyRXZlbnQiLCJDdXN0b21FdmVudCIsImRpc3BhdGNoRXZlbnQiLCJjb21iaW5lZExvYWRpbmciLCJpc0dlb2ZlbmNlUGxhY2VtZW50TW9kZSIsInJlZnJlc2hXaXRoRmlsdGVycyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/tracking/hooks/useFilterLogic.ts\n"));

/***/ })

});
"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_pages-dir-browser_components_tracking_map_AircraftTrackingMap_tsx",{

/***/ "(pages-dir-browser)/./components/tracking/hooks/useFilterLogic.ts":
/*!*****************************************************!*\
  !*** ./components/tracking/hooks/useFilterLogic.ts ***!
  \*****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useFilterLogic: () => (/* binding */ useFilterLogic)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _types_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/types/base */ \"(pages-dir-browser)/./types/base.ts\");\n/* harmony import */ var _context_EnhancedMapContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../context/EnhancedMapContext */ \"(pages-dir-browser)/./components/tracking/context/EnhancedMapContext.tsx\");\n/* harmony import */ var _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/services/openSkyTrackingService */ \"(pages-dir-browser)/./lib/services/openSkyTrackingService.ts\");\n/* harmony import */ var _lib_services_MapboxService__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../lib/services/MapboxService */ \"(pages-dir-browser)/./lib/services/MapboxService.ts\");\n/* harmony import */ var _lib_utils_geofenceAdapter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/lib/utils/geofenceAdapter */ \"(pages-dir-browser)/./lib/utils/geofenceAdapter.ts\");\n/* harmony import */ var _lib_utils_geofenceEnricher__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/lib/utils/geofenceEnricher */ \"(pages-dir-browser)/./lib/utils/geofenceEnricher.ts\");\n/* harmony import */ var _hooks_useGeolocationServices__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../hooks/useGeolocationServices */ \"(pages-dir-browser)/./components/tracking/hooks/useGeolocationServices.ts\");\n/* harmony import */ var _lib_services_geofencing__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../lib/services/geofencing */ \"(pages-dir-browser)/./lib/services/geofencing.ts\");\n/* harmony import */ var _hooks_useGeolocation__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../hooks/useGeolocation */ \"(pages-dir-browser)/./components/tracking/hooks/useGeolocation.ts\");\n/* harmony import */ var _config_map__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../config/map */ \"(pages-dir-browser)/./config/map.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\nfunction useFilterLogic() {\n    // Get context state and functions\n    const { selectedManufacturer, selectedModel, totalActive, selectManufacturer, selectModel, reset, fullRefresh, refreshPositions, mapInstance, updateAircraftData, clearGeofenceData, updateGeofenceAircraft, blockManufacturerApiCalls, setBlockManufacturerApiCalls, isManufacturerApiBlocked, setIsManufacturerApiBlocked, geofenceCenter, setGeofenceCenter, toggleGeofence, clearGeofence, displayedAircraft } = (0,_context_EnhancedMapContext__WEBPACK_IMPORTED_MODULE_2__.useEnhancedMapContext)();\n    // Use our combined geolocation services hook\n    const geolocationServices = (0,_hooks_useGeolocationServices__WEBPACK_IMPORTED_MODULE_7__.useGeolocationServices)();\n    // Local state\n    const [localLoading, setLocalLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [filterMode, setFilterMode] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [activeDropdown, setActiveDropdown] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [manufacturerSearchTerm, setManufacturerSearchTerm] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)('');\n    const [isRefreshing, setIsRefreshing] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [isRateLimited, setIsRateLimited] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [rateLimitTimer, setRateLimitTimer] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    // Geofence state\n    const [isGettingLocation, setIsGettingLocation] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [geofenceLocation, setGeofenceLocation] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)('');\n    const [geofenceRadius, setGeofenceRadius] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(25);\n    const [geofenceCoordinates, setGeofenceCoordinates] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [geofenceAircraft, setGeofenceAircraft] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [geofenceEnabled, setGeofenceEnabled] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [isGeofenceActive, setIsGeofenceActive] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [isSearchReady, setIsSearchReady] = react__WEBPACK_IMPORTED_MODULE_0___default().useState(false);\n    // Region state\n    const [activeRegion, setActiveRegion] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [regionOutline, setRegionOutline] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [selectedRegion, setSelectedRegion] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(_types_base__WEBPACK_IMPORTED_MODULE_1__.RegionCode.GLOBAL);\n    // Combined mode state\n    const [combinedModeReady, setCombinedModeReady] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    // Owner filter state\n    const allOwnerTypes = [\n        'individual',\n        'partnership',\n        'corp-owner',\n        'co-owned',\n        'llc',\n        'non-citizen-corp',\n        'airline',\n        'freight',\n        'medical',\n        'media',\n        'historical',\n        'flying-club',\n        'emergency',\n        'local-govt',\n        'education',\n        'federal-govt',\n        'flight-school',\n        'leasing-corp',\n        'military',\n        'unknown'\n    ];\n    const [ownerFilters, setOwnerFilters] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([\n        ...allOwnerTypes\n    ]);\n    // Refs for dropdown handling\n    const dropdownRefs = {\n        filter: (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),\n        manufacturer: (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),\n        model: (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),\n        location: (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),\n        region: (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),\n        owner: (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),\n        actions: (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null)\n    };\n    // Get geolocation hook - use the entire hook instance\n    const geolocation = (0,_hooks_useGeolocation__WEBPACK_IMPORTED_MODULE_9__.useGeolocation)(null);\n    // Geofence methods\n    // Fixed getUserLocation function to use the geolocation hook\n    const getUserLocation = async ()=>{\n        if (isRateLimited) {\n            alert(\"Rate limited. Please wait \".concat(rateLimitTimer || 30, \" seconds before trying to get location.\"));\n            return;\n        }\n        setIsGettingLocation(true);\n        try {\n            // Use the getCurrentPosition from our combined hook\n            const position = await geolocationServices.getCurrentPosition();\n            if (position) {\n                const { latitude, longitude } = position.coords;\n                // Update state with coordinates\n                setGeofenceCoordinates({\n                    lat: latitude,\n                    lng: longitude\n                });\n                setGeofenceCenter({\n                    lat: latitude,\n                    lng: longitude\n                });\n                // Update the location display with coordinates\n                setGeofenceLocation(\"\".concat(latitude.toFixed(6), \", \").concat(longitude.toFixed(6)));\n                // Automatically trigger the geofence search\n                try {\n                    const fetchedAircraft = await (0,_lib_services_geofencing__WEBPACK_IMPORTED_MODULE_8__.getAircraftNearLocation)(latitude, longitude, geofenceRadius);\n                    if (fetchedAircraft.length === 0) {\n                        alert(\"No aircraft found near your current location. Try increasing the radius.\");\n                        setIsGettingLocation(false);\n                        return;\n                    }\n                    // Process the aircraft data\n                    const adaptedAircraft = (0,_lib_utils_geofenceAdapter__WEBPACK_IMPORTED_MODULE_5__.adaptGeofenceAircraft)(fetchedAircraft);\n                    const enrichedAircraft = await (0,_lib_utils_geofenceEnricher__WEBPACK_IMPORTED_MODULE_6__.enrichGeofenceAircraft)(adaptedAircraft);\n                    // Save to local state\n                    setGeofenceAircraft(enrichedAircraft);\n                    // Clear existing aircraft data\n                    if (clearGeofenceData) {\n                        clearGeofenceData();\n                    }\n                    // Update the map with new aircraft\n                    updateGeofenceAircraft(enrichedAircraft);\n                    setIsGeofenceActive(true);\n                    // Center the map on user's location - SIMPLIFIED ZOOM LOGIC\n                    if (mapInstance) {\n                        // Don't modify zoom if it's already at an appropriate level\n                        const currentZoom = mapInstance.getZoom();\n                        const targetZoom = currentZoom <= 7 ? 9 : currentZoom;\n                        // Set the view directly to the user's location\n                        mapInstance.setView([\n                            latitude,\n                            longitude\n                        ], targetZoom);\n                        // Make sure the map reflects changes\n                        mapInstance.invalidateSize();\n                    }\n                    // If in geofence mode, ensure the filter mode is set correctly\n                    if (filterMode !== 'geofence' && filterMode !== 'both') {\n                        setFilterMode('geofence');\n                    }\n                } catch (error) {\n                    var _error_message;\n                    if (((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes('rate limit')) || error.status === 429) {\n                        handleRateLimit(30);\n                        // Still update the location even if we couldn't get aircraft\n                        if (mapInstance) {\n                            mapInstance.setView([\n                                latitude,\n                                longitude\n                            ], 9);\n                            mapInstance.invalidateSize();\n                        }\n                    } else {\n                        throw error;\n                    }\n                }\n                // Close the dropdown after selection\n                setActiveDropdown(null);\n            }\n        } catch (error) {\n            console.error('Error getting user location:', error);\n            alert('Unable to access your location. Please make sure location services are enabled in your browser.');\n        } finally{\n            setIsGettingLocation(false);\n        }\n    };\n    const processGeofenceSearch = async ()=>{\n        if (!geofenceLocation) return;\n        // Check if rate limited\n        if (isRateLimited) {\n            alert(\"Rate limited. Please wait \".concat(rateLimitTimer || 30, \" seconds before searching again.\"));\n            return;\n        }\n        // Block API calls while doing geofence search in combined mode\n        if (filterMode === 'both') {\n            _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].setBlockAllApiCalls(true);\n            setBlockManufacturerApiCalls(true);\n        }\n        // Set loading state\n        setLocalLoading(true);\n        try {\n            console.log('Searching for aircraft near location: \"'.concat(geofenceLocation, '\"'));\n            // This will handle Postal codes, place names, addresses, POIs, etc.\n            let fetchedAircraft;\n            try {\n                fetchedAircraft = await (0,_lib_services_geofencing__WEBPACK_IMPORTED_MODULE_8__.getAircraftNearSearchedLocation)(geofenceLocation, geofenceRadius);\n            } catch (error) {\n                var _error_message;\n                if (((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes('rate limit')) || error.status === 429) {\n                    const retryAfter = 30; // Default to 30 seconds if not specified\n                    handleRateLimit(retryAfter);\n                    setLocalLoading(false);\n                    return;\n                }\n                throw error;\n            }\n            // Get coordinates for the map\n            let locations;\n            try {\n                locations = await _lib_services_MapboxService__WEBPACK_IMPORTED_MODULE_4__.MapboxService.searchLocationWithMapbox(geofenceLocation, 1);\n            } catch (error) {\n                console.error('Error searching location with Mapbox:', error);\n                // Continue with aircraft data if available\n                locations = [];\n            }\n            let coordinates = null;\n            if (locations.length > 0) {\n                coordinates = {\n                    lat: locations[0].lat,\n                    lng: locations[0].lng\n                };\n                // Save the formatted location name\n                setGeofenceLocation(locations[0].name);\n            } else if (fetchedAircraft.length > 0 && fetchedAircraft[0].latitude && fetchedAircraft[0].longitude) {\n                // Fallback to first aircraft position\n                coordinates = {\n                    lat: fetchedAircraft[0].latitude,\n                    lng: fetchedAircraft[0].longitude\n                };\n            }\n            if (fetchedAircraft.length === 0) {\n                alert(\"No aircraft found near \".concat(geofenceLocation, \". Try increasing the radius or searching in a different area.\"));\n                setLocalLoading(false);\n                return;\n            }\n            // Update state with the coordinates\n            if (coordinates) {\n                setGeofenceCoordinates(coordinates);\n                setGeofenceCenter(coordinates);\n                setGeofenceRadius(geofenceRadius);\n            }\n            if (!isGeofenceActive) {\n                toggleGeofence();\n            } else if (!coordinates) {\n                throw new Error('Could not determine coordinates for the location');\n            }\n            console.log(\"Found \".concat(fetchedAircraft.length, \" aircraft in the area, preparing for display...\"));\n            // Ensure the data is in the right format\n            const adaptedAircraft = fetchedAircraft[0].MANUFACTURER !== undefined ? fetchedAircraft // Already in the right format\n             : (0,_lib_utils_geofenceAdapter__WEBPACK_IMPORTED_MODULE_5__.adaptGeofenceAircraft)(fetchedAircraft); // Needs adaptation\n            // Enrich with static data\n            console.log('Enriching geofence aircraft with static data...');\n            const enrichedAircraft = await (0,_lib_utils_geofenceEnricher__WEBPACK_IMPORTED_MODULE_6__.enrichGeofenceAircraft)(adaptedAircraft);\n            // Save the FULL set to local state\n            setGeofenceAircraft(enrichedAircraft);\n            setIsGeofenceActive(true);\n            // Clear existing aircraft data\n            if (clearGeofenceData) {\n                clearGeofenceData();\n            }\n            // If we're in combined mode and have a manufacturer, apply the combined filter\n            if (filterMode === 'both' && selectedManufacturer) {\n                // Make sure API calls remain blocked\n                _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].setBlockAllApiCalls(true);\n                setBlockManufacturerApiCalls(true);\n                setTimeout(()=>{\n                    applyCombinedFilters();\n                }, 100);\n            } else {\n                // Just show all aircraft in the geofence\n                updateGeofenceAircraft(enrichedAircraft);\n                // Center the map - SIMPLIFIED ZOOM LOGIC\n                if (mapInstance && coordinates) {\n                    // Get current zoom level\n                    const currentZoom = mapInstance.getZoom();\n                    // Use appropriate zoom level based on current view\n                    const targetZoom = currentZoom <= 7 ? 9 : currentZoom;\n                    // Set view to the coordinates\n                    mapInstance.setView([\n                        coordinates.lat,\n                        coordinates.lng\n                    ], targetZoom);\n                    // Ensure map is updated\n                    mapInstance.invalidateSize();\n                }\n            }\n            // Close dropdown after search\n            setActiveDropdown(null);\n        } catch (error) {\n            var _error_message1;\n            console.error('Error in geofence search:', error);\n            if (((_error_message1 = error.message) === null || _error_message1 === void 0 ? void 0 : _error_message1.includes('rate limit')) || error.status === 429) {\n                handleRateLimit(30);\n            } else {\n                alert(\"Error: \".concat(error instanceof Error ? error.message : 'Unknown error occurred'));\n            }\n        } finally{\n            setLocalLoading(false);\n        }\n    };\n    /**\r\n     * STEP 3: Fix toggleGeofenceState to better handle manually clicking the button\r\n     */ const toggleGeofenceState = (enabled)=>{\n        console.log('toggleGeofenceState called with:', enabled);\n        console.log('Current geofenceCoordinates:', geofenceCoordinates);\n        if (enabled) {\n            // Check if we have valid coordinates\n            if (geofenceCoordinates && typeof geofenceCoordinates.lat === 'number' && typeof geofenceCoordinates.lng === 'number' && !isNaN(geofenceCoordinates.lat) && !isNaN(geofenceCoordinates.lng)) {\n                console.log('Valid coordinates found, enabling geofence');\n                // Set flags first\n                setGeofenceEnabled(true);\n                setIsGeofenceActive(true);\n                // Call context toggle function if available\n                if (typeof toggleGeofence === 'function') {\n                    toggleGeofence();\n                }\n                // Display aircraft if we have them\n                if (geofenceAircraft && geofenceAircraft.length > 0) {\n                    console.log(\"Showing \".concat(geofenceAircraft.length, \" aircraft in geofence\"));\n                    updateGeofenceAircraft(geofenceAircraft);\n                } else {\n                    // No aircraft data yet, trigger a search\n                    console.log('No aircraft data yet, triggering search');\n                    setTimeout(()=>{\n                        processGeofenceSearch();\n                    }, 100);\n                }\n            } else {\n                // No valid coordinates\n                console.warn('No valid coordinates, showing alert');\n                alert('Please set a location before enabling geofence.\\n\\nClick anywhere on the map to set a location.');\n                setGeofenceEnabled(false);\n                setIsGeofenceActive(false);\n            }\n        } else {\n            // Disabling geofence\n            console.log('Disabling geofence');\n            setGeofenceEnabled(false);\n            setIsGeofenceActive(false);\n            // Clear geofence data if function available\n            if (typeof clearGeofenceData === 'function') {\n                clearGeofenceData();\n            }\n        }\n    };\n    // Effects\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect({\n        \"useFilterLogic.useEffect\": ()=>{\n            if (geofenceCoordinates) {\n                setIsSearchReady(true);\n            }\n        }\n    }[\"useFilterLogic.useEffect\"], [\n        geofenceCoordinates\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useFilterLogic.useEffect\": ()=>{\n            if (isRateLimited && rateLimitTimer) {\n                const timer = setTimeout({\n                    \"useFilterLogic.useEffect.timer\": ()=>{\n                        setIsRateLimited(false);\n                        setRateLimitTimer(null);\n                        console.log('Rate limit timer expired, resuming API calls');\n                    }\n                }[\"useFilterLogic.useEffect.timer\"], rateLimitTimer * 1000);\n                return ({\n                    \"useFilterLogic.useEffect\": ()=>clearTimeout(timer)\n                })[\"useFilterLogic.useEffect\"];\n            }\n        }\n    }[\"useFilterLogic.useEffect\"], [\n        isRateLimited,\n        rateLimitTimer\n    ]);\n    // Effect to sync geofence state\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useFilterLogic.useEffect\": ()=>{\n            // Update internal state when geofence is toggled externally\n            if (isGeofenceActive !== geofenceEnabled) {\n                setGeofenceEnabled(isGeofenceActive);\n            }\n        }\n    }[\"useFilterLogic.useEffect\"], [\n        isGeofenceActive\n    ]);\n    // Close dropdown when clicking outside\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useFilterLogic.useEffect\": ()=>{\n            const handleClickOutside = {\n                \"useFilterLogic.useEffect.handleClickOutside\": (event)=>{\n                    // Check if click is outside of all dropdowns\n                    const isOutsideAll = Object.values(dropdownRefs).every({\n                        \"useFilterLogic.useEffect.handleClickOutside.isOutsideAll\": (ref)=>!ref.current || !ref.current.contains(event.target)\n                    }[\"useFilterLogic.useEffect.handleClickOutside.isOutsideAll\"]);\n                    if (isOutsideAll) {\n                        setActiveDropdown(null);\n                    }\n                }\n            }[\"useFilterLogic.useEffect.handleClickOutside\"];\n            document.addEventListener('mousedown', handleClickOutside);\n            return ({\n                \"useFilterLogic.useEffect\": ()=>{\n                    document.removeEventListener('mousedown', handleClickOutside);\n                }\n            })[\"useFilterLogic.useEffect\"];\n        }\n    }[\"useFilterLogic.useEffect\"], []);\n    // Clean up region outline when component unmounts\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useFilterLogic.useEffect\": ()=>{\n            return ({\n                \"useFilterLogic.useEffect\": ()=>{\n                    if (regionOutline) {\n                        regionOutline.remove();\n                    }\n                }\n            })[\"useFilterLogic.useEffect\"];\n        }\n    }[\"useFilterLogic.useEffect\"], [\n        regionOutline\n    ]);\n    // Effect to handle map click for geofence\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useFilterLogic.useEffect\": ()=>{\n            const handleMapGeofenceClick = {\n                \"useFilterLogic.useEffect.handleMapGeofenceClick\": async (event)=>{\n                    try {\n                        // Cast the event to the proper type\n                        const customEvent = event;\n                        const { lat, lng } = customEvent.detail;\n                        // First update coordinates immediately\n                        setGeofenceCoordinates({\n                            lat,\n                            lng\n                        });\n                        // Then start an async operation to get the location name\n                        console.log(\"Getting location name for: \".concat(lat, \", \").concat(lng));\n                        // Temporarily show coordinates while fetching the name\n                        setGeofenceLocation(\"\".concat(lat.toFixed(6), \", \").concat(lng.toFixed(6)));\n                        // Get the friendly name asynchronously\n                        const locationName = await _lib_services_MapboxService__WEBPACK_IMPORTED_MODULE_4__.MapboxService.getLocationNameFromCoordinates(lat, lng);\n                        console.log(\"Got location name: \".concat(locationName));\n                        // Update with the friendly name once we have it\n                        if (locationName !== null) {\n                            setGeofenceLocation(locationName);\n                        }\n                        // Open the location dropdown if needed\n                        if (activeDropdown !== 'location') {\n                            setActiveDropdown('location');\n                        }\n                    } catch (error) {\n                        console.error('Error handling map click:', error);\n                    // Keep the coordinates display if there was an error\n                    }\n                }\n            }[\"useFilterLogic.useEffect.handleMapGeofenceClick\"];\n            // Add the event listener - use the standard event listener pattern\n            document.addEventListener('map-geofence-click', handleMapGeofenceClick);\n            // Clean up\n            return ({\n                \"useFilterLogic.useEffect\": ()=>{\n                    document.removeEventListener('map-geofence-click', handleMapGeofenceClick);\n                }\n            })[\"useFilterLogic.useEffect\"];\n        }\n    }[\"useFilterLogic.useEffect\"], [\n        setGeofenceLocation,\n        setGeofenceCoordinates,\n        setActiveDropdown,\n        activeDropdown\n    ]);\n    // Main methods\n    const toggleDropdown = (dropdown, event)=>{\n        if (activeDropdown === dropdown) {\n            setActiveDropdown(null);\n        } else {\n            setActiveDropdown(dropdown);\n        }\n        // Prevent events from bubbling up\n        event.stopPropagation();\n    };\n    const handleRateLimit = function() {\n        let retryAfter = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 30;\n        setIsRateLimited(true);\n        setRateLimitTimer(retryAfter);\n        console.log(\"Rate limited by API. Retry after \".concat(retryAfter, \"s\"));\n        // Block all API calls\n        _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].setBlockAllApiCalls(true);\n        setBlockManufacturerApiCalls(true);\n        // Show notification to user\n        if (retryAfter > 0) {\n            alert(\"Aircraft data refresh rate limited. Please wait \".concat(retryAfter, \" seconds before trying again.\"));\n        }\n    };\n    /**\r\n   * Toggle filter mode\r\n   */ const toggleFilterMode = (mode)=>{\n        setFilterMode(mode);\n        setActiveDropdown(null);\n        // Apply appropriate filters based on new mode\n        if (mode === 'region') {\n            // Block API calls in region mode\n            _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].setBlockAllApiCalls(true);\n            // Apply region filtering if we already have data\n            if (displayedAircraft && displayedAircraft.length > 0) {\n                filterAircraftByRegion(selectedRegion.toString());\n            }\n            // Clear manufacturer selection from the UI\n            selectManufacturer(null);\n            selectModel(null);\n            // If geofence is active, restore the full geofence data\n            if (geofenceCoordinates && geofenceAircraft.length > 0) {\n                updateGeofenceAircraft(geofenceAircraft);\n            }\n        } else if (mode === 'owner') {\n            // Filter displayed aircraft by owner type\n            if (displayedAircraft && displayedAircraft.length > 0) {\n                // First filter for valid coordinates\n                const aircraftWithValidCoords = displayedAircraft.filter((plane)=>typeof plane.latitude === 'number' && typeof plane.longitude === 'number' && !isNaN(plane.latitude) && !isNaN(plane.longitude));\n                // Apply owner type filter\n                let filteredByOwner = ownerFilters.length === 0 ? aircraftWithValidCoords : aircraftWithValidCoords.filter((aircraft)=>ownerFilters.includes(getAircraftOwnerType(aircraft)));\n                // Update display with filtered aircraft\n                if (clearGeofenceData) {\n                    clearGeofenceData();\n                }\n                updateGeofenceAircraft(filteredByOwner);\n            }\n        } else if (mode === 'both') {\n            // Both mode - BLOCK API CALLS\n            _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].setBlockAllApiCalls(true);\n            if (selectedManufacturer && isGeofenceActive && geofenceAircraft.length > 0) {\n                applyCombinedFilters();\n            } else {\n                // If one is missing, prompt the user\n                if (!selectedManufacturer && isGeofenceActive) {\n                    alert('Please select a manufacturer to use combined filter mode');\n                } else if (selectedManufacturer && !isGeofenceActive) {\n                    alert('Please set a location to use combined filter mode');\n                } else {\n                    alert('Please select both a manufacturer and location to use combined filter mode');\n                }\n            }\n        }\n    };\n    // Owner filter methods\n    const getAircraftOwnerType = (aircraft)=>{\n        const ownerType = aircraft.TYPE_REGISTRANT || 0;\n        return ownerTypeToString(ownerType);\n    };\n    const ownerTypeToString = (type)=>{\n        const typeNum = typeof type === 'string' ? parseInt(type, 10) : type;\n        const ownerTypeMap = {\n            1: 'individual',\n            2: 'partnership',\n            3: 'corp-owner',\n            4: 'co-owned',\n            7: 'llc',\n            8: 'non-citizen-corp',\n            9: 'airline',\n            10: 'freight',\n            11: 'medical',\n            12: 'media',\n            13: 'historical',\n            14: 'flying-club',\n            15: 'emergency',\n            16: 'local-govt',\n            17: 'education',\n            18: 'federal-govt',\n            19: 'flight-school',\n            20: 'leasing-corp',\n            21: 'military'\n        };\n        return ownerTypeMap[typeNum] || 'unknown';\n    };\n    const applyOwnerTypeFilter = (filters)=>{\n        // Skip filtering if all types are selected or none are selected\n        if (filters.length === 0 || filters.length === allOwnerTypes.length) {\n            return;\n        }\n        // Filter the aircraft based on selected owner types\n        if (displayedAircraft && displayedAircraft.length > 0) {\n            const filteredAircraft = displayedAircraft.filter((aircraft)=>{\n                const ownerType = getAircraftOwnerType(aircraft);\n                return filters.includes(ownerType);\n            });\n            // Update the displayed aircraft\n            if (clearGeofenceData) {\n                clearGeofenceData();\n            }\n            updateGeofenceAircraft(filteredAircraft);\n        }\n    };\n    const handleOwnerFilterChange = (updatedFilters)=>{\n        setOwnerFilters(updatedFilters);\n        // Apply the filter to your aircraft data\n        applyOwnerTypeFilter(updatedFilters);\n    };\n    const resetOwnerFilters = ()=>{\n        setOwnerFilters([\n            ...allOwnerTypes\n        ]);\n    };\n    // Region filter methods\n    const filterAircraftByRegion = (region)=>{\n        if (!displayedAircraft || displayedAircraft.length === 0) return;\n        setLocalLoading(true);\n        try {\n            // Get the bounds for the selected region\n            const boundsExpression = (0,_config_map__WEBPACK_IMPORTED_MODULE_10__.getBoundsByRegion)(region);\n            // Ensure bounds is in the correct format\n            if (!Array.isArray(boundsExpression) || boundsExpression.length !== 2) {\n                console.error(\"Invalid bounds format for region: \".concat(region), boundsExpression);\n                setLocalLoading(false);\n                return;\n            }\n            // Extract coordinates - Leaflet uses [lat, lng] format\n            const [[minLat, minLng], [maxLat, maxLng]] = boundsExpression;\n            console.log(\"Filtering by region: \".concat(region, \" with bounds:\"), {\n                minLat,\n                minLng,\n                maxLat,\n                maxLng\n            });\n            // Filter aircraft based on coordinates within the bounds\n            const filteredAircraft = displayedAircraft.filter((aircraft)=>{\n                // Check if aircraft has valid coordinates\n                if (typeof aircraft.latitude !== 'number' || typeof aircraft.longitude !== 'number' || isNaN(aircraft.latitude) || isNaN(aircraft.longitude)) {\n                    return false;\n                }\n                // Check if coordinates are within the bounds\n                return aircraft.latitude >= minLat && aircraft.latitude <= maxLat && aircraft.longitude >= minLng && aircraft.longitude <= maxLng;\n            });\n            // Update the display with filtered aircraft\n            if (clearGeofenceData) {\n                clearGeofenceData();\n            }\n            updateGeofenceAircraft(filteredAircraft);\n            console.log(\"Filtered to \".concat(filteredAircraft.length, \" aircraft in \").concat(region, \" region (out of \").concat(displayedAircraft.length, \" total)\"));\n        } catch (error) {\n            console.error('Error filtering aircraft by region:', error);\n        } finally{\n            setLocalLoading(false);\n        }\n    };\n    const handleRegionSelect = async (region)=>{\n        setActiveRegion(region);\n        setSelectedRegion(region);\n        setLocalLoading(true);\n        try {\n            // Set map bounds based on region\n            if (mapInstance) {\n                const bounds = (0,_config_map__WEBPACK_IMPORTED_MODULE_10__.getBoundsByRegion)(region);\n                // Get the appropriate zoom level for this region from your config\n                const zoomLevel = (0,_config_map__WEBPACK_IMPORTED_MODULE_10__.getZoomLevelForRegion)(region);\n                // First, set the appropriate zoom level\n                mapInstance.setZoom(zoomLevel);\n                // Then fit bounds with padding\n                const options = {\n                    padding: _config_map__WEBPACK_IMPORTED_MODULE_10__.MAP_CONFIG.PADDING.DEFAULT\n                };\n                mapInstance.fitBounds(bounds, options);\n                mapInstance.invalidateSize();\n                drawRegionOutline(region);\n            }\n            // Instead of immediately fetching aircraft data,\n            // just store the region selection for later use\n            console.log(\"Region selected. Waiting for manufacturer selection...\");\n            // Optionally, you could fetch just the count of aircraft in this region\n            // to give the user an idea of the data volume\n            const countResponse = await fetch(\"/api/tracking/region-count?region=\".concat(region));\n            if (countResponse.ok) {\n                const countData = await countResponse.json();\n                console.log(\"\".concat(countData.count, \" aircraft available in this region\"));\n            }\n            // Clear any previous aircraft data\n            if (clearGeofenceData) {\n                clearGeofenceData();\n            }\n        } catch (error) {\n            console.error('Error in region selection:', error);\n        } finally{\n            setLocalLoading(false);\n            setActiveDropdown(null);\n        }\n    };\n    const drawRegionOutline = (region)=>{\n        if (!mapInstance) return;\n        // Clear any existing outline\n        if (regionOutline) {\n            regionOutline.remove();\n        }\n        // Get the bounds for the selected region\n        const bounds = (0,_config_map__WEBPACK_IMPORTED_MODULE_10__.getBoundsByRegion)(region);\n        // Create a polygon from the bounds\n        const L = __webpack_require__(/*! leaflet */ \"(pages-dir-browser)/./node_modules/leaflet/dist/leaflet-src.js\");\n        const rectangle = L.rectangle(bounds, {\n            color: '#4f46e5',\n            weight: 3,\n            opacity: 0.7,\n            fill: true,\n            fillColor: '#4f46e5',\n            fillOpacity: 0.1,\n            dashArray: '5, 10',\n            interactive: false\n        });\n        // Add to map\n        rectangle.addTo(mapInstance);\n        // Update the state to include both the rectangle and the label\n        setRegionOutline({\n            remove: ()=>{\n                rectangle.remove();\n            }\n        });\n    };\n    // Manufacturer filter methods\n    const selectManufacturerAndClose = (value)=>{\n        // Close dropdown\n        setActiveDropdown(null);\n        setManufacturerSearchTerm('');\n        // If clearing the selection\n        if (value === '') {\n            selectManufacturer(null);\n            return;\n        }\n        // Set the manufacturer selection\n        selectManufacturer(value);\n        // If region is already selected, fetch filtered data\n        if (activeRegion !== null) {\n            fetchAircraftByRegionAndManufacturer(activeRegion, value);\n        } else {\n            // Otherwise, just proceed with manufacturer-only filtering as before\n            fetchManufacturerData(value);\n        }\n    };\n    const fetchManufacturerData = (manufacturer)=>{\n        if (isRateLimited) {\n            console.log(\"Skipping data fetch - rate limited for \".concat(rateLimitTimer, \"s\"));\n            return;\n        }\n        console.log(\"Fetching data for manufacturer: \".concat(manufacturer));\n        try {\n            // If you have a context function for this, call it after a slight delay\n            if (typeof refreshPositions === 'function') {\n                // Apply a small delay to prevent overwhelming the API\n                setTimeout(()=>{\n                    refreshPositions().catch((error)=>{\n                        var _error_message;\n                        if (((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes('rate limit')) || error.status === 429) {\n                            handleRateLimit(30);\n                        } else {\n                            console.error('Error fetching manufacturer data:', error);\n                        }\n                    });\n                }, 200);\n            }\n        } catch (error) {\n            var _error_message;\n            if (((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes('rate limit')) || error.status === 429) {\n                handleRateLimit(30);\n            } else {\n                console.error('Error scheduling manufacturer data fetch:', error);\n            }\n        }\n    };\n    const fetchAircraftByRegionAndManufacturer = async function(region, manufacturer) {\n        let page = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, limit = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 500;\n        if (!region || !manufacturer) {\n            console.log('Both region and manufacturer must be selected');\n            return;\n        }\n        setLocalLoading(true);\n        try {\n            const response = await fetch(\"/api/tracking/filtered-aircraft?region=\".concat(region, \"&manufacturer=\").concat(encodeURIComponent(manufacturer), \"&page=\").concat(page, \"&limit=\").concat(limit));\n            const data = await response.json();\n            const aircraftData = data.aircraft || [];\n            if (!response.ok) {\n                throw new Error(\"API error: \".concat(response.statusText));\n            }\n            // Process the filtered aircraft data\n            if (aircraftData.length > 0) {\n                const extendedAircraft = aircraftData.map((aircraft)=>{\n                    var _aircraft_OPERATOR;\n                    var _aircraft_OPERATOR_toLowerCase_includes;\n                    return {\n                        ...aircraft,\n                        type: aircraft.TYPE_AIRCRAFT || 'Unknown',\n                        isGovernment: (_aircraft_OPERATOR_toLowerCase_includes = (_aircraft_OPERATOR = aircraft.OPERATOR) === null || _aircraft_OPERATOR === void 0 ? void 0 : _aircraft_OPERATOR.toLowerCase().includes('government')) !== null && _aircraft_OPERATOR_toLowerCase_includes !== void 0 ? _aircraft_OPERATOR_toLowerCase_includes : false,\n                        REGION: aircraft.REGION,\n                        zoomLevel: undefined\n                    };\n                });\n                // Update the map\n                updateGeofenceAircraft(extendedAircraft);\n            } else {\n                console.log(\"No aircraft found for manufacturer \".concat(manufacturer, \" in region \").concat(region));\n            }\n        } catch (error) {\n            console.error('Error fetching filtered aircraft:', error);\n        } finally{\n            setLocalLoading(false);\n        }\n    };\n    // Model selection methods\n    const handleModelSelect = (value)=>{\n        selectModel(value === '' ? null : value);\n        setActiveDropdown(null);\n        // If in combined mode, reapply the filter\n        if (filterMode === 'both' && isGeofenceActive && selectedManufacturer) {\n            setTimeout(()=>{\n                applyCombinedFilters();\n            }, 100);\n        }\n    };\n    // Combined filter methods\n    const applyCombinedFilters = ()=>{\n        if (!selectedManufacturer || !isGeofenceActive || geofenceAircraft.length === 0) {\n            return;\n        }\n        setLocalLoading(true);\n        try {\n            console.log(\"Filtering \".concat(geofenceAircraft.length, \" aircraft by \").concat(selectedManufacturer));\n            // Filter the aircraft by manufacturer\n            let filteredAircraft = geofenceAircraft.filter((aircraft)=>{\n                var _aircraft_MANUFACTURER;\n                return ((_aircraft_MANUFACTURER = aircraft.MANUFACTURER) === null || _aircraft_MANUFACTURER === void 0 ? void 0 : _aircraft_MANUFACTURER.toLowerCase()) === selectedManufacturer.toLowerCase();\n            });\n            // Further filter by model if selected\n            if (selectedModel) {\n                filteredAircraft = filteredAircraft.filter((aircraft)=>{\n                    var _aircraft_MODEL;\n                    return ((_aircraft_MODEL = aircraft.MODEL) === null || _aircraft_MODEL === void 0 ? void 0 : _aircraft_MODEL.toLowerCase()) === selectedModel.toLowerCase();\n                });\n            }\n            console.log(\"Found \".concat(filteredAircraft.length, \" matching aircraft\"));\n            if (filteredAircraft.length === 0) {\n                alert(\"No \".concat(selectedManufacturer, \" aircraft found in this area.\"));\n                return;\n            }\n            // Clear display data\n            if (clearGeofenceData) {\n                clearGeofenceData();\n            }\n            // Update the display\n            updateGeofenceAircraft(filteredAircraft);\n        } catch (error) {\n            console.error('Error filtering aircraft:', error);\n        } finally{\n            setLocalLoading(false);\n        }\n    };\n    // Reset all filters\n    const clearAllFilters = ()=>{\n        console.log('Clearing all filters...');\n        // 1. Reset filter mode\n        setFilterMode('manufacturer');\n        // 2. Unblock API calls that might have been blocked\n        _lib_services_openSkyTrackingService__WEBPACK_IMPORTED_MODULE_3__[\"default\"].setBlockAllApiCalls(false);\n        setBlockManufacturerApiCalls(false);\n        setIsManufacturerApiBlocked(false);\n        // 3. Clear manufacturer selection\n        selectManufacturer(null);\n        selectModel(null);\n        // 4. Clear geofence\n        setGeofenceLocation('');\n        setGeofenceCoordinates(null);\n        setGeofenceAircraft([]);\n        setGeofenceEnabled(false);\n        setIsGeofenceActive(false);\n        if (typeof clearGeofence === 'function') {\n            clearGeofence();\n        }\n        if (typeof clearGeofenceData === 'function') {\n            clearGeofenceData();\n        }\n        // 5. Reset owner filters to select all\n        setOwnerFilters([\n            ...allOwnerTypes\n        ]);\n        // 6. Clear region filter properly\n        setActiveRegion(null);\n        setSelectedRegion(_types_base__WEBPACK_IMPORTED_MODULE_1__.RegionCode.GLOBAL);\n        // Clear region outline from map\n        if (regionOutline) {\n            try {\n                // Handle different possible object structures\n                if (typeof regionOutline.remove === 'function') {\n                    regionOutline.remove();\n                } else if (regionOutline.rectangle && typeof regionOutline.rectangle.remove === 'function') {\n                    regionOutline.rectangle.remove();\n                }\n                // Clear any labels associated with the region\n                if (regionOutline.label && typeof regionOutline.label.remove === 'function') {\n                    regionOutline.label.remove();\n                }\n            } catch (error) {\n                console.error('Error removing region outline:', error);\n            }\n            // Always reset the region outline state\n            setRegionOutline(null);\n        }\n        // 7. Reset map view to global\n        if (mapInstance) {\n            // Use the predefined center and zoom level from your map config\n            mapInstance.setView(_config_map__WEBPACK_IMPORTED_MODULE_10__.MAP_CONFIG.CENTER, _config_map__WEBPACK_IMPORTED_MODULE_10__.MAP_CONFIG.DEFAULT_ZOOM);\n            mapInstance.invalidateSize();\n        }\n        // 8. Reset to initial aircraft data\n        if (typeof reset === 'function') {\n            reset();\n        } else if (typeof fullRefresh === 'function') {\n            fullRefresh();\n        }\n        // 9. Close any open dropdown\n        setActiveDropdown(null);\n        // 10. Reset rate limiting states\n        setIsRateLimited(false);\n        setRateLimitTimer(null);\n        // 11. Clear combined mode state\n        setCombinedModeReady(false);\n        // 12. Reset search terms\n        setManufacturerSearchTerm('');\n        // 13. Dispatch a custom event that other components can listen for\n        const clearEvent = new CustomEvent('ribbon-filters-cleared');\n        document.dispatchEvent(clearEvent);\n        console.log('All filters cleared successfully');\n    };\n    // Calculate combined loading state\n    const combinedLoading = localLoading;\n    return {\n        // State\n        filterMode,\n        activeDropdown,\n        selectedManufacturer,\n        selectedModel,\n        geofenceLocation,\n        geofenceRadius,\n        isGeofenceActive,\n        geofenceCoordinates,\n        getUserLocation,\n        activeRegion,\n        ownerFilters,\n        allOwnerTypes,\n        manufacturerSearchTerm,\n        combinedLoading,\n        isGettingLocation,\n        dropdownRefs,\n        localLoading,\n        isRateLimited,\n        selectedRegion,\n        isRefreshing,\n        isGeofencePlacementMode: false,\n        // Methods\n        toggleDropdown,\n        toggleFilterMode,\n        selectManufacturerAndClose,\n        handleModelSelect,\n        processGeofenceSearch,\n        handleOwnerFilterChange,\n        handleRegionSelect,\n        setManufacturerSearchTerm,\n        setGeofenceLocation,\n        setGeofenceRadius,\n        toggleGeofenceState,\n        clearAllFilters,\n        applyCombinedFilters,\n        getAircraftOwnerType,\n        setGeofenceCoordinates,\n        setGeofenceCenter,\n        updateGeofenceAircraft,\n        refreshWithFilters: ()=>{\n            // Implement refresh logic here\n            if (typeof refreshPositions === 'function') {\n                refreshPositions().catch((error)=>{\n                    console.error('Error refreshing positions:', error);\n                });\n            }\n        },\n        setActiveDropdown\n    };\n}\nfunction applyCombinedFilters() {\n    throw new Error('Function not implemented.');\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvdHJhY2tpbmcvaG9va3MvdXNlRmlsdGVyTG9naWMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFvRDtBQUMxQjtBQUNnQjtBQUU0QjtBQUNLO0FBQ1A7QUFDQTtBQUNFO0FBQ0c7QUFJL0I7QUFDZTtBQU01QjtBQTRCdEIsU0FBU2lCO0lBQ2Qsa0NBQWtDO0lBQ2xDLE1BQU0sRUFDSkMsb0JBQW9CLEVBQ3BCQyxhQUFhLEVBQ2JDLFdBQVcsRUFDWEMsa0JBQWtCLEVBQ2xCQyxXQUFXLEVBQ1hDLEtBQUssRUFDTEMsV0FBVyxFQUNYQyxnQkFBZ0IsRUFDaEJDLFdBQVcsRUFDWEMsa0JBQWtCLEVBQ2xCQyxpQkFBaUIsRUFDakJDLHNCQUFzQixFQUN0QkMseUJBQXlCLEVBQ3pCQyw0QkFBNEIsRUFDNUJDLHdCQUF3QixFQUN4QkMsMkJBQTJCLEVBQzNCQyxjQUFjLEVBQ2RDLGlCQUFpQixFQUVqQkMsY0FBYyxFQUNkQyxhQUFhLEVBQ2JDLGlCQUFpQixFQUNsQixHQUFHakMsa0ZBQXFCQTtJQUV6Qiw2Q0FBNkM7SUFDN0MsTUFBTWtDLHNCQUFzQjdCLHFGQUFzQkE7SUFFbEQsY0FBYztJQUNkLE1BQU0sQ0FBQzhCLGNBQWNDLGdCQUFnQixHQUFHekMsK0NBQVFBLENBQUM7SUFDakQsTUFBTSxDQUFDMEMsWUFBWUMsY0FBYyxHQUFHM0MsK0NBQVFBLENBQW9CO0lBQ2hFLE1BQU0sQ0FBQzRDLGdCQUFnQkMsa0JBQWtCLEdBQUc3QywrQ0FBUUEsQ0FBZ0I7SUFDcEUsTUFBTSxDQUFDOEMsd0JBQXdCQywwQkFBMEIsR0FBRy9DLCtDQUFRQSxDQUFDO0lBQ3JFLE1BQU0sQ0FBQ2dELGNBQWNDLGdCQUFnQixHQUFHakQsK0NBQVFBLENBQUM7SUFDakQsTUFBTSxDQUFDa0QsZUFBZUMsaUJBQWlCLEdBQUduRCwrQ0FBUUEsQ0FBQztJQUNuRCxNQUFNLENBQUNvRCxnQkFBZ0JDLGtCQUFrQixHQUFH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O1FBQ0EzSTtRQUNBVTtRQUNBRTtRQUNBc0U7UUFDQTBHO1FBQ0EzRztRQUNBcUM7UUFDQXhHO1FBQ0ExQjtRQUNBTjtRQUVBdU4sb0JBQW9CO1lBQ2xCLCtCQUErQjtZQUMvQixJQUFJLE9BQU8zTixxQkFBcUIsWUFBWTtnQkFDMUNBLG1CQUFtQmlNLEtBQUssQ0FBQyxDQUFDNUc7b0JBQ3hCSyxRQUFRTCxLQUFLLENBQUMsK0JBQStCQTtnQkFDL0M7WUFDRjtRQUNGO1FBQ0FqRTtJQUNGO0FBQ0Y7QUFFRixTQUFTbUY7SUFDUCxNQUFNLElBQUlKLE1BQU07QUFDbEIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcc2F0aG9cXERvY3VtZW50c1xcUHJvamVjdHNcXGFpcmNyYWZ0LXRyYWNraW5nXFxjb21wb25lbnRzXFx0cmFja2luZ1xcaG9va3NcXHVzZUZpbHRlckxvZ2ljLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVN0YXRlLCB1c2VSZWYsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgUmVnaW9uQ29kZSB9IGZyb20gJ0AvdHlwZXMvYmFzZSc7XHJcbmltcG9ydCB0eXBlIHsgRXh0ZW5kZWRBaXJjcmFmdCB9IGZyb20gJ0AvdHlwZXMvYmFzZSc7XHJcbmltcG9ydCB7IHVzZUVuaGFuY2VkTWFwQ29udGV4dCB9IGZyb20gJy4uL2NvbnRleHQvRW5oYW5jZWRNYXBDb250ZXh0JztcclxuaW1wb3J0IG9wZW5Ta3lUcmFja2luZ1NlcnZpY2UgZnJvbSAnQC9saWIvc2VydmljZXMvb3BlblNreVRyYWNraW5nU2VydmljZSc7XHJcbmltcG9ydCB7IE1hcGJveFNlcnZpY2UgfSBmcm9tICcuLi8uLi8uLi9saWIvc2VydmljZXMvTWFwYm94U2VydmljZSc7XHJcbmltcG9ydCB7IGFkYXB0R2VvZmVuY2VBaXJjcmFmdCB9IGZyb20gJ0AvbGliL3V0aWxzL2dlb2ZlbmNlQWRhcHRlcic7XHJcbmltcG9ydCB7IGVucmljaEdlb2ZlbmNlQWlyY3JhZnQgfSBmcm9tICdAL2xpYi91dGlscy9nZW9mZW5jZUVucmljaGVyJztcclxuaW1wb3J0IHsgdXNlR2VvbG9jYXRpb25TZXJ2aWNlcyB9IGZyb20gJy4uL2hvb2tzL3VzZUdlb2xvY2F0aW9uU2VydmljZXMnO1xyXG5pbXBvcnQge1xyXG4gIGdldEFpcmNyYWZ0TmVhckxvY2F0aW9uLFxyXG4gIGdldEFpcmNyYWZ0TmVhclNlYXJjaGVkTG9jYXRpb24sXHJcbn0gZnJvbSAnLi4vLi4vLi4vbGliL3NlcnZpY2VzL2dlb2ZlbmNpbmcnO1xyXG5pbXBvcnQgeyB1c2VHZW9sb2NhdGlvbiB9IGZyb20gJy4uL2hvb2tzL3VzZUdlb2xvY2F0aW9uJztcclxuXHJcbmltcG9ydCB7XHJcbiAgTUFQX0NPTkZJRyxcclxuICBnZXRCb3VuZHNCeVJlZ2lvbixcclxuICBnZXRab29tTGV2ZWxGb3JSZWdpb24sXHJcbn0gZnJvbSAnLi4vLi4vLi4vY29uZmlnL21hcCc7XHJcblxyXG5pbnRlcmZhY2UgRmlsdGVyTG9naWNSZXN1bHQge1xyXG4gIGdlb2ZlbmNlTG9jYXRpb246IHN0cmluZztcclxuICBnZW9mZW5jZVJhZGl1czogbnVtYmVyO1xyXG4gIGlzR2V0dGluZ0xvY2F0aW9uOiBib29sZWFuO1xyXG4gIGlzR2VvZmVuY2VBY3RpdmU6IGJvb2xlYW47XHJcbiAgZ2VvZmVuY2VDb29yZGluYXRlczogeyBsYXQ6IG51bWJlcjsgbG5nOiBudW1iZXIgfSB8IG51bGw7XHJcbiAgY29tYmluZWRMb2FkaW5nOiBib29sZWFuO1xyXG4gIHByb2Nlc3NHZW9mZW5jZVNlYXJjaDogKCkgPT4gdm9pZDtcclxuICB0b2dnbGVHZW9mZW5jZVN0YXRlOiAoYWN0aXZlOiBib29sZWFuKSA9PiB2b2lkO1xyXG4gIHNldEdlb2ZlbmNlTG9jYXRpb246IChsb2NhdGlvbjogc3RyaW5nKSA9PiB2b2lkO1xyXG4gIHNldEdlb2ZlbmNlUmFkaXVzOiAocmFkaXVzOiBudW1iZXIpID0+IHZvaWQ7XHJcbiAgc2V0R2VvZmVuY2VDb29yZGluYXRlczogKGNvb3JkczogeyBsYXQ6IG51bWJlcjsgbG5nOiBudW1iZXIgfSB8IG51bGwpID0+IHZvaWQ7XHJcbiAgc2V0R2VvZmVuY2VDZW50ZXI6IChjb29yZHM6IHsgbGF0OiBudW1iZXI7IGxuZzogbnVtYmVyIH0pID0+IHZvaWQ7XHJcbiAgc2V0SXNHZXR0aW5nTG9jYXRpb246IChpc0dldHRpbmc6IGJvb2xlYW4pID0+IHZvaWQ7XHJcbiAgdXBkYXRlR2VvZmVuY2VBaXJjcmFmdDogKGFpcmNyYWZ0OiBhbnlbXSkgPT4gdm9pZDtcclxufVxyXG5cclxudHlwZSBNYXBHZW9mZW5jZUNsaWNrRXZlbnQgPSBDdXN0b21FdmVudDx7IGxhdDogbnVtYmVyOyBsbmc6IG51bWJlciB9PjtcclxuXHJcbmV4cG9ydCB0eXBlIEZpbHRlck1vZGUgPVxyXG4gIHwgJ21hbnVmYWN0dXJlcidcclxuICB8ICdnZW9mZW5jZSdcclxuICB8ICdib3RoJ1xyXG4gIHwgJ293bmVyJ1xyXG4gIHwgJ3JlZ2lvbic7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlRmlsdGVyTG9naWMoKSB7XHJcbiAgLy8gR2V0IGNvbnRleHQgc3RhdGUgYW5kIGZ1bmN0aW9uc1xyXG4gIGNvbnN0IHtcclxuICAgIHNlbGVjdGVkTWFudWZhY3R1cmVyLFxyXG4gICAgc2VsZWN0ZWRNb2RlbCxcclxuICAgIHRvdGFsQWN0aXZlLFxyXG4gICAgc2VsZWN0TWFudWZhY3R1cmVyLFxyXG4gICAgc2VsZWN0TW9kZWwsXHJcbiAgICByZXNldCxcclxuICAgIGZ1bGxSZWZyZXNoLFxyXG4gICAgcmVmcmVzaFBvc2l0aW9ucyxcclxuICAgIG1hcEluc3RhbmNlLFxyXG4gICAgdXBkYXRlQWlyY3JhZnREYXRhLFxyXG4gICAgY2xlYXJHZW9mZW5jZURhdGEsXHJcbiAgICB1cGRhdGVHZW9mZW5jZUFpcmNyYWZ0LFxyXG4gICAgYmxvY2tNYW51ZmFjdHVyZXJBcGlDYWxscyxcclxuICAgIHNldEJsb2NrTWFudWZhY3R1cmVyQXBpQ2FsbHMsXHJcbiAgICBpc01hbnVmYWN0dXJlckFwaUJsb2NrZWQsXHJcbiAgICBzZXRJc01hbnVmYWN0dXJlckFwaUJsb2NrZWQsXHJcbiAgICBnZW9mZW5jZUNlbnRlcixcclxuICAgIHNldEdlb2ZlbmNlQ2VudGVyLFxyXG5cclxuICAgIHRvZ2dsZUdlb2ZlbmNlLFxyXG4gICAgY2xlYXJHZW9mZW5jZSxcclxuICAgIGRpc3BsYXllZEFpcmNyYWZ0LFxyXG4gIH0gPSB1c2VFbmhhbmNlZE1hcENvbnRleHQoKTtcclxuXHJcbiAgLy8gVXNlIG91ciBjb21iaW5lZCBnZW9sb2NhdGlvbiBzZXJ2aWNlcyBob29rXHJcbiAgY29uc3QgZ2VvbG9jYXRpb25TZXJ2aWNlcyA9IHVzZUdlb2xvY2F0aW9uU2VydmljZXMoKTtcclxuXHJcbiAgLy8gTG9jYWwgc3RhdGVcclxuICBjb25zdCBbbG9jYWxMb2FkaW5nLCBzZXRMb2NhbExvYWRpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gIGNvbnN0IFtmaWx0ZXJNb2RlLCBzZXRGaWx0ZXJNb2RlXSA9IHVzZVN0YXRlPEZpbHRlck1vZGUgfCBudWxsPihudWxsKTtcclxuICBjb25zdCBbYWN0aXZlRHJvcGRvd24sIHNldEFjdGl2ZURyb3Bkb3duXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xyXG4gIGNvbnN0IFttYW51ZmFjdHVyZXJTZWFyY2hUZXJtLCBzZXRNYW51ZmFjdHVyZXJTZWFyY2hUZXJtXSA9IHVzZVN0YXRlKCcnKTtcclxuICBjb25zdCBbaXNSZWZyZXNoaW5nLCBzZXRJc1JlZnJlc2hpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gIGNvbnN0IFtpc1JhdGVMaW1pdGVkLCBzZXRJc1JhdGVMaW1pdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICBjb25zdCBbcmF0ZUxpbWl0VGltZXIsIHNldFJhdGVMaW1pdFRpbWVyXSA9IHVzZVN0YXRlPG51bWJlciB8IG51bGw+KG51bGwpO1xyXG5cclxuICAvLyBHZW9mZW5jZSBzdGF0ZVxyXG4gIGNvbnN0IFtpc0dldHRpbmdMb2NhdGlvbiwgc2V0SXNHZXR0aW5nTG9jYXRpb25dID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gIGNvbnN0IFtnZW9mZW5jZUxvY2F0aW9uLCBzZXRHZW9mZW5jZUxvY2F0aW9uXSA9IHVzZVN0YXRlPHN0cmluZz4oJycpO1xyXG4gIGNvbnN0IFtnZW9mZW5jZVJhZGl1cywgc2V0R2VvZmVuY2VSYWRpdXNdID0gdXNlU3RhdGU8bnVtYmVyPigyNSk7XHJcbiAgY29uc3QgW2dlb2ZlbmNlQ29vcmRpbmF0ZXMsIHNldEdlb2ZlbmNlQ29vcmRpbmF0ZXNdID0gdXNlU3RhdGU8e1xyXG4gICAgbGF0OiBudW1iZXI7XHJcbiAgICBsbmc6IG51bWJlcjtcclxuICB9IHwgbnVsbD4obnVsbCk7XHJcbiAgY29uc3QgW2dlb2ZlbmNlQWlyY3JhZnQsIHNldEdlb2ZlbmNlQWlyY3JhZnRdID0gdXNlU3RhdGU8RXh0ZW5kZWRBaXJjcmFmdFtdPihcclxuICAgIFtdXHJcbiAgKTtcclxuICBjb25zdCBbZ2VvZmVuY2VFbmFibGVkLCBzZXRHZW9mZW5jZUVuYWJsZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gIGNvbnN0IFtpc0dlb2ZlbmNlQWN0aXZlLCBzZXRJc0dlb2ZlbmNlQWN0aXZlXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICBjb25zdCBbaXNTZWFyY2hSZWFkeSwgc2V0SXNTZWFyY2hSZWFkeV0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XHJcblxyXG4gIC8vIFJlZ2lvbiBzdGF0ZVxyXG4gIGNvbnN0IFthY3RpdmVSZWdpb24sIHNldEFjdGl2ZVJlZ2lvbl0gPSB1c2VTdGF0ZTxSZWdpb25Db2RlIHwgc3RyaW5nIHwgbnVsbD4oXHJcbiAgICBudWxsXHJcbiAgKTtcclxuICBjb25zdCBbcmVnaW9uT3V0bGluZSwgc2V0UmVnaW9uT3V0bGluZV0gPSB1c2VTdGF0ZTxhbnk+KG51bGwpO1xyXG4gIGNvbnN0IFtzZWxlY3RlZFJlZ2lvbiwgc2V0U2VsZWN0ZWRSZWdpb25dID0gdXNlU3RhdGU8bnVtYmVyPihcclxuICAgIFJlZ2lvbkNvZGUuR0xPQkFMXHJcbiAgKTtcclxuXHJcbiAgLy8gQ29tYmluZWQgbW9kZSBzdGF0ZVxyXG4gIGNvbnN0IFtjb21iaW5lZE1vZGVSZWFkeSwgc2V0Q29tYmluZWRNb2RlUmVhZHldID0gdXNlU3RhdGU8Ym9vbGVhbj4oZmFsc2UpO1xyXG5cclxuICAvLyBPd25lciBmaWx0ZXIgc3RhdGVcclxuICBjb25zdCBhbGxPd25lclR5cGVzID0gW1xyXG4gICAgJ2luZGl2aWR1YWwnLFxyXG4gICAgJ3BhcnRuZXJzaGlwJyxcclxuICAgICdjb3JwLW93bmVyJyxcclxuICAgICdjby1vd25lZCcsXHJcbiAgICAnbGxjJyxcclxuICAgICdub24tY2l0aXplbi1jb3JwJyxcclxuICAgICdhaXJsaW5lJyxcclxuICAgICdmcmVpZ2h0JyxcclxuICAgICdtZWRpY2FsJyxcclxuICAgICdtZWRpYScsXHJcbiAgICAnaGlzdG9yaWNhbCcsXHJcbiAgICAnZmx5aW5nLWNsdWInLFxyXG4gICAgJ2VtZXJnZW5jeScsXHJcbiAgICAnbG9jYWwtZ292dCcsXHJcbiAgICAnZWR1Y2F0aW9uJyxcclxuICAgICdmZWRlcmFsLWdvdnQnLFxyXG4gICAgJ2ZsaWdodC1zY2hvb2wnLFxyXG4gICAgJ2xlYXNpbmctY29ycCcsXHJcbiAgICAnbWlsaXRhcnknLFxyXG4gICAgJ3Vua25vd24nLFxyXG4gIF07XHJcblxyXG4gIGNvbnN0IFtvd25lckZpbHRlcnMsIHNldE93bmVyRmlsdGVyc10gPSB1c2VTdGF0ZTxzdHJpbmdbXT4oW1xyXG4gICAgLi4uYWxsT3duZXJUeXBlcyxcclxuICBdKTtcclxuXHJcbiAgLy8gUmVmcyBmb3IgZHJvcGRvd24gaGFuZGxpbmdcclxuICBjb25zdCBkcm9wZG93blJlZnMgPSB7XHJcbiAgICBmaWx0ZXI6IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCksXHJcbiAgICBtYW51ZmFjdHVyZXI6IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCksXHJcbiAgICBtb2RlbDogdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKSxcclxuICAgIGxvY2F0aW9uOiB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpLFxyXG4gICAgcmVnaW9uOiB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpLFxyXG4gICAgb3duZXI6IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCksXHJcbiAgICBhY3Rpb25zOiB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpLFxyXG4gIH07XHJcblxyXG4gIC8vIEdldCBnZW9sb2NhdGlvbiBob29rIC0gdXNlIHRoZSBlbnRpcmUgaG9vayBpbnN0YW5jZVxyXG4gIGNvbnN0IGdlb2xvY2F0aW9uID0gdXNlR2VvbG9jYXRpb24obnVsbCk7XHJcbiBcclxuIFxyXG4gLy8gR2VvZmVuY2UgbWV0aG9kc1xyXG4gIC8vIEZpeGVkIGdldFVzZXJMb2NhdGlvbiBmdW5jdGlvbiB0byB1c2UgdGhlIGdlb2xvY2F0aW9uIGhvb2tcclxuXHJcbiAgICBjb25zdCBnZXRVc2VyTG9jYXRpb24gPSBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGlmIChpc1JhdGVMaW1pdGVkKSB7XHJcbiAgICAgICAgYWxlcnQoXHJcbiAgICAgICAgICBgUmF0ZSBsaW1pdGVkLiBQbGVhc2Ugd2FpdCAke3JhdGVMaW1pdFRpbWVyIHx8IDMwfSBzZWNvbmRzIGJlZm9yZSB0cnlpbmcgdG8gZ2V0IGxvY2F0aW9uLmBcclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgc2V0SXNHZXR0aW5nTG9jYXRpb24odHJ1ZSk7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgLy8gVXNlIHRoZSBnZXRDdXJyZW50UG9zaXRpb24gZnJvbSBvdXIgY29tYmluZWQgaG9va1xyXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gYXdhaXQgZ2VvbG9jYXRpb25TZXJ2aWNlcy5nZXRDdXJyZW50UG9zaXRpb24oKTtcclxuXHJcbiAgICAgICAgaWYgKHBvc2l0aW9uKSB7XHJcbiAgICAgICAgICBjb25zdCB7IGxhdGl0dWRlLCBsb25naXR1ZGUgfSA9IHBvc2l0aW9uLmNvb3JkcztcclxuXHJcbiAgICAgICAgICAvLyBVcGRhdGUgc3RhdGUgd2l0aCBjb29yZGluYXRlc1xyXG4gICAgICAgICAgc2V0R2VvZmVuY2VDb29yZGluYXRlcyh7IGxhdDogbGF0aXR1ZGUsIGxuZzogbG9uZ2l0dWRlIH0pO1xyXG4gICAgICAgICAgc2V0R2VvZmVuY2VDZW50ZXIoeyBsYXQ6IGxhdGl0dWRlLCBsbmc6IGxvbmdpdHVkZSB9KTtcclxuXHJcbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIGxvY2F0aW9uIGRpc3BsYXkgd2l0aCBjb29yZGluYXRlc1xyXG4gICAgICAgICAgc2V0R2VvZmVuY2VMb2NhdGlvbihcclxuICAgICAgICAgICAgYCR7bGF0aXR1ZGUudG9GaXhlZCg2KX0sICR7bG9uZ2l0dWRlLnRvRml4ZWQoNil9YFxyXG4gICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAvLyBBdXRvbWF0aWNhbGx5IHRyaWdnZXIgdGhlIGdlb2ZlbmNlIHNlYXJjaFxyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgZmV0Y2hlZEFpcmNyYWZ0ID0gYXdhaXQgZ2V0QWlyY3JhZnROZWFyTG9jYXRpb24oXHJcbiAgICAgICAgICAgICAgbGF0aXR1ZGUsXHJcbiAgICAgICAgICAgICAgbG9uZ2l0dWRlLFxyXG4gICAgICAgICAgICAgIGdlb2ZlbmNlUmFkaXVzXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBpZiAoZmV0Y2hlZEFpcmNyYWZ0Lmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgIGFsZXJ0KFxyXG4gICAgICAgICAgICAgICAgYE5vIGFpcmNyYWZ0IGZvdW5kIG5lYXIgeW91ciBjdXJyZW50IGxvY2F0aW9uLiBUcnkgaW5jcmVhc2luZyB0aGUgcmFkaXVzLmBcclxuICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgIHNldElzR2V0dGluZ0xvY2F0aW9uKGZhbHNlKTtcclxuICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFByb2Nlc3MgdGhlIGFpcmNyYWZ0IGRhdGFcclxuICAgICAgICAgICAgY29uc3QgYWRhcHRlZEFpcmNyYWZ0ID0gYWRhcHRHZW9mZW5jZUFpcmNyYWZ0KGZldGNoZWRBaXJjcmFmdCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGVucmljaGVkQWlyY3JhZnQgPVxyXG4gICAgICAgICAgICAgIGF3YWl0IGVucmljaEdlb2ZlbmNlQWlyY3JhZnQoYWRhcHRlZEFpcmNyYWZ0KTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNhdmUgdG8gbG9jYWwgc3RhdGVcclxuICAgICAgICAgICAgc2V0R2VvZmVuY2VBaXJjcmFmdChlbnJpY2hlZEFpcmNyYWZ0KTtcclxuXHJcbiAgICAgICAgICAgIC8vIENsZWFyIGV4aXN0aW5nIGFpcmNyYWZ0IGRhdGFcclxuICAgICAgICAgICAgaWYgKGNsZWFyR2VvZmVuY2VEYXRhKSB7XHJcbiAgICAgICAgICAgICAgY2xlYXJHZW9mZW5jZURhdGEoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBtYXAgd2l0aCBuZXcgYWlyY3JhZnRcclxuICAgICAgICAgICAgdXBkYXRlR2VvZmVuY2VBaXJjcmFmdChlbnJpY2hlZEFpcmNyYWZ0KTtcclxuICAgICAgICAgICAgc2V0SXNHZW9mZW5jZUFjdGl2ZSh0cnVlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIENlbnRlciB0aGUgbWFwIG9uIHVzZXIncyBsb2NhdGlvbiAtIFNJTVBMSUZJRUQgWk9PTSBMT0dJQ1xyXG4gICAgICAgICAgICBpZiAobWFwSW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgICAvLyBEb24ndCBtb2RpZnkgem9vbSBpZiBpdCdzIGFscmVhZHkgYXQgYW4gYXBwcm9wcmlhdGUgbGV2ZWxcclxuICAgICAgICAgICAgICBjb25zdCBjdXJyZW50Wm9vbSA9IG1hcEluc3RhbmNlLmdldFpvb20oKTtcclxuICAgICAgICAgICAgICBjb25zdCB0YXJnZXRab29tID0gY3VycmVudFpvb20gPD0gNyA/IDkgOiBjdXJyZW50Wm9vbTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gU2V0IHRoZSB2aWV3IGRpcmVjdGx5IHRvIHRoZSB1c2VyJ3MgbG9jYXRpb25cclxuICAgICAgICAgICAgICBtYXBJbnN0YW5jZS5zZXRWaWV3KFtsYXRpdHVkZSwgbG9uZ2l0dWRlXSwgdGFyZ2V0Wm9vbSk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgbWFwIHJlZmxlY3RzIGNoYW5nZXNcclxuICAgICAgICAgICAgICBtYXBJbnN0YW5jZS5pbnZhbGlkYXRlU2l6ZSgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBpbiBnZW9mZW5jZSBtb2RlLCBlbnN1cmUgdGhlIGZpbHRlciBtb2RlIGlzIHNldCBjb3JyZWN0bHlcclxuICAgICAgICAgICAgaWYgKGZpbHRlck1vZGUgIT09ICdnZW9mZW5jZScgJiYgZmlsdGVyTW9kZSAhPT0gJ2JvdGgnKSB7XHJcbiAgICAgICAgICAgICAgc2V0RmlsdGVyTW9kZSgnZ2VvZmVuY2UnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgICAgICAgICBpZiAoZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ3JhdGUgbGltaXQnKSB8fCBlcnJvci5zdGF0dXMgPT09IDQyOSkge1xyXG4gICAgICAgICAgICAgIGhhbmRsZVJhdGVMaW1pdCgzMCk7XHJcbiAgICAgICAgICAgICAgLy8gU3RpbGwgdXBkYXRlIHRoZSBsb2NhdGlvbiBldmVuIGlmIHdlIGNvdWxkbid0IGdldCBhaXJjcmFmdFxyXG4gICAgICAgICAgICAgIGlmIChtYXBJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgbWFwSW5zdGFuY2Uuc2V0VmlldyhbbGF0aXR1ZGUsIGxvbmdpdHVkZV0sIDkpO1xyXG4gICAgICAgICAgICAgICAgbWFwSW5zdGFuY2UuaW52YWxpZGF0ZVNpemUoKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBDbG9zZSB0aGUgZHJvcGRvd24gYWZ0ZXIgc2VsZWN0aW9uXHJcbiAgICAgICAgICBzZXRBY3RpdmVEcm9wZG93bihudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyB1c2VyIGxvY2F0aW9uOicsIGVycm9yKTtcclxuICAgICAgICBhbGVydChcclxuICAgICAgICAgICdVbmFibGUgdG8gYWNjZXNzIHlvdXIgbG9jYXRpb24uIFBsZWFzZSBtYWtlIHN1cmUgbG9jYXRpb24gc2VydmljZXMgYXJlIGVuYWJsZWQgaW4geW91ciBicm93c2VyLidcclxuICAgICAgICApO1xyXG4gICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHNldElzR2V0dGluZ0xvY2F0aW9uKGZhbHNlKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBcclxuICAgIGNvbnN0IHByb2Nlc3NHZW9mZW5jZVNlYXJjaCA9IGFzeW5jICgpID0+IHtcclxuICAgICAgaWYgKCFnZW9mZW5jZUxvY2F0aW9uKSByZXR1cm47XHJcblxyXG4gICAgICAvLyBDaGVjayBpZiByYXRlIGxpbWl0ZWRcclxuICAgICAgaWYgKGlzUmF0ZUxpbWl0ZWQpIHtcclxuICAgICAgICBhbGVydChcclxuICAgICAgICAgIGBSYXRlIGxpbWl0ZWQuIFBsZWFzZSB3YWl0ICR7cmF0ZUxpbWl0VGltZXIgfHwgMzB9IHNlY29uZHMgYmVmb3JlIHNlYXJjaGluZyBhZ2Fpbi5gXHJcbiAgICAgICAgKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEJsb2NrIEFQSSBjYWxscyB3aGlsZSBkb2luZyBnZW9mZW5jZSBzZWFyY2ggaW4gY29tYmluZWQgbW9kZVxyXG4gICAgICBpZiAoZmlsdGVyTW9kZSA9PT0gJ2JvdGgnKSB7XHJcbiAgICAgICAgb3BlblNreVRyYWNraW5nU2VydmljZS5zZXRCbG9ja0FsbEFwaUNhbGxzKHRydWUpO1xyXG4gICAgICAgIHNldEJsb2NrTWFudWZhY3R1cmVyQXBpQ2FsbHModHJ1ZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFNldCBsb2FkaW5nIHN0YXRlXHJcbiAgICAgIHNldExvY2FsTG9hZGluZyh0cnVlKTtcclxuXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICBgU2VhcmNoaW5nIGZvciBhaXJjcmFmdCBuZWFyIGxvY2F0aW9uOiBcIiR7Z2VvZmVuY2VMb2NhdGlvbn1cImBcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyBUaGlzIHdpbGwgaGFuZGxlIFBvc3RhbCBjb2RlcywgcGxhY2UgbmFtZXMsIGFkZHJlc3NlcywgUE9JcywgZXRjLlxyXG4gICAgICAgIGxldCBmZXRjaGVkQWlyY3JhZnQ7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGZldGNoZWRBaXJjcmFmdCA9IGF3YWl0IGdldEFpcmNyYWZ0TmVhclNlYXJjaGVkTG9jYXRpb24oXHJcbiAgICAgICAgICAgIGdlb2ZlbmNlTG9jYXRpb24sXHJcbiAgICAgICAgICAgIGdlb2ZlbmNlUmFkaXVzXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygncmF0ZSBsaW1pdCcpIHx8IGVycm9yLnN0YXR1cyA9PT0gNDI5KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJldHJ5QWZ0ZXIgPSAzMDsgLy8gRGVmYXVsdCB0byAzMCBzZWNvbmRzIGlmIG5vdCBzcGVjaWZpZWRcclxuICAgICAgICAgICAgaGFuZGxlUmF0ZUxpbWl0KHJldHJ5QWZ0ZXIpO1xyXG4gICAgICAgICAgICBzZXRMb2NhbExvYWRpbmcoZmFsc2UpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEdldCBjb29yZGluYXRlcyBmb3IgdGhlIG1hcFxyXG4gICAgICAgIGxldCBsb2NhdGlvbnM6IHsgbGF0OiBudW1iZXI7IGxuZzogbnVtYmVyOyBuYW1lOiBzdHJpbmcgfVtdO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBsb2NhdGlvbnMgPSBhd2FpdCBNYXBib3hTZXJ2aWNlLnNlYXJjaExvY2F0aW9uV2l0aE1hcGJveChcclxuICAgICAgICAgICAgZ2VvZmVuY2VMb2NhdGlvbixcclxuICAgICAgICAgICAgMVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igc2VhcmNoaW5nIGxvY2F0aW9uIHdpdGggTWFwYm94OicsIGVycm9yKTtcclxuICAgICAgICAgIC8vIENvbnRpbnVlIHdpdGggYWlyY3JhZnQgZGF0YSBpZiBhdmFpbGFibGVcclxuICAgICAgICAgIGxvY2F0aW9ucyA9IFtdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGNvb3JkaW5hdGVzOiB7IGxhdDogbnVtYmVyOyBsbmc6IG51bWJlciB9IHwgbnVsbCA9IG51bGw7XHJcblxyXG4gICAgICAgIGlmIChsb2NhdGlvbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgY29vcmRpbmF0ZXMgPSB7XHJcbiAgICAgICAgICAgIGxhdDogbG9jYXRpb25zWzBdLmxhdCxcclxuICAgICAgICAgICAgbG5nOiBsb2NhdGlvbnNbMF0ubG5nLFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICAgIC8vIFNhdmUgdGhlIGZvcm1hdHRlZCBsb2NhdGlvbiBuYW1lXHJcbiAgICAgICAgICBzZXRHZW9mZW5jZUxvY2F0aW9uKGxvY2F0aW9uc1swXS5uYW1lKTtcclxuICAgICAgICB9IGVsc2UgaWYgKFxyXG4gICAgICAgICAgZmV0Y2hlZEFpcmNyYWZ0Lmxlbmd0aCA+IDAgJiZcclxuICAgICAgICAgIGZldGNoZWRBaXJjcmFmdFswXS5sYXRpdHVkZSAmJlxyXG4gICAgICAgICAgZmV0Y2hlZEFpcmNyYWZ0WzBdLmxvbmdpdHVkZVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgLy8gRmFsbGJhY2sgdG8gZmlyc3QgYWlyY3JhZnQgcG9zaXRpb25cclxuICAgICAgICAgIGNvb3JkaW5hdGVzID0ge1xyXG4gICAgICAgICAgICBsYXQ6IGZldGNoZWRBaXJjcmFmdFswXS5sYXRpdHVkZSxcclxuICAgICAgICAgICAgbG5nOiBmZXRjaGVkQWlyY3JhZnRbMF0ubG9uZ2l0dWRlLFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChmZXRjaGVkQWlyY3JhZnQubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICBhbGVydChcclxuICAgICAgICAgICAgYE5vIGFpcmNyYWZ0IGZvdW5kIG5lYXIgJHtnZW9mZW5jZUxvY2F0aW9ufS4gVHJ5IGluY3JlYXNpbmcgdGhlIHJhZGl1cyBvciBzZWFyY2hpbmcgaW4gYSBkaWZmZXJlbnQgYXJlYS5gXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgc2V0TG9jYWxMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSBzdGF0ZSB3aXRoIHRoZSBjb29yZGluYXRlc1xyXG4gICAgICAgIGlmIChjb29yZGluYXRlcykge1xyXG4gICAgICAgICAgc2V0R2VvZmVuY2VDb29yZGluYXRlcyhjb29yZGluYXRlcyk7XHJcbiAgICAgICAgICBzZXRHZW9mZW5jZUNlbnRlcihjb29yZGluYXRlcyk7XHJcbiAgICAgICAgICBzZXRHZW9mZW5jZVJhZGl1cyhnZW9mZW5jZVJhZGl1cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaXNHZW9mZW5jZUFjdGl2ZSkge1xyXG4gICAgICAgICAgdG9nZ2xlR2VvZmVuY2UoKTtcclxuICAgICAgICB9IGVsc2UgaWYgKCFjb29yZGluYXRlcykge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZGV0ZXJtaW5lIGNvb3JkaW5hdGVzIGZvciB0aGUgbG9jYXRpb24nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgYEZvdW5kICR7ZmV0Y2hlZEFpcmNyYWZ0Lmxlbmd0aH0gYWlyY3JhZnQgaW4gdGhlIGFyZWEsIHByZXBhcmluZyBmb3IgZGlzcGxheS4uLmBcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyBFbnN1cmUgdGhlIGRhdGEgaXMgaW4gdGhlIHJpZ2h0IGZvcm1hdFxyXG4gICAgICAgIGNvbnN0IGFkYXB0ZWRBaXJjcmFmdCA9XHJcbiAgICAgICAgICBmZXRjaGVkQWlyY3JhZnRbMF0uTUFOVUZBQ1RVUkVSICE9PSB1bmRlZmluZWRcclxuICAgICAgICAgICAgPyBmZXRjaGVkQWlyY3JhZnQgLy8gQWxyZWFkeSBpbiB0aGUgcmlnaHQgZm9ybWF0XHJcbiAgICAgICAgICAgIDogYWRhcHRHZW9mZW5jZUFpcmNyYWZ0KGZldGNoZWRBaXJjcmFmdCk7IC8vIE5lZWRzIGFkYXB0YXRpb25cclxuXHJcbiAgICAgICAgLy8gRW5yaWNoIHdpdGggc3RhdGljIGRhdGFcclxuICAgICAgICBjb25zb2xlLmxvZygnRW5yaWNoaW5nIGdlb2ZlbmNlIGFpcmNyYWZ0IHdpdGggc3RhdGljIGRhdGEuLi4nKTtcclxuICAgICAgICBjb25zdCBlbnJpY2hlZEFpcmNyYWZ0ID0gYXdhaXQgZW5yaWNoR2VvZmVuY2VBaXJjcmFmdChhZGFwdGVkQWlyY3JhZnQpO1xyXG5cclxuICAgICAgICAvLyBTYXZlIHRoZSBGVUxMIHNldCB0byBsb2NhbCBzdGF0ZVxyXG4gICAgICAgIHNldEdlb2ZlbmNlQWlyY3JhZnQoZW5yaWNoZWRBaXJjcmFmdCk7XHJcbiAgICAgICAgc2V0SXNHZW9mZW5jZUFjdGl2ZSh0cnVlKTtcclxuXHJcbiAgICAgICAgLy8gQ2xlYXIgZXhpc3RpbmcgYWlyY3JhZnQgZGF0YVxyXG4gICAgICAgIGlmIChjbGVhckdlb2ZlbmNlRGF0YSkge1xyXG4gICAgICAgICAgY2xlYXJHZW9mZW5jZURhdGEoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIElmIHdlJ3JlIGluIGNvbWJpbmVkIG1vZGUgYW5kIGhhdmUgYSBtYW51ZmFjdHVyZXIsIGFwcGx5IHRoZSBjb21iaW5lZCBmaWx0ZXJcclxuICAgICAgICBpZiAoZmlsdGVyTW9kZSA9PT0gJ2JvdGgnICYmIHNlbGVjdGVkTWFudWZhY3R1cmVyKSB7XHJcbiAgICAgICAgICAvLyBNYWtlIHN1cmUgQVBJIGNhbGxzIHJlbWFpbiBibG9ja2VkXHJcbiAgICAgICAgICBvcGVuU2t5VHJhY2tpbmdTZXJ2aWNlLnNldEJsb2NrQWxsQXBpQ2FsbHModHJ1ZSk7XHJcbiAgICAgICAgICBzZXRCbG9ja01hbnVmYWN0dXJlckFwaUNhbGxzKHRydWUpO1xyXG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGFwcGx5Q29tYmluZWRGaWx0ZXJzKCk7XHJcbiAgICAgICAgICB9LCAxMDApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBKdXN0IHNob3cgYWxsIGFpcmNyYWZ0IGluIHRoZSBnZW9mZW5jZVxyXG4gICAgICAgICAgdXBkYXRlR2VvZmVuY2VBaXJjcmFmdChlbnJpY2hlZEFpcmNyYWZ0KTtcclxuXHJcbiAgICAgICAgICAvLyBDZW50ZXIgdGhlIG1hcCAtIFNJTVBMSUZJRUQgWk9PTSBMT0dJQ1xyXG4gICAgICAgICAgaWYgKG1hcEluc3RhbmNlICYmIGNvb3JkaW5hdGVzKSB7XHJcbiAgICAgICAgICAgIC8vIEdldCBjdXJyZW50IHpvb20gbGV2ZWxcclxuICAgICAgICAgICAgY29uc3QgY3VycmVudFpvb20gPSBtYXBJbnN0YW5jZS5nZXRab29tKCk7XHJcbiAgICAgICAgICAgIC8vIFVzZSBhcHByb3ByaWF0ZSB6b29tIGxldmVsIGJhc2VkIG9uIGN1cnJlbnQgdmlld1xyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXRab29tID0gY3VycmVudFpvb20gPD0gNyA/IDkgOiBjdXJyZW50Wm9vbTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNldCB2aWV3IHRvIHRoZSBjb29yZGluYXRlc1xyXG4gICAgICAgICAgICBtYXBJbnN0YW5jZS5zZXRWaWV3KFtjb29yZGluYXRlcy5sYXQsIGNvb3JkaW5hdGVzLmxuZ10sIHRhcmdldFpvb20pO1xyXG5cclxuICAgICAgICAgICAgLy8gRW5zdXJlIG1hcCBpcyB1cGRhdGVkXHJcbiAgICAgICAgICAgIG1hcEluc3RhbmNlLmludmFsaWRhdGVTaXplKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDbG9zZSBkcm9wZG93biBhZnRlciBzZWFyY2hcclxuICAgICAgICBzZXRBY3RpdmVEcm9wZG93bihudWxsKTtcclxuICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGdlb2ZlbmNlIHNlYXJjaDonLCBlcnJvcik7XHJcbiAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCdyYXRlIGxpbWl0JykgfHwgZXJyb3Iuc3RhdHVzID09PSA0MjkpIHtcclxuICAgICAgICAgIGhhbmRsZVJhdGVMaW1pdCgzMCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGFsZXJ0KFxyXG4gICAgICAgICAgICBgRXJyb3I6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvciBvY2N1cnJlZCd9YFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgc2V0TG9jYWxMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiBcclxuICAgICAgICAvKipcclxuICAgICAqIFNURVAgMzogRml4IHRvZ2dsZUdlb2ZlbmNlU3RhdGUgdG8gYmV0dGVyIGhhbmRsZSBtYW51YWxseSBjbGlja2luZyB0aGUgYnV0dG9uXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IHRvZ2dsZUdlb2ZlbmNlU3RhdGUgPSAoZW5hYmxlZDogYm9vbGVhbikgPT4ge1xyXG4gICAgICBjb25zb2xlLmxvZygndG9nZ2xlR2VvZmVuY2VTdGF0ZSBjYWxsZWQgd2l0aDonLCBlbmFibGVkKTtcclxuICAgICAgY29uc29sZS5sb2coJ0N1cnJlbnQgZ2VvZmVuY2VDb29yZGluYXRlczonLCBnZW9mZW5jZUNvb3JkaW5hdGVzKTtcclxuXHJcbiAgICAgIGlmIChlbmFibGVkKSB7XHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSB2YWxpZCBjb29yZGluYXRlc1xyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgIGdlb2ZlbmNlQ29vcmRpbmF0ZXMgJiZcclxuICAgICAgICAgIHR5cGVvZiBnZW9mZW5jZUNvb3JkaW5hdGVzLmxhdCA9PT0gJ251bWJlcicgJiZcclxuICAgICAgICAgIHR5cGVvZiBnZW9mZW5jZUNvb3JkaW5hdGVzLmxuZyA9PT0gJ251bWJlcicgJiZcclxuICAgICAgICAgICFpc05hTihnZW9mZW5jZUNvb3JkaW5hdGVzLmxhdCkgJiZcclxuICAgICAgICAgICFpc05hTihnZW9mZW5jZUNvb3JkaW5hdGVzLmxuZylcclxuICAgICAgICApIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKCdWYWxpZCBjb29yZGluYXRlcyBmb3VuZCwgZW5hYmxpbmcgZ2VvZmVuY2UnKTtcclxuXHJcbiAgICAgICAgICAvLyBTZXQgZmxhZ3MgZmlyc3RcclxuICAgICAgICAgIHNldEdlb2ZlbmNlRW5hYmxlZCh0cnVlKTtcclxuICAgICAgICAgIHNldElzR2VvZmVuY2VBY3RpdmUodHJ1ZSk7XHJcblxyXG4gICAgICAgICAgLy8gQ2FsbCBjb250ZXh0IHRvZ2dsZSBmdW5jdGlvbiBpZiBhdmFpbGFibGVcclxuICAgICAgICAgIGlmICh0eXBlb2YgdG9nZ2xlR2VvZmVuY2UgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdG9nZ2xlR2VvZmVuY2UoKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBEaXNwbGF5IGFpcmNyYWZ0IGlmIHdlIGhhdmUgdGhlbVxyXG4gICAgICAgICAgaWYgKGdlb2ZlbmNlQWlyY3JhZnQgJiYgZ2VvZmVuY2VBaXJjcmFmdC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgICAgIGBTaG93aW5nICR7Z2VvZmVuY2VBaXJjcmFmdC5sZW5ndGh9IGFpcmNyYWZ0IGluIGdlb2ZlbmNlYFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB1cGRhdGVHZW9mZW5jZUFpcmNyYWZ0KGdlb2ZlbmNlQWlyY3JhZnQpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gTm8gYWlyY3JhZnQgZGF0YSB5ZXQsIHRyaWdnZXIgYSBzZWFyY2hcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ05vIGFpcmNyYWZ0IGRhdGEgeWV0LCB0cmlnZ2VyaW5nIHNlYXJjaCcpO1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICBwcm9jZXNzR2VvZmVuY2VTZWFyY2goKTtcclxuICAgICAgICAgICAgfSwgMTAwKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gTm8gdmFsaWQgY29vcmRpbmF0ZXNcclxuICAgICAgICAgIGNvbnNvbGUud2FybignTm8gdmFsaWQgY29vcmRpbmF0ZXMsIHNob3dpbmcgYWxlcnQnKTtcclxuICAgICAgICAgIGFsZXJ0KFxyXG4gICAgICAgICAgICAnUGxlYXNlIHNldCBhIGxvY2F0aW9uIGJlZm9yZSBlbmFibGluZyBnZW9mZW5jZS5cXG5cXG5DbGljayBhbnl3aGVyZSBvbiB0aGUgbWFwIHRvIHNldCBhIGxvY2F0aW9uLidcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICBzZXRHZW9mZW5jZUVuYWJsZWQoZmFsc2UpO1xyXG4gICAgICAgICAgc2V0SXNHZW9mZW5jZUFjdGl2ZShmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIERpc2FibGluZyBnZW9mZW5jZVxyXG4gICAgICAgIGNvbnNvbGUubG9nKCdEaXNhYmxpbmcgZ2VvZmVuY2UnKTtcclxuICAgICAgICBzZXRHZW9mZW5jZUVuYWJsZWQoZmFsc2UpO1xyXG4gICAgICAgIHNldElzR2VvZmVuY2VBY3RpdmUoZmFsc2UpO1xyXG5cclxuICAgICAgICAvLyBDbGVhciBnZW9mZW5jZSBkYXRhIGlmIGZ1bmN0aW9uIGF2YWlsYWJsZVxyXG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJHZW9mZW5jZURhdGEgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgIGNsZWFyR2VvZmVuY2VEYXRhKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgLy8gRWZmZWN0c1xyXG5cclxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKGdlb2ZlbmNlQ29vcmRpbmF0ZXMpIHtcclxuICAgICAgc2V0SXNTZWFyY2hSZWFkeSh0cnVlKTtcclxuICAgIH1cclxuICB9LCBbZ2VvZmVuY2VDb29yZGluYXRlc10pO1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKGlzUmF0ZUxpbWl0ZWQgJiYgcmF0ZUxpbWl0VGltZXIpIHtcclxuICAgICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICBzZXRJc1JhdGVMaW1pdGVkKGZhbHNlKTtcclxuICAgICAgICBzZXRSYXRlTGltaXRUaW1lcihudWxsKTtcclxuICAgICAgICBjb25zb2xlLmxvZygnUmF0ZSBsaW1pdCB0aW1lciBleHBpcmVkLCByZXN1bWluZyBBUEkgY2FsbHMnKTtcclxuICAgICAgfSwgcmF0ZUxpbWl0VGltZXIgKiAxMDAwKTtcclxuXHJcbiAgICAgIHJldHVybiAoKSA9PiBjbGVhclRpbWVvdXQodGltZXIpO1xyXG4gICAgfVxyXG4gIH0sIFtpc1JhdGVMaW1pdGVkLCByYXRlTGltaXRUaW1lcl0pO1xyXG5cclxuICAvLyBFZmZlY3QgdG8gc3luYyBnZW9mZW5jZSBzdGF0ZVxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAvLyBVcGRhdGUgaW50ZXJuYWwgc3RhdGUgd2hlbiBnZW9mZW5jZSBpcyB0b2dnbGVkIGV4dGVybmFsbHlcclxuICAgIGlmIChpc0dlb2ZlbmNlQWN0aXZlICE9PSBnZW9mZW5jZUVuYWJsZWQpIHtcclxuICAgICAgc2V0R2VvZmVuY2VFbmFibGVkKGlzR2VvZmVuY2VBY3RpdmUpO1xyXG4gICAgfVxyXG4gIH0sIFtpc0dlb2ZlbmNlQWN0aXZlXSk7XHJcblxyXG4gIC8vIENsb3NlIGRyb3Bkb3duIHdoZW4gY2xpY2tpbmcgb3V0c2lkZVxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBjb25zdCBoYW5kbGVDbGlja091dHNpZGUgPSAoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgLy8gQ2hlY2sgaWYgY2xpY2sgaXMgb3V0c2lkZSBvZiBhbGwgZHJvcGRvd25zXHJcbiAgICAgIGNvbnN0IGlzT3V0c2lkZUFsbCA9IE9iamVjdC52YWx1ZXMoZHJvcGRvd25SZWZzKS5ldmVyeShcclxuICAgICAgICAocmVmKSA9PiAhcmVmLmN1cnJlbnQgfHwgIXJlZi5jdXJyZW50LmNvbnRhaW5zKGV2ZW50LnRhcmdldCBhcyBOb2RlKVxyXG4gICAgICApO1xyXG5cclxuICAgICAgaWYgKGlzT3V0c2lkZUFsbCkge1xyXG4gICAgICAgIHNldEFjdGl2ZURyb3Bkb3duKG51bGwpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGhhbmRsZUNsaWNrT3V0c2lkZSk7XHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBoYW5kbGVDbGlja091dHNpZGUpO1xyXG4gICAgfTtcclxuICB9LCBbXSk7XHJcblxyXG4gIC8vIENsZWFuIHVwIHJlZ2lvbiBvdXRsaW5lIHdoZW4gY29tcG9uZW50IHVubW91bnRzXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIGlmIChyZWdpb25PdXRsaW5lKSB7XHJcbiAgICAgICAgcmVnaW9uT3V0bGluZS5yZW1vdmUoKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9LCBbcmVnaW9uT3V0bGluZV0pO1xyXG5cclxuICAvLyBFZmZlY3QgdG8gaGFuZGxlIG1hcCBjbGljayBmb3IgZ2VvZmVuY2VcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgY29uc3QgaGFuZGxlTWFwR2VvZmVuY2VDbGljayA9IGFzeW5jIChldmVudDogRXZlbnQpID0+IHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICAvLyBDYXN0IHRoZSBldmVudCB0byB0aGUgcHJvcGVyIHR5cGVcclxuICAgICAgICBjb25zdCBjdXN0b21FdmVudCA9IGV2ZW50IGFzIEN1c3RvbUV2ZW50PHsgbGF0OiBudW1iZXI7IGxuZzogbnVtYmVyIH0+O1xyXG4gICAgICAgIGNvbnN0IHsgbGF0LCBsbmcgfSA9IGN1c3RvbUV2ZW50LmRldGFpbDtcclxuXHJcbiAgICAgICAgLy8gRmlyc3QgdXBkYXRlIGNvb3JkaW5hdGVzIGltbWVkaWF0ZWx5XHJcbiAgICAgICAgc2V0R2VvZmVuY2VDb29yZGluYXRlcyh7IGxhdCwgbG5nIH0pO1xyXG5cclxuICAgICAgICAvLyBUaGVuIHN0YXJ0IGFuIGFzeW5jIG9wZXJhdGlvbiB0byBnZXQgdGhlIGxvY2F0aW9uIG5hbWVcclxuICAgICAgICBjb25zb2xlLmxvZyhgR2V0dGluZyBsb2NhdGlvbiBuYW1lIGZvcjogJHtsYXR9LCAke2xuZ31gKTtcclxuXHJcbiAgICAgICAgLy8gVGVtcG9yYXJpbHkgc2hvdyBjb29yZGluYXRlcyB3aGlsZSBmZXRjaGluZyB0aGUgbmFtZVxyXG4gICAgICAgIHNldEdlb2ZlbmNlTG9jYXRpb24oYCR7bGF0LnRvRml4ZWQoNil9LCAke2xuZy50b0ZpeGVkKDYpfWApO1xyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIGZyaWVuZGx5IG5hbWUgYXN5bmNocm9ub3VzbHlcclxuICAgICAgICBjb25zdCBsb2NhdGlvbk5hbWUgPSBhd2FpdCBNYXBib3hTZXJ2aWNlLmdldExvY2F0aW9uTmFtZUZyb21Db29yZGluYXRlcyhcclxuICAgICAgICAgIGxhdCxcclxuICAgICAgICAgIGxuZ1xyXG4gICAgICAgICk7XHJcbiAgICAgICAgY29uc29sZS5sb2coYEdvdCBsb2NhdGlvbiBuYW1lOiAke2xvY2F0aW9uTmFtZX1gKTtcclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIHdpdGggdGhlIGZyaWVuZGx5IG5hbWUgb25jZSB3ZSBoYXZlIGl0XHJcbiAgICAgICAgaWYgKGxvY2F0aW9uTmFtZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgc2V0R2VvZmVuY2VMb2NhdGlvbihsb2NhdGlvbk5hbWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gT3BlbiB0aGUgbG9jYXRpb24gZHJvcGRvd24gaWYgbmVlZGVkXHJcbiAgICAgICAgaWYgKGFjdGl2ZURyb3Bkb3duICE9PSAnbG9jYXRpb24nKSB7XHJcbiAgICAgICAgICBzZXRBY3RpdmVEcm9wZG93bignbG9jYXRpb24nKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaGFuZGxpbmcgbWFwIGNsaWNrOicsIGVycm9yKTtcclxuICAgICAgICAvLyBLZWVwIHRoZSBjb29yZGluYXRlcyBkaXNwbGF5IGlmIHRoZXJlIHdhcyBhbiBlcnJvclxyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEFkZCB0aGUgZXZlbnQgbGlzdGVuZXIgLSB1c2UgdGhlIHN0YW5kYXJkIGV2ZW50IGxpc3RlbmVyIHBhdHRlcm5cclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXHJcbiAgICAgICdtYXAtZ2VvZmVuY2UtY2xpY2snLFxyXG4gICAgICBoYW5kbGVNYXBHZW9mZW5jZUNsaWNrIGFzIEV2ZW50TGlzdGVuZXJcclxuICAgICk7XHJcblxyXG4gICAgLy8gQ2xlYW4gdXBcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXHJcbiAgICAgICAgJ21hcC1nZW9mZW5jZS1jbGljaycsXHJcbiAgICAgICAgaGFuZGxlTWFwR2VvZmVuY2VDbGljayBhcyBFdmVudExpc3RlbmVyXHJcbiAgICAgICk7XHJcbiAgICB9O1xyXG4gIH0sIFtcclxuICAgIHNldEdlb2ZlbmNlTG9jYXRpb24sXHJcbiAgICBzZXRHZW9mZW5jZUNvb3JkaW5hdGVzLFxyXG4gICAgc2V0QWN0aXZlRHJvcGRvd24sXHJcbiAgICBhY3RpdmVEcm9wZG93bixcclxuICBdKTtcclxuXHJcbiAgLy8gTWFpbiBtZXRob2RzXHJcbiAgY29uc3QgdG9nZ2xlRHJvcGRvd24gPSAoZHJvcGRvd246IHN0cmluZywgZXZlbnQ6IFJlYWN0Lk1vdXNlRXZlbnQpID0+IHtcclxuICAgIGlmIChhY3RpdmVEcm9wZG93biA9PT0gZHJvcGRvd24pIHtcclxuICAgICAgc2V0QWN0aXZlRHJvcGRvd24obnVsbCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzZXRBY3RpdmVEcm9wZG93bihkcm9wZG93bik7XHJcbiAgICB9XHJcbiAgICAvLyBQcmV2ZW50IGV2ZW50cyBmcm9tIGJ1YmJsaW5nIHVwXHJcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICB9O1xyXG5cclxuICBjb25zdCBoYW5kbGVSYXRlTGltaXQgPSAocmV0cnlBZnRlcjogbnVtYmVyID0gMzApID0+IHtcclxuICAgIHNldElzUmF0ZUxpbWl0ZWQodHJ1ZSk7XHJcbiAgICBzZXRSYXRlTGltaXRUaW1lcihyZXRyeUFmdGVyKTtcclxuICAgIGNvbnNvbGUubG9nKGBSYXRlIGxpbWl0ZWQgYnkgQVBJLiBSZXRyeSBhZnRlciAke3JldHJ5QWZ0ZXJ9c2ApO1xyXG5cclxuICAgIC8vIEJsb2NrIGFsbCBBUEkgY2FsbHNcclxuICAgIG9wZW5Ta3lUcmFja2luZ1NlcnZpY2Uuc2V0QmxvY2tBbGxBcGlDYWxscyh0cnVlKTtcclxuICAgIHNldEJsb2NrTWFudWZhY3R1cmVyQXBpQ2FsbHModHJ1ZSk7XHJcblxyXG4gICAgLy8gU2hvdyBub3RpZmljYXRpb24gdG8gdXNlclxyXG4gICAgaWYgKHJldHJ5QWZ0ZXIgPiAwKSB7XHJcbiAgICAgIGFsZXJ0KFxyXG4gICAgICAgIGBBaXJjcmFmdCBkYXRhIHJlZnJlc2ggcmF0ZSBsaW1pdGVkLiBQbGVhc2Ugd2FpdCAke3JldHJ5QWZ0ZXJ9IHNlY29uZHMgYmVmb3JlIHRyeWluZyBhZ2Fpbi5gXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogVG9nZ2xlIGZpbHRlciBtb2RlXHJcbiAgICovXHJcbiAgY29uc3QgdG9nZ2xlRmlsdGVyTW9kZSA9IChtb2RlOiBGaWx0ZXJNb2RlKSA9PiB7XHJcbiAgICBzZXRGaWx0ZXJNb2RlKG1vZGUpO1xyXG4gICAgc2V0QWN0aXZlRHJvcGRvd24obnVsbCk7XHJcblxyXG4gICAgLy8gQXBwbHkgYXBwcm9wcmlhdGUgZmlsdGVycyBiYXNlZCBvbiBuZXcgbW9kZVxyXG4gICAgaWYgKG1vZGUgPT09ICdyZWdpb24nKSB7XHJcbiAgICAgIC8vIEJsb2NrIEFQSSBjYWxscyBpbiByZWdpb24gbW9kZVxyXG4gICAgICBvcGVuU2t5VHJhY2tpbmdTZXJ2aWNlLnNldEJsb2NrQWxsQXBpQ2FsbHModHJ1ZSk7XHJcblxyXG4gICAgICAvLyBBcHBseSByZWdpb24gZmlsdGVyaW5nIGlmIHdlIGFscmVhZHkgaGF2ZSBkYXRhXHJcbiAgICAgIGlmIChkaXNwbGF5ZWRBaXJjcmFmdCAmJiBkaXNwbGF5ZWRBaXJjcmFmdC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgZmlsdGVyQWlyY3JhZnRCeVJlZ2lvbihzZWxlY3RlZFJlZ2lvbi50b1N0cmluZygpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2xlYXIgbWFudWZhY3R1cmVyIHNlbGVjdGlvbiBmcm9tIHRoZSBVSVxyXG4gICAgICBzZWxlY3RNYW51ZmFjdHVyZXIobnVsbCk7XHJcbiAgICAgIHNlbGVjdE1vZGVsKG51bGwpO1xyXG5cclxuICAgICAgLy8gSWYgZ2VvZmVuY2UgaXMgYWN0aXZlLCByZXN0b3JlIHRoZSBmdWxsIGdlb2ZlbmNlIGRhdGFcclxuICAgICAgaWYgKGdlb2ZlbmNlQ29vcmRpbmF0ZXMgJiYgZ2VvZmVuY2VBaXJjcmFmdC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgdXBkYXRlR2VvZmVuY2VBaXJjcmFmdChnZW9mZW5jZUFpcmNyYWZ0KTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChtb2RlID09PSAnb3duZXInKSB7XHJcbiAgICAgIC8vIEZpbHRlciBkaXNwbGF5ZWQgYWlyY3JhZnQgYnkgb3duZXIgdHlwZVxyXG4gICAgICBpZiAoZGlzcGxheWVkQWlyY3JhZnQgJiYgZGlzcGxheWVkQWlyY3JhZnQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIC8vIEZpcnN0IGZpbHRlciBmb3IgdmFsaWQgY29vcmRpbmF0ZXNcclxuICAgICAgICBjb25zdCBhaXJjcmFmdFdpdGhWYWxpZENvb3JkcyA9IGRpc3BsYXllZEFpcmNyYWZ0LmZpbHRlcihcclxuICAgICAgICAgIChwbGFuZSkgPT5cclxuICAgICAgICAgICAgdHlwZW9mIHBsYW5lLmxhdGl0dWRlID09PSAnbnVtYmVyJyAmJlxyXG4gICAgICAgICAgICB0eXBlb2YgcGxhbmUubG9uZ2l0dWRlID09PSAnbnVtYmVyJyAmJlxyXG4gICAgICAgICAgICAhaXNOYU4ocGxhbmUubGF0aXR1ZGUpICYmXHJcbiAgICAgICAgICAgICFpc05hTihwbGFuZS5sb25naXR1ZGUpXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gQXBwbHkgb3duZXIgdHlwZSBmaWx0ZXJcclxuICAgICAgICBsZXQgZmlsdGVyZWRCeU93bmVyID1cclxuICAgICAgICAgIG93bmVyRmlsdGVycy5sZW5ndGggPT09IDBcclxuICAgICAgICAgICAgPyBhaXJjcmFmdFdpdGhWYWxpZENvb3Jkc1xyXG4gICAgICAgICAgICA6IGFpcmNyYWZ0V2l0aFZhbGlkQ29vcmRzLmZpbHRlcigoYWlyY3JhZnQpID0+XHJcbiAgICAgICAgICAgICAgICBvd25lckZpbHRlcnMuaW5jbHVkZXMoZ2V0QWlyY3JhZnRPd25lclR5cGUoYWlyY3JhZnQpKVxyXG4gICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSBkaXNwbGF5IHdpdGggZmlsdGVyZWQgYWlyY3JhZnRcclxuICAgICAgICBpZiAoY2xlYXJHZW9mZW5jZURhdGEpIHtcclxuICAgICAgICAgIGNsZWFyR2VvZmVuY2VEYXRhKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHVwZGF0ZUdlb2ZlbmNlQWlyY3JhZnQoZmlsdGVyZWRCeU93bmVyKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChtb2RlID09PSAnYm90aCcpIHtcclxuICAgICAgLy8gQm90aCBtb2RlIC0gQkxPQ0sgQVBJIENBTExTXHJcbiAgICAgIG9wZW5Ta3lUcmFja2luZ1NlcnZpY2Uuc2V0QmxvY2tBbGxBcGlDYWxscyh0cnVlKTtcclxuXHJcbiAgICAgIGlmIChcclxuICAgICAgICBzZWxlY3RlZE1hbnVmYWN0dXJlciAmJlxyXG4gICAgICAgIGlzR2VvZmVuY2VBY3RpdmUgJiZcclxuICAgICAgICBnZW9mZW5jZUFpcmNyYWZ0Lmxlbmd0aCA+IDBcclxuICAgICAgKSB7XHJcbiAgICAgICAgYXBwbHlDb21iaW5lZEZpbHRlcnMoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBJZiBvbmUgaXMgbWlzc2luZywgcHJvbXB0IHRoZSB1c2VyXHJcbiAgICAgICAgaWYgKCFzZWxlY3RlZE1hbnVmYWN0dXJlciAmJiBpc0dlb2ZlbmNlQWN0aXZlKSB7XHJcbiAgICAgICAgICBhbGVydCgnUGxlYXNlIHNlbGVjdCBhIG1hbnVmYWN0dXJlciB0byB1c2UgY29tYmluZWQgZmlsdGVyIG1vZGUnKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHNlbGVjdGVkTWFudWZhY3R1cmVyICYmICFpc0dlb2ZlbmNlQWN0aXZlKSB7XHJcbiAgICAgICAgICBhbGVydCgnUGxlYXNlIHNldCBhIGxvY2F0aW9uIHRvIHVzZSBjb21iaW5lZCBmaWx0ZXIgbW9kZScpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBhbGVydChcclxuICAgICAgICAgICAgJ1BsZWFzZSBzZWxlY3QgYm90aCBhIG1hbnVmYWN0dXJlciBhbmQgbG9jYXRpb24gdG8gdXNlIGNvbWJpbmVkIGZpbHRlciBtb2RlJ1xyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvLyBPd25lciBmaWx0ZXIgbWV0aG9kc1xyXG4gIGNvbnN0IGdldEFpcmNyYWZ0T3duZXJUeXBlID0gKGFpcmNyYWZ0OiBFeHRlbmRlZEFpcmNyYWZ0KTogc3RyaW5nID0+IHtcclxuICAgIGNvbnN0IG93bmVyVHlwZSA9IGFpcmNyYWZ0LlRZUEVfUkVHSVNUUkFOVCB8fCAwO1xyXG4gICAgcmV0dXJuIG93bmVyVHlwZVRvU3RyaW5nKG93bmVyVHlwZSk7XHJcbiAgfTtcclxuXHJcbiAgY29uc3Qgb3duZXJUeXBlVG9TdHJpbmcgPSAodHlwZTogbnVtYmVyIHwgc3RyaW5nKTogc3RyaW5nID0+IHtcclxuICAgIGNvbnN0IHR5cGVOdW0gPSB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgPyBwYXJzZUludCh0eXBlLCAxMCkgOiB0eXBlO1xyXG5cclxuICAgIGNvbnN0IG93bmVyVHlwZU1hcDogUmVjb3JkPG51bWJlciwgc3RyaW5nPiA9IHtcclxuICAgICAgMTogJ2luZGl2aWR1YWwnLFxyXG4gICAgICAyOiAncGFydG5lcnNoaXAnLFxyXG4gICAgICAzOiAnY29ycC1vd25lcicsXHJcbiAgICAgIDQ6ICdjby1vd25lZCcsXHJcbiAgICAgIDc6ICdsbGMnLFxyXG4gICAgICA4OiAnbm9uLWNpdGl6ZW4tY29ycCcsXHJcbiAgICAgIDk6ICdhaXJsaW5lJyxcclxuICAgICAgMTA6ICdmcmVpZ2h0JyxcclxuICAgICAgMTE6ICdtZWRpY2FsJyxcclxuICAgICAgMTI6ICdtZWRpYScsXHJcbiAgICAgIDEzOiAnaGlzdG9yaWNhbCcsXHJcbiAgICAgIDE0OiAnZmx5aW5nLWNsdWInLFxyXG4gICAgICAxNTogJ2VtZXJnZW5jeScsXHJcbiAgICAgIDE2OiAnbG9jYWwtZ292dCcsXHJcbiAgICAgIDE3OiAnZWR1Y2F0aW9uJyxcclxuICAgICAgMTg6ICdmZWRlcmFsLWdvdnQnLFxyXG4gICAgICAxOTogJ2ZsaWdodC1zY2hvb2wnLFxyXG4gICAgICAyMDogJ2xlYXNpbmctY29ycCcsXHJcbiAgICAgIDIxOiAnbWlsaXRhcnknLFxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gb3duZXJUeXBlTWFwW3R5cGVOdW1dIHx8ICd1bmtub3duJztcclxuICB9O1xyXG5cclxuICBjb25zdCBhcHBseU93bmVyVHlwZUZpbHRlciA9IChmaWx0ZXJzOiBzdHJpbmdbXSkgPT4ge1xyXG4gICAgLy8gU2tpcCBmaWx0ZXJpbmcgaWYgYWxsIHR5cGVzIGFyZSBzZWxlY3RlZCBvciBub25lIGFyZSBzZWxlY3RlZFxyXG4gICAgaWYgKGZpbHRlcnMubGVuZ3RoID09PSAwIHx8IGZpbHRlcnMubGVuZ3RoID09PSBhbGxPd25lclR5cGVzLmxlbmd0aCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRmlsdGVyIHRoZSBhaXJjcmFmdCBiYXNlZCBvbiBzZWxlY3RlZCBvd25lciB0eXBlc1xyXG4gICAgaWYgKGRpc3BsYXllZEFpcmNyYWZ0ICYmIGRpc3BsYXllZEFpcmNyYWZ0Lmxlbmd0aCA+IDApIHtcclxuICAgICAgY29uc3QgZmlsdGVyZWRBaXJjcmFmdCA9IGRpc3BsYXllZEFpcmNyYWZ0LmZpbHRlcigoYWlyY3JhZnQpID0+IHtcclxuICAgICAgICBjb25zdCBvd25lclR5cGUgPSBnZXRBaXJjcmFmdE93bmVyVHlwZShhaXJjcmFmdCk7XHJcbiAgICAgICAgcmV0dXJuIGZpbHRlcnMuaW5jbHVkZXMob3duZXJUeXBlKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBVcGRhdGUgdGhlIGRpc3BsYXllZCBhaXJjcmFmdFxyXG4gICAgICBpZiAoY2xlYXJHZW9mZW5jZURhdGEpIHtcclxuICAgICAgICBjbGVhckdlb2ZlbmNlRGF0YSgpO1xyXG4gICAgICB9XHJcbiAgICAgIHVwZGF0ZUdlb2ZlbmNlQWlyY3JhZnQoZmlsdGVyZWRBaXJjcmFmdCk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgaGFuZGxlT3duZXJGaWx0ZXJDaGFuZ2UgPSAodXBkYXRlZEZpbHRlcnM6IHN0cmluZ1tdKSA9PiB7XHJcbiAgICBzZXRPd25lckZpbHRlcnModXBkYXRlZEZpbHRlcnMpO1xyXG4gICAgLy8gQXBwbHkgdGhlIGZpbHRlciB0byB5b3VyIGFpcmNyYWZ0IGRhdGFcclxuICAgIGFwcGx5T3duZXJUeXBlRmlsdGVyKHVwZGF0ZWRGaWx0ZXJzKTtcclxuICB9O1xyXG5cclxuICBjb25zdCByZXNldE93bmVyRmlsdGVycyA9ICgpID0+IHtcclxuICAgIHNldE93bmVyRmlsdGVycyhbLi4uYWxsT3duZXJUeXBlc10pO1xyXG4gIH07XHJcblxyXG4gIC8vIFJlZ2lvbiBmaWx0ZXIgbWV0aG9kc1xyXG4gIGNvbnN0IGZpbHRlckFpcmNyYWZ0QnlSZWdpb24gPSAocmVnaW9uOiBzdHJpbmcpID0+IHtcclxuICAgIGlmICghZGlzcGxheWVkQWlyY3JhZnQgfHwgZGlzcGxheWVkQWlyY3JhZnQubGVuZ3RoID09PSAwKSByZXR1cm47XHJcbiAgICBzZXRMb2NhbExvYWRpbmcodHJ1ZSk7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gR2V0IHRoZSBib3VuZHMgZm9yIHRoZSBzZWxlY3RlZCByZWdpb25cclxuICAgICAgY29uc3QgYm91bmRzRXhwcmVzc2lvbiA9IGdldEJvdW5kc0J5UmVnaW9uKHJlZ2lvbik7XHJcblxyXG4gICAgICAvLyBFbnN1cmUgYm91bmRzIGlzIGluIHRoZSBjb3JyZWN0IGZvcm1hdFxyXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYm91bmRzRXhwcmVzc2lvbikgfHwgYm91bmRzRXhwcmVzc2lvbi5sZW5ndGggIT09IDIpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKFxyXG4gICAgICAgICAgYEludmFsaWQgYm91bmRzIGZvcm1hdCBmb3IgcmVnaW9uOiAke3JlZ2lvbn1gLFxyXG4gICAgICAgICAgYm91bmRzRXhwcmVzc2lvblxyXG4gICAgICAgICk7XHJcbiAgICAgICAgc2V0TG9jYWxMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEV4dHJhY3QgY29vcmRpbmF0ZXMgLSBMZWFmbGV0IHVzZXMgW2xhdCwgbG5nXSBmb3JtYXRcclxuICAgICAgY29uc3QgW1ttaW5MYXQsIG1pbkxuZ10sIFttYXhMYXQsIG1heExuZ11dID0gYm91bmRzRXhwcmVzc2lvbjtcclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKGBGaWx0ZXJpbmcgYnkgcmVnaW9uOiAke3JlZ2lvbn0gd2l0aCBib3VuZHM6YCwge1xyXG4gICAgICAgIG1pbkxhdCxcclxuICAgICAgICBtaW5MbmcsXHJcbiAgICAgICAgbWF4TGF0LFxyXG4gICAgICAgIG1heExuZyxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBGaWx0ZXIgYWlyY3JhZnQgYmFzZWQgb24gY29vcmRpbmF0ZXMgd2l0aGluIHRoZSBib3VuZHNcclxuICAgICAgY29uc3QgZmlsdGVyZWRBaXJjcmFmdCA9IGRpc3BsYXllZEFpcmNyYWZ0LmZpbHRlcigoYWlyY3JhZnQpID0+IHtcclxuICAgICAgICAvLyBDaGVjayBpZiBhaXJjcmFmdCBoYXMgdmFsaWQgY29vcmRpbmF0ZXNcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICB0eXBlb2YgYWlyY3JhZnQubGF0aXR1ZGUgIT09ICdudW1iZXInIHx8XHJcbiAgICAgICAgICB0eXBlb2YgYWlyY3JhZnQubG9uZ2l0dWRlICE9PSAnbnVtYmVyJyB8fFxyXG4gICAgICAgICAgaXNOYU4oYWlyY3JhZnQubGF0aXR1ZGUpIHx8XHJcbiAgICAgICAgICBpc05hTihhaXJjcmFmdC5sb25naXR1ZGUpXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDaGVjayBpZiBjb29yZGluYXRlcyBhcmUgd2l0aGluIHRoZSBib3VuZHNcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgYWlyY3JhZnQubGF0aXR1ZGUgPj0gbWluTGF0ICYmXHJcbiAgICAgICAgICBhaXJjcmFmdC5sYXRpdHVkZSA8PSBtYXhMYXQgJiZcclxuICAgICAgICAgIGFpcmNyYWZ0LmxvbmdpdHVkZSA+PSBtaW5MbmcgJiZcclxuICAgICAgICAgIGFpcmNyYWZ0LmxvbmdpdHVkZSA8PSBtYXhMbmdcclxuICAgICAgICApO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIFVwZGF0ZSB0aGUgZGlzcGxheSB3aXRoIGZpbHRlcmVkIGFpcmNyYWZ0XHJcbiAgICAgIGlmIChjbGVhckdlb2ZlbmNlRGF0YSkge1xyXG4gICAgICAgIGNsZWFyR2VvZmVuY2VEYXRhKCk7XHJcbiAgICAgIH1cclxuICAgICAgdXBkYXRlR2VvZmVuY2VBaXJjcmFmdChmaWx0ZXJlZEFpcmNyYWZ0KTtcclxuICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgYEZpbHRlcmVkIHRvICR7ZmlsdGVyZWRBaXJjcmFmdC5sZW5ndGh9IGFpcmNyYWZ0IGluICR7cmVnaW9ufSByZWdpb24gKG91dCBvZiAke2Rpc3BsYXllZEFpcmNyYWZ0Lmxlbmd0aH0gdG90YWwpYFxyXG4gICAgICApO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmlsdGVyaW5nIGFpcmNyYWZ0IGJ5IHJlZ2lvbjonLCBlcnJvcik7XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICBzZXRMb2NhbExvYWRpbmcoZmFsc2UpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGNvbnN0IGhhbmRsZVJlZ2lvblNlbGVjdCA9IGFzeW5jIChyZWdpb246IFJlZ2lvbkNvZGUpID0+IHtcclxuICAgIHNldEFjdGl2ZVJlZ2lvbihyZWdpb24pO1xyXG4gICAgc2V0U2VsZWN0ZWRSZWdpb24ocmVnaW9uKTtcclxuICAgIHNldExvY2FsTG9hZGluZyh0cnVlKTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBTZXQgbWFwIGJvdW5kcyBiYXNlZCBvbiByZWdpb25cclxuICAgICAgaWYgKG1hcEluc3RhbmNlKSB7XHJcbiAgICAgICAgY29uc3QgYm91bmRzID0gZ2V0Qm91bmRzQnlSZWdpb24ocmVnaW9uKTtcclxuXHJcbiAgICAgICAgLy8gR2V0IHRoZSBhcHByb3ByaWF0ZSB6b29tIGxldmVsIGZvciB0aGlzIHJlZ2lvbiBmcm9tIHlvdXIgY29uZmlnXHJcbiAgICAgICAgY29uc3Qgem9vbUxldmVsID0gZ2V0Wm9vbUxldmVsRm9yUmVnaW9uKHJlZ2lvbik7XHJcblxyXG4gICAgICAgIC8vIEZpcnN0LCBzZXQgdGhlIGFwcHJvcHJpYXRlIHpvb20gbGV2ZWxcclxuICAgICAgICBtYXBJbnN0YW5jZS5zZXRab29tKHpvb21MZXZlbCk7XHJcblxyXG4gICAgICAgIC8vIFRoZW4gZml0IGJvdW5kcyB3aXRoIHBhZGRpbmdcclxuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xyXG4gICAgICAgICAgcGFkZGluZzogTUFQX0NPTkZJRy5QQURESU5HLkRFRkFVTFQsXHJcbiAgICAgICAgICAvLyBEb24ndCBzZXQgbWF4Wm9vbSBoZXJlIGFzIHdlIHdhbnQgdGhlIHJlZ2lvbiB0byBiZSBwcm9wZXJseSBkaXNwbGF5ZWRcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBtYXBJbnN0YW5jZS5maXRCb3VuZHMoYm91bmRzIGFzIGFueSwgb3B0aW9ucyk7XHJcbiAgICAgICAgbWFwSW5zdGFuY2UuaW52YWxpZGF0ZVNpemUoKTtcclxuICAgICAgICBkcmF3UmVnaW9uT3V0bGluZShyZWdpb24pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBJbnN0ZWFkIG9mIGltbWVkaWF0ZWx5IGZldGNoaW5nIGFpcmNyYWZ0IGRhdGEsXHJcbiAgICAgIC8vIGp1c3Qgc3RvcmUgdGhlIHJlZ2lvbiBzZWxlY3Rpb24gZm9yIGxhdGVyIHVzZVxyXG4gICAgICBjb25zb2xlLmxvZyhgUmVnaW9uIHNlbGVjdGVkLiBXYWl0aW5nIGZvciBtYW51ZmFjdHVyZXIgc2VsZWN0aW9uLi4uYCk7XHJcblxyXG4gICAgICAvLyBPcHRpb25hbGx5LCB5b3UgY291bGQgZmV0Y2gganVzdCB0aGUgY291bnQgb2YgYWlyY3JhZnQgaW4gdGhpcyByZWdpb25cclxuICAgICAgLy8gdG8gZ2l2ZSB0aGUgdXNlciBhbiBpZGVhIG9mIHRoZSBkYXRhIHZvbHVtZVxyXG4gICAgICBjb25zdCBjb3VudFJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXHJcbiAgICAgICAgYC9hcGkvdHJhY2tpbmcvcmVnaW9uLWNvdW50P3JlZ2lvbj0ke3JlZ2lvbn1gXHJcbiAgICAgICk7XHJcbiAgICAgIGlmIChjb3VudFJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgY29uc3QgY291bnREYXRhID0gYXdhaXQgY291bnRSZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgY29uc29sZS5sb2coYCR7Y291bnREYXRhLmNvdW50fSBhaXJjcmFmdCBhdmFpbGFibGUgaW4gdGhpcyByZWdpb25gKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2xlYXIgYW55IHByZXZpb3VzIGFpcmNyYWZ0IGRhdGFcclxuICAgICAgaWYgKGNsZWFyR2VvZmVuY2VEYXRhKSB7XHJcbiAgICAgICAgY2xlYXJHZW9mZW5jZURhdGEoKTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gcmVnaW9uIHNlbGVjdGlvbjonLCBlcnJvcik7XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICBzZXRMb2NhbExvYWRpbmcoZmFsc2UpO1xyXG4gICAgICBzZXRBY3RpdmVEcm9wZG93bihudWxsKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBjb25zdCBkcmF3UmVnaW9uT3V0bGluZSA9IChyZWdpb246IFJlZ2lvbkNvZGUpID0+IHtcclxuICAgIGlmICghbWFwSW5zdGFuY2UpIHJldHVybjtcclxuXHJcbiAgICAvLyBDbGVhciBhbnkgZXhpc3Rpbmcgb3V0bGluZVxyXG4gICAgaWYgKHJlZ2lvbk91dGxpbmUpIHtcclxuICAgICAgcmVnaW9uT3V0bGluZS5yZW1vdmUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBHZXQgdGhlIGJvdW5kcyBmb3IgdGhlIHNlbGVjdGVkIHJlZ2lvblxyXG4gICAgY29uc3QgYm91bmRzID0gZ2V0Qm91bmRzQnlSZWdpb24ocmVnaW9uKSBhcyBbXHJcbiAgICAgIFtudW1iZXIsIG51bWJlcl0sXHJcbiAgICAgIFtudW1iZXIsIG51bWJlcl0sXHJcbiAgICBdO1xyXG5cclxuICAgIC8vIENyZWF0ZSBhIHBvbHlnb24gZnJvbSB0aGUgYm91bmRzXHJcbiAgICBjb25zdCBMID0gcmVxdWlyZSgnbGVhZmxldCcpO1xyXG4gICAgY29uc3QgcmVjdGFuZ2xlID0gTC5yZWN0YW5nbGUoYm91bmRzLCB7XHJcbiAgICAgIGNvbG9yOiAnIzRmNDZlNScsIC8vIEluZGlnbyBjb2xvciBtYXRjaGluZyB5b3VyIFVJXHJcbiAgICAgIHdlaWdodDogMyxcclxuICAgICAgb3BhY2l0eTogMC43LFxyXG4gICAgICBmaWxsOiB0cnVlLFxyXG4gICAgICBmaWxsQ29sb3I6ICcjNGY0NmU1JyxcclxuICAgICAgZmlsbE9wYWNpdHk6IDAuMSxcclxuICAgICAgZGFzaEFycmF5OiAnNSwgMTAnLCAvLyBPcHRpb25hbDogY3JlYXRlcyBhIGRhc2hlZCBsaW5lXHJcbiAgICAgIGludGVyYWN0aXZlOiBmYWxzZSwgLy8gUHJldmVudHMgdGhlIHJlY3RhbmdsZSBmcm9tIGNhcHR1cmluZyBtb3VzZSBldmVudHNcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEFkZCB0byBtYXBcclxuICAgIHJlY3RhbmdsZS5hZGRUbyhtYXBJbnN0YW5jZSk7XHJcblxyXG4gICAgLy8gVXBkYXRlIHRoZSBzdGF0ZSB0byBpbmNsdWRlIGJvdGggdGhlIHJlY3RhbmdsZSBhbmQgdGhlIGxhYmVsXHJcbiAgICBzZXRSZWdpb25PdXRsaW5lKHtcclxuICAgICAgcmVtb3ZlOiAoKSA9PiB7XHJcbiAgICAgICAgcmVjdGFuZ2xlLnJlbW92ZSgpO1xyXG4gICAgICB9LFxyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgICAvLyBNYW51ZmFjdHVyZXIgZmlsdGVyIG1ldGhvZHNcclxuICAgIGNvbnN0IHNlbGVjdE1hbnVmYWN0dXJlckFuZENsb3NlID0gKHZhbHVlOiBzdHJpbmcpID0+IHtcclxuICAgICAgLy8gQ2xvc2UgZHJvcGRvd25cclxuICAgICAgc2V0QWN0aXZlRHJvcGRvd24obnVsbCk7XHJcbiAgICAgIHNldE1hbnVmYWN0dXJlclNlYXJjaFRlcm0oJycpO1xyXG5cclxuICAgICAgLy8gSWYgY2xlYXJpbmcgdGhlIHNlbGVjdGlvblxyXG4gICAgICBpZiAodmFsdWUgPT09ICcnKSB7XHJcbiAgICAgICAgc2VsZWN0TWFudWZhY3R1cmVyKG51bGwpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gU2V0IHRoZSBtYW51ZmFjdHVyZXIgc2VsZWN0aW9uXHJcbiAgICAgIHNlbGVjdE1hbnVmYWN0dXJlcih2YWx1ZSk7XHJcblxyXG4gICAgICAvLyBJZiByZWdpb24gaXMgYWxyZWFkeSBzZWxlY3RlZCwgZmV0Y2ggZmlsdGVyZWQgZGF0YVxyXG4gICAgICBpZiAoYWN0aXZlUmVnaW9uICE9PSBudWxsKSB7XHJcbiAgICAgICAgZmV0Y2hBaXJjcmFmdEJ5UmVnaW9uQW5kTWFudWZhY3R1cmVyKGFjdGl2ZVJlZ2lvbiBhcyBSZWdpb25Db2RlLCB2YWx1ZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBqdXN0IHByb2NlZWQgd2l0aCBtYW51ZmFjdHVyZXItb25seSBmaWx0ZXJpbmcgYXMgYmVmb3JlXHJcbiAgICAgICAgZmV0Y2hNYW51ZmFjdHVyZXJEYXRhKHZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBmZXRjaE1hbnVmYWN0dXJlckRhdGEgPSAobWFudWZhY3R1cmVyOiBzdHJpbmcpID0+IHtcclxuICAgICAgaWYgKGlzUmF0ZUxpbWl0ZWQpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgIGBTa2lwcGluZyBkYXRhIGZldGNoIC0gcmF0ZSBsaW1pdGVkIGZvciAke3JhdGVMaW1pdFRpbWVyfXNgXHJcbiAgICAgICAgKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKGBGZXRjaGluZyBkYXRhIGZvciBtYW51ZmFjdHVyZXI6ICR7bWFudWZhY3R1cmVyfWApO1xyXG5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICAvLyBJZiB5b3UgaGF2ZSBhIGNvbnRleHQgZnVuY3Rpb24gZm9yIHRoaXMsIGNhbGwgaXQgYWZ0ZXIgYSBzbGlnaHQgZGVsYXlcclxuICAgICAgICBpZiAodHlwZW9mIHJlZnJlc2hQb3NpdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgIC8vIEFwcGx5IGEgc21hbGwgZGVsYXkgdG8gcHJldmVudCBvdmVyd2hlbG1pbmcgdGhlIEFQSVxyXG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHJlZnJlc2hQb3NpdGlvbnMoKS5jYXRjaCgoZXJyb3I6IGFueSkgPT4ge1xyXG4gICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCdyYXRlIGxpbWl0JykgfHxcclxuICAgICAgICAgICAgICAgIGVycm9yLnN0YXR1cyA9PT0gNDI5XHJcbiAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVSYXRlTGltaXQoMzApO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBtYW51ZmFjdHVyZXIgZGF0YTonLCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH0sIDIwMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCdyYXRlIGxpbWl0JykgfHwgZXJyb3Iuc3RhdHVzID09PSA0MjkpIHtcclxuICAgICAgICAgIGhhbmRsZVJhdGVMaW1pdCgzMCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHNjaGVkdWxpbmcgbWFudWZhY3R1cmVyIGRhdGEgZmV0Y2g6JywgZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBmZXRjaEFpcmNyYWZ0QnlSZWdpb25BbmRNYW51ZmFjdHVyZXIgPSBhc3luYyAoXHJcbiAgICAgIHJlZ2lvbjogUmVnaW9uQ29kZSxcclxuICAgICAgbWFudWZhY3R1cmVyOiBzdHJpbmcsXHJcbiAgICAgIHBhZ2U6IG51bWJlciA9IDEsXHJcbiAgICAgIGxpbWl0OiBudW1iZXIgPSA1MDBcclxuICAgICkgPT4ge1xyXG4gICAgICBpZiAoIXJlZ2lvbiB8fCAhbWFudWZhY3R1cmVyKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ0JvdGggcmVnaW9uIGFuZCBtYW51ZmFjdHVyZXIgbXVzdCBiZSBzZWxlY3RlZCcpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgc2V0TG9jYWxMb2FkaW5nKHRydWUpO1xyXG5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFxyXG4gICAgICAgICAgYC9hcGkvdHJhY2tpbmcvZmlsdGVyZWQtYWlyY3JhZnQ/cmVnaW9uPSR7cmVnaW9ufSZtYW51ZmFjdHVyZXI9JHtlbmNvZGVVUklDb21wb25lbnQobWFudWZhY3R1cmVyKX0mcGFnZT0ke3BhZ2V9JmxpbWl0PSR7bGltaXR9YFxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgY29uc3QgYWlyY3JhZnREYXRhID0gZGF0YS5haXJjcmFmdCB8fCBbXTtcclxuXHJcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBUEkgZXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFByb2Nlc3MgdGhlIGZpbHRlcmVkIGFpcmNyYWZ0IGRhdGFcclxuICAgICAgICBpZiAoYWlyY3JhZnREYXRhLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIC8vIFRyYW5zZm9ybSB0byBFeHRlbmRlZEFpcmNyYWZ0XHJcbiAgICAgICAgICBpbnRlcmZhY2UgQWlyY3JhZnREYXRhIHtcclxuICAgICAgICAgICAgVFlQRV9BSVJDUkFGVD86IHN0cmluZztcclxuICAgICAgICAgICAgT1BFUkFUT1I/OiBzdHJpbmc7XHJcbiAgICAgICAgICAgIFJFR0lPTjogbnVtYmVyO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGNvbnN0IGV4dGVuZGVkQWlyY3JhZnQ6IEV4dGVuZGVkQWlyY3JhZnRbXSA9IGFpcmNyYWZ0RGF0YS5tYXAoXHJcbiAgICAgICAgICAgIChhaXJjcmFmdDogQWlyY3JhZnREYXRhKSA9PiAoe1xyXG4gICAgICAgICAgICAgIC4uLmFpcmNyYWZ0LFxyXG4gICAgICAgICAgICAgIHR5cGU6IGFpcmNyYWZ0LlRZUEVfQUlSQ1JBRlQgfHwgJ1Vua25vd24nLFxyXG4gICAgICAgICAgICAgIGlzR292ZXJubWVudDpcclxuICAgICAgICAgICAgICAgIGFpcmNyYWZ0Lk9QRVJBVE9SPy50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdnb3Zlcm5tZW50JykgPz9cclxuICAgICAgICAgICAgICAgIGZhbHNlLFxyXG4gICAgICAgICAgICAgIFJFR0lPTjogYWlyY3JhZnQuUkVHSU9OLFxyXG4gICAgICAgICAgICAgIHpvb21MZXZlbDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIG1hcFxyXG4gICAgICAgICAgdXBkYXRlR2VvZmVuY2VBaXJjcmFmdChleHRlbmRlZEFpcmNyYWZ0KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICAgIGBObyBhaXJjcmFmdCBmb3VuZCBmb3IgbWFudWZhY3R1cmVyICR7bWFudWZhY3R1cmVyfSBpbiByZWdpb24gJHtyZWdpb259YFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgZmlsdGVyZWQgYWlyY3JhZnQ6JywgZXJyb3IpO1xyXG4gICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHNldExvY2FsTG9hZGluZyhmYWxzZSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8gTW9kZWwgc2VsZWN0aW9uIG1ldGhvZHNcclxuICAgIGNvbnN0IGhhbmRsZU1vZGVsU2VsZWN0ID0gKHZhbHVlOiBzdHJpbmcpID0+IHtcclxuICAgICAgc2VsZWN0TW9kZWwodmFsdWUgPT09ICcnID8gbnVsbCA6IHZhbHVlKTtcclxuICAgICAgc2V0QWN0aXZlRHJvcGRvd24obnVsbCk7XHJcblxyXG4gICAgICAvLyBJZiBpbiBjb21iaW5lZCBtb2RlLCByZWFwcGx5IHRoZSBmaWx0ZXJcclxuICAgICAgaWYgKGZpbHRlck1vZGUgPT09ICdib3RoJyAmJiBpc0dlb2ZlbmNlQWN0aXZlICYmIHNlbGVjdGVkTWFudWZhY3R1cmVyKSB7XHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICBhcHBseUNvbWJpbmVkRmlsdGVycygpO1xyXG4gICAgICAgIH0sIDEwMCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8gQ29tYmluZWQgZmlsdGVyIG1ldGhvZHNcclxuICAgIGNvbnN0IGFwcGx5Q29tYmluZWRGaWx0ZXJzID0gKCkgPT4ge1xyXG4gICAgICBpZiAoXHJcbiAgICAgICAgIXNlbGVjdGVkTWFudWZhY3R1cmVyIHx8XHJcbiAgICAgICAgIWlzR2VvZmVuY2VBY3RpdmUgfHxcclxuICAgICAgICBnZW9mZW5jZUFpcmNyYWZ0Lmxlbmd0aCA9PT0gMFxyXG4gICAgICApIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHNldExvY2FsTG9hZGluZyh0cnVlKTtcclxuXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICBgRmlsdGVyaW5nICR7Z2VvZmVuY2VBaXJjcmFmdC5sZW5ndGh9IGFpcmNyYWZ0IGJ5ICR7c2VsZWN0ZWRNYW51ZmFjdHVyZXJ9YFxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIC8vIEZpbHRlciB0aGUgYWlyY3JhZnQgYnkgbWFudWZhY3R1cmVyXHJcbiAgICAgICAgbGV0IGZpbHRlcmVkQWlyY3JhZnQgPSBnZW9mZW5jZUFpcmNyYWZ0LmZpbHRlcihcclxuICAgICAgICAgIChhaXJjcmFmdCkgPT5cclxuICAgICAgICAgICAgYWlyY3JhZnQuTUFOVUZBQ1RVUkVSPy50b0xvd2VyQ2FzZSgpID09PVxyXG4gICAgICAgICAgICBzZWxlY3RlZE1hbnVmYWN0dXJlci50b0xvd2VyQ2FzZSgpXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gRnVydGhlciBmaWx0ZXIgYnkgbW9kZWwgaWYgc2VsZWN0ZWRcclxuICAgICAgICBpZiAoc2VsZWN0ZWRNb2RlbCkge1xyXG4gICAgICAgICAgZmlsdGVyZWRBaXJjcmFmdCA9IGZpbHRlcmVkQWlyY3JhZnQuZmlsdGVyKFxyXG4gICAgICAgICAgICAoYWlyY3JhZnQpID0+XHJcbiAgICAgICAgICAgICAgYWlyY3JhZnQuTU9ERUw/LnRvTG93ZXJDYXNlKCkgPT09IHNlbGVjdGVkTW9kZWwudG9Mb3dlckNhc2UoKVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKGBGb3VuZCAke2ZpbHRlcmVkQWlyY3JhZnQubGVuZ3RofSBtYXRjaGluZyBhaXJjcmFmdGApO1xyXG5cclxuICAgICAgICBpZiAoZmlsdGVyZWRBaXJjcmFmdC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgIGFsZXJ0KGBObyAke3NlbGVjdGVkTWFudWZhY3R1cmVyfSBhaXJjcmFmdCBmb3VuZCBpbiB0aGlzIGFyZWEuYCk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDbGVhciBkaXNwbGF5IGRhdGFcclxuICAgICAgICBpZiAoY2xlYXJHZW9mZW5jZURhdGEpIHtcclxuICAgICAgICAgIGNsZWFyR2VvZmVuY2VEYXRhKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBVcGRhdGUgdGhlIGRpc3BsYXlcclxuICAgICAgICB1cGRhdGVHZW9mZW5jZUFpcmNyYWZ0KGZpbHRlcmVkQWlyY3JhZnQpO1xyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZpbHRlcmluZyBhaXJjcmFmdDonLCBlcnJvcik7XHJcbiAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgc2V0TG9jYWxMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBSZXNldCBhbGwgZmlsdGVyc1xyXG4gICAgY29uc3QgY2xlYXJBbGxGaWx0ZXJzID0gKCkgPT4ge1xyXG4gICAgICBjb25zb2xlLmxvZygnQ2xlYXJpbmcgYWxsIGZpbHRlcnMuLi4nKTtcclxuXHJcbiAgICAgIC8vIDEuIFJlc2V0IGZpbHRlciBtb2RlXHJcbiAgICAgIHNldEZpbHRlck1vZGUoJ21hbnVmYWN0dXJlcicpO1xyXG5cclxuICAgICAgLy8gMi4gVW5ibG9jayBBUEkgY2FsbHMgdGhhdCBtaWdodCBoYXZlIGJlZW4gYmxvY2tlZFxyXG4gICAgICBvcGVuU2t5VHJhY2tpbmdTZXJ2aWNlLnNldEJsb2NrQWxsQXBpQ2FsbHMoZmFsc2UpO1xyXG4gICAgICBzZXRCbG9ja01hbnVmYWN0dXJlckFwaUNhbGxzKGZhbHNlKTtcclxuICAgICAgc2V0SXNNYW51ZmFjdHVyZXJBcGlCbG9ja2VkKGZhbHNlKTtcclxuXHJcbiAgICAgIC8vIDMuIENsZWFyIG1hbnVmYWN0dXJlciBzZWxlY3Rpb25cclxuICAgICAgc2VsZWN0TWFudWZhY3R1cmVyKG51bGwpO1xyXG4gICAgICBzZWxlY3RNb2RlbChudWxsKTtcclxuXHJcbiAgICAgIC8vIDQuIENsZWFyIGdlb2ZlbmNlXHJcbiAgICAgIHNldEdlb2ZlbmNlTG9jYXRpb24oJycpO1xyXG4gICAgICBzZXRHZW9mZW5jZUNvb3JkaW5hdGVzKG51bGwpO1xyXG4gICAgICBzZXRHZW9mZW5jZUFpcmNyYWZ0KFtdKTtcclxuICAgICAgc2V0R2VvZmVuY2VFbmFibGVkKGZhbHNlKTtcclxuICAgICAgc2V0SXNHZW9mZW5jZUFjdGl2ZShmYWxzZSk7XHJcbiAgICAgIGlmICh0eXBlb2YgY2xlYXJHZW9mZW5jZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIGNsZWFyR2VvZmVuY2UoKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodHlwZW9mIGNsZWFyR2VvZmVuY2VEYXRhID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgY2xlYXJHZW9mZW5jZURhdGEoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gNS4gUmVzZXQgb3duZXIgZmlsdGVycyB0byBzZWxlY3QgYWxsXHJcbiAgICAgIHNldE93bmVyRmlsdGVycyhbLi4uYWxsT3duZXJUeXBlc10pO1xyXG5cclxuICAgICAgLy8gNi4gQ2xlYXIgcmVnaW9uIGZpbHRlciBwcm9wZXJseVxyXG4gICAgICBzZXRBY3RpdmVSZWdpb24obnVsbCk7XHJcbiAgICAgIHNldFNlbGVjdGVkUmVnaW9uKFJlZ2lvbkNvZGUuR0xPQkFMKTtcclxuXHJcbiAgICAgIC8vIENsZWFyIHJlZ2lvbiBvdXRsaW5lIGZyb20gbWFwXHJcbiAgICAgIGlmIChyZWdpb25PdXRsaW5lKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIC8vIEhhbmRsZSBkaWZmZXJlbnQgcG9zc2libGUgb2JqZWN0IHN0cnVjdHVyZXNcclxuICAgICAgICAgIGlmICh0eXBlb2YgcmVnaW9uT3V0bGluZS5yZW1vdmUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgcmVnaW9uT3V0bGluZS5yZW1vdmUoKTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgICAgICAgIHJlZ2lvbk91dGxpbmUucmVjdGFuZ2xlICYmXHJcbiAgICAgICAgICAgIHR5cGVvZiByZWdpb25PdXRsaW5lLnJlY3RhbmdsZS5yZW1vdmUgPT09ICdmdW5jdGlvbidcclxuICAgICAgICAgICkge1xyXG4gICAgICAgICAgICByZWdpb25PdXRsaW5lLnJlY3RhbmdsZS5yZW1vdmUoKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBDbGVhciBhbnkgbGFiZWxzIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVnaW9uXHJcbiAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIHJlZ2lvbk91dGxpbmUubGFiZWwgJiZcclxuICAgICAgICAgICAgdHlwZW9mIHJlZ2lvbk91dGxpbmUubGFiZWwucmVtb3ZlID09PSAnZnVuY3Rpb24nXHJcbiAgICAgICAgICApIHtcclxuICAgICAgICAgICAgcmVnaW9uT3V0bGluZS5sYWJlbC5yZW1vdmUoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVtb3ZpbmcgcmVnaW9uIG91dGxpbmU6JywgZXJyb3IpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQWx3YXlzIHJlc2V0IHRoZSByZWdpb24gb3V0bGluZSBzdGF0ZVxyXG4gICAgICAgIHNldFJlZ2lvbk91dGxpbmUobnVsbCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIDcuIFJlc2V0IG1hcCB2aWV3IHRvIGdsb2JhbFxyXG4gICAgICBpZiAobWFwSW5zdGFuY2UpIHtcclxuICAgICAgICAvLyBVc2UgdGhlIHByZWRlZmluZWQgY2VudGVyIGFuZCB6b29tIGxldmVsIGZyb20geW91ciBtYXAgY29uZmlnXHJcbiAgICAgICAgbWFwSW5zdGFuY2Uuc2V0VmlldyhNQVBfQ09ORklHLkNFTlRFUiwgTUFQX0NPTkZJRy5ERUZBVUxUX1pPT00pO1xyXG4gICAgICAgIG1hcEluc3RhbmNlLmludmFsaWRhdGVTaXplKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIDguIFJlc2V0IHRvIGluaXRpYWwgYWlyY3JhZnQgZGF0YVxyXG4gICAgICBpZiAodHlwZW9mIHJlc2V0ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgcmVzZXQoKTtcclxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZnVsbFJlZnJlc2ggPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICBmdWxsUmVmcmVzaCgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyA5LiBDbG9zZSBhbnkgb3BlbiBkcm9wZG93blxyXG4gICAgICBzZXRBY3RpdmVEcm9wZG93bihudWxsKTtcclxuXHJcbiAgICAgIC8vIDEwLiBSZXNldCByYXRlIGxpbWl0aW5nIHN0YXRlc1xyXG4gICAgICBzZXRJc1JhdGVMaW1pdGVkKGZhbHNlKTtcclxuICAgICAgc2V0UmF0ZUxpbWl0VGltZXIobnVsbCk7XHJcblxyXG4gICAgICAvLyAxMS4gQ2xlYXIgY29tYmluZWQgbW9kZSBzdGF0ZVxyXG4gICAgICBzZXRDb21iaW5lZE1vZGVSZWFkeShmYWxzZSk7XHJcblxyXG4gICAgICAvLyAxMi4gUmVzZXQgc2VhcmNoIHRlcm1zXHJcbiAgICAgIHNldE1hbnVmYWN0dXJlclNlYXJjaFRlcm0oJycpO1xyXG5cclxuICAgICAgLy8gMTMuIERpc3BhdGNoIGEgY3VzdG9tIGV2ZW50IHRoYXQgb3RoZXIgY29tcG9uZW50cyBjYW4gbGlzdGVuIGZvclxyXG4gICAgICBjb25zdCBjbGVhckV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdyaWJib24tZmlsdGVycy1jbGVhcmVkJyk7XHJcbiAgICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoY2xlYXJFdmVudCk7XHJcblxyXG4gICAgICBjb25zb2xlLmxvZygnQWxsIGZpbHRlcnMgY2xlYXJlZCBzdWNjZXNzZnVsbHknKTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIGNvbWJpbmVkIGxvYWRpbmcgc3RhdGVcclxuICAgIGNvbnN0IGNvbWJpbmVkTG9hZGluZyA9IGxvY2FsTG9hZGluZztcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAvLyBTdGF0ZVxyXG4gICAgICBmaWx0ZXJNb2RlLFxyXG4gICAgICBhY3RpdmVEcm9wZG93bixcclxuICAgICAgc2VsZWN0ZWRNYW51ZmFjdHVyZXIsXHJcbiAgICAgIHNlbGVjdGVkTW9kZWwsXHJcbiAgICAgIGdlb2ZlbmNlTG9jYXRpb24sXHJcbiAgICAgIGdlb2ZlbmNlUmFkaXVzLFxyXG4gICAgICBpc0dlb2ZlbmNlQWN0aXZlLFxyXG4gICAgICBnZW9mZW5jZUNvb3JkaW5hdGVzLFxyXG4gICAgICBnZXRVc2VyTG9jYXRpb24sXHJcbiAgICAgIGFjdGl2ZVJlZ2lvbixcclxuICAgICAgb3duZXJGaWx0ZXJzLFxyXG4gICAgICBhbGxPd25lclR5cGVzLFxyXG4gICAgICBtYW51ZmFjdHVyZXJTZWFyY2hUZXJtLFxyXG4gICAgICBjb21iaW5lZExvYWRpbmcsXHJcbiAgICAgIGlzR2V0dGluZ0xvY2F0aW9uLFxyXG4gICAgICBkcm9wZG93blJlZnMsXHJcbiAgICAgIGxvY2FsTG9hZGluZyxcclxuICAgICAgaXNSYXRlTGltaXRlZCxcclxuICAgICAgc2VsZWN0ZWRSZWdpb24sXHJcbiAgICAgIGlzUmVmcmVzaGluZyxcclxuICAgICAgaXNHZW9mZW5jZVBsYWNlbWVudE1vZGU6IGZhbHNlLCAvLyBJbml0aWFsaXplIHdpdGggYSBkZWZhdWx0IHZhbHVlXHJcblxyXG4gICAgICAvLyBNZXRob2RzXHJcbiAgICAgIHRvZ2dsZURyb3Bkb3duLFxyXG4gICAgICB0b2dnbGVGaWx0ZXJNb2RlLFxyXG4gICAgICBzZWxlY3RNYW51ZmFjdHVyZXJBbmRDbG9zZSxcclxuICAgICAgaGFuZGxlTW9kZWxTZWxlY3QsXHJcbiAgICAgIHByb2Nlc3NHZW9mZW5jZVNlYXJjaCxcclxuICAgICAgaGFuZGxlT3duZXJGaWx0ZXJDaGFuZ2UsXHJcbiAgICAgIGhhbmRsZVJlZ2lvblNlbGVjdCxcclxuICAgICAgc2V0TWFudWZhY3R1cmVyU2VhcmNoVGVybSxcclxuICAgICAgc2V0R2VvZmVuY2VMb2NhdGlvbixcclxuICAgICAgc2V0R2VvZmVuY2VSYWRpdXMsXHJcbiAgICAgIHRvZ2dsZUdlb2ZlbmNlU3RhdGUsXHJcbiAgICAgIGNsZWFyQWxsRmlsdGVycyxcclxuICAgICAgYXBwbHlDb21iaW5lZEZpbHRlcnMsXHJcbiAgICAgIGdldEFpcmNyYWZ0T3duZXJUeXBlLFxyXG4gICAgICBzZXRHZW9mZW5jZUNvb3JkaW5hdGVzLFxyXG4gICAgICBzZXRHZW9mZW5jZUNlbnRlcixcclxuICAgICAgdXBkYXRlR2VvZmVuY2VBaXJjcmFmdCxcclxuXHJcbiAgICAgIHJlZnJlc2hXaXRoRmlsdGVyczogKCkgPT4ge1xyXG4gICAgICAgIC8vIEltcGxlbWVudCByZWZyZXNoIGxvZ2ljIGhlcmVcclxuICAgICAgICBpZiAodHlwZW9mIHJlZnJlc2hQb3NpdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgIHJlZnJlc2hQb3NpdGlvbnMoKS5jYXRjaCgoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVmcmVzaGluZyBwb3NpdGlvbnM6JywgZXJyb3IpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBzZXRBY3RpdmVEcm9wZG93biwgLy8gQWRkIHRoaXMgbGluZSBpZiB5b3UgaGF2ZSB0aGlzIGZ1bmN0aW9uXHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG5mdW5jdGlvbiBhcHBseUNvbWJpbmVkRmlsdGVycygpIHtcclxuICB0aHJvdyBuZXcgRXJyb3IoJ0Z1bmN0aW9uIG5vdCBpbXBsZW1lbnRlZC4nKTtcclxufVxyXG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VSZWYiLCJ1c2VFZmZlY3QiLCJSZWFjdCIsIlJlZ2lvbkNvZGUiLCJ1c2VFbmhhbmNlZE1hcENvbnRleHQiLCJvcGVuU2t5VHJhY2tpbmdTZXJ2aWNlIiwiTWFwYm94U2VydmljZSIsImFkYXB0R2VvZmVuY2VBaXJjcmFmdCIsImVucmljaEdlb2ZlbmNlQWlyY3JhZnQiLCJ1c2VHZW9sb2NhdGlvblNlcnZpY2VzIiwiZ2V0QWlyY3JhZnROZWFyTG9jYXRpb24iLCJnZXRBaXJjcmFmdE5lYXJTZWFyY2hlZExvY2F0aW9uIiwidXNlR2VvbG9jYXRpb24iLCJNQVBfQ09ORklHIiwiZ2V0Qm91bmRzQnlSZWdpb24iLCJnZXRab29tTGV2ZWxGb3JSZWdpb24iLCJ1c2VGaWx0ZXJMb2dpYyIsInNlbGVjdGVkTWFudWZhY3R1cmVyIiwic2VsZWN0ZWRNb2RlbCIsInRvdGFsQWN0aXZlIiwic2VsZWN0TWFudWZhY3R1cmVyIiwic2VsZWN0TW9kZWwiLCJyZXNldCIsImZ1bGxSZWZyZXNoIiwicmVmcmVzaFBvc2l0aW9ucyIsIm1hcEluc3RhbmNlIiwidXBkYXRlQWlyY3JhZnREYXRhIiwiY2xlYXJHZW9mZW5jZURhdGEiLCJ1cGRhdGVHZW9mZW5jZUFpcmNyYWZ0IiwiYmxvY2tNYW51ZmFjdHVyZXJBcGlDYWxscyIsInNldEJsb2NrTWFudWZhY3R1cmVyQXBpQ2FsbHMiLCJpc01hbnVmYWN0dXJlckFwaUJsb2NrZWQiLCJzZXRJc01hbnVmYWN0dXJlckFwaUJsb2NrZWQiLCJnZW9mZW5jZUNlbnRlciIsInNldEdlb2ZlbmNlQ2VudGVyIiwidG9nZ2xlR2VvZmVuY2UiLCJjbGVhckdlb2ZlbmNlIiwiZGlzcGxheWVkQWlyY3JhZnQiLCJnZW9sb2NhdGlvblNlcnZpY2VzIiwibG9jYWxMb2FkaW5nIiwic2V0TG9jYWxMb2FkaW5nIiwiZmlsdGVyTW9kZSIsInNldEZpbHRlck1vZGUiLCJhY3RpdmVEcm9wZG93biIsInNldEFjdGl2ZURyb3Bkb3duIiwibWFudWZhY3R1cmVyU2VhcmNoVGVybSIsInNldE1hbnVmYWN0dXJlclNlYXJjaFRlcm0iLCJpc1JlZnJlc2hpbmciLCJzZXRJc1JlZnJlc2hpbmciLCJpc1JhdGVMaW1pdGVkIiwic2V0SXNSYXRlTGltaXRlZCIsInJhdGVMaW1pdFRpbWVyIiwic2V0UmF0ZUxpbWl0VGltZXIiLCJpc0dldHRpbmdMb2NhdGlvbiIsInNldElzR2V0dGluZ0xvY2F0aW9uIiwiZ2VvZmVuY2VMb2NhdGlvbiIsInNldEdlb2ZlbmNlTG9jYXRpb24iLCJnZW9mZW5jZVJhZGl1cyIsInNldEdlb2ZlbmNlUmFkaXVzIiwiZ2VvZmVuY2VDb29yZGluYXRlcyIsInNldEdlb2ZlbmNlQ29vcmRpbmF0ZXMiLCJnZW9mZW5jZUFpcmNyYWZ0Iiwic2V0R2VvZmVuY2VBaXJjcmFmdCIsImdlb2ZlbmNlRW5hYmxlZCIsInNldEdlb2ZlbmNlRW5hYmxlZCIsImlzR2VvZmVuY2VBY3RpdmUiLCJzZXRJc0dlb2ZlbmNlQWN0aXZlIiwiaXNTZWFyY2hSZWFkeSIsInNldElzU2VhcmNoUmVhZHkiLCJhY3RpdmVSZWdpb24iLCJzZXRBY3RpdmVSZWdpb24iLCJyZWdpb25PdXRsaW5lIiwic2V0UmVnaW9uT3V0bGluZSIsInNlbGVjdGVkUmVnaW9uIiwic2V0U2VsZWN0ZWRSZWdpb24iLCJHTE9CQUwiLCJjb21iaW5lZE1vZGVSZWFkeSIsInNldENvbWJpbmVkTW9kZVJlYWR5IiwiYWxsT3duZXJUeXBlcyIsIm93bmVyRmlsdGVycyIsInNldE93bmVyRmlsdGVycyIsImRyb3Bkb3duUmVmcyIsImZpbHRlciIsIm1hbnVmYWN0dXJlciIsIm1vZGVsIiwibG9jYXRpb24iLCJyZWdpb24iLCJvd25lciIsImFjdGlvbnMiLCJnZW9sb2NhdGlvbiIsImdldFVzZXJMb2NhdGlvbiIsImFsZXJ0IiwicG9zaXRpb24iLCJnZXRDdXJyZW50UG9zaXRpb24iLCJsYXRpdHVkZSIsImxvbmdpdHVkZSIsImNvb3JkcyIsImxhdCIsImxuZyIsInRvRml4ZWQiLCJmZXRjaGVkQWlyY3JhZnQiLCJsZW5ndGgiLCJhZGFwdGVkQWlyY3JhZnQiLCJlbnJpY2hlZEFpcmNyYWZ0IiwiY3VycmVudFpvb20iLCJnZXRab29tIiwidGFyZ2V0Wm9vbSIsInNldFZpZXciLCJpbnZhbGlkYXRlU2l6ZSIsImVycm9yIiwibWVzc2FnZSIsImluY2x1ZGVzIiwic3RhdHVzIiwiaGFuZGxlUmF0ZUxpbWl0IiwiY29uc29sZSIsInByb2Nlc3NHZW9mZW5jZVNlYXJjaCIsInNldEJsb2NrQWxsQXBpQ2FsbHMiLCJsb2ciLCJyZXRyeUFmdGVyIiwibG9jYXRpb25zIiwic2VhcmNoTG9jYXRpb25XaXRoTWFwYm94IiwiY29vcmRpbmF0ZXMiLCJuYW1lIiwiRXJyb3IiLCJNQU5VRkFDVFVSRVIiLCJ1bmRlZmluZWQiLCJzZXRUaW1lb3V0IiwiYXBwbHlDb21iaW5lZEZpbHRlcnMiLCJ0b2dnbGVHZW9mZW5jZVN0YXRlIiwiZW5hYmxlZCIsImlzTmFOIiwid2FybiIsInRpbWVyIiwiY2xlYXJUaW1lb3V0IiwiaGFuZGxlQ2xpY2tPdXRzaWRlIiwiZXZlbnQiLCJpc091dHNpZGVBbGwiLCJPYmplY3QiLCJ2YWx1ZXMiLCJldmVyeSIsInJlZiIsImN1cnJlbnQiLCJjb250YWlucyIsInRhcmdldCIsImRvY3VtZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJyZW1vdmUiLCJoYW5kbGVNYXBHZW9mZW5jZUNsaWNrIiwiY3VzdG9tRXZlbnQiLCJkZXRhaWwiLCJsb2NhdGlvbk5hbWUiLCJnZXRMb2NhdGlvbk5hbWVGcm9tQ29vcmRpbmF0ZXMiLCJ0b2dnbGVEcm9wZG93biIsImRyb3Bkb3duIiwic3RvcFByb3BhZ2F0aW9uIiwidG9nZ2xlRmlsdGVyTW9kZSIsIm1vZGUiLCJmaWx0ZXJBaXJjcmFmdEJ5UmVnaW9uIiwidG9TdHJpbmciLCJhaXJjcmFmdFdpdGhWYWxpZENvb3JkcyIsInBsYW5lIiwiZmlsdGVyZWRCeU93bmVyIiwiYWlyY3JhZnQiLCJnZXRBaXJjcmFmdE93bmVyVHlwZSIsIm93bmVyVHlwZSIsIlRZUEVfUkVHSVNUUkFOVCIsIm93bmVyVHlwZVRvU3RyaW5nIiwidHlwZSIsInR5cGVOdW0iLCJwYXJzZUludCIsIm93bmVyVHlwZU1hcCIsImFwcGx5T3duZXJUeXBlRmlsdGVyIiwiZmlsdGVycyIsImZpbHRlcmVkQWlyY3JhZnQiLCJoYW5kbGVPd25lckZpbHRlckNoYW5nZSIsInVwZGF0ZWRGaWx0ZXJzIiwicmVzZXRPd25lckZpbHRlcnMiLCJib3VuZHNFeHByZXNzaW9uIiwiQXJyYXkiLCJpc0FycmF5IiwibWluTGF0IiwibWluTG5nIiwibWF4TGF0IiwibWF4TG5nIiwiaGFuZGxlUmVnaW9uU2VsZWN0IiwiYm91bmRzIiwiem9vbUxldmVsIiwic2V0Wm9vbSIsIm9wdGlvbnMiLCJwYWRkaW5nIiwiUEFERElORyIsIkRFRkFVTFQiLCJmaXRCb3VuZHMiLCJkcmF3UmVnaW9uT3V0bGluZSIsImNvdW50UmVzcG9uc2UiLCJmZXRjaCIsIm9rIiwiY291bnREYXRhIiwianNvbiIsImNvdW50IiwiTCIsInJlcXVpcmUiLCJyZWN0YW5nbGUiLCJjb2xvciIsIndlaWdodCIsIm9wYWNpdHkiLCJmaWxsIiwiZmlsbENvbG9yIiwiZmlsbE9wYWNpdHkiLCJkYXNoQXJyYXkiLCJpbnRlcmFjdGl2ZSIsImFkZFRvIiwic2VsZWN0TWFudWZhY3R1cmVyQW5kQ2xvc2UiLCJ2YWx1ZSIsImZldGNoQWlyY3JhZnRCeVJlZ2lvbkFuZE1hbnVmYWN0dXJlciIsImZldGNoTWFudWZhY3R1cmVyRGF0YSIsImNhdGNoIiwicGFnZSIsImxpbWl0IiwicmVzcG9uc2UiLCJlbmNvZGVVUklDb21wb25lbnQiLCJkYXRhIiwiYWlyY3JhZnREYXRhIiwic3RhdHVzVGV4dCIsImV4dGVuZGVkQWlyY3JhZnQiLCJtYXAiLCJUWVBFX0FJUkNSQUZUIiwiaXNHb3Zlcm5tZW50IiwiT1BFUkFUT1IiLCJ0b0xvd2VyQ2FzZSIsIlJFR0lPTiIsImhhbmRsZU1vZGVsU2VsZWN0IiwiTU9ERUwiLCJjbGVhckFsbEZpbHRlcnMiLCJsYWJlbCIsIkNFTlRFUiIsIkRFRkFVTFRfWk9PTSIsImNsZWFyRXZlbnQiLCJDdXN0b21FdmVudCIsImRpc3BhdGNoRXZlbnQiLCJjb21iaW5lZExvYWRpbmciLCJpc0dlb2ZlbmNlUGxhY2VtZW50TW9kZSIsInJlZnJlc2hXaXRoRmlsdGVycyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/tracking/hooks/useFilterLogic.ts\n"));

/***/ })

});